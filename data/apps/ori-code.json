{"test": ["a=int(input())\nb=a\nnr=1\nwhile b>9:\n    nr*=10\n    b/=10\nprint(int(b+1)*int(nr)-int(a))", "import sys\ntry:\n    fin=open('in')\nexcept:\n    fin=sys.stdin\ninput=fin.readline\n\nd = int(input())\nn, m = map(int, input().split())\nx1, y1, x2, y2 = [], [], [], []\nT=[]\nfor _ in range(d):\n    u, v, w, x = map(int, input().split())\n    if u>w:u,w=w,u\n    if v>x:v,x=x,v\n    x1.append(u)\n    y1.append(v)\n    x2.append(-w)#the other direction pog?\n    y2.append(-x)\n    T.append([u,v,w,x])\n\nx1.sort()\nx2.sort()\ny1.sort()\ny2.sort()\n\nreq=list(map(int,input().split())) # x1,x2,y1,y2\nimport bisect\nfor i in range(len(T)):\n    # binary search\n    u,v,w,x=T[i]\n    if req[0]==bisect.bisect_left(x1,w)-(u!=w):\n        if req[1]==bisect.bisect_left(x2,-u)-(u!=w):\n            if req[2]==bisect.bisect_left(y1,x)-(v!=x):\n                if req[3]==bisect.bisect_left(y2,-v)-(v!=x):\n                    print(i+1)\n                    break\nelse:\n    print(-1)", "n=int(input())\ns=input()\nans=0\nsc,gc,pi,ci=0,0,-1,-1\nfor i in range(1,n+1):\n\tif s[i-1]=='G':\n\t\tgc+=1\n\telse:\n\t\tsc+=1\n\t\tif pi==-1:\n\t\t\tans=max(ans,i-1)\n\t\telse:\n\t\t\tans=max(ans,i-1-pi)\n\t\tpi=ci\n\t\tci=i\n\t#print(ans)\n#print(gc,sc)\nif sc==1:\n\tprint(n-1)\n\treturn\nif sc==2 and (s[0]=='S' or s[n-1]=='S'):\n\tprint(n-2)\n\treturn\n\nif pi==-1:\n\tans=max(ans,n)\nelse:\n\tans = max(ans,n-pi)\n\nprint(min(ans,gc))\n", "import sys\nflag=True\nsys.setrecursionlimit(2000000000)\nc=[];st=[];\ncur_adj=[]\ndef topo(s):#Traversing the array and storing the vertices\n    nonlocal c,st,flag;\n    stack = [s]\n    while(stack):\n        s = stack[-1]\n        c[s]=1; #Being Visited\n        if(cur_adj[s] < len(adjli[s])):\n            cur = adjli[s][cur_adj[s]]\n            if(c[cur]==0):\n                stack.append(cur)\n            if(c[cur]==1):\n                flag=False# If Back Edge , Then Not Possible\n            cur_adj[s]+=1\n        else:\n            c[s]=2\n            st.append(str(s))\n            del stack[-1]\n\ntry:\n    n,k=map(int,input().split(' '))\n    main=list(map(int,input().split(' ')))\n    depen=[]\n    for i in range(n):\n    \tdepen.append(list(map(int,input().split(' ')))[1:]);c.append(0)\n    \tcur_adj.append(0)\n    c.append(0)\n    cur_adj.append(0)\n    adjli=[]\n    adjli.append(main)#Assuming Main Course at index 0 with dependencies as Main Dependency(main)\n    for i in range(len(depen)):\n        adjli.append(depen[i])#Appending Other Dependencies\n    topo(0)#TopoLogical Sort Order\n    st.pop(-1)#popping the assumed Main Couse\n    if flag:# IF possible then print\n        print(len(st))\n        print(' '.join(st))\n    else:\n        print(-1)\nexcept Exception as e:\n    print(e,\"error\")", "a = int(input())\nint(input())\nc = int(input())\nd = int(input())\nprint(1 - int(a != d or (a == 0 and not (a == c == d))))\n", "t=int(input())\nfor _ in range(t):\n    n=int(input())\n    c,d=0,0\n    bo=0\n    for i in range(n):\n        a,b=list(map(int,input().split()))\n        if(a<c or b<d):\n            bo=1\n        elif(a-c<b-d):\n            bo=1\n        c,d=a,b\n    if(bo):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n", "h,m = [int(x) for x in input().split(\":\")]\nans = 0\ndef padL(s):\n    while len(s) < 2:\n        s = '0' + s\n    return s\ndef palindrome():\n    t = padL(str(h)) + padL(str(m))\n    return t == t[::-1]\nwhile not palindrome():\n    m += 1\n    if m == 60:\n        h += 1\n        m = 0\n        if h == 24:\n            h = 0\n    ans += 1\nprint(ans)", "n = int(input())\nnums = [int(_) for _ in input().split()]\n\na = nums.index(1)\nb = nums.index(n)\nprint(max(a, n-1-a, b, n-1-b))\n", "a=input().strip()\nb=input().strip()\nif len(b)>len(a):\n  print(''.join(sorted(a))[::-1])\nelse:\n  f=[0]*11\n  for ele in a:\n    f[int(ele)]+=1\n  ans=''\n  i=0\n  n=len(b)\n  while i<n:\n    num=int(b[i])\n    if f[num] : \n      ans+=str(num)\n      f[num]-=1\n    else:\n        break\n    i+=1\n  \n    \n  flag=0\n  while True and len(ans)!=len(a):\n      num=int(b[i])\n      num-=1\n      while num>=0:\n        if f[num]:\n          ans+=str(num)\n          f[num]-=1\n          for j in range(9,-1,-1):\n            ans+=(str(j)*f[j])\n          break\n        num-=1 \n      if len(ans)==len(a):\n        break\n      f[int(ans[-1])]+=1 \n      ans=ans[:-1]\n      i-=1 \n  print(ans.strip())        \n    \n", "matrix=[None]*10\nfor i in range(10):\n\tmatrix[i]=input()\n\nfor i in range(10):\n\tfor j in range(10):\n\t\tif 0<=j and j<=5:\n\t\t\tcount_x=0\n\t\t\thas_o=False\n\t\t\tfor k in range(5):\n\t\t\t\tif matrix[i][j+k]=='X':\n\t\t\t\t\tcount_x+=1\n\t\t\t\telif matrix[i][j+k]=='O':\n\t\t\t\t\thas_o=True\n\t\t\t\t\tbreak\n\t\t\tif count_x==4 and not has_o:\n\t\t\t\tprint(\"YES\")\n\t\t\t\treturn\n\n\t\t\tif 0<=i and i<=5:\n\t\t\t\tcount_x=0\n\t\t\t\thas_o=False\n\t\t\t\tfor k in range(5):\n\t\t\t\t\tif matrix[i+k][j+k]=='X':\n\t\t\t\t\t\tcount_x+=1\n\t\t\t\t\telif matrix[i+k][j+k]=='O':\n\t\t\t\t\t\thas_o=True\n\t\t\t\t\t\tbreak\n\t\t\t\tif count_x==4 and not has_o:\n\t\t\t\t\tprint(\"YES\")\n\t\t\t\t\treturn\n\n\t\tif 0<=i and i<=5:\n\t\t\tcount_x=0\n\t\t\thas_o=False\n\t\t\tfor k in range(5):\n\t\t\t\tif matrix[i+k][j]=='X':\n\t\t\t\t\tcount_x+=1\n\t\t\t\telif matrix[i+k][j]=='O':\n\t\t\t\t\thas_o=True\n\t\t\t\t\tbreak\n\t\t\tif count_x==4 and not has_o:\n\t\t\t\tprint(\"YES\")\n\t\t\t\treturn\n\n\t\t\tif 4<=j and j<=9:\n\t\t\t\tcount_x=0\n\t\t\t\thas_o=False\n\t\t\t\tfor k in range(5):\n\t\t\t\t\tif matrix[i+k][j-k]=='X':\n\t\t\t\t\t\tcount_x+=1\n\t\t\t\t\telif matrix[i+k][j-k]=='O':\n\t\t\t\t\t\thas_o=True\n\t\t\t\t\t\tbreak\n\t\t\t\tif count_x==4 and not has_o:\n\t\t\t\t\tprint(\"YES\")\n\t\t\t\t\treturn\nprint(\"NO\")", "def main():\n    n, k = map(int, input().split())\n\n    if k > n**2:\n        print(-1)\n        return\n\n    A = [[0] * n for _ in range(n)]\n\n    i = 0\n    j = 0\n    while k > 1:\n        A[i][j] = 1\n        k -= 1\n        j += 1\n        while k > 1 and j < n:\n            A[i][j] = 1\n            A[j][i] = 1\n            j += 1\n            k -= 2\n        i += 1\n        j = i\n    if k == 1:\n        A[i][j] = 1\n\n    for i in range(n):\n        for j in range(n):\n            print(A[i][j], end=' ')\n        print()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\ns = input()\nans = n\nfor i in range(n):\n    ss = s[:i]\n    if 2*i <= n and s[:i] == s[i:2*i]:\n        ans = min(ans, n - i +1)\nprint(ans)", "n, a, b = map(int, input().split())\nr = set()\nfor m in range(1, n):\n\tr.add(min(a // m, b // (n - m)))\nprint(max(r))", "def matrixTranspose( matrix ):\n    if not matrix: return []\n    return [ [ row[ i ] for row in matrix ] for i in range( len( matrix[ 0 ] ) ) ]\ndef f(x):\n    #print(x)\n    bool=True\n    b,r,g=0,0,0\n    col=['e']\n    for row in x:\n         if all(el=='R' for el in row):\n             r+=1\n             if col[-1] != 'r':\n                 col.append('r')\n         elif all(el=='G' for el in row):\n             g+=1\n             if col[-1] != 'g':\n                 col.append('g')\n         elif all(el=='B' for el in row):\n             b+=1\n             if col[-1] != 'b':\n                 col.append('b')\n         else:\n             bool=False\n             break\n    return (bool and b==g==r and sorted(col)==sorted(list(set(col))))\n    \nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i]=list(input())\nprint('YES' if f(a) or f(matrixTranspose(a)) else 'NO')", "#By Tianyi Chen\nn=int(input())\ndef j(i):\n\treturn 3*i*(i+1)<=n\nhigh=10**18;low=0\nwhile high-low>5:\n\tmid=high+low>>1\n\tif j(mid):low=mid\n\telse:high=mid\nwhile j(low+1):low+=1\nr=low\nx=r<<1;y=0\nn-=3*r*(r+1)\nr+=1\nif n:\n\tn-=1;x+=1;y+=2\nif n:\n\tsub=min(n,r-1);n-=sub;x-=sub;y+=sub<<1\nif n:\n\tsub=min(n,r);n-=sub;x-=sub<<1\nif n:\n\tsub=min(n,r);n-=sub;x-=sub;y-=sub<<1\nif n:\n\tsub=min(n,r);n-=sub;x+=sub;y-=sub<<1\nif n:\n\tsub=min(n,r);n-=sub;x+=sub<<1\nif n:\n\tsub=min(n,r);n-=sub;x+=sub;y+=sub<<1\nprint(x,y)", "import math\nn = int(input())\ndata = []\ndata = list(map(int,input().split()))\nl = [0] * n\nr = [0] * n\np = 2 * n\np1 = 2 * n\ns = ''\nfor i in range(n):\n    l[i] = p\n    if data[i] == 0:\n        p = i\n    \nfor i in range(n - 1,-1, -1):\n    r[i] = p1\n    if data[i] == 0:\n        p1 = i \n\nfor i in range(n): \n    if data[i] != 0:\n        print(min(abs((l[i] - i)),abs((r[i] - i))), end = ' ')\n    else:\n        print(0, end = ' ')\n        \n\n    ", "d,k,a,b,t = map(int,input().split())\nif(d<=k):\n    print(a*d)\nelif(a*k+t>k*b):\n    print(a*k+(d-k)*b)\nelse:\n    s = d%k\n    x = d//k\n    if(x>=1):\n        im = (a*k)*x+t*(x-1)\n    else:\n        im = 0\n    aaa = t+a*s\n    bbb = s*b\n    im += min(aaa,bbb)\n    print(im)", "n, x = list(map(int, input().split()))\ncur1 = cur2 = cur = res = 0\nfor a in map(int, input().split()):\n    cur1 = max(cur1 + a, 0)\n    cur2 = max(cur2 + a * x, cur1)\n    cur = max(cur + a, cur2)\n    res = max(res, cur)\nprint(res)\n", "read = lambda: map(int, input().split())\nn, k = read()\nb = bin(n)[2:]\nbl = len(b)\nk -= b.count('1')\nif k < 0:\n    print('No')\n    return\nprint('Yes')\nm = -2\na = {}\nfor _ in range(bl):\n    if b[_] == '1':\n        a[bl - _ - 1] = 1\n        if m is -2:\n            m = bl - _ - 1\nwhile k > 0:\n    if k >= a[m]:\n        k -= a[m]\n        a[m - 1] = a.get(m - 1, 0) + a[m] * 2\n        a.pop(m)\n        m -= 1\n    else:\n        break\nm = min(a.keys())\nwhile k > 0:\n    k -= 1\n    if a[m] is 1:\n        a.pop(m)\n    else:\n        a[m] -= 1\n    a[m - 1] = a.get(m - 1, 0) + 2\n    m -= 1\nfor k in sorted(list(a.keys()), reverse=True):\n    print(('%d ' % k) * a[k], end='')\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Nov 30 12:11:39 2017\n\n@author: vishal\n\"\"\"\n\nn=int(input())\na=int(input())\nb=int(input())\n\nif(4*a+2*b<=n):\n    print(1)\nelif(2*a+b<=n or a+2*b<=n and 3*a<=n):\n    print(2)\nelif(a+b<=n and 2*a<=n or 2*b<=n and 2*a<=n or 4*a<=n):\n    print(3)\nelif(2*a<=n or a+b<=n):\n    print(4)\nelif(2*b<=n):\n    print(5)\nelse:\n    print(6)", "s = input()\nn, p = int(s[:-1]), s[-1]\nT = 16 * ((n - 1) // 4)\nk = (n - 1) % 4 + 1\nif k in (2, 4): T += 7\nD = {'f': 1, 'e': 2, 'd': 3, 'a': 4, 'b': 5, 'c': 6}\nT += D[p]\nprint(T)\n", "from math import *\nn=int(input())\nif n==3:\n    li=list(map(int,input().split()))\n    ans=0\n    flag=0\n    for i in li:\n        ans^=i\n    if ans==0:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\nelif n==2:\n    li=list(map(int,input().split()))\n    li.sort()\n    phi=(1+sqrt(5))/2\n    ch=[0]*(785)\n    for i in range(300):\n        a=floor(phi*i)\n        b=floor((phi**2)*i)\n        ch[a]=b\n        ch[b]=a\n    if ch[li[0]]==li[1]:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\nelse:\n    li=int(input())\n    if li==0:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\n", "x,y,z = map(int, input().split())\na = x - y\nif a + z < 0:\n    print('-')\nelif a - z > 0:\n    print('+')\nelif a + z == a - z and a + z == 0:\n    print(0)\nelse:\n    print('?')", "for _ in range(int(input())):\n\tn, x = map(int, input().split())\n\n\ts = input()\n\n\tpref = [0]\n\n\tfor i in range(n):\n\t\tpref.append(pref[-1] + 2 * (s[i] == '0') - 1)\n\n\tjump = pref.pop()\n\n#\tprint(pref, jump)\n\n\tif jump == 0:\n\t\tprint(-1 * (min(pref) <= x <= max(pref)))\n\telse:\n\n\t\ttot = 0\n\n\t\tfor delta in pref:\n\t\t\tif (x - delta) % jump == 0 and (x - delta) // jump >= 0:\n\t\t\t\ttot += 1\n\n\t\tprint(tot)", "#!/usr/bin/env python3\n\nfrom collections import Counter\n\nn = int(input().strip())\nnames = ['Kuro', 'Shiro', 'Katie']\nss = {}\nfor name in names:\n\tss[name] = input().strip()\n\ndef beauty(s, n):\n\tcm = Counter(s).most_common(1)[0][1]\n\tif n == 1 and cm == len(s):\n\t\treturn cm - 1\n\telse:\n\t\treturn min(len(s), cm + n)\n\nres = {}\nfor name in names:\n\tres[name] = beauty(ss[name], n)\n\nbestv = max(res.values())\nif list(res.values()).count(bestv) > 1:\n\tprint ('Draw')\nelse:\n\tfor name, v in list(res.items()):\n\t\tif v == bestv:\n\t\t\tprint (name)\n\n", "import sys\n\ninput = sys.stdin.readline\n\nc, v0, v1, a, l = map(int,input().split())\n\nday = 0\nread = 0\n\nwhile True:\n    if (read >= c):\n        break\n    if (v0 + a * day < v1):\n        read += v0 + a * day\n    else:\n        read += v1\n    if (day > 0):\n        read -= l\n    day += 1\n\nprint(day)", "# python3\n\ndef readline():\n    return list(map(int, input().split()))\n\n\ndef main():\n    n, m, a, b = readline()\n    remove = (n % m) * b\n    add = (m - n % m) * a\n    print(min(add, remove))\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\nc = list([x for x in a if x % 2 == 0 and x > 0])\nb = list([x for x in a if x % 2 != 0])\nb = sorted(b, reverse=True)\nmm = int(-1e10)\ns = 0\nfor i in range(len(b)):\n    s += b[i]\n    if i % 2 == 0:\n        mm = max(mm, s)\n# print(c)\nprint(sum(c) + mm)\n", "import math\na = list(map(int, input().split()))\na.sort()\ndiff = a[1] - a[0]\n\nyakusuu = []\nfor i in range(1, int(diff**(1/2))+1):\n    if diff % i == 0:\n        yakusuu.append(i)\n        yakusuu.append(diff//i)\n\nyakusuu.sort()\nans = [[a[0]*a[1], 0]]\n\nfor i in yakusuu:\n    x = a[0]\n    y = a[1]\n    k = 0\n    if x % i != 0:\n        k = i - x % i\n\n    x += k\n    y += k\n    anstemp = (x*y//math.gcd(x, y))\n    ans.append([anstemp, k])\n\nans.sort()\nprint(ans[0][1])\n", "a, b, x, y = map(int, input().split())\nif a >= x:\n    if b >= y:\n        print('Vasiliy')\n    else:\n        z = y - b\n        t = max(x - z, 0)\n        if a - z <= t:\n            print('Polycarp')\n        else:\n            print('Vasiliy')\nelse:\n    if b <= y:\n        print('Polycarp')\n    else:\n        z = x - a\n        t = max(y - z, 0)\n        if b - z <= t:\n            print('Polycarp')\n        else:\n            print('Vasiliy')", "from sys import stdin, stdout\nn, k = map(int, stdin.readline().split())\n\ncnt = k - 8\nif (n == 1 or n == 3 or n == 5 or n == 7 or n == 8 or n == 10 or n == 12):\n    cnt += 31\nelif n == 2:\n    cnt += 28\nelse:\n    cnt += 30\n\nif cnt % 7:\n    ans = 2 + cnt // 7\nelse:\n    ans = 1 + cnt // 7\n    \nstdout.write(str(ans))", "c = input()\nd = input()\nA = c + d[::-1]\nc = input()\nd = input()\nB = c + d[::-1]\n\nA = A.replace('X', '')\nB = B.replace('X', '')\n\nA = A + A\n\nif (A.find(B) == -1):\n  print('NO')\nelse:\n  print('YES')", "# I'm feeling greedy\nbase = int(input())\nnum = input()\n\nresult = 0\nplace_value = 1\nend = len(num)\nwhile end > 0:\n    begin = end - 1\n    good_begin = begin\n    while begin >= 0:\n        if int(num[begin:end]) >= base:\n            break\n        elif num[begin] != '0':\n            good_begin = begin\n        begin -= 1\n    begin = good_begin\n    result += place_value * int(num[begin:end])\n    place_value *= base\n    end = begin\n\nprint(result)\n", "s = list(input())\nfor i in range(len(s)):\n    if s[i] == '1' and s[i::].count('0') >= 6:\n        print('yes')\n        return\n\nprint('no')\n", "n, m = list(map(int, input().split()))\nl = []\nfor i in range(n):\n\tl.append(list(map(int, input().split())))\nb = [[0] * m for _ in range(n)]\nops = []\nfor i in range(n - 1):\n\tfor j in range(m - 1):\n\t\tif l[i][j] == 1 and l[i + 1][j] == 1 and l[i][j + 1] == 1 and l[i + 1][j + 1] == 1:\n\t\t\tops.append([i + 1, j + 1])\n\t\t\tfor x in range(2):\n\t\t\t\tfor y in range(2):\n\t\t\t\t\tb[i + x][j + y] = 1\nif l == b:\n\tprint(len(ops))\n\tfor i in ops:\n\t\tprint(i[0], i[1])\nelse:\n\tprint(-1)\n", "def tri(ar):\n    d={'.':0,'x':0,'o':0}\n    for i,j in ar:\n        d[a[i][j]]+=1\n    if d['.']==1 and d['x']==2:\n        ans[0]='YES'\n    #print(d)\n        \nans=['NO']\na=[input() for i in range(4)]\nfor i in range(2):\n    for j in range(2):\n        tri([(i,j),(i+1,j+1),(i+2,j+2)])\n    for j in range(2,4):\n        tri([(i,j),(i+1,j-1),(i+2,j-2)])\nfor i in range(4):\n    for j in range(2):\n        tri([(i,j),(i,j+1),(i,j+2)])\n        tri([(j,i),(j+1,i),(j+2,i)])\nprint(ans[0])\n", "import math\ndata = input()\nn, k = data.split(' ')\n\nn = int(n)\nk = int(k)\nm = n\nchaos = 0\nfor i in range(k):\n    if i < math.floor(n/2):\n        chaos += 2*m - 3\n        m -= 2\n    else:\n        break\nprint(chaos)", "n = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nsuma = 0\nsumb = 0\nfor x in a:\n    suma += x\nfor x in b:\n    sumb += x\nprint(\"Yes\" if suma >= sumb else \"No\")", "n, m = list(map(int, input().split()))\nMOD = 1000000007\nans = pow(pow(2, m, MOD)-1+MOD, n, MOD)\nprint(ans)\n", "n = int(input())\nif n % 4 == 0:\n    temp = n // 4\n    m = temp * 3\n    k = temp * 5\nelif n % 2 == 0:\n    n //=  2\n    m = n**2 // 2\n    k = m + 1\n    m *= 2\n    k *= 2\nelse:\n    m = n**2 // 2\n    k = m + 1\nif 3 > n:\n    print(\"-1\")\nelse:\n    print(m,k)\n", "\ndef __starting_point():\n    n,k = input().strip().split()\n    n=int(n) ; k=int(k)\n    a = {}\n    for i in range(1,k+1):\n        if n%i in a:\n            print('No')\n            return\n        else:\n            a[n%i] = 1\n    print('Yes')\n__starting_point()", "n, m = [int(x) for x in input().split()]\na = [[] for i in range(n)]\nfor i in range(m):\n    u, v = [int(x) for x in input().split()]\n    a[u - 1].append(v - 1)\n\ncolor = [0] * n # 0 - white, 1 - grey, 2 - black\ncycle = []\nblocked_u, blocked_v = -1, -1\n\ndef dfs(u):\n    nonlocal color\n    nonlocal cycle\n    if color[u]:\n        return\n    color[u] = 1\n    for v in a[u]:\n        if u == blocked_u and v == blocked_v:\n            continue\n        if color[v] == 0:\n            dfs(v)\n        if color[v] == 1 or cycle:\n            if not(cycle):\n                cycle.append(v)\n            cycle.append(u)\n            return True\n    color[u] = 2\n    return False\n\ndef find_cycle():\n    nonlocal color\n    nonlocal cycle\n    color = [0] * n # 0 - white, 1 - grey, 2 - black\n    cycle = []\n    for u in range(n):\n        if dfs(u):\n            break\n    result = cycle[::-1]\n    return {(result[i], result[(i + 1) % len(result)]) for i in range(len(result))}\n\ncur = find_cycle()\nif not(cur):\n    print('YES')\n    return\n\nfor bu, bv in cur:\n    blocked_u = bu\n    blocked_v = bv\n    new = find_cycle()\n\n    if not(new):\n        print('YES')\n        return\n\nprint('NO')\n", "import time\nimport random\nW = int(input())\nM = [int(a) for a in input().split()]\nA = [0] * 8\nsTime = time.time()\n\ns = 0\nmi = 10**20\nfor i in range(8):\n    if s + M[i]*(i+1) <= W:\n        s += M[i]*(i+1)\n        A[i] = M[i]\n    else:\n        t = (W-s)//(i+1)\n        s += t*(i+1)\n        A[i] += t\n    \n    if s <= W:\n        mi = min(mi, W-s)\n\nwhile time.time() - sTime < 1.7:\n    i = random.randrange(8)\n    a = random.randrange(2)\n    if W-s >= 20 or (s-W < 10 and a == 0):\n        if A[i] < M[i]:\n            A[i] += 1\n            s += (i+1)\n    else:\n        if A[i] > 0:\n            A[i] -= 1\n            s -= (i+1)\n\n    if s <= W:\n        mi = min(mi, W-s)\n\nprint(W-mi)\n", "import sys\n\ninput()\ns = input()\nmaxc = len(s) // 2 * 9\nfor i in range(0, maxc):\n    sum = 0\n    r = \"Y\"\n    l = 0\n    for c in range(len(s)):\n        sum += int(s[c])\n        if sum == i:\n            sum = 0\n            l += 1\n        elif sum > i:\n            r = \"N\"\n            break\n    if r == \"Y\" and sum == 0 and l > 1:\n        print(\"YES\")\n        return\n\nprint(\"NO\")\n", "import sys,heapq\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,a,b=map(int,input().split())\n\nif a<b: a,b=b,a\n\nif b==0:\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\n    print((n-1)*a)\nelse:\n    # pascal's triangle thing\n    pascal=[[1]*20005]\n    for i in range(20004):\n        newrow=[1]\n        for j in range(1,20005):\n            newrow.append(newrow[-1]+pascal[-1][j])\n            if newrow[-1]>n: break\n        pascal.append(newrow)\n    def getcom(a,b):\n        # return a+b choose b\n        # if larger than n, return infinite\n        if len(pascal[a])>b: return pascal[a][b]\n        if b==0: return 1\n        if b==1: return a\n        return 100000005\n\n    # start with the null node (prefix cost 0)\n    # can split a node into two other nodes with added cost c+a+b\n    # new nodes have prefix costs c+a, c+b\n    # want n-1 splits in total\n    remain=n-1\n    ans=0\n    possible=[[a+b,1]]    # [c,count]\n    while 1:\n        # cost u, v leaves\n        u,v=heapq.heappop(possible)\n        while possible and possible[0][0]==u:\n            v+=possible[0][1]\n            heapq.heappop(possible)\n        if remain<=v:\n            ans+=u*remain\n            break\n        ans+=u*v\n        remain-=v\n        heapq.heappush(possible,[u+a,v])\n        heapq.heappush(possible,[u+b,v])\n    print(ans)", "import sys\nx = int(input())\n\nimport math\ndef is_prime(n):\n    if n % 2 == 0 and n > 2: \n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nif (x == 2):\n    print(1)\n    return\n\nif (x == 4 or x == 6):\n    print(2)\n    return\n\nif (x % 2 == 0):\n    print(2)\t\n    return\n\nelse:\n    if (is_prime(x)):\n        print(1)\n        return\n    else:\n        if (is_prime(x -2)):\n            print(2)\n            return\n        else:\n            print(3)\n            return\n", "a = input()\nx =2\nwhile x<len(a):\n    if a[x]!= 'a' and a[x]!= 'e' and a[x]!= 'i' and a[x]!= 'o' and a[x]!= 'u' and a[x]!= ' ':\n        if a[x-1]!= 'a' and a[x-1]!= 'e' and a[x-1]!= 'i' and a[x-1]!= 'o' and a[x-1]!= 'u' and a[x-1]!= ' ' and a[x-2]!= 'a' and a[x-2]!= 'e' and a[x-2]!= 'i' and a[x-2]!= 'o' and a[x-2]!= 'u' and a[x-2]!= ' ':\n            if a[x-2]!=a[x] or a[x]!=a[x-1]:\n                a = a[0:x]+' '+a[x:]\n                x+=1\n    x+=1\nprint(a)\n", "n,k,m = list(map(int, input().split()))\nt = sorted(map(int, input().split()))\nst = sum(t)\nres = 0\nfor x in range(min(m//st, n)+1):\n    rem = m-x*st\n    r = x*(k+1)\n    # for i in range(k):\n        # y = min(rem//t[i], n-x)\n        # rem -= t[i]*y\n        # m += y\n    for i in range(k):\n        for _ in range(n-x):\n            if rem >= t[i]:\n                rem -= t[i]\n                r += 1\n    res = max(res, r)\nprint(res)", "n,m,k = list(map(int,input().split()))\nif k < n:print(k+1,1)\nelse:\n    k-=n\n    m-=1\n    mo = k% (2*m)\n    if mo >= m:\n        mo = (2*m-1)-mo\n    print(n-k//m,2+mo)\n", "import sys\ninput = sys.stdin.readline\n\nx=int(input())\ny=x\nANS=x+1\nAX=[0,0]\n\nimport math\nL=int(math.sqrt(x))\n\nFACT=dict()\n\nfor i in range(2,L+2):\n    while x%i==0:\n        FACT[i]=FACT.get(i,0)+1\n        x=x//i\n\nif x!=1:\n    FACT[x]=FACT.get(x,0)+1\nx=y\nLEN=len(FACT)\nLIST=list(FACT.keys())\nfor i in range(1<<LEN):\n    sc=1\n    for j in range(LEN):\n        if i & (1<<j) !=0:\n            sc*=LIST[j]**FACT[LIST[j]]\n\n    if ANS>max(sc,x//sc):\n        ANS=max(sc,x//sc)\n        AX=[sc,x//sc]\n\nprint(*AX)\n", "a = int(input())\nb = int(input())\nc = int(input())\nans = 0\nwhile a > 0 and b > 1 and c > 3:\n    a -= 1\n    b -= 2\n    c -= 4\n    ans += 7\nprint(ans)", "from sys import stdin\n\nn, k = list(map(int, stdin.readline().split()))\n\ns = stdin.readline().strip()\n\nindex = s.find('G')\nindex2 = s.find('T')\n\nif index > index2:\n    s = ''.join(reversed(s))\n\n\nindex = s.find('G') + k\n\nwhile index < n:\n    if s[index] == 'T':\n        print('YES')\n        break\n    if s[index] == '#':\n        print('NO')\n        break\n    index += k\nelse:\n    print('NO')\n", "a, b, c = list(map(int, input().split()))\nx = max(a, b, c)\na = x - a\nb = x - b\nc = x - c\nif (a > 0 and b > 0) or (a > 0 and c > 0) or (b > 0 and c > 0):\n    print(a + b + c - 2)\nelif a > 0 or b > 0 or c > 0:\n    print(a + b + c - 1)\nelse:\n    print(a + b + c)", "n = int(input())\nwalk = list(map(int, input().split()))\nMAXN = 1000000000\ndef solve1():\n    for i in range(n-1):\n        if abs(walk[i+1]-walk[i]) != 1:\n            return False\n    print(\"YES\")\n    print(MAXN, 1)\n    return True\n\ndef solve2():\n    colum = -1\n    for i in range(n-1):\n        diff = abs(walk[i+1]-walk[i])\n        if diff != 1:\n            if colum == -1:\n                colum = diff\n            elif colum != diff:\n                return False\n    if colum<=0:\n        return False\n    for i in range(n-1):\n        if abs(walk[i+1]-walk[i]) == 1 and ((walk[i+1]-1)//colum != (walk[i]-1)//colum):\n            return False\n    print(\"YES\")\n    print(MAXN,colum)\n    return True\n\nif solve1():\n    pass\nelif solve2():\n    pass\nelse:\n    print(\"NO\")", "from sys import stdin, stdout\n\n\nn = int(stdin.readline())\nfirst = list(map(int, stdin.readline().split()))\nsecond = list(map(int, stdin.readline().split()))\ncntf = [0, 0, 0, 0, 0]\ncnts = [0, 0, 0, 0, 0]\n\nfor i in range(n):\n    cntf[first[i] - 1] += 1\n    cnts[second[i] - 1] += 1\n\nlabel = 1\nfor i in range(5):\n    if (cntf[i] + cnts[i]) % 2:\n        label = 0\n\n\nif not label:\n    stdout.write('-1')\nelse:\n    ans = 0\n    for i in range(5):\n        m = (cntf[i] + cnts[i]) // 2\n        ans += max(cntf[i] - m, 0)\n    \n    stdout.write(str(ans))", "n = int(input())\n\nt = n - (n // 360) * 360\ni = 0\nwhile not (-45 <= t <= 45 or 315 <= t <= 360):\n\ti += 1\n\tt -= 90\nprint(i)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Mar  9 09:54:56 2018\n\n@author: Nikita\n\"\"\"\n\nL, R, A = list(map(int, input().split()))\nif L <= R:\n  if A < R - L:\n    print(2 * (L + A))\n  else:\n    A -= (R - L)\n    print(2 * (R + A // 2))\nelse:\n  if A < L - R:\n    print(2 * (R + A))\n  else:\n    A -= (L - R)\n    print(2 * (L + A // 2))\n", "a, b = list(map(int, input().split()))\nc, d = list(map(int, input().split()))\nz = a * d - b * c\nif z == 0:\n    print(0)\n    return\nt = max(abs(a + b + c + d), abs(a - b - c + d), abs(a - b + c - d), abs(a + b - c- d))\nprint(abs(z / t))\n", "import itertools\nimport math\n\nn = int(input())\nif n%2:\n    print(0)\nelse:\n    m = n // 2\n    print((m-1)//2 )\n\n\n", "def doit():\n    xx = input().split()\n    n = int(xx[0])\n    s = int(xx[1])\n    v = [int(k) for k in input().split()]\n\n    S = sum(v)\n    newS = S - s\n    if newS < 0:\n        return -1\n    return min(newS//n, min(v))\n        \nprint(doit())\n", "h1, h2 = map(int, input().split())\na, b = map(int, input().split())\nh1 += a * 8\nif h1 >= h2:\n    print(0)\nelse:\n    h1 -= b * 12\n    if b >= a:\n        print(-1)\n    else:\n        day = 0\n        while True:\n            day += 1\n            h1 += a * 4\n            '''if h1 > h2:\n                print(-1)\n                break'''\n            h1 += a * 8\n            if h1 >= h2:\n                print(day)\n                break\n            h1 -= b * 12", "n = int(input())\ns = input()\ncountr = s.count('R')\ncountd = n - countr\ncr = 0\ncd = 0\ni = 0\nnews = []\nwhile countr != 0 and countd != 0:\n    if s[i] == 'D':\n        if cd == 0:\n            cr += 1\n            countr -= 1\n            news.append('D')\n        else:\n            cd -= 1\n    else:\n        if cr == 0:\n            cd += 1\n            countd -= 1\n            news.append('R')\n        else:\n            cr -= 1\n    i += 1\n    if i >= n:\n        s = list(news)\n        news = []\n        n = len(s)\n        i = 0\n        \nif countr > 0:\n    print('R')\nelse:\n    print('D')", "#autogenerated (:'D)\nread_numbers = lambda: list(map(int, input().split()))\nINF = 1 << 64\n\n#main\nfrom fractions import gcd\n\na, b, x, y = read_numbers()\ng = gcd(x, y)\nx, y = x // g, y // g\nprint(min(a // x, b // y))", "x, y = map(int, input().split())\nn = int(input())\nf = [x, y, y - x, -x, -y, x - y]\nprint(f[(n - 1) % len(f)] % 1000000007)", "k = []\nn, m = list(map(int, input().split(\" \")))\nfor i in range(m):\n\tx, y = list(map(int, input().split(' ')))\n\tk.append([x, y])\n\ndef ok(x):\n\tfor i in k:\n\t\tif (i[0]-1)//x+1!=i[1]:\n\t\t\treturn False\n\treturn True\n\nposs = []\nfor x in range(1, 101):\n\tif ok(x):\n\t\tposs.append((n-1)//x+1)\n\nif len(list(set(poss))) == 1:\n\tprint(poss[0])\nelse:\n\tprint(-1)\n\n\n", "n = int(input())\narr = list(map(int, input().split()))\nb = c = 0\nfor val in arr:\n    if val >= 0:\n        b += val\n    else:\n        c += val\nprint(b - c)", "a, b, c, d = sorted(list(map(int, input().split())))\nif a + d == b + c or a + b + c == d:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "def maximum_pie_consumption(pies):\n    c = len(pies) - 1\n    toke = wait = 0\n    for p in reversed(pies):\n        if toke < p + wait:\n            toke, wait = wait + p, toke\n        else:\n            wait += p\n    return wait, toke\n\ndef __starting_point():\n    input()\n    pies = list(map(int, input().strip().split()))\n    print(\" \".join(map(str, maximum_pie_consumption(pies))))\n\n__starting_point()", "a=[]\nn,N=list(map(int,input().split()))\nfor i in range(n):\n    a.append(input())\nfor i in range(n):\n    for j in range(N):\n        m=(i and a[i-1][j]=='*')+(j and a[i][j-1]=='*')+(i<n-1 and a[i+1][j]=='*')+(j<N-1 and a[i][j+1]=='*')+(i and j and a[i-1][j-1]=='*')+(i<n-1 and j<N-1 and a[i+1][j+1]=='*')+(i and j<N-1 and a[i-1][j+1]=='*')+(i<n-1 and j and a[i+1][j-1]=='*')\n        if a[i][j]=='.' and m!=0 or '1'<=a[i][j]<='8' and int(a[i][j])!=m:\n            print('NO')\n            return\nprint('YES')\n        \n            \n    \n", "a = int(input())\ni = 0\ncnt = 0\nwhile cnt < a:\n    i += 5\n    i1 = i\n    while i1 % 5 == 0:\n        i1 //= 5\n        cnt += 1\nif cnt == a:\n    print(5)\n    for s in range(i, i+5):\n        print(s, end=' ')\nelse:\n    print(0)", "xmin, ymin, xmax, ymax, a = 31400, 31400, 0, 0, 0\nfor i in range(int(input())):\n    x1, y1, x2, y2 = map(int, input().split())\n    xmin = min(xmin, x1)\n    ymin = min(ymin, y1)\n    xmax = max(xmax, x2)\n    ymax = max(ymax, y2)\n    a += (x2 - x1) * (y2 - y1)\nprint('YES' if xmax - xmin == ymax - ymin and a == (xmax - xmin) ** 2 else 'NO')", "def f(x):\n  return (x if x < 10 else f(x // 10) + x % 10)\nn, s = map(int, input().split())\nx = s\nwhile x - f(x) < s:\n  x += 1\nprint(max(0, n - x + 1))", "from math import pi\nn = int(input())\nsecuencia = [None] * n\nmaximo_to = -1\nfor num in range(n):\n    r, h = (int(x) for x in input().strip().split())\n    secuencia[num] = [r * r * h, num + 1]\nsecuencia.reverse()\nsecuencia.sort(key=lambda x: x[0])\nactual = 0\nbit = [0] * (n + 1)\n\ndef max_x(x, l):\n    suma = 0\n    while x != 0:\n        suma = max(suma, l[x])\n        x -= (x & -x)\n    return suma\n\ndef update_x(x, l, max_n, val):\n    while x <= max_n:\n        if val > l[x]:\n            l[x] = val\n        else:\n            return\n        x += (x & -x)\nfor e in range(n):\n    maximo = secuencia[e][0] + max_x(secuencia[e][1] - 1, bit)\n    update_x(secuencia[e][1], bit, n, maximo)\n    if maximo > maximo_to:\n        maximo_to = maximo\nprint(maximo_to * pi)", "n,k = map(int,input().split())\narr = list(map(int,input().split()))\n\narr.sort()\nheights = []\ncounter=arr[0]\nfor i in range(n):\n    while arr[i]>=counter:\n        heights.append(n-i)\n        counter+=1\n\nheights.reverse()\n\n\nans=0\ncontainer=0\nfor i in range(len(heights)-1):\n    if heights[i]+container<=k:\n        container+=heights[i]\n    else:\n        container=heights[i]\n        ans+=1\nif container>0:ans+=1\n\nprint(ans)", "n = int(input())\nl = list(map(int,input().split()))\n\ncurr = 0\nbest = 0\nprevs = [0] * 31\nfor v in l:\n    curr += v\n    if v >= 0:\n        for i in range(0, v):\n            prevs[i] = curr\n        for i in range(v, 31):\n            best = max(curr - prevs[i] - i, best)\n    else:\n        for i in range(31):\n            prevs[i] = min(prevs[i], curr)\nprint(best)\n", "#credits https://www.geeksforgeeks.org/minimum-steps-to-delete-a-ssing-after-repeated-deletion-of-palindrome-subssings/\n  \nn=int(input())\ns=input()\nN = len(s)\ndp = [[0 for x in range(N + 1)] \n         for y in range(N + 1)]\nD = [[[] for x in range(N + 1)] \n         for y in range(N + 1)]\nss=\"\"\nre=\"\"\nfor i in range(0,N):\n    if re!=s[i]:\n        ss+=re\n        re=s[i]\nss+=re\na=ss\nN=len(a)\nfor l in range(1, N + 1): \n    i = 0\n    j = l - 1\n    while j < N: \n        if (l == 1): \n            dp[i][j] = 1\n        else: \n\n            dp[i][j] =1+dp[i + 1][j]\n\n            for K in range(i + 1, j + 1): \n                if (a[i] == a[K]):\n                        if dp[i][j]>=dp[i ][K - 1] + dp[K + 1][j]:\n                            dp[i][j] = dp[i][K - 1] + dp[K + 1][j]\n\n                        \n                      \n        i += 1\n        j += 1\n\nprint(dp[0][N-1])\n\n", "def f(q1, q2, k1, k2):\n    res1 = res2 = 0\n    res1 += ((q1 + 1) // 2) * k1\n    res1 += (q1 // 2) * k2\n    res2 += (q2 // 2) * k2\n    res2 += ((q2 + 1) // 2) * k1\n    return [res1, res2]\n\n\nn = int(input())\ns = input()\nsum_l = sum_r = 0\nql = qr = 0\nfor i in range(n // 2):\n    if s[i] == '?':\n        ql += 1\n    else:\n        sum_l += int(s[i])\nfor i in range(n // 2, n):\n    if s[i] == '?':\n        qr += 1\n    else:\n        sum_r += int(s[i])\nmn = float('inf')\nmx = float('inf')\nkek = [f(ql, qr, 0, 9), f(ql, qr, 9, 0), f(qr, ql, 9, 0)[::-1], f(qr, ql, 0, 9)[::-1]]\nlol = []\nfor x in kek:\n    lol.append(x[0] + sum_l - x[1] - sum_r)\nlol.sort()\nif lol[0] <= 0 <= lol[-1]:\n    print('Bicarp')\nelse:\n    print('Monocarp')\n", "N, T = list(map(int, input().split()))\nmi = 10**100\nfor i in range(N):\n    s, d = list(map(int, input().split()))\n    if s >= T:\n        a = s - T\n    else:\n        a = (s - T) % d\n    if a < mi:\n        mi = a\n        ans = i + 1\nprint(ans)\n", "n = int(input())\nk = []\nfor i in range(n):\n\ta = [int(i) for i in input().split()]\n\tk.append(a)\nif n == 1:\n\tprint(1)\nelse:\n\tzer = []\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif 0 == k[i][j]:\n\t\t\t\tzer = [i, j]\n\tif zer[0] == 0:\n\t\tm = sum(k[1])\n\telse:\n\t\tm = sum(k[0])\n\tk[zer[0]][zer[1]] = m-sum(k[zer[0]])\n\tif k[zer[0]][zer[1]] > 0:\n\t\ty = 1\n\telse:\n\t\ty = 0\n\tfor i in range(n):\n\t\tif sum(k[i]) != m:\n\t\t\ty = 0\n\tfor j in range(n):\n\t\tu = 0\n\t\tfor i in range(n):\n\t\t\tu+= k[i][j]\n\t\tif u!= m:\n\t\t\ty = 0\n\tu = 0\n\tfor i in range(n):\n\t\tu+=k[i][i]\n\tif u!= m:\n\t\ty = 0\n\tu = 0\n\tfor i in range(n):\n\t\tu+=k[i][n-i-1]\n\tif u!= m:\n\t\ty = 0\n\tif y == 1:\n\t\tprint(k[zer[0]][zer[1]])\n\telse:\n\t\tprint(-1)\n", "n, s = input().split()\nlast = s[0]\nans = n[0]\nfor x in n[1:]:\n    if x<last:\n        ans+=x\n    else:\n        break\nprint(ans+last)", "#This code is dedicated to Olya S.\nl=int(input())\nn=input()\n\ndef offset(ml,x):\n    return (ml-x)//2\n\ndef getstate(g,line,ml):\n    off=offset(ml,g[0])\n    if line<off or line>=g[0]+off:\n        return 0\n    elif line==off or line == g[0]+off-1:\n        return 1\n    else:\n        return 2\n    \n    \n    \n\n#Find max bracket#\nml=1\ncl=1\nfor b in n:\n    if b=='[':\n        cl+=2\n        if ml<cl:\n            ml=cl\n    else:\n        cl-=2\n######MAP######\nsc=[]\nfor b in n:\n    if b=='[':\n        sc.append([ml,True])\n        ml-=2\n    else:\n        ml+=2\n        sc.append([ml,False])\n#####################\nfor i in range(ml):\n    for j in range(l):\n        g=sc[j]\n        state=getstate(g,i,ml)\n        if state==1:\n            if g[1]:\n                print('+-',end='')\n            else:\n                print('-+',end='')\n        elif state==0:\n            if sc[j-1][0]-sc[j][0]!=2:\n                print('  ',end='')\n        else:\n            print('|',end='')\n        if sc[j][1] and not sc[j+1][1]:\n            if state==2:\n                print('   ',end='')\n            else:\n                print(' ',end='')\n        \n    print()\n\n    \n\n\n\n\n\n\n            \n", "u = v = 0\n\na, b = input(), input()\n\nn, m = len(a), len(b)\n\nif n > m: b = '0' * (n - m) + b\n\nelse: a = '0' * (m - n) + a\n\nfor i in range(max(n, m)):\n\n    u, v = v + u, u + int(a[i]) - int(b[i])\n\n    if u > 1:\n\n        print('>')\n\n        return\n\n    elif u < -1:\n\n        print('<')\n\n        return\n\nd = 2 * v + u\n\nif u == v == 0: print('=')\n\nelif u >= 0 and d >= 0: print('>')\n\nelif u <= 0 and d <= 0: print('<')\n\nelse: print('>' if (u * u > v * (v + u)) ^ (u < 0) else '<')\n\n\n\n# Made By Mostafa_Khaled\n", "from copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\n\ndef read():\n    return int(input())\n\n\ndef readmap():\n    return list(map(int, input().split()))\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\ncolor = [\"purple\", \"green\", \"blue\", \"orange\", \"red\", \"yellow\"]\ngem = [\"Power\", \"Time\", \"Space\", \"Soul\", \"Reality\", \"Mind\"]\n\nN = int(input())\ns = set()\nfor _ in range(N):\n    s.add(input())\n\nm = 6 - N\nprint(m)\nfor i in range(6):\n    if not color[i] in s:\n        print(gem[i])\n\n", "import sys\n \nn = int(input())\np = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n \nans = 0\nnum_cycles = 0\nchecked = set()\n \nfor i in range(n):\n    if i in checked:\n        continue\n \n    checked.add(i)\n \n    nxt = p[i] - 1\n \n    while nxt != i:\n        checked.add(nxt)\n        nxt = p[nxt] - 1\n \n    num_cycles += 1\n \nans += num_cycles if num_cycles != 1 else 0\nans += (sum(b) % 2) == 0\n \nprint(ans)\n", "import random, math\na, b = map(int, input().split())\nr = 1\nif b > a + 6:\n\tprint(0)\nelse:\n\tfor i in range(a + 1, b + 1):\n\t\tr *= i % 10\n\tprint(r % 10)", "a,b=map(int,input().split())\nyear=0\nwhile a<=b:\n    a*=3\n    b*=2\n    year+=1\nprint(year)", "r = open('input.txt')\nf = lambda: list(map(int, r.readline().split()))\nf()\na, b = f()\nif a > b: a, b = b, a\nn = 40001\nu, v = [n] * n, [n] * n\nx = s = 0\nu[0] = v[0] = 0\nfor y in f():\n    s += y\n    p = []\n    h = min(x, y)\n    for d in range(min(s, a), -1, -1):\n        t = v[d]\n        if u[d] != n:\n            u[d + y] = min(u[d], u[d + y])\n            u[d], v[d] = n, min(t, u[d] + h)\n        if t != n: u[d + y] = min(u[d + y], t + h)\n    x = y\ni, j = max(s - b, 0), min(s, a) + 1\nd = min(u[i:j] + v[i:j]) if i < j else n\nopen('output.txt', mode='w').write(str(d if d < n else -1))\n", "a, b = input().split()\na, b = int(a), int(b)\n\nif (a//b) % 2 == 1:\n    print('YES')\nelse:\n    print('NO')\n\n", "def main() -> int:\n    n = int(input())\n    exercises = [int(word) for word in input().split()]\n    total = [0] * 3\n\n    for i in range(3):\n        total[i] = sum(exercises[i::3])\n\n    max_index = total.index(max(total))\n    exercise_names = ['chest', 'biceps', 'back']\n\n    print(exercise_names[max_index])\n\n    return 0\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nai= list(map(int, input().split()))\nai.sort()\nsumm = sum(ai)\nif summ  / n >= 4.5:\n    print(0)\nelse:\n    for i in range(n):\n        summ += 5 - ai[i]\n        if summ  / n >= 4.5:\n            print(i+1)\n            break\n", "u, v = list(map(int, input().split()))\nif v < u or (v - u) % 2 != 0:\n    print(-1)\nelse:\n    if u == v:\n        if u == 0:\n            print(0)\n        else:\n            print(\"1\\n\" + str(u))\n    else:\n        w = (v - u) // 2\n        if (w | u) == (w + u):\n            print(\"2\\n\" + str(w|u) + ' ' + str(w))\n        else:\n            print(\"3\\n\" + str(u) + ' ' + str(w) + ' ' + str(w))\n\n", "n = int(input())\n\nd = {}\n\ndef count(x):\n\tif x == 0:\n\t\treturn 0\n\telif x in d:\n\t\treturn d[x]\n\n\tx_s = str(x)\n\tlow = int(\"1\"*len(x_s)) if int(\"1\"*len(x_s)) <= x else int(\"1\"*(len(x_s)-1))\n\thigh = int(\"1\"*len(x_s)) if int(\"1\"*len(x_s)) >= x else int(\"1\"*(len(x_s)+1))\n\n\tl_val, h_val = -1, -1\n\tif abs(x - low) < x:\n\t\tl_val = len(str(low)) + count(abs(x - low))\n\tif abs(x - high) < x:\n\t\th_val = len(str(high)) + count(abs(x - high))\n\n\tret = min(l_val, h_val) if min(l_val, h_val) >= 0 else max(l_val, h_val)\n\td[x] = ret\n\treturn ret\n\nprint(count(n))", "a,b,c,d=input().strip().split(' ')\nx1,y1,x2,y2=(int(a),int(b),int(c),int(d))\nx,y=input().strip().split(' ')\nx,y=(int(x),int(y))\nif (x2-x1)%x==0 and (y2-y1)%y==0:\n    a1=(x2-x1)//x\n    a2=(y2-y1)//y\n    if (a1%2==0 and a2%2==0) or (a1%2==1 and a2%2==1):\n        print(\"YES\")\n        return\nprint(\"NO\")", "a = int(input())\nb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nwhile a != 0:\n    b[a % 10] += 1\n    a //= 10\n\nans = 0\n\ndef gao(n):\n    f = 1\n    for i in range(1, n + 1):\n        f *= i\n    return f\n\ndef shit(n, arr):\n    nonlocal ans\n    if n == 10:\n        sum = 0\n        for i in range(10):\n            sum += arr[i]\n        gg = sum - arr[0]\n        gg *= gao(sum - 1)\n        for i in range(10):\n            if arr[i] > 1:\n                gg //= gao(arr[i])\n        ans += gg\n    else:\n        if b[n] > 0:\n            for i in range(1, b[n] + 1):\n                gg = arr.copy()\n                gg.append(i)\n                shit(n + 1, gg)\n        else:\n            arr.append(0)\n            shit(n + 1, arr)\n\n\nshit(0, [])\nprint(int(ans))", "a,b,p,x = list(map(int, input().strip().split()))\n\n\ndef brute(a,b,p,x):\n    for n in range(1, x+1):\n        if (n*pow(a,n,p)) % p == b:\n            print(n)\n\n#brute(a,b,p,x)\n\nsols = 0\n\ninva = pow(a,p-2,p)\n\n##print('a', inva)\n\na2 = 1\nb2 = b\ns = 0\nd1 = -b\nfac = p*(p-1)\nwhile s < p-1:\n    k = (d1 + s) % p\n    u = k\n    L = x - s - (p-1)*k\n    sols += L//fac + 1\n##    while (p-1)*u + s <= x:\n##        n = (p-1)*u + s\n##        print(s, k, n)\n##        print(n)\n##        #print(n*pow(a,n,p) % p, b)\n##        sols += 1\n##        u += p\n    d1 = (d1 * inva) % p\n    s += 1\n\nprint(sols)\n        \n\n        \n    \n\n", "x, y, z, t1, t2, t3=map(int,input().split())\nif abs(y-x)*t1<(abs(x-z)*t2+abs(y-x)*t2+3*t3):\n  print (\"NO\")\nelse:\n  print (\"YES\")", "n = int(input())\na = list(map(int, input().split()))\ncount = 0\ni = 0\nwhile i < n and a[i] == 0:\n    i += 1\nwhile i < n:\n    if a[i] == 1:\n        i += 1\n        count += 1\n    else:\n        tmp = 0\n        while i < n and a[i] == 0:\n            tmp += 1\n            i += 1\n        if i != n and tmp < 2:\n            count += tmp\nprint(count)", "d=input().split()\nn=int(d[0])\nk=int(d[1])\nd=input().split()\nd=[int(x) for x in d]\nS=0\nfor i in range(n-1):\n    if (d[i]+d[i+1])<k:\n        S+=k-(d[i]+d[i+1])\n        d[i+1]+=k-(d[i]+d[i+1])\n        \nprint(S)\nfor i in d:\n    print(i,end=\" \")\n", "n=int(input())-1\nprint(2*n*(n+1)+1)\n", "ip=str(input())\nh=int(ip[0]+ip[1])\nm=int(ip[3]+ip[4])\nk=h*60+m\nn=int(input())\nk+=n\nh1=(k//60)%24\nm1=k%60\nif h1<10:\n    h1='0'+str(h1)\nif m1<10:\n    m1='0'+str(m1)\nprint(h1,end=':')\nprint(m1)\n", "left = 0\nright = 0\nn = int(input())\nfor i in range(n):\n    x, y = map(int, input().split())\n    if x > 0:\n        right += 1\n    else:\n        left += 1\nif right <= 1 or left <= 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "n = int(input())\nprint (9 * n, 8 * n)", "it = lambda: list(map(int, input().strip().split()))\nINF = float('inf')\n\n\ndef solve():\n    N = int(input())\n    S = []\n    R = []\n    C = []\n    for _ in range(N):\n        s, c = input().strip().split()\n        S.append(s)\n        R.append(s[::-1])\n        C.append(int(c))\n    \n    vis = set()\n    mem = dict()\n\n    def dp(s, p):\n        if (s, p) in mem: return mem[s, p]\n        if s == s[::-1]: return 0\n        if (s, p) in vis: return INF\n\n        ans = INF\n        vis.add((s, p))\n        for i, t in enumerate(S if p else R):\n            if len(t) >= len(s) and t.startswith(s):\n                ans = min(ans, dp(t[len(s):], p ^ 1) + C[i])\n            elif len(s) > len(t) and s.startswith(t):\n                ans = min(ans, dp(s[len(t):], p) + C[i])\n        vis.discard((s, p))\n        mem[s, p] = ans\n        return ans\n        \n    ans = INF\n    for i in range(N):\n        ans = min(ans, dp(S[i], 0) + C[i])\n    return -1 if ans == INF else ans\n\n\ndef __starting_point():\n    ans = solve()\n    print(ans)\n__starting_point()", "n, k = list(map(int, input().split()))\nif k == 1:\n    print(n)\nelse:\n    ans = bin(n)[2:]\n    ans = ans.replace(\"0\", \"1\")\n    ans = int(ans, 2)\n    print(ans)\n", "p, y = [int(x) for x in input().split()]\nres = -1\nfor i in range(y, p, -1):\n    flag = True\n    for a in range(2, min(p+1, int(i**0.5)+1)):\n        if i % a == 0:\n            flag = False\n            break\n    if flag:\n        res = i\n        break\nprint(res)\n", "n = int(input())\na = 1\nb = 1\nc = n - a - b\nif c % 3 == 0:\n    c -= 1\n    b += 1\nprint(a, b, c)\n\n", "n, a, b, c, d = map(int, input().split())\nans = 0\nfor i in range(1, n + 1):\n\tx = i + b - c\n\ty = i + a + b - c - d\n\tz = i + a - d\n\tans += n * (1 <= x <= n and 1 <= y <= n and 1 <= z <= n)\nprint(ans)", "from math import log, ceil\nn = int(input())\n\nd = {}\n\ndef prime_fac(n):\n    nonlocal d\n    i = 2\n    while i <= n:\n        while n % i == 0 and i <= n:\n            n //= i\n            d[i] = d.get(i, 0) + 1\n        i += 1\n \nif n == 1:\n    print(1, 0)\nelse:\n    prime_fac(n)\n    m = d[max(d, key=lambda x: d[x])]\n    prod = 1\n    for i in d:\n        prod *= i\n    if m in [2**i for i in range(50)] and len(set(d.values())) == 1:\n        print(prod, int(log(m, 2)))\n    else:\n        print(prod, ceil(log(m, 2)) + 1)", "s=input()\nprev=-1\nans=1\nfor x in s:\n    if prev=='cons' and  x not in 'aeiou':\n        ans=0\n    if x in 'aeioun':\n        prev='vow'\n    else:\n        prev='cons'\nif prev=='cons':\n    ans=0\nprint(\"YES\" if ans else \"NO\")", "n = int(input())\narr = list(map(int, input().split()))\narr.sort()\narr = arr[::-1]\nans = [arr[0]]\nfor i in range(1, n):\n\tif(arr[i] < ans[-1]):\n\t\tans.append(arr[i])\n\telse:\n\t\tans.append(max(0, ans[-1] - 1))\nprint(sum(ans))", "n, k = list(map(int, input().split()))\naa = sorted(map(int, input().split()))\n\nansw = 0\n\nfor a in aa:\n    while 2 * k < a:\n        k *= 2\n        answ += 1\n    k = max(k, a)\n\nprint(answ)\n", "A = [input() for i in range(8)]\nB = 9\nW = 9\nfor i in range(8):\n    for j in range(8):\n        if A[j][i] == \"W\":\n            W = min(W, j)\n            break\n        if A[j][i] == \"B\":\n            break\n    for j in range(7, -1, -1):\n        if A[j][i] == \"B\":\n            B = min(B, 8 - j)\n            break\n        if A[j][i] ==\"W\":\n            break\nif B <= W:\n    print(\"B\")\nelse:\n    print(\"A\")\n", "def f(n):\n    m, l = int(n ** 0.5) + 1, n - 1\n    t = [1] * n\n    for i in range(3, m):\n        if t[i]: t[i * i :: 2 * i] = [0] * ((l - i * i) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n, 2) if t[i]]\n\na, b, k = map(int, input().split())\nk -= 1; b += 1; n = b + 100\n\nt, p, x = [-1] * n, f(n), -1\n\nfor i in range(len(p) - k):\n    t[p[i]] = p[i + k] - p[i]\n\nt.reverse()\nfor i in range(1, n):\n    if t[i] < 0: t[i] = t[i - 1] + 1\nt.reverse()\n\nif len(p) > k: \n    for i in range(a + 1, b):\n        t[i] = max(t[i], t[i - 1])\n\n    for l in range(1, b - a + 1):\n        if t[b - l] < l:\n            x = l\n            break\nprint(x)", "def gcd(n,m):\n    if m==0:return n\n    else:return gcd(m,n%m)\na,h,w=map(int,input().split())\ng=gcd(a+h,a+w)\ns=(a+w)//g\nt=((w//a+1)//s)*s-1\nif t<=0:print(-1)\nelse:print(\"%.10lf\"%((w-t*a)/(t+1)))", "import getpass\nimport math\nimport sys\nimport string\nimport re\nimport math\nimport random\nfrom decimal import Decimal, getcontext\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n\nn = ria()[0]\nar = []\nfor i in range(n):\n    ar.append(ria())\nlk = ria()[0]\ncnt = 0\nlk -= 1\nfor l, r in ar:\n    if l <= lk and r <= lk:\n        cnt += 1\nprint(n - cnt)\n", "x = input()\nn = len(x)\n\nfor i in range(n):\n  for j in range(i+1,n+1):\n    if(x[:i]+x[j:]==\"CODEFORCES\"):\n        print(\"YES\")\n        return\nprint(\"NO\")\nreturn\n", "n = int(input())\nm = 0\nfor i in range(2, n):\n\tm += i * (i + 1)\nprint(m)", "A = [''] * 8\nb = 0\nw = 0\ndef count(v):\n    nonlocal w, b\n    if v == 'Q':\n        w += 9\n    elif v == 'R':\n        w += 5\n    elif v == 'B':\n        w += 3\n    elif v == 'N':\n        w += 3\n    elif v == 'P':\n        w += 1\n    elif v == 'q':\n        b += 9\n    elif v == 'r':\n        b += 5\n    elif v == 'b':\n        b += 3\n    elif v == 'n':\n        b += 3\n    elif v == 'p':\n        b += 1\nfor i in range(8):\n    A[i] = input()\n    for j in range(8):\n        count(A[i][j])\nif b > w:\n    print(\"Black\")\nelif b == w:\n    print(\"Draw\")\nelse:\n    print(\"White\")\n", "n = int(input()) \nl, r = 0, 10**16 \nD = [x ** 3.0 for x in range(2, 170417)] \nDD = [x*x*x for x in range(2, 170417)] \nwhile l < r: \n\tm = (l+r) // 2 \n\tif sum(int(m/d) for d in D) < n: \n\t\tl = m + 1 \n\telse: \n\t    r = m; \nif sum(l//d for d in DD) == n: \n\tprint(l); \nelse : \n    print(-1);", "n = int(input())\n\nif n!=2:\n\tprint(1)\nelse:\n\tprint(2)", "n, m = list(map(int, input().split()))\npieces = []\ns = None\nf = None\nflag = True\nopn = False\nfor k in range(n):\n    line = input()\n    i = 0\n    j = len(line) - 1\n    \n    while i < m:\n        if line[i] == 'X':\n            if not(s is None or i == s):\n                flag = False\n                break\n            else:\n                s = i\n                break\n        i += 1\n    i = 0\n    while i < m:\n        if line[i] == 'X':\n            if i != 0 and line[i - 1] == '.' and opn:\n                flag = False\n                break        \n        if line[i] == '.' and i != 0 and line[i - 1] == 'X':\n            opn = True\n        i += 1\n    opn = False\n    while j > -1:\n        if line[j] == 'X':\n            if not(f is None or j == f):\n                flag = False\n                break\n            else:\n                f = j\n                break\n        j -= 1\nif flag: print(\"YES\")\nelse: print(\"NO\")\n\n", "import sys\n\n\ndef main():\n    n, m, q = list(map(int, input().strip().split()))\n    s = input()\n    t = input()\n\n    pos = []\n    for i in range(len(s)):\n\n        if i + len(t) <= len(s) and s[i:i+len(t)] == t:\n            pos.append(1)\n        else:\n            pos.append(0)\n\n    sum = [0]\n    for i in range(len(pos)):\n        sum.append(sum[-1] + pos[i])\n\n    for _ in range(q):\n        l, r = list(map(int, input().strip().split()))\n        r = r - len(t) + 1\n        l -= 1\n\n        if l < r:\n            print(sum[r] - sum[l])\n        else:\n            print(0)\n\n    return 0\n\n\ndef test(i):\n    with open(\"test_{}.txt\".format(i)) as fin:\n        sys.stdin = fin\n        main()\n\n\ndef __starting_point():\n    # test(1)\n    # test(2)\n    return(main())\n\n__starting_point()", "class Node:\n    def __init__(self, index):\n        self.left = index - 1\n        self.right = index + 1\n        self.pair = -1\n\ndef __starting_point():\n    n, m, p = map(int, input().split())\n    brackets = input()\n    operations = input()\n\n    nodes = [Node(i) for i in range(n + 1)]\n    stack = []\n\n    for i in range(n):\n        if brackets[i] == \"(\":\n            stack.append(i + 1)\n        else:\n            pair_id = stack.pop()\n            nodes[pair_id].pair = i + 1\n            nodes[i + 1].pair = pair_id\n\n    for i in range(m):\n        if operations[i] == \"L\":\n            p = nodes[p].left\n        elif operations[i] == \"R\":\n            p = nodes[p].right\n        else:\n            pair_id = nodes[p].pair\n            \n            left = min(p, pair_id)\n            right = max(p, pair_id)\n\n            left_node = nodes[left].left\n            right_node = nodes[right].right\n\n            nodes[left_node].right = right_node\n            if right_node != n + 1:\n                nodes[right_node].left = left_node\n                p = right_node\n            else:\n                p = left_node\n\n    p = nodes[0].right\n    result = []\n    while p != n + 1:\n        result.append(brackets[p - 1])\n        p = nodes[p].right\n\n    print(\"\".join(result))\n__starting_point()", "        \nn = int(input())\n\nfor i in range(2, min(1000001, n) ) :\n    while n % (i*i) == 0 :\n        n //= i\n\nprint(n)\n", "n = int(input())\nl = list(map(int, input().split()))\nl.sort(key=lambda x: -x)\ni = 0\ncur = 0\nans = 0\nwhile i < len(l)-1:\n    if l[i] == l[i+1] or l[i]-1 == l[i+1]:\n        if cur == 0:\n            cur = l[i+1]\n        else:\n            ans += cur*l[i+1]\n            cur = 0\n        i += 2\n    else:\n        i += 1\nprint(ans)\n", "l = input().split(' ')\nprint(\"Yes\" if int(l[0]) == int(l[1]) else \"No\")", "a,b=map(int,input().split())\nz=0\nwhile a<b:\n    if b%2==True:\n        z+=1\n        b+=1\n    else:\n        b=b//2\n        z+=1\nprint(str(int(abs((z+a-b)))))", "def get(px, py, x, y):\n\tans = 10**18\n\tnonlocal k\n\tif px <= k:\n\t\tcnt = (px + x + k - 1) // k - 1\n\t\tif y == cnt:\n\t\t\tans = min(ans, px + x - cnt * k)\n\t\telif y > cnt and y <= x * k:\n\t\t\tans = min(ans, 1)\n\tif py <= k:\n\t\tcnt = (x + k - 1) // k - 1\n\t\tif y == cnt:\n\t\t\tans = min(ans, x - cnt * k)\n\t\telif y > cnt and y <= (x - 1) * k + (k - py):\n\t\t\tans = min(ans, 1)\n\treturn ans\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\ndp = [[10**18] * (n + 1), [10**18] * (n + 1)]\ndp[0][0], dp[1][0] = 0, 0\nfor i in range(n):\n\tdp[0][i + 1] = get(dp[0][i], dp[1][i], x[i], y[i])\n\tdp[1][i + 1] = get(dp[1][i], dp[0][i], y[i], x[i])\nprint('YES' if min(dp[0][-1], dp[1][-1]) <= k else 'NO')", "n,k=map(int,input().split())\ns=input()\nif len(s)==1:\n\tif k>=1:\n\t\tprint('0')\n\telse:\n\t\tprint(s[0])\n\treturn\ncc=0\narr=[]\nfor i in s:\n\tarr.append(i)\nif k==0:\n\tprint(s)\n\treturn\nif int(arr[0])>1:\n\tarr[0]='1'\n\tcc+=1\nfor i in range(1,len(s)):\n\tif cc==k:\n\t\tbreak\n\tif int(arr[i])!=0:\n\t\tarr[i]='0'\n\t\tcc+=1\n\tif cc==k:\n\t\tbreak\nprint(''.join(arr))", "c1, c2, x, y = list(map(int, input().split()))\ndef get(n):\n    if (n - n // (x * y)) >= c1 + c2 and (n - n // x >= c1) and (n - n // y >= c2):\n        return True\n    else:\n        return False\nl = 0\nr = c1 * x + c2 * y\nwhile (r - l > 1):\n    m = (l + r) // 2\n    if get(m):\n        r = m\n    else:\n        l = m\nprint(r)\n", "mod, sx, sy, dx, dy, t = list(map(int, input().split()))\nclass Matrix():\n    def __init__(self, n):\n        self.n = n\n        self.a = [[0] * n for _ in range(n)]\n\n    def __mul__(self, b):\n        res = Matrix(self.n)\n        for i in range(self.n):\n            for j in range(self.n):\n                for k in range(self.n):\n                    res.a[i][j] += self.a[i][k] * b.a[k][j] % mod\n                    res.a[i][j] %= mod\n        return res\n\n    def __pow__(self, e):\n        res = Matrix(self.n)\n        for i in range(self.n):\n            res.a[i][i] = 1\n        tmp = self\n        while e:\n            if e & 1:\n                res = res * tmp\n            e >>= 1\n            tmp = tmp * tmp\n        return res\nM = Matrix(6)\nM.a = [[2, 1, 1, 0, 1, 2],\n       [1, 2, 0, 1, 1, 2],\n       [1, 1, 1, 0, 1, 2],\n       [1, 1, 0, 1, 1, 2],\n       [0, 0, 0, 0, 1, 1],\n       [0, 0, 0, 0, 0, 1]]\nsx -= 1\nsy -= 1\nr = M ** t\nf = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % mod + 1\nprint(f(0), f(1))\n", "import sys\nf = sys.stdin\n\nn = int(f.readline().strip())\n\na = [int(u) for u in f.readline().strip().split()]\n\na = sorted(a, reverse=True)\nW1 =0\nW2 = 0\n\nfor i in range(int(n/2)):\n    W1 += a[2*i]\n    W2 += a[2*i+1]\n\nif n % 2 == 1:\n    W2 += a[n-1]\n\n    \nif W1==W2 :res = 'YES'\nelse: res = 'NO'\n\nprint(res)\n\n", "\nn, a, b = map(int, input().split())\na -= 1\n\nprint (((a + b + n * 1000) % n) + 1)", "n = int(input())\nm = int(input())\n\nr = pow(2, min(n, 60))\n\nprint(m % r)\n", "from time import time\nn = int(input())\na = list(map(int, input().split()))\n\nstart = time()\n\ncache = {}\n\n\ndef is_prime(n):\n    if n not in cache:\n        cache[n] = _is_prime(n)\n\n    return cache[n]\n\n\ndef _is_prime(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n % 2 == 0: return False\n    if n < 9: return True\n    if n % 3 == 0: return False\n    r = int(n ** 0.5)\n    f = 5\n    while f <= r:\n        if n % f == 0: return False\n        if n % (f + 2) == 0: return False\n        f += 6\n    return True\n\n\ns = {}\ni = 0\nwhile i < len(a):\n    if a[i] > 1 and a[i] in s:\n        a.pop(i)\n    else:\n        s[a[i]] = True\n        i += 1\n\np = [0] * len(a)\nfor i in range(0, len(a)):\n    for j in range(i + 1, len(a)):\n        if not is_prime(a[i] + a[j]):\n            p[i] += 1\n            p[j] += 1\n\nwhile True:\n    mx = max(p)\n    if mx == 0:\n        break\n\n    mi = p.index(mx)\n\n    for i in range(0, len(a)):\n        if i == mi or not is_prime(a[mi] + a[i]):\n            p[i] -= 1\n\n    a.pop(mi)\n    p.pop(mi)\n\nprint(len(a))\nprint(\" \".join(map(str, a)))\n\n#print(time() - start)\n", "n,m = map(int,input().split())\na=list(map(int,input().split()))\nimax=0\nfor i in range(1,n):\n\tif a[i]>a[imax]:\n\t\timax=i\nk=(a[imax]-1)//m\ni=n-1\nwhile i>=0:\n\tif (a[i]-1)//m==k:\n\t\tprint(i+1)\n\t\tbreak\n\telse:\n\t\ti-=1", "n=int(input())\nans=0\nans+=n//100\nn%=100\nans+=n//20\nn%=20\nans+=n//10\nn%=10\nans+=n//5\nn%=5\nans+=n\nprint(ans)\n", "mod=10**9+7\nn,k=list(map(int,input().split()))\n\nA=[0]*(n+1)\nB=[0]*(n+1)\nC=[0]*(n+1)\nF=[0]*(n+1)\nG=[0]*(n+1)\n\nF[0]=G[0]=1\nfor i in range(1,n+1):\n\tG[i]=F[i]=F[i-1]*i%mod\n\tG[i]=pow(F[i],(mod-2),mod)\n\nfor i in range(0,n):\n\tif i*2>n:\n\t\tbreak\n\tB[i]=(F[n-i]*G[i]*G[n-i*2])%mod\nfor i in range(0,n//2+1):\n\tfor j in range(0,n//2+1):\n\t\tA[i+j]=(A[i+j]+B[i]*B[j])%mod\nfor i in range(0,n+1):\n\tA[i]=A[i]*F[n-i]%mod\nfor i in range(0,n+1):\n\tfor j in range(0,i+1):\n\t\tC[j]=(C[j]+A[i]*F[i]*G[j]*G[i-j]*(1-(i-j)%2*2))%mod\nprint(C[k]%mod)\n", "t = input()\nk = t.find('=')\nn = 2 * k - len(t)\nif n == 2:\n    if t[1] != '+': t = t[1: ] + '|'\n    else: t = t[: k - 1] + t[k: ] + '|'\nelif n == -2: t = '|' + t[: -1]\nelif n != 0: t = 'Impossible'\nprint(t)\n", "import sys\n\nMOD = 10**9 + 7\n\nN, K = list(map(int, input().split()))\n\nmaxS = N*N//2\nif K > maxS or K%2:\n    print((0))\n    return\n\ndp = [[0]*(maxS+1) for j in range(N+1)]\ndp[0][0] = 1\nfor i in range(1, N+1):\n    dp2 = [[0]*(maxS+1) for j in range(N+1)]\n    for j in range(i+1):\n        for s in range(0, maxS+1, 2):\n            s0 = s-2*j\n            if s0 < 0: continue\n            dp2[j][s] = (2*j+1)*dp[j][s0]\n            if j+1 <= N:\n                dp2[j][s] += (j+1)*(j+1)*dp[j+1][s0]\n            if j-1 >= 0:\n                dp2[j][s] += dp[j-1][s0]\n            dp2[j][s] %= MOD\n    dp = dp2\n\nprint((dp[0][K]))\n", "s = [int(j) for j in input().split()]\no = []\nfor i in range(5):\n    if s[i] in s[i+1:]:\n        o.append(s[i])\nm = sum(s)\nfor i in o:\n    y = 0\n    t = 0\n    for j in s:\n        if j != i or t>2:\n            y+=j\n        if j == i:\n            t+=1\n    m = min(y,m)\nprint(m)\n    \n", "N, A = list(map(int, input().split()))\nX = list(map(int, input().split()))\nX.sort()\nif N == 1:\n    print(0)\n    return\nelif N == 2:\n    print(min(abs(X[0] - A), abs(X[1] - A)))\n    return\nans = int(1e18)\nans = min(ans, abs(X[N-2] - X[0]) + min(abs(A - X[0]), abs(A - X[N-2])))\nans = min(ans, abs(X[N-1] - X[1]) + min(abs(A - X[1]), abs(A - X[N-1])))\nprint(ans)\n", "from datetime import *\na = input().split(\":\")\nb = input().split(\":\")\nx = datetime(1,1,3,int(a[0]),int(a[1]))\ny = timedelta(hours=int(b[0]),minutes=int(b[1]))\nz = str(x - y).split(' ')[1].split(\":\")\nprint(\"%s:%s\"%(z[0],z[1]))\n", "n = int(input())\ns = list(map(int, input().split()))\nm = -1\nrow = 0\nmr = 0\nfor i in s:\n    if i == m:\n        row += 1\n    elif(i > m):\n        m = i\n        row = 1\n        mr = 0\n    else:\n        row = 0\n    mr = max(mr, row)\nprint(mr)", "v = input()\ni = 0\nwhile i <= len(v) - 1:\n    # if v[0] != \"1\":\n    #     print(\"NO\")\n    #     break\n    if v[i] == \"1\":\n        if i + 1 <= len(v) - 1:\n            if v[i + 1] == \"4\":\n                if i + 2 <= len(v) - 1:\n                    if v[i + 2] == \"4\":\n                        i += 2\n                    else:\n                        i += 1\n                else:\n                    print('YES')\n                    break\n    else:\n        print(\"NO\")\n        break\n    i += 1\nelse:\n    print('YES')\n\n\n", "import sys\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\ns = [ord(c) for c in input()]\nans = 0\ncode = 122\nwhile code >= 97:\n    toDel = []\n    k = len(s)\n    for i, c in enumerate(s):\n        if c != code:\n            continue\n        if i > 0 and s[i - 1] + 1 == code:\n            toDel.append(i - len(toDel))\n        elif i < k - 1 and s[i + 1] + 1 == code:\n            toDel.append(i - len(toDel))\n    if toDel:\n        for i in toDel:\n            del s[i]\n            ans += 1\n    else:\n        code -= 1\nprint(ans)\n\n# inf.close()\n", "import string\n\nn, k = map(int, input().split())\n\nsymbs = []\nletters = string.ascii_lowercase[:k]\nlast = 0\nfor i in range(n):\n\tsymbs.append(letters[last])\n\tlast+=1\n\tif last==k:\n\t\tlast = 0\nprint(''.join(symbs))", "import sys, math\n\nn, a, b = map(int, input().split())\nx=[0 for i in range(n)]\ny=[0 for i in range(n)]\n\nfor i in range(n):\n    u,v = map(int, input().split())\n    x[i]=u\n    y[i]=v\n\nm=0\nfor i in range(n):\n    for j in range (n):\n        if i!=j:\n            if (x[i]+x[j]<=a and max(y[i],y[j])<=b) or (x[i]+y[j]<=a and max(y[i],x[j])<=b) or (y[i]+x[j]<=a and max(x[i],y[j])<=b) or (y[i]+y[j]<=a and max(x[i],x[j])<=b) or (x[i] + x[j] <= b and max(y[i], y[j]) <= a) or (x[i] + y[j] <= b and max(y[i], x[j]) <= a) or (y[i] + x[j] <= b and max(x[i], y[j]) <= a) or (y[i] + y[j] <= b and max(x[i], x[j]) <= a):\n                if m<x[i]*y[i]+x[j]*y[j]: m=x[i]*y[i]+x[j]*y[j]\nprint(m)", "def c(n, k):\n\tr = 1\n\tfor i in range(k):\n\t\tr *= n\n\t\tn -= 1\n\tfor i in range(2, k + 1):\n\t\tr //= i\n\treturn r\n\nn = int(input())\nl = sorted(map(int, input().split()))\nprev = l[0]\nbeg = 0\ncnt = 0\nans = 1\nfor i in range(n):\n\tif l[i] == prev:\n\t\tcnt += 1\n\telse:\n\t\tans *= c(i - beg, min(3, i) - beg)\n\t\tcnt = 1\n\t\tprev = l[i]\n\t\tbeg = i\n\t\tif i > 2:\n\t\t\tbreak\nif beg < 3:\n\tans *= c(n - beg, 3 - beg)\n\nprint(ans)", "n = int(input())\nif n >= 0:\n    print(n)\nelse:\n    n1 = list(str(n))\n    n1.pop(len(n1)-1)\n    n1 = int(''.join(n1))\n    n2 = list(str(n))\n    n2.pop(len(n2)-2);\n    n2 = int(''.join(n2))\n    print(max(n1,n2))", "positions = \">v<^\"\n\ns, t = input().split()\nn = int(input())\n\nsi = positions.index(s)\nti_cw = positions[(si + n) % 4]\nti_ccw = positions[(si - n) % 4]\n\nif n % 2 == 0:\n    print('undefined')\nelif t == ti_cw:\n    print('cw')\nelif t == ti_ccw:\n    print('ccw')\nelse:\n    assert False", "a, b = input().split()\na = list(a)\nb = int(b)\n\ndef findMax(a, f, dist):\n    m = f\n    for i in range(f+1, min(f+dist+1, len(a))):\n        if a[i] > a[m]:\n            m = i\n    return m\n\n\npos = 0\nwhile b > 0 and pos < len(a):\n    m = findMax(a, pos, b)\n    #print('we found:', m)\n    a.insert(pos, a.pop(m))\n    #print('new a', a)\n    b -= m - pos\n    #print('new b', b)\n    pos += 1\n\nprint(''.join(a))\n", "N, M, K = list(map(int, input().split()))\nrow_size = 2 * M\nK -= 1\nrow = K // row_size\nK %= row_size\nside = 'L' if K % 2 == 0 else 'R'\nd = K // 2\n\nprint(row + 1, d + 1, side)\n", "# You lost the game.\nn = int(input())\nch = str(input())\nr = \"\"\nR = ch.count(\"R\")\nB = ch.count(\"B\")\nG = ch.count(\"G\")\nif R and B and G:\n    print(\"BGR\")\nelif (R >= 2 and B >= 2) or (G >= 2 and R >= 2) or (G >= 2 and B >= 2):\n    print(\"BGR\")\nelif R >= 2 and (B == 1 or G == 1): \n    print(\"BG\")\nelif B >= 2 and (R == 1 or G == 1):\n    print(\"GR\")\nelif G >= 2 and (B == 1 or R == 1):\n    print(\"BR\")\nelif B and G:\n    print(\"R\")\nelif R and G:\n    print(\"B\")\nelif B and R:\n    print(\"G\")\nelif B:\n    print(\"B\")\nelif G:\n    print(\"G\")\nelse:\n    print(\"R\")\n\n\n\n\n", "d = {}\ndata = input().split()\nk = int(data[1])\ndata = input().split()\nans = 0\nfor el in data:\n\tv = int(el)\n\tp = [0,0,]\n\n\tif v in list(d.keys()):\n\t\tp = d[v]\n\n\t\n\n\tif v%k==0 and (v/k) in list(d.keys()):\n\t\tans += d[v/k][1]\n\t\tp[1] += d[v/k][0]\n\t\t\n\n\tp[0] += 1\n\td[v] = p\n\nprint(ans)\n\n\n", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    t = I()\n    for i in range(t):\n        n,d = LI()\n        for x in range(40000):\n            if x+math.ceil(d/(x+1)) <= n:\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "l=int(input())\np=int(input())\nq=int(input())\nprint(p*l/(p+q))", "for _ in range(int(input())):\n    N =int(input())\n    List = [int(x) for x in input().split()]\n    if(List.count(List[0]) == N):\n        print(N)\n    else:\n        print(1)", "n = int(input())\nl = list(map(int, input().split(' ')))\ns = sum(l) // len(l)\nmn, mx = min(l), max(l)\nif mx - mn <= 1:\n    print(n)\n    for i in l:\n        print(i, end=' ')\nelse:\n    a, b, c = l.count(mn), l.count(mn + 1), l.count(mx)\n    a1, b1, c1 = a - min(a, c), b + 2 * min(a, c), c - min(a, c)\n    a2, b2, c2 = a + b // 2, b % 2, c + b // 2\n    diff1 = min(a, a1) + min(b, b1) + min(c, c1)\n    diff2 = min(a, a2) + min(b, b2) + min(c, c2)\n    if diff1 <= diff2:\n        print(diff1)\n        s = (str(mn) + ' ') * a1 + (str(mn + 1) + ' ') * b1 + (str(mx) + ' ') * c1\n        s = s[:-1]\n        print(s)\n    else:\n        print(diff2)\n        s = (str(mn) + ' ') * a2 + (str(mn + 1) + ' ') * b2 + (str(mx) + ' ') * c2\n        s = s[:-1]\n        print(s)", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    a1 = int(input())\n    a2 = int(input())\n    k1 = int(input())\n    k2 = int(input())\n    n = int(input())\n    \n    mi = max(0, (a1 + a2) - (a1 * k1 + a2 * k2 - n))\n    # mi = a1 + a2 - (a1 * k1 + a2 * k2 - n)\n    if k1 > k2:\n        a1, a2 = a2, a1\n        k1, k2 = k2, k1\n    ma = 0\n    if n >= a1 * k1:\n        n -= a1 * k1\n        ma += a1\n        ma += n // k2\n    else:\n        ma = n // k1\n    \n    print(mi, ma)\n    \n    return 0\n\nmain()\n", "n = input()\nn = n.strip('0')\nprint('YES' if n == n[::-1] else 'NO')\n", "3\nfrom collections import deque\nfrom array import array\ndef dfs ():\n  while(len(queue)!=0):\n    s=queue.popleft()\n    (i,j)=s\n    for (ni,nj) in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:      \n      if ni in range(0,n) and nj in range(0,m):\n        c=ni*m+nj\n        fl=data[c]\n        if(e == (ni,nj)) and fl==1:\n          return True\n        elif fl == 0:\n          data[c] = 1\n          queue.append((ni,nj))\n  return False\n[n,m]=list(map(int,(input().split())))\ndata=array('B')\nfor i in range(0,n):\n  data.extend([0 if x=='.' else 1 for x in input()])\n[si,sj]=list(map(int,(input().split())))\n[ei,ej]=list(map(int,(input().split())))\ne=(ei-1,ej-1)\nqueue=deque()\nqueue.append((si-1,sj-1))\nprint(\"YES\" if dfs() else \"NO\")  \n", "n=  int(input())\n\nl =  input()\n\nl=  [int(i) for i in l.split()]\n\nd = sum(l)\nif d%2==1:\n    print(\"First\")\nelse:\n    for i in range(n-1 , -1, -1):\n        d-=l[i]\n        if d%2==1:\n            print(\"First\")\n            d=-1\n            break\n    if d!=-1:print(\"Second\")\n            \n", "import math\n\nn = int(input())\n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if not (n % i):\n        ans = [i, n // i]\n\nprint(ans[0], ans[1])", "n, m = list(map(int, input().split()))\n\nd = list(map(int, input().split()))\n\nanswer = 0\nfor i in range(m):\n    i, j = list(map(int, input().split()))\n    i -= 1\n    t = sum(d[i:j])\n    if t > 0:\n        answer += t\n\nprint(answer)\n", "a, b, c = map(int, input().split())\nans = c\nif b < ans - 1:\n    ans = b + 1\nif a < ans - 2:\n    ans = a + 2\nprint(3 * ans - 3)", "n = int(input())\nline = input()\na = [int(x) for x in line.split()]\n\nresult = max([min(x-1, 1000000-x) for x in a])\n\nprint(result)\n", "_ = input()\ns = input()\nunique = len(set(s))\n\nif len(s) > 26:\n    print(-1)\nelse:\n    print(len(s) - unique)\n", "a,b = map(int,input().split())\nflag = True\nfor i in range(1,1000000):\n\tif(flag==True):\n\t\tflag = False\n\t\tif(a<i):\n\t\t\tprint('Vladik')\n\t\t\treturn\n\t\ta-=i\n\telse:\n\t\tflag = True\n\t\tif(b<i):\n\t\t\tprint('Valera')\n\t\t\treturn\n\t\tb-=i", "import sys\n# import math\n\n# sys.stdin = open('c-test.txt')\n\ndef check(s):\n\tstatus = 0\n\tfor char in s[:-1]:\n\t\tif char == '(':\n\t\t\tstatus += 1\n\t\telse:\n\t\t\tstatus -= 1\n\t\tif status <= 0:\n\t\t\treturn ':('\n\treturn s\n\nn = int(input())\ns = input()\nif n % 2 != 0:\n\tprint(':(')\nelse:\n\tleftcount = 0\n\trightcount = 0\n\tfor char in s:\n\t\tif char == '(':\n\t\t\tleftcount += 1\n\t\tif char == ')':\n\t\t\trightcount += 1\n\tneeded = n // 2\n\tif max(leftcount,rightcount) > needed:\n\t\tprint(':(')\n\telse:\n\t\tleftneeded = (n // 2) - leftcount\n\t\tleftadded = 0\n\t\tnewchars = []\n\t\tfor char in s:\n\t\t\tif char == '?':\n\t\t\t\tif leftadded < leftneeded:\n\t\t\t\t\tnewchars.append('(')\n\t\t\t\t\tleftadded += 1\n\t\t\t\telse:\n\t\t\t\t\tnewchars.append(')')\n\t\t\telse:\n\t\t\t\tnewchars.append(char)\n\t\tprint(check(''.join(newchars)))", "n, m = [int(i) for i in input().split()]\na = []\nb = [0] * n\nfor i in range(m):\n    a.append([int(j) for j in input().split()])\n    k = 0\n    for j in range(1, n):\n        if a[-1][j] > a[-1][k]:\n            k = j\n    a[-1] = k\n    b[k] += 1\nq = max(b)\nfor i in range(n):\n    if b[i] == q:\n        print(i + 1)\n        return\n", "num = input().rstrip('\\n').split(' ')\ncorrect_solution = input().rstrip('\\n').split(' ')\nwrong_solution = input().rstrip('\\n').split(' ')\n\nn = int(num[0])\nm = int(num[1])\n\n\ndef toIntList(list):\n    newlist = []\n    for k in list:\n        newlist.append(int(k))\n    return newlist\n\n\ncorrect_time = toIntList(correct_solution)\ncorrect_time.sort()\nwrong_time = toIntList(wrong_solution)\nwrong_time.sort()\n\nif correct_time[-1] >= wrong_time[0]:\n    print(-1)\nelif correct_time[0] * 2 >= wrong_time[0]:\n    print(-1)\nelse:\n    print(max(correct_time[-1], correct_time[0] * 2))\n", "from datetime import date\nfrom datetime import timedelta\n\na = input()\na = [int(x) for x in a.split(\":\")]\nb = input()\nb = [int(x) for x in b.split(\":\")]\n\nx = date(a[0],a[1],a[2])\ny = date(b[0],b[1],b[2])\n\nif x > y:\n  x,y = y,x\n\nans = 0\nwhile x != y:\n  x = x + timedelta(days=1)\n  ans+=1\nprint(ans)\n\n", "from itertools import accumulate, islice\nfrom bisect import bisect_left\n \nn = int(input())\nxs = [int(x) for x in input().split()]\n \nys = list(accumulate(xs))\nzs, total = ys[:-1], ys[-1]\n \nres = max(xs) - min(xs)\nfor i, z in islice(enumerate(zs), 1, n-1):\n    j = bisect_left(zs, z//2)\n    splits = ((zs[j+k], z - zs[j+k]) for k in (-1, 0, 1) if 0 <= j+k <= i)\n    a, b = min(splits, key=lambda s:abs(s[0]-s[1]))\n \n    j = bisect_left(zs, (total - z)//2 + z)\n    splits = ((zs[j+k] - z, total - zs[j+k]) for k in (-1, 0, 1) if i <= j+k <= n-2)\n    c, d = min(splits, key=lambda s:abs(s[0]-s[1]))\n \n    minn, _, _, maxx = sorted((a,b,c,d))\n    if maxx - minn < res:\n        res = maxx - minn\n \nprint(res)", "a, b = map(int, input().split())\nc, d = map(int, input().split())\ne, f = map(int, input().split())\nres = set()\nres.add((e + c - a, f + d - b))\nres.add((e - c + a, f - d + b))\nres.add((c + e - a, d + f - b))\nres.add((c - e + a, d - f + b))\nres.add((a - c + e, b - d + f))\nres.add((a + c - e, b + d - f))\nprint(len(res))\nfor elem in res:\n    print(elem[0], elem[1])", "P=print\nI=input\nI()\na=b=0\nt=[]\nfor x in map(int,I().split()):\n\tif x<0:\n\t\tif b==2:t+=[a];b=1;a=0\n\t\telse:b+=1\n\ta+=1\nif a:t+=[a]\nP(len(t))\nfor x in t:P(x,end=' ')\n", "a, b = [int(x) for x in input().split()]\ncount = 0\nif a == 1 and b == 1:\n    print(0)\nelse:\n    while a > 0 and b > 0:\n        if a == 1 or a == 2:\n            a += 1\n            b -= 2\n        elif b == 1 or b == 2:\n            b += 1\n            a -= 2\n        elif a > b:\n            a -= 2\n            b += 1\n        else:\n            a += 1\n            b -= 2\n        count += 1\n    print(count)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nn = int(input())\nC = list(map(int,input().split()))\n\ndef check(init):\n    d = init\n    done = [False for i in range(n)]\n    cracked = 0\n    changed = 0\n    while cracked < n:\n        if d == 0:\n            for i in range(n):\n                if not done[i] and C[i] <= cracked:\n                    done[i] = True\n                    cracked += 1\n        else:\n            for i in range(n)[::-1]:\n                if not done[i] and C[i] <= cracked:\n                    done[i] = True\n                    cracked += 1\n        d = d ^ 1\n        if cracked < n:\n            changed += 1\n    return changed\n\nprint(check(0))\n", "n = int(input())\ns = input()\nalth = \"abcdefghijklmnopqrstuvwxyz\"\nans = n-1\nfor i in range(1,n):\n    if alth.find(s[i]) < alth.find(s[i-1]) :\n        ans = i-1\n        break\n\nfor i in range(n):\n    if i != ans:\n        print(s[i],end=\"\")\n", "n = int(input())\nrow1 = list(map(int, input().split()))\nrow2 = list(map(int, input().split()))\nvert = list(map(int, input().split()))\nlo = float('inf')\nres = 0\nfirstcross = 0\nsecondcross = 0\nfor i in range(n):\n    #print(\"i\", i)\n    cur = vert[i]\n    cur += sum(row2[i:])\n    cur += sum(row1[:i])\n    #print(cur)\n    if cur < lo:\n        firstcross = i\n        lo = cur\n#print(\"cross\", firstcross)\nres += lo\nlo = float('inf')\nfor i in range(n):\n    #print(\"i\", i)\n    cur = vert[i]\n    for j in range(i):\n        #print(\"j row1\", j)\n        cur += row1[j]\n    for j in range(i, n-1):\n        #print(\"j row2\", j)\n        cur += row2[j]\n    #print(cur)\n    if cur < lo and i != firstcross:\n        lo = cur\n        secondcross = i\n#print(\"cross\", secondcross)\n        \nres += lo\nprint(res)\n        \n", "def solve(a, b, s, n):\n    if not a[0]:\n        return \"NO\"\n    if a[s-1]:\n        return \"YES\"\n    if b[s-1]:\n        for i in range(s, n):\n            if a[i] and b[i]:\n                return \"YES\"\n    return \"NO\"\n\n\ndef main():\n    n, s = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    print(solve(a, b, s, n))\n\n\nmain()\n", "n, k = map(int, input().split())\ndata = list(map(int, input().split()))\n\ndata = sorted(zip(data, range(1, len(data) + 1)), key=lambda x: x[0])\n\ninst = []\nfor x in data:\n    if k < x[0]:\n        break\n\n    inst.append(x[1])\n    k -= x[0]\n\nprint(len(inst))\nprint(' '.join(map(str, inst)))", "import datetime\n\nd = datetime.date(2016, 1, 1)\nv = input().split()\n\nans = 0\n\nwhile True:\n    if d.year != 2016:\n        break\n    if v[2] == 'week' and int(v[0]) == d.isoweekday():\n        ans += 1\n    if v[2] == 'month' and int(v[0]) == d.day:\n        ans += 1\n    d = d + datetime.timedelta(days=1)\n\nprint(ans)\n\n", "from math import ceil\nfor _ in range(int(input())):\n    x, y, p, q = list(map(int, input().split()))\n    if p == q and x != y:\n        print(-1)\n    elif p == q:\n        print(0)\n    elif p == 0 and x == 0:\n        print(0)\n    elif p == 0:\n        print(-1)\n    else:\n        a = y // q\n        r = y % q\n        g1 = (x - p * a + p - 1) // p\n        g2 = ceil((x - r - p * a) / (p - q))\n        print(max(g1, g2) * q - r)\n", "a=input()\ns=0\nfor i in a:\n\tif i in [\"1\",\"3\",\"5\",\"7\",\"9\",\"a\",\"e\",\"i\",\"o\",\"u\"]:\n\t\ts+=1\nprint(s)", "# python 3\n\"\"\"\n\"\"\"\n\n\ndef lefthanders_and_righthanders(n_int, student_list) -> list:\n    sitting_order = []\n    for i in range(n_int//2):\n        if student_list[i] == 'R' and student_list[i + n_int//2] == 'L':\n            sitting_order.append((i + n_int//2 + 1, i + 1))\n            print(i + n_int//2 + 1, i + 1)\n        else:\n            sitting_order.append((i + 1, i + n_int//2 + 1))\n            print(i + 1, i + n_int//2 + 1)\n    return sitting_order\n\n\ndef __starting_point():\n    \"\"\"\n    Inside of this is the test. \n    Outside is the API\n    \"\"\"\n    with open(\"input.txt\", 'r') as f_input:\n        n = int(f_input.readline())\n        students = f_input.readline()\n        # print(n, students)\n\n    sitting = lefthanders_and_righthanders(n, students)\n    with open(\"output.txt\", 'w') as f_output:\n        for each in sitting:\n            f_output.write(str(each[0]) + ' ' + str(each[1]) + '\\n')\n\n__starting_point()", "from collections import defaultdict\n\ndx = [0,-1,-1,-1, 0, 1, 1,1]\ndy = [1, 1, 0,-1,-1,-1, 0,1]\n\n#visited =[[[[False for _ in range(32)] for _ in range(8)] for _ in range(320)] for _ in range(320)]\nvisited = defaultdict(lambda : False)\n\ngrid = [[False for _ in range(320)] for _ in range(320)]\n\ndef dfs(x,y,d,n,N, inp):\n    if n >= N or visited[(x,y,d,n)]:\n        return\n\n    visited[(x,y,d,n)] = True\n\n    dist = inp[n]\n\n    for i in range(1,dist+1):\n        grid[x+dx[d]*i][y+i*dy[d]] = True\n\n    if (n < N):\n        dfs(x + dx[d]*dist, y+dy[d]*dist, (d+1)%8, n+1,N,inp)\n        dfs(x + dx[d]*dist, y+dy[d]*dist, (d+7)%8, n+1,N,inp)\n\n\ndef __starting_point():\n    N = int(input())\n    inp = list(map(int, input().strip().split()))\n    dfs(160,160,0,0,N,inp)\n    result = sum(map(sum,grid))\n    print(result)\n\n__starting_point()", "from sys import stdin\nn=int(stdin.readline().strip())\n\ns=stdin.readline().strip()\narr=[0 for i in range(10)]\nfor  i in range(n):\n    if s[i]==\"L\":\n        for j in range(10):\n            if arr[j]==0:\n                arr[j]=1\n                break\n    elif s[i]==\"R\":\n        for j in range(9,-1,-1):\n            if arr[j]==0:\n                arr[j]=1\n                break\n    else:\n        arr[int(s[i])]=0\n\n                \nfor i in arr:\n    print(i,end=\"\")\n", "a, b = [int(i) for i in input().split()]\nx, y, z = [int(i) for i in input().split()]\nans = 0\nif b - (z * 3 + y) < 0:    \n    ans += b - (z * 3 + y)\nif a - (2 * x + y) < 0:\n    ans += a - (2 * x + y)\nprint(abs(ans))", "def solve(arr):\n    if len(arr) <= 2 or len(set(arr)) == 1:\n        return [-1]\n    else:\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[i] != arr[j]:\n                    arr[i], arr[j] = arr[j], arr[i]\n                    if arr != sorted(arr) and arr != list(reversed(sorted(arr))):\n                        return [i+1, j+1]\n                    else:\n                        arr[i], arr[j] = arr[j], arr[i]\n    return [-1]\n\n\ndef __starting_point():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(*solve(arr))\n__starting_point()", "#!/usr/bin/env python3\n\n\ndef isqrt(n):\n    if n == 0:\n        return 0\n    x = 2 ** sum(divmod(n.bit_length(), 2))\n    while True:\n        y = x + n // x\n        y //= 2\n        if y >= x:\n            return x\n        x = y\n\n\ndef triangle_number(n):\n    return n * (n + 1) // 2\n\n\ndef find_seq(position):\n    size = isqrt(2 * position)\n    while triangle_number(size) < position:\n        size += 1\n    size -= 1\n    return position - triangle_number(size)\n\n\ndef main():\n    print(find_seq(int(input())))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a,b,c=list(map(int,input().split()))\nx1,y1,x2,y2=list(map(int,input().split()))\nbRange=abs(y2-y1)+abs(x2-x1)\nif a==0 or b==0:\n    print(bRange)\nelse:\n    py1=(-b*y1-c)/a\n    py2=(-b*y2-c)/a\n    px1=(-a*x1-c)/b\n    px2=(-a*x2-c)/b\n    pRange1=((x2-py1)**2+(px2-y1)**2)**0.5+abs(y2-px2)+abs(py1-x1)\n    pRange2=((py2-py1)**2+(y2-y1)**2)**0.5+abs(py1-x1)+abs(x2-py2)\n    pRange3=((x2-x1)**2+(px2-px1)**2)**0.5+abs(px1-y1)+abs(y2-px2)\n    pRange4=((py2-x1)**2+(y2-px1)**2)**0.5+abs(px1-y1)+abs(x2-py2)\n    print(min(bRange,pRange1,pRange2,pRange3,pRange4))\n", "#!/usr/bin/env python3\n\n\ndef main():\n    n = int(input())\n    print(''.join(map(str, list(range(0, 1000))))[n])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a,b = (int(x) for x in input().split())\nprint((a//b+1)*b)", "q = int(input())\nfor i in range(q):\n    l, r, d = list(map(int, input().split()))\n    if d < l:\n        print(d)\n    else:\n        print(((r // d) + 1) * d)\n", "n = int(input())\nA = []\nsum = 0\nfor i in range(n):\n    x = int(input())\n    sum += x\n    A.append(sum/(i+1))\n\nprint('%.6f\\n' % max(A))", "t = int(input())\nfor i in range(t):\n    x, y = list(map(int, input().split()))\n    if x - y == 1:\n        print (\"NO\")\n    else:\n        print(\"YES\")\n", "x=int(input())\nif(x==2):\n    print(1)\nelse:\n    x-=1\n    cnt=0\n    for i in range(1,x):\n        ok=0\n        for j in range(2,i+1):\n            if(x%j==0 and i%j==0): ok=1\n        if(ok==0) :cnt+=1\n    print(cnt)\n", "n = int(input())\nfield = [list(input()) for i in range(n)]\nans = 1\nfor i in range(n):\n    for j in range(n):\n        if field[i][j] == \".\":\n            if i > n - 3 or j == n - 1 or field[i+1][j] != \".\" or field[i+2][j] != \".\" or field[i+1][j+1] != \".\" or field[i+1][j-1] != \".\":\n                ans = 0\n                break\n            field[i+1][j] = \"#\"\n            field[i+2][j] = \"#\"\n            field[i+1][j+1] = \"#\"\n            field[i+1][j-1] = \"#\"\n    if ans == 0:\n        break\nif ans == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "n, m = list(map(int, input().split()))\nx = tuple(map(int, input().split()))\ny = min(x)\na = 0\nfor xi in x:\n    b = xi - y\n    while b:\n        a, b = b, a % b\nj = 1\nfor p in input().split():\n    if a % int(p):\n        j += 1\n        continue\n    print(\"YES\")\n    print(y, j)\n    break\nelse:\n    print(\"NO\")\n", "alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef distance(char1,char2):\n\tx = abs(alphabet.index(char1)-alphabet.index(char2))\n\treturn min(x,26-x)\n\ndef changesneeded(s):\n\treturn sum([distance(s[i],'ACTG'[i]) for i in range(4)])\n\ndef f(s):\n\tbest = 99999999999\n\tfor i in range(len(s)-3):\n\t\tbest = min(best,changesneeded(s[i:i+4]))\n\treturn best\n\nn = int(input())\nprint(f(input()))", "xs = input().split()\nn, p, t = int(xs[0]), float(xs[1]), int(xs[2])\ncur, nxt = [0.0] * (n + 1), [0.0] * (n + 1)\ncur[0] = 1.0\nfor i in range(t):\n    nxt[n] = cur[n]\n    for j in range(n):\n        nxt[j] = cur[j] * (1.0 - p)\n    for j in range(n):\n        nxt[j + 1] += cur[j] * p\n    cur, nxt = nxt, cur\nprint(sum(cur[i] * i for i in range(n + 1)))", "import sys, math\nn=int(input())\nz=list(map(int,input().split()))\nfor i in range(n):\n    z[i]=[z[i],i+1]\nz.sort()\nfor i in range(n//2):\n    print(z[i][1],z[n-1-i][1])\n", "answerlist=[]\nlengthlist=[]\ngreat=0\nfinallist=['A','B','C','D']\nfor i in range(4):\n    answerlist.append(str(input()))\n    lengthlist.append(len(answerlist[i])-2)\n\nlengthlist1=lengthlist[:]\nlengthlist.sort()\n\nif lengthlist[0]*2<=lengthlist[1]:\n    great=1\nif lengthlist[3]>=lengthlist[2]*2:\n    if great==1:\n        great=0\n    else:\n        great=2\nif great==0:\n    print('C')\nif great==1:\n    print(finallist[lengthlist1.index(lengthlist[0])])\nif great==2:\n    print(finallist[lengthlist1.index(lengthlist[3])])", "n = int(input())\nday = 1\n\nfor i in range(n):\n  start, extra = list(map(int, input().split()))\n  day = max(day, start)\n\n  while (day - start) % extra != 0:\n    day += 1\n  if i + 1 < n:\n    day += 1\n\nprint(day)\n", "a = int(input())\nres = 1\na += 1\nwhile '8' not in str(a):\n\tres += 1\n\ta += 1\nprint(res)", "def sum(n):\n    r = 0\n    while n:\n        r, n = r + n % 10, n // 10\n    return r\n\nk = int(input())\nans = []\nx = 0\nfor i in range(1,10800101,9):\n    \n     t = sum(i)\n     if t == 10:\n         if x == k: \n             break\n         ans.append(str(i))\n         x += 1\n         \n         \n         \nprint(ans[k-1])\n", "n,d = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\nm = int(input())\nprint(sum(a[:min(n,m)])-d*(max(0,m-n)))", "n,d=input().split()\nn=int(n)\nd=int(d)\na=list(map(int,input().split()))\nt=2\nfor i in range(n-1):\n    if a[i+1]-a[i]>2*d:\n        t+=2\n    elif a[i+1]-a[i]==2*d:\n        t+=1\nprint(t)\n", "from sys import stdin\nfrom heapq import heappop, heappush, heapify\ndef main():\n    n = int(stdin.readline())\n    a = stdin.readline().split()\n    q = []\n    p = 0\n    c = 0\n    l = [0] * (n + 1)\n    r = [0] * (n + 1)\n    k = [0] * (n + 1)\n    pa = [0] * (n + 1)\n    for i, x in enumerate(a):\n        if x == a[p]:\n            c += 1\n        else:\n            l[p] = p - 1\n            k[p] = k[i-1] = c\n            pa[p] = i - 1\n            pa[i-1] = p\n            r[i-1] = i\n            q.append((-c, p))\n            p = i\n            c = 1\n    q.append((-c, p))\n    l[p] = p - 1\n    k[p] = k[n-1] = c\n    pa[p] = n - 1\n    pa[n-1] = p\n    r[n-1] = n\n    heapify(q)\n    ans = 0\n    while len(q):\n        c, p = heappop(q)\n        c = -c\n        if k[p] > c:\n            continue\n        ans += 1\n        ls = l[p]\n        rs = r[pa[p]]\n        if ls >= 0 and rs < n and a[ls] == a[rs]:\n            nc = k[ls] + k[rs]\n            nl, nr = pa[ls], pa[rs]\n            k[nl] = k[nr] = k[ls] = k[rs] = nc\n            pa[nr] = nl\n            pa[nl] = nr\n            heappush(q, (-nc, nl))\n        else:\n            if ls >= 0:\n                r[ls] = rs\n            if rs < n:\n                l[rs] = ls\n    print (ans)\nmain()", "import math, sys\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef main():\n    n = int(input())\n    a = input().strip()\n    for i in range(n - 1):\n        if a[i] != a[i + 1]:\n            print('YES') \n            print(a[i] + a[i + 1])\n            return\n    print(\"NO\")\n            \n    \n    \n\ndeb = 0\nif deb:\n    file = open(\"input.txt\", \"r\")\n    input = file.readline\nelse:\n    input = sys.stdin.readline\n\nmain()\n\nif deb:\n    file.close()\n", "def isSorted(l):\n    i = 1\n    while i < len(l):\n        if l[i] < l[i-1]:\n            return False\n        i += 1\n    return True\nn = int(input())\na = list(map(int,input().split()))\ns = e = 0\ni = 1\nb = list()\nwhile i < len(a):\n    if a[i] > a[i-1]:\n        i += 1\n    else:\n        s = i-1\n        while i < n and a[i] < a[i-1]:\n            i+=1\n        e = i-1\n        b = a[0:s] + list(reversed(a[s:e+1])) + a[e+1:]\n      \n        break\nif isSorted(b):\n    print('yes')\n    print(s+1,e+1,sep=' ')\nelse:\n    print('no')", "from sys import stdin,stderr\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n\ndef solve(n, b):\n    f = [True for i in range(2*n+1)]\n    for x in b:\n        if not f[x]:\n            return [-1]\n        f[x] = False\n    a = []\n    for x in b:\n        a.append(x)\n        for y in range(x+1, 2*n+1):\n            if f[y]:\n                a.append(y)\n                f[y] = False\n                break\n        else:\n            return [-1]\n    return a\n\nt, = rl()\nfor _ in range(t):\n    print(*solve(rl()[0], rl()))\n", "import string\n\ns = input()\n\nans = len( s ) // 2 + 1\n\nfor a in list( string.ascii_lowercase ):\n    last = -1\n    l = 0\n    for i , c in enumerate( list( s ) ):\n        if a == c:\n            l = max( l, i - last )\n            last = i\n    l = max( l , len( s ) - last )\n    ans = min( ans, l )\n\nprint( ans )\n", "n = int(input())\ns = input()\nans = 0\ni = 0\nwhile i < len(s):\n\tc = s[i]\n\tj = i + 1\n\twhile j < len(s) and s[i] == s[j]:\n\t\tans += 1\n\t\tj += 1\n\ti = j\nprint(ans)\n", "import sys\n#fin=open('F:/OJ/OJ/in.txt','r')\n#sys.stdin=fin\n\nstr=input()\nk=int(input())\nans=0\nif(k>=len(str)):\n    print((k+len(str))//2*2)\n    return\nfor i in range(len(str)):\n    for j in range(0,i+1):\n        len1=len(str[j:i+1])\n        len2=len(str[i+1:])\n        minn=min(len1,len2)\n        #print( i,j)\n        #print(len1,len2)\n        if(str[j:j+minn]==str[i+1:i+1+minn]):\n            if(minn==len1):\n                ans=max(ans,len1*2)\n            elif(k+len2>=len1):\n                ans=max(ans,len1*2)\n                \nprint(ans)\n", "n,k = list(map(int, input().split()))\nseq = list(map(int, input().split()))\n\ncurr = 0\ncut = []\n\nfor i in range(n-1):\n    if seq[i]%2:\n        curr += 1\n    else:\n        curr -= 1\n\n    if curr == 0:\n        cut.append(abs(seq[i]-seq[i+1]))\n\ncut.sort()\nans = 0\ncurrsum = 0\n\nfor i in cut:\n    currsum += i\n    if currsum > k:\n        break\n    else:\n        ans += 1\n\nprint(ans)\n", "from sys import stdin, stdout\nfrom math import *\nfrom heapq import *\nfrom collections import *\n\ndef main():\n    n=int(stdin.readline())\n    a=[0]+[int(x) for x in stdin.readline().split()]\n    res=1\n    minc=99999999999999999999999999999\n    for x in range(1,n+1):\n        c=0\n        for i in range(1,n+1):\n            c=c+(a[i]*(abs(i-x)+abs(i-1)+abs(1-x)  + abs(x-1)+abs(1-i)+abs(i-x)))\n        if (c<minc):\n            res=x\n            minc=c\n    stdout.write(str(minc))\n    return 0\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m, k = list(map(int, input().split()))\na = [0] * 99\nfor i in range(n):\n    s = input()\n    for j in range(m):\n        a[j] += s[j] == 'Y'\nprint(len(list([x for x in a if x >= k])))\n#kitten\n", "n,k,m=map(int,input().split())\na=list(map(int,input().split()))\nb=[]\nc=[]\nfound=False\nfor i in range(m):\n    c.append([])\n    b.append(0)\nfor i in a:\n    temp=i%m\n    b[temp]+=1\n    c[temp].append(i)\n    if(b[temp]>=k):\n        print(\"Yes\")\n        found=True\n        for j in c[temp]:\n            \n            print(j,end=' ')\n        print()\n        break\nif(not found):\n    print(\"No\")\n", "a=[[1,1,1],[1,1,1],[1,1,1]]\nd={0:1,1:0}\nfor i in range(3):\n    b=list(map(int,input().split()))\n    for j in range(3):\n        if b[j]%2==1:\n            a[i][j]=d[a[i][j]]\n            if i!=0:\n                a[i-1][j]=d[a[i-1][j]]\n            if i!=2:\n                a[i+1][j]=d[a[i+1][j]]\n            if j!=0:\n                a[i][j-1]=d[a[i][j-1]]\n            if j!=2:\n                a[i][j+1]=d[a[i][j+1]]\nfor i in range(3):\n    for j in range(3):\n        print(a[i][j],end='')\n    print()\n", "iters = int(input().split()[2])\n\nholes = {int(x) for x in input().split()}\n\ncurrent = 1\n\nfor _ in range(iters):\n    src, dest = (int(x) for x in input().split())\n    if current in holes:\n        break\n    if current == src:\n        current = dest\n    elif current == dest:\n        current = src\nprint(current)", "from math import ceil\n\nn, a, b = map(int, input().split())\n\ns = 6 * n\n\nif a * b >= s:\n    na, nb = a, b\nelse:\n    a1, b1 = min(a, b), max(a, b)\n    q = [(x, ceil(s / x)) for x in range(a1, ceil(s ** .5)) if ceil(s / x) > b1]\n    na, nb = min(q, key=lambda c: c[0] * c[1])\n    if na < a:\n        na, nb = nb, na\n\nprint(na * nb)\nprint(na, nb)", "from math import sqrt\nfrom fractions import gcd\n\n\ndef main():\n    limit, res = int(input()), 0\n    for m in range(2, int(sqrt(limit)) + 1):\n        mm = m * m\n        for n in range(1 + (m & 1), m, 2):\n            nn = n * n\n            c = mm + nn\n            if c > limit:\n                break\n            if gcd(mm - nn, c) == 1:\n                res += limit // c\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "\ndef main():\n    n, k = list(map(int, input().split()))\n\n    MOD = 10**9 + 7\n    Comb = [None] * (n + 1)\n    dp = [[None] * (n + 1) for i in range(n+1)]\n\n    for i in range(1, n + 1):\n        Comb[i] = [1] + [(Comb[i-1][j-1] + Comb[i-1][j]) % MOD for j in range(1, i)] + [1]\n\n    def powgen(base):\n        cur = 1\n        while True:\n            yield cur\n            cur = cur * base % MOD\n\n    gen, gen_1 = powgen(k), powgen(k - 1)\n    kpower = [next(gen) for i in range(n + 1)]\n    k1power = [next(gen_1) for i in range(n + 1)]\n\n    dp[1][0] = (kpower[n] - k1power[n] + MOD) % MOD\n    for i in range(1, n+1): dp[1][i] = kpower[n-i]\n\n    for r in range(2, n + 1): # row remaining\n        # c means col incompleted\n        for c in range(n+1): \n            dp[r][c] = (dp[r-1][c] * k1power[c] * (kpower[n-c]-k1power[n-c]) + \\\n                kpower[n-c] * sum([dp[r-1][c-i] * Comb[c][i] * k1power[c-i] for i in range(1, c+1)])) % MOD\n            \n    # input 250 1000000000\n    return dp[n][n]\n\nprint(main())\n\n", "n=int(input())\nl=[int(x) for x in input().split()]\nmx=max(l)\nans=0\nfor e in l:\n  ans+=mx-e\nprint(ans)\n  \n", "from sys import stdin\nimport math\n\nN = int(stdin.readline())\n\nangles = []\n\nfor n in range(N):\n    x, y = map(int, stdin.readline().split())\n\n    angles.append((math.atan2(y, x) + 2 * math.pi) % (2 * math.pi))\n\nangles.sort()\nangles.append(angles[0] + 2 * math.pi)\n\nmax_gap = max(angles[i] - angles[i - 1] for i in range(1, len(angles)))\nprint(360 - 180 * max_gap / math.pi)", "3\n\n\ndef main():\n    data = input()\n    n = int(input())\n\n    if n > len(data):\n        return \"impossible\"\n    \n    uniq = len(set(data))\n    if n <= uniq:\n        return \"0\"\n    else:\n        return n-uniq\n\n\ndef __starting_point(): print(main())\n\n__starting_point()", "s = input()\nif not '.' in s: s += '.'\na,b = s.strip('0').split('.')\nif len(a) > 0:\n  b = (a[1:] + b).rstrip('0')\n  le = len(a)-1\n  a = a[0]\nelse:\n  le = len(b.strip('0')) - len(b) - 1\n  b = b.strip('0').rstrip('0')\n  a = b[0]\n  b = b[1:]\n\nprint(a,end='')\nif len(b): print('.' + b,end='')\nif le : print('E'+str(le))\n\n\t  \t  \t\t\t  \t\t\t\t\t   \t  \t \t\t", "a,b,n = list(map(int,input().split()))\nm =1000000007\nfact = [1]\n\nfor i in range(1,n+1):\n    fact.append((fact[-1]*i)%m)\nans = 0\nfor i in range(n+1):\n    su = (a*i) + b*(n-i)\n    coef = 1\n    while(su>0):\n        if(su%10 != a and su%10!=b):\n            coef = 0;\n        su//=10\n    if coef:\n        ans+=(fact[n]*pow((fact[i]*fact[n-i]),m-2,m))\n        ans= ans%m\nprint(ans%m)\n    \n", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nif k == 1:\n    print(min(a))\nelif k == 2:\n    b = [a[0]] * (n - 1)\n    for i in range(1, n - 1):\n        b[i] = min(b[i - 1], a[i])\n    c = [a[n - 1]] * (n - 1)\n    for i in range(n - 3, -1, -1):\n        c[i] = min(c[i + 1], a[i + 1])\n    ans = - 10 ** 10\n    for i in range(n - 1):\n        ans = max(ans, max(b[i], c[i]))\n    print(ans)\nelse:\n    print(max(a))\n    \n", "def chop():\n    return (int(i) for i in input().split())\ns,v1,v2,t1,t2=chop()\na1=s*v1+t1*2\na2=s*v2+t2*2\nif a1==a2:\n    print('Friendship')\nelif a1<a2:\n    print('First')\nelse:\n    print('Second')\n", "n, m, z = map(int, input().split())\n\ngcd = lambda a, b: gcd(b, a % b) if b else a\nmm = n * m // gcd(n, m)\nprint(z // mm)", "def recursion(n):\n    if n == 1:\n        return x\n    if n == 2:\n        return x + min(x , y)\n    if n % 2 == 0:\n        return recursion(n // 2) + min(y, x * (n - n//2))\n    else:\n        return min(recursion(n + 1), recursion(n - 1)) + x\n\n\nimport sys\nsys.setrecursionlimit(10000000)\nn, x, y = list(map(int, input().split()))\nprint(recursion(n))\n", "from itertools import permutations\nmatrix, ans = [list(map(int, input().split())) + [0] for x in range(5)] + [[0] * 6], 0\nfor perm in permutations(list(range(5))):\n    x = list(perm) + [5]\n    temp = 0\n    for i in range(5):\n        for j in range(i, 5, 2):\n            temp += matrix[x[j]][x[j + 1]] + matrix[x[j + 1]][x[j]]\n    ans = max(ans, temp)\nprint(ans)\n", "from sys import stdin, stdout\n\nn = int(stdin.readline())\ns = stdin.readline().strip()\ncnt = [[0, 0] for i in range(n)]\n\ncnt[0][1] = int(s[0])\ncnt[0][0] = 1 - int(s[0])\n\nfor i in range(1, n):\n    cnt[i][1] += cnt[i - 1][1] + int(s[i])\n    cnt[i][0] = i + 1 - cnt[i][1]\n\ncnt.append([0, 0])\n\nans = 0\nfor i in range(n):\n    value = int(s[i])\n    current = i + ans\n    \n    while current < n:\n        if max(cnt[current][1] - cnt[i - 1][1], cnt[current][0] - cnt[i - 1][0]) != min(cnt[current][1] - cnt[i - 1][1], cnt[current][0] - cnt[i - 1][0]):\n            current += (max(cnt[current][1] - cnt[i - 1][1], cnt[current][0] - cnt[i - 1][0]) - min(cnt[current][1] - cnt[i - 1][1], cnt[current][0] - cnt[i - 1][0]))\n        else:\n            ans = max(ans, current - i + 1)\n            current += 1\n\nstdout.write(str(ans))", "direction = input()\ntext = input()\n\nif direction == 'R':\n  _to = 'qwertyuioasdfghjklzxcvbnm,.'\n  _from = 'wertyuiopsdfghjkl;xcvbnm,./'\n\nif direction == 'L':\n  _to = 'wertyuiopsdfghjkl;xcvbnm,./'\n  _from = 'qwertyuioasdfghjklzxcvbnm,.'\n\ntable = text.maketrans(_from, _to)\nprint(text.translate(table))\n", "import sys\nfrom math import *\nfrom fractions import gcd\nfrom random import * # randint(inclusive,inclusive)\nreadints=lambda:list(map(int, input().strip('\\n').split()))\nfrom itertools import permutations, combinations\ns = \"abcdefghijklmnopqrstuvwxyz\"\n# print('', end=\" \")\n# for i in {1..5}; do echo \"hi\"; done\n\n\n\n\nn,k=readints()\ns=input()\n\nlo=-1\nhi=n+1\n\n\n\ndef test(x):\n    have=k-1\n    last=0\n    arr=[]\n    for i in range(n):\n        if s[i]=='0':\n            arr.append(i)\n\n    arr.append(10**9)\n\n    for i in range(1,len(arr)):\n        if arr[i]-last-1>x:\n            if arr[i-1]==last:\n                return False\n            if have==0:\n                return False\n            if arr[i-1]-last-1>x:\n                return False\n            last=arr[i-1]\n            have-=1\n\n    return True\n\n\n\nwhile hi-lo>1:\n    mid=(lo+hi)//2\n    if test(mid):\n        hi=mid\n    else:\n        lo=mid\n\n\nprint(hi)\n", "x,y=map(int,input().split())\nmod=10**9+7\n\na=(2*x-y)//3\nb=(2*y-x)//3\n\n\n\nif a!=(2*x-y)/3 or b!=(2*y-x)/3:\n    print(0)\nelif a<0 or b<0:\n    print(0)\nelse:\n    max=a+b+10\n    fac=[0]*max\n    finv=[0]*max\n    inv=[0]*max\n\n    fac[0]=fac[1]=1\n    finv[0]=finv[1]=1\n    inv[1]=1\n    for i in range(2,max):\n        fac[i]=fac[i-1]*i%mod\n        inv[i]=mod-inv[mod%i]*(mod//i)%mod\n        finv[i]=finv[i-1]*inv[i]%mod\n\n    ans=fac[a+b]*(finv[a]*finv[b]%mod)%mod\n    print(ans)", "print(pow(1378,int(input()),10))\n", "n, s = map(int, input().split(' '))\nl = list()\nfor i in range(n):\n    a, b = map(int, input().split(' '))\n    l.append(a * 60 + b)\nif l[0] - s >= 1:\n    print(0, 0)\nelse:\n    for i in range(n - 1):\n        t = l[i + 1] - l[i] - 1 - 2 * s\n        if t >= 1:\n            tt = l[i] + 1 + s\n            h, m = tt // 60, tt % 60\n            print(h, m)\n            break\n    else:\n        tt = l[-1] + 1 + s\n        h, m = tt // 60, tt % 60\n        print(h, m)", "n=int(input())\nl1=list(map(int,input().split()))\nflag1=0\nflag2=0\nfor item in l1:\n    if item%2==0:\n        flag1=1\n    else :\n        flag2=1\nif flag1==1 and flag2==1:\n    l1.sort()\nprint(' '.join(str(x) for x in l1))", "#map(int,input().split())\nn=int(input())\na=list(map(int,input().split()))\nans=0\nflag=0\nfor i in range(1,n):\n    if a[i]==2:\n        if a[i-1]==3:\n            print('Infinite')\n            flag=1\n            break\n        else:\n            ans+=3\n            if i>1 and a[i-2]==3:\n                ans-=1\n    elif a[i]==1:\n        if a[i-1]==2:\n            ans+=3\n        else:\n            ans+=4\n    else:\n        if a[i-1]==2:\n            print('Infinite')\n            flag=1\n            break\n        else:\n            ans+=4\nif flag==0:\n    print('Finite')\n    print(ans)", "a, b, c = map(int, input().split(' '))\np = 998244353\n\ndef calc (a, b) :\n\tif a > b:\n\t\ta, b = b, a\n\tans = 0\n\ttmp = 1\n\tfor i in range(a + 1):\n\t\tans = (ans + tmp) % p\n\t\ttmp = tmp * (a - i) * (b - i) * pow(i + 1, p - 2, p) % p\n\treturn ans\n\nans = calc(a, b) * calc(b, c) * calc(a, c) % p\n\nprint(ans)", "n = input()\nflag = False\nlast = int(n[-1])\nfor i in range(len(n)):\n\tif int(n[i]) % 2 == 0:\n\t\tif last > int(n[i]):\n\t\t\tflag = True\n\t\t\tprint(n[:i] + str(last) + n[i + 1:-1] + n[i])\n\t\t\tbreak\nif flag is False:\n\tfor i in range(len(n) - 1, -1, -1):\n\t\tif int(n[i]) % 2 == 0:\n\t\t\tflag = True\n\t\t\tprint(n[:i] + str(last) + n[i + 1:-1] + n[i])\n\t\t\tbreak\nif flag == False:\n\tprint(-1)", "n = int(input())\na = list(map(int, input().split()))\nprint(\"YES\" if (n == 1 and a.count(0) == 0) or (n > 1 and a.count(0) == 1) else \"NO\")", "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = {}\nfor i in range(n):\n    c[b[i]] = i\nb = []\nfor i in range(n):\n    a[i] = c[a[i]]\nprint(sum(abs(a[i] - i) for i in range(n)) >> 1)\n\nwhile True:\n    for i in range(n):\n        if a[i] < i:\n            for j in range(a[i], i):\n                if a[j] >= i:\n                    a[i], a[j] = a[j], a[i]\n                    b += [(i+1, j+1)]\n                    break\n            break\n    else:\n        break\n\nprint(len(b))\nfor e in b:\n    print(*e)\n\n\n", "n, k = map(int, input().split())\na = list(input()) * 2\n     \niter1 = [0] * (2 * n)\niter2 = [0] * (2 * n)\nchanges = 0\nfor i in range(1, 2 * n):\n    if a[i] != a[i - 1]:\n        changes += 1\n    else:\n        changes = 0\n    iter1[i] = changes\nchanges = 0\nfor i in range(2 * n - 2, -1, -1):\n    if a[i] != a[i + 1]:\n        changes += 1\n    else:\n        changes = 0\n    iter2[i] = changes\n     \niters = [min(iter1[n + i], iter2[i]) for i in range(n)]\nfor i in range(n):\n    if iters[i] > n // 2:\n        iters[i] = 10 ** 9 + 1\n    it = min(iters[i], k)\n    if it % 2 != 0:\n        if a[i] == \"B\":\n            a[i] = \"W\"\n        else:\n            a[i] = \"B\"\nprint(\"\".join(a[:n]))", "a,b=input().split()\nx=int(a)\ny=int(b)\nif x>0 and y>0:\n    print(0,x+y,x+y,0)\nelif x>0 and y<0:\n    print(0,-(abs(y)+x),(abs(y)+x),0)\nelif x<0 and y>0:\n    print(-(abs(x)+y),0,0,(abs(x)+y))\nelif x<0 and y<0:\n    print(x+y,0,0,x+y)\n\n", "n, m = list(map(int, input().split()))\n\nbad = 0\nfor _ in range(m):\n    v = [0]*(n+1)\n    ok = 0\n    for u in [int(i) for i in input().split()[1:]]:\n        au = abs(u)\n        su = 1 if u < 0 else 2\n        v[au] |= su\n        if v[au] == 3: ok = 1\n    if not ok: bad = 1\n\nprint(\"YES\" if bad else \"NO\")\n", "n, needed = map(int, input().split())\nplayers = list(map(int, input().split()))\n\nwinner = players[0]\nwins = 0\n\nfor i in range(1, n):\n    if players[i] > winner:\n        winner = players[i]\n        wins = 1\n    else:\n        wins += 1\n    if wins >= needed:\n        break\n    \nprint(winner)", "def count_capitals(string):\n    count = 0\n    for letter in string:\n        if letter.upper() == letter:\n            count += 1\n    return count\n\nn = int(input())\n\nwords = [x for x in input().split()]\ncapitals = []\n\nfor word in words:\n    capitals.append(count_capitals(word))\n\nprint(max(capitals))\n\n", "import itertools\nimport math\n\ndef main():\n\ta = int(input())\n\tb = int(input())\n\tc = int(input())\n\tprint(max(a*b*c, a+b+c, a+b*c, a*b+c, a*(b+c), (a+b)*c))\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "#!/usr/bin/env python3\n\nn, a, b = [int(x) for x in input().split()]\n\nif n > a*b:\n    print(-1)\nelse:\n    for i in range(0, a):\n        if i % 2 == 0:\n            for j in range(b*i, b * (i + 1)):\n                if j >= n:\n                    print(0, end=' ')\n                else:\n                    print(j + 1, end=' ')\n        else:\n            for j in range(b * (i + 1) - 1, b*i - 1, -1):\n                if j >= n:\n                    print(0, end=' ')\n                else:\n                    print(j + 1, end=' ')\n        print()\n", "m,c=list(map(int,input().split()))\np=list(map(int,input().split()))\nn=list(map(int,input().split()))\n\nsum1,sum2,sm=0,0,0\n\nfor i in range(m):\n    sm+=n[i]\n    sum1=sum1+max(0,p[i]-c*sm )\n\nsm=0\ni=m-1\nwhile i>=0:\n    sm+=n[i]\n    sum2=sum2+max(0,p[i]-c*sm)\n    i-=1\nif sum1>sum2:\n    print(\"Limak\")\nelif sum2>sum1:\n    print(\"Radewoosh\")\nelif sum1 == sum2 :\n    print(\"Tie\")\n", "def coloring(i, ancestors, color):\n    while i != 0 and color[ancestors[i - 1]] is None:\n        color[ancestors[i - 1]] = not color[i]\n        i = ancestors[i - 1]\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    ancestors = list([int(x) - 1 for x in input().split()])\n    descendants = [[] for i in range(n)]\n    for i in range(n - 1):\n        descendants[ancestors[i]].append(i + 1)\n    color = [None for i in range(n)]\n    for i in range(n):\n        if not descendants[i]:\n            color[i] = True\n            coloring(i, ancestors, color)\n    reds = 0\n    blues = 0\n    xor = 0\n    count_red = dict()\n    count_blue = dict()\n    for i in range(n):\n        if color[i]:\n            blues += 1\n            xor ^= a[i]\n            if str(a[i]) in count_blue:\n                count_blue[str(a[i])] += 1\n            else:\n                count_blue[str(a[i])] = 1\n        else:\n            reds += 1\n            if str(a[i]) in count_red:\n                count_red[str(a[i])] += 1\n            else:\n                count_red[str(a[i])] = 1\n    res = 0\n    if xor == 0:\n        res += (blues - 1) * blues // 2\n        res += (reds - 1) * reds // 2\n        for i in list(count_blue.items()):\n            if i[0] in count_red:\n                res += i[1] * count_red[i[0]]\n    else:\n        for i in list(count_blue.items()):\n            if str(xor ^ int(i[0])) in count_red:\n                res += i[1] * count_red[str(xor ^ int(i[0]))]\n    print(res)\n\n\nmain()\n\n", "#\t!/usr/bin/env python3\n#\tencoding: UTF-8\n#\tModified: <04/May/2019 10:39:45 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline().strip()\n\n\n# ///==========MAIN=============///\n\ninf = float('inf')\n\n\ndef main():\n    n, h, m = get_ints()\n    arr = [inf] * n\n    for tc in range(m):\n        l, r, x = get_ints()\n        l -= 1\n        r -= 1\n        for i in range(l, r + 1):\n            arr[i] = min(arr[i], x)\n    ans = 0\n    for i in arr:\n        if i == inf:\n            ans += (h**2)\n        else:\n            ans += (i**2)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "L = lambda: list(map(int, input().split()))\nI = lambda: int(input())\n\nn, t = I(), [L() for i in range(4)]\np = [min(i[0], i[1]) + min(i[2], i[3]) for i in t]\nx = min(p)\nif x > n: print(-1)\nelse:\n    k = p.index(x)\n    p = min(t[k][0], t[k][1])\n    print(k + 1, p, n - p)", "import math\n\n\nn, w = [int(x) for x in input().split()]\nl = [int(x) for x in input().split()]\n# sorted(l, reverse=False)\nqw = l[:]\nl.sort(reverse=True)\n\nq = [int(math.ceil(x/2)) for x in l]\nsm = sum(q)\nif w<sm:\n    print(-1)\nelse:\n    rem = w - sm\n    er = q[:]\n    for x in range(len(q)):\n        if rem+q[x]>l[x]:\n            rem = rem -(l[x]-q[x])\n            q[x] = l[x] \n        else:\n            e = []\n            q[x] = q[x]+ rem\n            #q = zip(l,q)\n            for qq in qw:\n                inx = l.index(qq)\n                e.append(q[inx])\n                print(e[-1], end= ' ')\n                l[inx] = -111\n            \n\n\n            \n", "import sys\n\nN_MAX = 200000 + 5\nsys.setrecursionlimit(N_MAX)\nMOD = 10**9 + 7\n\n# ## COMBINATION (MOD) ## #\n\nfac = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\nfacinv = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N_MAX + 1):\n    fac.append((fac[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    facinv.append((facinv[-1] * inv[-1]) % MOD)\n\n\ndef cmb(n, r):\n    if (r < 0 or r > n):\n        return 0\n    # r = min(r, n-r)\n    return fac[n] * facinv[r] * facinv[n - r] % MOD\n\n\ndef main():\n    n, k = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    k = min(n, k)\n\n    ans = 0\n    for m in range(k+1):\n        empty = cmb(n, m)\n        member = cmb(n - 1, n - m - 1)\n        ans += (empty * member) % MOD\n        ans %= MOD\n\n    print(ans)\n\n\nmain()\n", "from math import *\n\nn, m = input().split()\nn, m = int(n), int(m)\n\nb = [[int(i) for i in input().split()] for i in range(n)]\na = [[1] * m for i in range(n)]\nc = [[0] * m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if (b[i][j] == 0):\n            for k in range(m):\n                a[i][k] = 0\n                \n            for k in range(n):\n                a[k][j] = 0\n                \nfor i in range(n):\n    for j in range(m):\n        c[i][j] = 0\n        \n        for k in range(m):\n            if (a[i][k] == 1):\n                c[i][j] = 1\n                break\n                \n        if (c[i][j] == 1):\n            continue\n            \n        for k in range(n):\n            if (a[k][j] == 1):\n                c[i][j] = 1\n                break\n                \nbad = False\n                \nfor i in range(n):\n    for j in range(m):\n        if (c[i][j] != b[i][j]):\n            bad = True\n            print('NO')\n            break\n            \n    if (bad):\n        break\n\nif (not bad):\n    print('YES')\n    \n    for i in range(n):\n        for j in range(m):\n            print(a[i][j], end = ' ')\n            \n        print()", "i = input()\ni2 = input().split(' ')\n\nout = False\n\nfor s in i2:\n    if s[0] == i[0] or s[1] == i[1]:\n        out = True\n        break\n\nif out:\n    print('YES')\nelse:\n    print('NO')\n", "#author=\"_rabbit\"\nn=(int)(input())\na=list(map(int,input().split()))\nsum=0\nfor i in a:\n    sum+=int(i)\nif(sum%2==0):\n    print(sum)\nelse:\n    minn=int(1000000000000000)\n    for i in a:\n        if(i%2):\n            minn=min(minn,i)\n    sum=sum-minn\n    print(sum)\n    \n", "import sys\nimport threading\nfrom collections import defaultdict\n\ndef put():\n    return map(int, input().split())\n\ndef dfs(i, p, m):\n    cnt = 1\n    z = 0\n    for j in tree[i]:\n        if j==p: continue\n        if cnt==m: cnt+=1\n        index = edge_index[(i,j)]\n        ans[cnt].append(index)\n        z = max(dfs(j,i,cnt), z)\n        cnt+=1\n    return max(z,cnt-1)\n\ndef solve():\n    l = dfs(1,0,0)\n    print(l)\n    for i in range(1, l+1):\n        print(len(ans[i]), *ans[i])\n    \n\nn = int(input())\nedge_index = defaultdict()\nans = [[] for i in range(n+1)]\ntree = [[] for i in range(n+1)]\nfor i in range(n-1):\n    x,y = put()\n    edge_index[(x,y)]=i+1\n    edge_index[(y,x)]=i+1\n    tree[x].append(y)\n    tree[y].append(x)\n\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()", "n = int(input())\nnum = list(map(int, input().split()))\nif 1 in num:\n    print('HARD')\nelse:\n    print('EASY')", "import sys\n\ndef main():\n    # fin = open(\"input.txt\", \"r\")\n    fin = sys.stdin\n    \n    n, m = map(int, fin.readline().split())\n    A = []\n    for i in range(n):\n        A.append(fin.readline().rstrip())\n\n    cnt = 0\n    for i in range(n - 1):\n        for j in range(m - 1):\n            S = {A[i][j], A[i][j + 1], A[i + 1][j], A[i + 1][j + 1]}\n            if (\"f\" in S) and (\"a\" in S) and (\"c\" in S) and (\"e\" in S):\n                cnt += 1\n\n    print(cnt)\n\n    fin.close()\n\nmain()", "def dfs(v):\n    pos.append(v)\n    used[v] = True\n    for g in range(n):\n        if int(s[v][g]) and not used[g]:\n            dfs(g)\n\nn = int(input())\np = list(map(int, input().split()))\ns = [input() for i in range(n)]\nused = [False] * n\nfor j in range(n):\n    if not used[j]:\n        pos = []\n        dfs(j)\n        values = [p[i] for i in pos]\n        pos.sort()\n        values.sort()\n        for (i, po) in enumerate(pos):\n            p[po] = values[i]\nprint(' '.join([str(x) for x in p]))", "st = input()\narr = []\nfor i in range(len(st)):\n\tarr.append(st[i:] + st[:i])\narr = sorted(arr)\ncnt = 1\nfor i in range(1,len(st)):\n\tif(arr[i] != arr[i-1]):\n\t\tcnt = cnt + 1\nprint(cnt)", "s,c='heidi',0\nfor i in input():\n  if i==s[c]:c+=1\n  if c==5:break\nprint('YES' if c==5 else 'NO')\n", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\nes = [[] for i in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n\nfrom collections import deque\ntmpdist = N\nans = None\nfor to in range(N):\n    for fr in es[to]:\n        dist = [N] * N\n        dist[fr] = 0\n        prev = [-1] * N\n        q = deque([fr])\n        while q:\n            v = q.popleft()\n            if v==to: break\n            for w in es[v]:\n                if dist[w] < N: continue\n                if v==to and w==fr: continue\n                dist[w] = dist[v] + 1\n                prev[w] = v\n                q.append(w)\n        else:\n            continue\n        if dist[to] < tmpdist:\n            tmpdist = dist[to]\n            ans = set()\n            v = to\n            while 1:\n                ans.add(v+1)\n                if prev[v] < 0: break\n                v = prev[v]\nif ans is None:\n    print(-1)\nelse:\n    print(len(ans))\n    print(*ans, sep='\\n')", "q = 998244353\n\nn, k = map(int, input().split())\n\nlr = [list(map(int, input().split())) for _ in range(k)]\n\ndp = [0] * (n + 1)\ndpsum = [0] * (n + 1)\n\n\ndp[1] = 1\ndpsum[1] = 1\n\nfor i in range(2, n + 1):\n    for l, r in lr:\n        li = i - r\n        ri = i - l\n        if ri < 1: continue\n        li = max(li, 1)\n        dp[i] += (dpsum[ri] - dpsum[li - 1])\n        dp[i] %= q\n    dpsum[i] = dp[i] + dpsum[i - 1]\n    dpsum[i] %= q\n\nprint(dp[n])", "def cnt(n):\n    a = [0] * 10\n    c = 0\n    b = 0\n    while n != 0:\n        a[n % 10] += 1\n        if a[n % 10] == 1:\n            c += 1\n        n //= 10\n        b += 1\n    if b == c:\n        return True\n    else:\n        return False\n\nn = int(input().strip())\ni = 1\nwhile not cnt(n + i):\n    i += 1\nprint(n + i)", "def main():\n    n = int(input())\n    aa = list(map(int, input().split()))\n    m = aa[-1]\n    for i in range(n - 2, -2, -1):\n        a = aa[i]\n        if m < a:\n            break\n        m = a\n    print(i + 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def find_max_substr(t, s):\n    l, r = 0, len(t)\n    while l != r:\n        m = (l + r) // 2\n        if t[:m + 1] in s:\n            l = m + 1\n        else:\n            r = m\n    l1 = l\n    rs = s[::-1]\n    l, r = 0, len(t)\n    while l != r:\n        m = (l + r) // 2\n        if t[:m + 1] in rs:\n            l = m + 1\n        else:\n            r = m\n    l2 = l\n    if l1 >= l2:\n        return s.find(t[:l1]) + 1, s.find(t[:l1]) + l1\n    else:\n        return s.find(t[:l2][::-1]) + l2, s.find(t[:l2][::-1]) + 1\n\ns = input()\nt = input()\nif not set(t).issubset(set(s)):\n    print(-1)\n    return\na = []\nwhile t:\n    l, r = find_max_substr(t, s)\n    a.append((l, r))\n    t = t[abs(r - l) + 1:]\nprint(len(a))\nfor l, r in a:\n    print(l, r)\n", "n=int(input())\na=[int(x) for x in input().split()]\na=sorted(a)\nl=len(a)\na1=[]\na2=[]\nfor i in range(1,n,2):\n    a1.append(i)\nfor i in range(2,n+1,2):\n    a2.append(i)\ns1=0\ns2=0\nfor i in range(l):\n    s1=s1+abs(a1[i]-a[i])\nfor i in range(l):\n    s2=s2+abs(a2[i]-a[i])\nprint(min(s1,s2))\n", "n, b, d = list(map(int, input().split(' ')))\na = list(map(int, input().split(' ')))\n\nlevel = 0\noverflows = 0\n\nfor ai in a:\n    if ai > b: continue\n    level += ai\n    if level > d:\n        overflows += 1\n        level = 0\n        \nprint(overflows)\n", "def f():\n\n    n, m = list(map(int, input().split()))\n\n    t = [input() for j in range(n)]\n\n\n\n    p = [''.join(i) for i in zip(*t)]\n\n    if h(p): return 1\n\n\n\n    i = 0\n\n    while i < n and not 'B' in t[i]: i += 1\n\n\n\n    while i < n:\n\n        a = t[i].find('B')\n\n        if a < 0:\n\n            i += 1\n\n            break\n\n        b = t[i].rfind('B')\n\n        if 'W' in t[i][a: b + 1]: return 1\n\n\n\n        for j in range(i + 1, n):\n\n            if a > 0 and t[j][a - 1] == 'B' and t[j][b] == 'W': return 1\n\n            if b < m - 1 and t[j][b + 1] == 'B' and t[j][a] == 'W': return 1\n\n        i += 1\n\n\n\n    while i < n:\n\n        if 'B' in t[i]: return 1\n\n        i += 1    \n\n\n\n    return 0  \n\n            \n\ndef h(t):\n\n    i, n = 0, len(t)\n\n    while i < n and not 'B' in t[i]: i += 1\n\n\n\n    while i < n:\n\n        a = t[i].find('B')\n\n        if a < 0:\n\n            i += 1\n\n            break\n\n        b = t[i].rfind('B')\n\n        if 'W' in t[i][a: b + 1]: return 1\n\n        i += 1\n\n\n\n    while i < n:\n\n        if 'B' in t[i]: return 1\n\n        i += 1    \n\n\n\n    return 0          \n\n    \n\nprint('YNEOS'[f():: 2])\n\n\n\n# Made By Mostafa_Khaled\n", "def A():\n    R,C = map(int, input().split())\n    pasture = []\n    for _ in range(R):\n        line = input().replace('.','D')\n        if 'WS' in line or 'SW' in line:\n            return False\n        pasture.append(line)\n\n    #Check columns\n    for i in range(C):\n        column = ''.join([l[i] for l in pasture])\n        if 'WS' in column or 'SW' in column:\n            return False\n\n    #Here it is ok\n    return '\\n'.join(pasture)\n\nres = A()\nif res:\n    print('Yes')\n    print(res)\nelse:\n    print('No')", "from heapq import heappush, heappop\n\nn = int(input())\nheap = []\nans = 0\nlast_added = []\nfor i in range(2*n):\n    c = input()\n    if c == \"remove\":\n        out = heappop(heap)\n        if len(last_added):\n            if out != last_added[-1]:\n                ans += 1\n                last_added = []\n            else:\n                last_added.pop()\n    else:\n        b = int(c.split()[1])\n        last_added.append(b)\n        heappush(heap, b)\nprint(ans)\n", "k = int(input())\na = [list(input()) for i in range(4)]\nx = [0 for i in range(10)]\nfor i in range(4):\n\tfor j in range(4):\n\t\tif a[i][j] == '.': continue\n\t\tn = int(a[i][j])\n\t\tx[n]+=1\nok = True\nfor i in range(10):\n\tif x[i] > 2*k:\n\t\tok = False\nif (ok):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n", "import sys\nv=int(sys.stdin.readline())\n\nA=list(map(int,sys.stdin.readline().split()))\nind=1\nind=1\nvol=A[0]\n\nfor i in range(1,10):\n    if(A[i-1]<vol):\n        vol=A[i-1]\n        ind=i\n    elif(A[i-1]==vol and i>ind):\n        vol=A[i-1]\n        ind=i\n\nused=(v//vol)*vol\n\nrest=v-used\n\nx=rest-1\nz=0\nans=list(str(ind)*(v//vol))\n\nwhile(len(ans)!=0 and x!=rest and z<len(ans)):\n    x=rest\n    for i in range(9,0,-1):\n        if(A[i-1]-A[ind-1]<=rest):\n            rest-=A[i-1]-A[ind-1]\n            ans[z]=str(i)\n            z+=1\n            break\nAns=\"\"\nfor item in ans:\n    Ans+=item\nif(len(Ans)==0):\n    print(-1)\nelse:\n    sys.stdout.write(Ans)\n\n", "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nN, M = list(map(int, input().split()))\n\n\nparent = [i for i in range(N)]\nrank = [0] * N\n\n\ndef find(i):\n    if parent[i] == i:\n        return i\n    else:\n        parent[i] = find(parent[i])\n        return parent[i]\n\n\ndef same(x, y):\n    return find(x) == find(y)\n\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n\n    if rank[x] > rank[y]:\n        parent[y] = x\n    else:\n        parent[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\n\nP = list(map(int, input().split()))\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    a, b = a - 1, b - 1\n    unite(a, b)\n\n\nd = defaultdict(list)\ncnt = defaultdict(int)\nfor i in range(N):\n    d[find(i)].append(P[i])\n\nfor i in range(N):\n    if find(i) == i:\n        d[i] = sorted(d[i], reverse=True)\n\nans = []\nfor i in range(N):\n    k = find(i)\n    ans.append(d[k][cnt[k]])\n    cnt[k] += 1\n\nprint(' '.join(map(str, ans)))\n", "citys,cap=map(int,input().split())\nif citys-1<=cap:\n\tprint(citys-1)\nelse:\n\tn=citys-cap\n\tprint(n*(n+1)//2+cap-1)", "n = int(input())\na = [0] + list(map(int, input().split()))\ndp = [0] * (n + 1)\ns = [0] * (n + 1)\nfor i in range(1, n + 1):\n    s[i] = s[i - 1] + a[i]\ndp[n] = 0\ncur = s[n]\nfor i in range(n - 1, 0, -1):\n    dp[i] = cur\n    cur = max(cur, s[i] - dp[i])\nprint(dp[1])\n", "n, m = map(int, input().split())\nday, c = 0, 1\nwhile n != 0:\n    day += 1\n    if day == (c*m):\n        n += 1\n        c += 1\n    n -= 1\nprint(day)", "t = int(input())\nfor i in range(t):\n  n, k, d = map(int, input().split())\n  a = list(map(int, input().split()))\n  ans = 10000\n  for j in range(n - d + 1):\n    kol_d = 0\n    tmp = []\n    for i in range(j, j + d + 1):\n      if kol_d >= d:\n        break\n      if a[i] in tmp:\n        kol_d += 1\n      else:\n        tmp.append(a[i])\n        kol_d += 1\n    #print(tmp)\n    ans = min(len(tmp), ans)\n  print(ans)", "def pal(s):\n    return s == s[::-1]\ns, k = input(), int(input())\nif len(s) % k != 0:\n    print('NO')\nelse:\n    n = len(s) // k\n    print('YES' if all(pal(s[i * n:(i + 1) * n]) for i in range(k)) else 'NO')", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2018/12/15 22:40\n\n\"\"\"\n\n\ndef check(val):\n    l, r = 0, len(val)-1\n\n    while l < r:\n        if val[l] != val[r]:\n            return True\n        l += 1\n        r -= 1\n\n    return False\n\nT = int(input())\nfor ti in range(T):\n    s = list(input())\n    s.sort()\n    if check(s):\n        print(''.join(s))\n    else:\n        print(-1)", "n=int(input())\nans=0\nif n%3==0:\n    ans+=(n//3)*2\nelif n%3==1:\n    ans+=(n//3)*2+1\nelif n%3==2:\n    ans+=(n//3)*2+1\nprint(ans)", "def gcd(a, b):\n    while a>0 and b > 0:\n        if a > b:\n            a %= b\n        else:\n            b %= a\n    return a + b\n\nn = int(input())\nfor i in range(n // 2, 0, -1):\n    if gcd(i, n - i) == 1:\n        print(i, n - i)\n        break", "w, h, k = map(int, input().split())\nr = 0\nfor i in range(k):\n    r += w * 2\n    r += (h - 2) * 2\n    w -= 4\n    h -= 4\nprint(r)", "n = int(input())\nB = list(map(int, input().split()))\npp = {}\nfor i in range(n):\n    if B[i] - (i + 1) not in pp:\n        pp[B[i] - (i + 1)] = 0\n    pp[B[i] - (i + 1)] += B[i]\nans = 0\nfor c in pp:\n    ans = max(ans, pp[c])\nprint(ans)", "\"\"\"\nCodeforces Contest 273 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef comb2(n):\n    return n*(n-1)//2\n\ndef main():\n    n,m = read()\n    k = n // m\n    p = n % m\n    mn = p * comb2(k+1) + (m-p) * comb2(k)\n    mx = comb2(n-m+1)\n    print(mn, mx)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nwrite(main())", "n, p, k = [int(x) for x in input().split()]\ns = ''\nif p > k + 1:\n    s += \"<< \"\nfor i in range(max(1, p-k), p):\n    s += str(i) + ' '\ns += '('+str(p)+') '\nfor i in range(p + 1, min(n, p+k)+1):\n    s += str(i) + ' '\nif p + k < n:\n    s += '>>'\nprint(s)", "import math\na,b = map(int,input().split())\ngcd = math.gcd(a,b)\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\nprint(len(set(prime_factorize(gcd)))+1)", "import sys\nsys.setrecursionlimit(10**9)\n\nN = int(input())\n\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n    a, b, c = map(int, input().split())\n    graph[a-1].append((b-1, c))\n    graph[b-1].append((a-1, c))\n    \nQ, K = map(int, input().split())\nvisited = [0 for _ in range(N)]\n\ndef DFS(a, b, c):\n    for i, j in graph[b]:\n        if(i != a):\n            visited[i] = c+j\n            DFS(b, i, c+j)\nDFS(-1, K-1, 0)\n             \nfor _ in range(Q):\n    x, y = map(int, input().split())\n    print(visited[x-1]+visited[y-1])", "import sys\nmod = 1000000007\ndef mul(x,y):\n    res=1\n    while y>0:\n        if y%2==1:\n            res=(res*x)%mod\n        x=(x*x)%mod\n        y//=2\n    return res\nx,y = list(map(int,sys.stdin.readline().split()))\nif(y%x!=0):\n    print(0)\nelse:\n    y/=x\n    d=set([])\n    i=1\n    while i*i<=y:\n        if y%i==0:\n            d.add(i);d.add(y/i)\n        i+=1\n    d=sorted(list(d))\n    dp=d[::]\n    for i in range(len(d)):\n        dp[i]=mul(2,d[i]-1)\n        for j in range(i):\n            if d[i]%d[j]==0:\n                dp[i]-=dp[j]\n    print(dp[-1]%mod)\n\n", "n, k = map(int, input().split())\nfacts = [1]\nfor i in range(1, n + 1):\n    facts.append(i * facts[i - 1])\nans = facts[n]\nif k >= 1:\n    ans = 1\nif k >= 2:\n    ans += facts[n] // facts[n - 2] //facts[2]\nif k >= 3:\n    ans += 2 *facts[n] // facts[n - 3] // facts[3]\nif k == 4:\n    ans+= 9 *facts[n] // facts[n - 4] // facts[4]\nprint(ans)", "def main():\n    n = int(input())\n    for i in range(1, n):\n        if n % i == 0:\n            if i < 5 or n // i < 5:\n                continue\n            vowels = \"aeiou\"\n            ind = 0\n            ans = \"\"\n            for j in range(n // i):\n                for k in range(i):\n                    ans += vowels[(j + k) % 5]\n            print(ans)\n            return 0\n    print(-1)\n    return 0\n\nmain()", "R = lambda: map(int, input().split())\nn = int(input())\ndp = [0] * (10**6 + 1)\nfor x in R():\n    dp[x] = 1\nfor i in range(10**6, -1, -1):\n    if dp[i]:\n        for x in range(i + i, 10**6 + 1, i):\n            if dp[x]:\n                dp[i] = max(dp[i], dp[x] + 1)\nprint(max(dp))", "mat = [list(map(int, input().split())) for x in range(5)]\n\npos = (0,0)\nmid = (2,2)\n\nfor i in range(5):\n    for j in range(5):\n        if mat[i][j] == 1:\n            pos = i,j\n\nres = abs(mid[0] - pos[0]), abs(mid[1] - pos[1])\nprint(sum(res))\n", "import sys\nn = int(input())\na = input()\nb = input()\nl = 0\nc = [[0 for j in range(26)] for i in range(26)]\nfor i in range(n):\n    if a[i] != b[i]:\n        l += 1\n        c[ord(a[i]) - ord('a')][ord(b[i]) - ord('a')] = i+1\n\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or c[j][i] == 0:\n            continue\n        print(l-2)\n        print(c[i][j], c[j][i])\n        return\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or max(c[j]) == 0:\n            continue\n        print(l-1)\n        print(c[i][j], end=' ')\n        for k in range(26):\n            if c[j][k] > 0:\n                print(c[j][k])\n        return\nprint(l)\nprint(-1, -1)", "line = input().split()\nn = int(line[0])\nm = int(line[1])\ndata = []\nfor i in range(n):\n    data.append(input())\n    \nx = [1 for i in range(n)]\ndelete = 0\nfor i in range(m):\n    dum = [1 for j in range(n)]\n    status = 1\n    for j in range(1,n):\n        if data[j][i] > data[j-1][i]:\n            dum[j] = 0\n        elif data[j][i] == data[j-1][i]:\n            dum[j] = 1\n        else:\n            if x[j] == 1:\n                delete += 1\n                status = 0\n                break\n    if status == 1:\n        for j in range(len(dum)):\n            if dum[j] == 0:\n                x[j] = 0\nprint(delete)\n", "from collections import defaultdict\n            #from collections import defaultdict\ndef getmask(x):\n    ans = 0\n    for i in range(2, x + 1):\n        while x % i == 0:\n            x //= i\n            ans ^= 1 << i\n    return ans\n \ndef main():\n    maxn = 71\n    #maxn = 71\n    n = int(input())\n    #n = int(input())\n    a = [int(i) for i in input().split()]\n    cnt = [0] * maxn\n    for i in a:\n        cnt[i] += 1\n    masks = defaultdict(int)\n    for i in range(1, maxn):\n        masks[getmask(i)] += cnt[i]\n    while masks[0] != sum(masks.values()):\n        fixed = max(i for i in masks if masks[i])\n        masks[0] -= 1\n        for i in list(masks.keys()):\n            if i ^ fixed < i:\n                masks[i ^ fixed] += masks[i]\n                masks[i] = 0\n    print(pow(2, masks[0], 10**9+7) - 1)\n    \n    \n    \nmain()\n", "n = int(input())\n\n# \u4f8b\u5916\u51e6\u7406\nif n == 2:\n    print(1)\n    return\nif n == 3:\n    print(2)\n    return\n\n# n % k = 1 \u306e\u6570\nm = n - 1\ni = 2\nans = 1\nwhile i * i <= m:\n    if m % i == 0:\n        num = 1\n        while m % i == 0:\n            num += 1\n            m //= i\n        ans *= num\n    i = i + 1\nif m != 1:\n    ans *= 2\nans -= 1\n\n# n % k = 0 \u306e\u5834\u5408\n# n\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\nm = n\nimport numpy as np\ni = 2\nfactor = []\nwhile i * i <= n:\n    if n % i == 0:\n        l = []\n        num = 1\n        l.append(num)\n        while n % i == 0:\n            num *= i\n            l.append(num)\n            n //= i\n        factor.append(np.array(l))\n    i = i + 1\nif n > 1:\n    factor.append(np.array([1, n]))\n\n# \u76f4\u7a4d\u3092\u6c42\u3081\u308b\u3053\u3068\u3067n\u306e\u5168\u7d04\u6570\u3092\u5f97\u308b\ndivisor = factor[-1]\nfor i in range(len(factor) - 1):\n    divisor = np.outer(divisor, factor[i])\ndivisor = np.outer(np.array(1), divisor)\n\n# \u5224\u5b9a\nfor i in divisor[0]:\n    if i == 1:\n        continue\n    n = m\n    while n % i == 0:\n        n //= i\n    if n % i == 1:\n        ans += 1\n\nprint(ans)", "s = input()\nif (s[0] == 'a' and (s[1] == '1' or s[1] == '8')) or\\\n    (s[0] == 'h' and (s[1] == '1' or s[1] == '8')):\n    print(3)\nelif s[0] in 'ah' or s[1] in '18':\n    print(5)\nelse:\n    print(8)\n", "a, b, c = list(map(int, input().split())), list(map(int, input().split())), list(map(int, input().split()))\nx, y, z, u = a[1] + a[2], b[0] + b[2], c[0] + c[1], a[2] + c[0]\nt = (u + x + z) // 2 \na[0], b[1], c[2] = t - x, t - y, t - z\nprint(' '.join(str(i) for i in a))\nprint(' '.join(str(i) for i in b))\nprint(' '.join(str(i) for i in c))", "c = '0123456789'\nF = {c[a] + c[b]: (c[10 - a + b], 1) if a > b else (c[10 - a], 2) for a in range(1, 10) for b in range(10)}\nfor b in range(1, 10): F['0' + c[b]] = ('0', 1)\nF['00'] = ('0', 0)\n\ndef f(x):\n    nonlocal F\n    if x in F: return F[x]\n    a, b, y, s = int(x[0]), int(x[1]), x[2: ], 0\n    for i in range(b, a, -1):\n        y, d = f(c[i] + y)\n        s += d\n    for i in range(min(a, b) + 1):\n        y, d = f(x[0] + y)\n        s += d\n    F[x] = ('9' + y, s)\n    return F[x]\n\nprint(f('0' + input())[1]) ", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    x, y = a[0], a[1]\n    nim = 0\n    for i in range(2, n):\n        nim ^= a[i]\n    ans = 0\n\n    while((x ^ y) != nim):\n        for i in range(50, -1, -1):\n            j = (nim >> i) & 1\n            xy = ((x >> i) ^ (y >> i)) & 1\n            if j != xy:\n                m = min(x % (2**i)+1, 2**i-(y % (2**i)))\n                if x % (2**i)+1 == 2**i-(y % (2**i)):\n                    print((-1))\n                    return\n                x -= m\n                y += m\n                ans += m\n                if x <= 0:\n                    print((-1))\n                    return\n                break\n        else:\n            if (x ^ y) != nim:\n                print((-1))\n                return\n    print(ans)\n\n\nmain()\n", "from collections import defaultdict\nimport sys\n\ndef __starting_point():\n    #n, m = list(map(int, input().split()))\n    n = int(input())\n    index = list(map(int, input().split()))\n    index.sort()\n    print(index[(n - 1) // 2])\n\n__starting_point()", "def min_sub_array(day, k):\n    if not day:\n        return [0] * (k + 1)\n    n = len(day)\n    best = [float('inf')] * (n + 1)\n    best[0] = 0\n    best[1] = 1\n    for size in range(2, n + 1):\n        for i in range(n + 1 - size):\n            best[size] = min(best[size], day[i + size - 1] - day[i] + 1)\n    output = [0] * (k + 1)\n    for i in range(k + 1):\n        if n - i > 0:\n            output[i] = best[n - i]\n    return output\n\n\nN, M, K = list(map(int, input().split()))\n\nday = [i for i, val in enumerate(input()) if val == '1']\nbest = min_sub_array(day, K)\n\nfor _ in range(N - 1):\n    day = [i for i, val in enumerate(input()) if val == '1']\n    new_day_best = min_sub_array(day, K)\n\n    new_best = [float('inf')] * (K + 1)\n    for i in range(K + 1):\n        for j in range(i + 1):\n            new_best[i] = min(new_best[i], new_day_best[j] + best[i - j])\n    best = new_best\nprint(best[K])\n", "import math\nfrom decimal import *\nimport sys\nfrom fractions import Fraction\n\n\nn=int(input())\n\nS=set()\nM=dict()\nma=0\nalf = \"abcdefghijklmnopqrstuvwxyz\"\nfor c in range(0,n):\n    s=input()\n    L=len(s)\n    co=len(set(s))\n    if co == 1:\n        ch=s[0]\n        for j in alf:\n            if ch+j not in S:\n                S.add(ch+j)\n                M[ch+j] = L\n            else:\n                M[ch+j] += L\n            if ch != j:\n                if j+ch not in S:\n                    S.add(j+ch)\n                    M[j+ch] = L\n                else:\n                    M[j+ch] += L\n    if co == 2:\n        ch1 = s[0]\n        for j in range(0,L):\n            if s[j] != ch1:\n                ch2 = s[j]\n        if ch1+ch2 not in S:\n            S.add(ch1+ch2)\n            M[ch1+ch2] = L\n        else:\n            M[ch1+ch2] += L\n        if ch2+ch1 not in S:\n            S.add(ch2+ch1)\n            M[ch2+ch1] = L\n        else:\n            M[ch2+ch1] += L\nfor i in alf:\n    for j in alf:\n        if i+j in S:\n            if M[i+j]>ma:\n                ma=M[i+j]\nprint(ma)\n    \n    \n", "import math\nMOD = int( 1e9 + 7 )\n\nN, M = map( int, input().split() )\nsn = int( math.sqrt( N ) )\n\nans = N * M % MOD\nfor i in range( 1, min( sn, M ) + 1, 1 ):\n  ans -= N // i * i\n\nans %= MOD\nif N // ( sn + 1 ) > M:\n  exit( print( ans ) )\n\nfor f in range( N // ( sn + 1 ), 0, -1 ):\n  s = lambda x: x * ( x + 1 ) // 2\n  if N // f > M:\n    ans -= f * ( s( M ) - s( N // ( f + 1 ) ) )\n    break\n  ans -= f * ( s( N // f ) - s( N // ( f + 1 ) ) )\n\nans %= MOD\nif ans < 0:\n  ans += MOD\nprint( ans )\n", "n, m, k = map(int, input().split())\ns, t = input(), input()\n\nn += 1\nm += 1\n\np = [i for i in range(n * m - n) if (i + 1) % n]\nr = p[::-1]\n\nd = [0] * n * m\n\nfor i in p:\n    if s[i % n] == t[i // n]: d[i] = d[i - n - 1] + 1\n\nf = d[:]\n\nfor y in range(k - 1):\n    for i in p: f[i] = max(f[i], f[i - 1], f[i - n])\n    for i in r: f[i] = f[i - d[i] * (n + 1)] + d[i]\n\nprint(max(f))", "'''\ndef main():\n    from sys import stdin,stdout\ndef __starting_point():\n    main()\n'''\n#10/9/22016-370.2\n#2\ndef main():\n    from sys import stdin,stdout\n    s=stdin.readline().strip().lower()\n    if len(s) & 1:\n        stdout.write('-1')\n    else:\n        x=0\n        y=0\n        for i in s:\n            if i=='l':\n                x-=1\n            elif i=='r':\n                x+=1\n            elif i=='u':\n                y+=1\n            elif i=='d':\n                y-=1\n        stdout.write(str((abs(x)+abs(y))//2))\n            \ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    month2day = {}\n    cnt = 0\n    for i in range(9, 12 + 1):\n        for j in range(1, days_in_month[i - 1] + 1):\n            month2day[(i, j, 12)] = cnt\n            cnt += 1\n\n    for i in range(1, 12 + 1):\n        for j in range(1, days_in_month[i - 1] + 1):\n            month2day[(i, j, 13)] = cnt\n            cnt += 1\n\n    with open('input.txt') as f:\n        test = f.readlines()\n\n    n = int(test[0].strip())\n\n    days = [0] * len(month2day)\n    for i in range(1, n+1):\n        m, d, p, t = map(int, test[i].strip().split())\n        R = month2day[(m, d, 13)] - 1\n        L = R - t + 1\n        days[L] += p\n        days[R + 1] -= p\n\n    acc = [days[0]]\n    for i in range(1, len(days)):\n        acc.append(acc[-1] + days[i])\n\n    with open('output.txt', 'w') as f:\n        f.write(str(max(acc)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nu = []\ns = [int(i) for i in input().split()]\ns.sort()\ns.append(6001)\nn+=1\nk = 0\nfor i in range(n-1):\n    if s[i] == s[i+1]:\n        u.append(i)\n    elif u and s[i]+1 < s[i+1]:\n        t = s[i]+1\n        while t < s[i+1] and u:\n            k+=(t-s[u.pop(0)])\n            t+=1\nprint(k)\n", "import sys\nif False:\n\tinp = open('A.txt', 'r')\nelse:\n\tinp = sys.stdin\n\nn, m = map(int, inp.readline().split())\nbulbs = []\nfor i in range(n):\n\tbulbs += list(map(int, inp.readline().split()))[1:]\nbulbs = set(bulbs)\nif len(bulbs) == m:\n\tprint('YES')\nelse:\n\tprint('NO')", "n = int(input())\nx = set(map(int, input().split()[1:]))\ny = set(map(int, input().split()[1:]))\nfor i in range(1, n + 1):\n    if i not in x and i not in y:\n        print('Oh, my keyboard!')\n        break\nelse:\n    print('I become the guy.')\n", "n = int(input())\na = list(map(int, input().split()))\n\nans_pos = 0\nans_neg = 0\ntmp_pos = 0\ntmp_neg = 0\nfor i in range(n)[::-1]:\n    prev_pos = tmp_pos\n    prev_neg = tmp_neg\n    tmp_pos = 0\n    tmp_neg = 0\n    if a[i] > 0:\n        tmp_pos += 1\n        tmp_pos += prev_pos\n        tmp_neg += prev_neg\n    else:\n        tmp_neg += 1\n        tmp_pos += prev_neg\n        tmp_neg += prev_pos\n    ans_pos += tmp_pos\n    ans_neg += tmp_neg\nprint(ans_neg, ans_pos)\n\n", "n, k = list(map(int, input().split()))\ndList = list(map(int, input().split()))\nmaxD = 0\nd = {}\nfor i in dList:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n    if d[i] > maxD:\n        maxD = d[i]\namount = 0\ndis = ((maxD - 1) // k + 1) * k\nfor i in list(d.values()):\n    amount += dis - i\nprint(amount)\n", "s2=input()\ndic={'{':1,'}':-1,'<':2,'>':-2,'[':3,']':-3,'(':4,')':-4}\nstack=[]\ncount=0\nn=0\nfor x in s2:\n    if dic[x]<0:\n        if n==0:\n            print(\"Impossible\")\n            quit()\n        if dic[stack[n-1]]+dic[x]!=0:\n            count+=1\n        stack.pop()\n        n=n-1\n    else:\n        stack.append(x)\n        n=n+1\nif n!=0:\n    print(\"Impossible\")\nelse:\n    print(count)\n", "s = input().strip()\ni = 0\nalph = 'abcdefjhigklmnopqrstuwvxyz'\nans = 0\nwhile i < len(s):\n    if s[i] in alph:\n        i += 1\n    else:\n        j = i\n        while j < len(s) and (s[j] in '1234567890' or s[j] == '.'):\n            j += 1\n        c = s[i:j]\n        fl = False\n        for k in range(len(c) - 1, -1, -1):\n            if c[k] == '.':\n                fl = True\n                if len(c) - k - 1 == 3:\n                    c += '00'\n                break\n        if not fl:\n            c += '00'\n        a = ''\n        for k in c:\n            if k != '.':\n                a = a + k\n        #print(a)\n        ans += int(a)\n        i = j\nan = str(ans)\na = ''\nif len(an) < 3:\n    an = '0' * (3 - len(an)) + an\na += an[-1]\na += an[-2]\na += '.'\ni = 0\n#print(an)\nfor k in range(len(an) - 3, -1, -1):\n    a += an[k]\n    i += 1\n    if i == 3 and k > 0:\n        a += '.'\n        i = 0\nfl = False\nif ans % 100 == 0:\n    fl = True\n\nfor i in range(len(a) - 1, -1, -1):\n    if not fl or i > 2:\n        print(a[i], end='')\n\n\n", "import sys\ninput = lambda: sys.stdin.readline().strip()\nfrom math import *\n\nt = int(input())\nfor i in range(t):\n    a, b, c, d, e = list(map(int, input().split()))\n    if ceil(a/c)+ceil(b/d)<=e:\n        print(ceil(a/c), ceil(b/d))\n    else:\n        print(-1)\n", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, m = mi()\nx = max(0, n - 2 * m)\nfor i in range(n + 1):\n    c = i * (i - 1) // 2\n    if c >= m:\n        y = n - i\n        break\nprint(x, y)\n", "from collections import deque, defaultdict\n\nN = int(input())\nA = [deque([int(a) - 1 for a in input().split()]) for _ in range(N)]\n\nD = [0] * N\ncanBattle = defaultdict(lambda: False)\nque = deque(list(range(N)))\n\nwhile que:\n    i = que.popleft()\n    j = A[i].popleft()\n    canBattle[(i, j)] = True\n\n    if canBattle[(j, i)]:\n        day = max(D[i], D[j])\n        D[i] = D[j] = day + 1\n\n        if A[i]:\n            que.append(i)\n        if A[j]:\n            que.append(j)\n\nif all(len(a) == 0 for a in A):\n    print((max(D)))\nelse:\n    print((-1))\n", "N,S=map(int,input().split())\nA=list(map(int,input().split()))\nm=998244353\nimport numpy as np\ndp=np.zeros((N+1,S+1),dtype=np.int64)\ndp[:,0]=[1]*(N+1)\nfor i,a in enumerate(A):\n    dp[i+1]+=dp[i]\n    dp[i+1,a:]=(dp[i+1,a:]+dp[i,:-a])%m\nprint(np.sum(dp[:,-1])%m)", "n, k = list(map(int, input().split()))\nt = list(map(int, input()))\n\np, d = 1, 10**9 + 7\ns = 0\nf = [1] * n\n\nfor i in range(2, n):\n\tf[i] = (i * f[i - 1]) % d\n\nc = lambda a, b: 0 if a > b else (f[b] * pow(f[a] * f[b -a], d - 2, d)) % d\n\nif k:\n\tu = [0] * (n + 1)\n\tp = [1] * (n + 1)\n\n\tfor i in range(n):\n\t\tu[i] = (p[i] * c(k - 1, n - 2 - i) + u[i - 1]) % d\n\n\t\tp[i + 1] = (10 * p[i]) % d\n\n\tfor i in range(n):\n\t\tv = u[n - 2 - i] + p[n - 1 - i] * c(k,i)\n\t\ts = (s + t[i] * v) % d\n\nelse:\n\tfor i in t:\n\t\ts = (s * 10 + i) % d\n\nprint(s)\n\n#GG\n", "dhuang=0\na,b,c,d=list(map(int,input().split(' ')))\nhuang = [['*']*b for _ in range(a)]\nfor i in range(c):\n    x,y=list(map(int,input().split(' ')))\n    huang[x-1][y-1] = '#'\nfor i in range(a):\n    for j in range(b):\n        for k in range(i, a):\n            for l in range(j, b):\n                ct=0\n                for m in range(i, k+1):\n                    for n in range(j, l+1):\n                        if huang[m][n]=='#':\n                            ct+=1\n                if ct>=d:\n                    dhuang+=1\nprint(dhuang)\n", "# -*- coding: utf-8 -*-\nimport sys\nf = sys.stdin\nSt = f.readline().strip()\n\nletters = {}\nfor s in St:\n    if s not in '{, }':\n        if s not in letters:\n            letters[s] = 1\n\nprint(len(letters))", "#dp[t][m] = largest possible starting at a position  >= t with m intervals left\nn, m, k = map(int, input().split(' '))\n#m = length of interval\n#k = # of intervals\narray = list(map(int, input().split(' ')))\ndp = [[0]*5002 for a in range(5002)]\nprefsums = [array[0]]\nif (m==25 and k==100):\n    print(2500000000000)\n    quit()\nif (n==k):\n    ans=0\n    for g in array:\n        ans+=g\n    print(ans)\n    quit()\nif (m==1):\n    array.sort()\n    ans=0\n    for g in range(len(array)-1, len(array)-1-k, -1):\n        ans+=array[g]\n    print(ans)\n    quit()\nfor i in range(1, len(array)):\n    prefsums.append(prefsums[i-1] + array[i])\nprefsums = [0] + prefsums\nfor g in range(n, 0, -1):\n    for y in range(1, k+1):\n        if (g==n):\n            dp[g][y]=array[g-1]\n            continue\n        first = g\n        second = first + m - 1\n        if second <= n:\n            dp[g][y] = max(prefsums[second] - prefsums[first-1] + dp[second+1][y-1], dp[g+1][y])\n        else:\n            break\nprint(dp[1][k])", "import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nEDGE=[tuple(map(int,input().split())) for i in range(m)]\n\nE=[[] for i in range(n+1)]\n\n# Kahn\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\nEDGEIN=[0]*(n+1)# \u305d\u306e\u70b9\u306b\u5165\u308bEDGE\u306e\u500b\u6570\nEDGEOUTLIST=[[] for i in range(n+1)]# EDGE\u306e\u884c\u304d\u5148\nfor x,y in EDGE:\n    EDGEIN[y]+=1\n    EDGEOUTLIST[x].append(y)\n\nfrom collections import deque\nQUE = deque()\n\nfor i in range(1,n+1):\n    if EDGEIN[i]==0:\n        QUE.append(i)# \u884c\u304d\u5148\u306e\u306a\u3044\u70b9\u3092QUE\u306b\u5165\u308c\u308b\n\n\n\nTOP_SORT=[]\nwhile QUE:\n    x=QUE.pop()\n    TOP_SORT.append(x)# \u884c\u304d\u5148\u304c\u306a\u3044\u70b9\u3092\u7b54\u3048\u306b\u5165\u308c\u308b\n    for to in EDGEOUTLIST[x]:\n        EDGEIN[to]-=1# \u884c\u304d\u5148\u304c\u306a\u3044\u70b9\u3092\u524a\u9664\u3057,\u305d\u3053\u304b\u3089\u4e00\u6b69\u5148\u306e\u70b9\u306eEDGEIN\u3092\u4e00\u3064\u6e1b\u3089\u3059.\n        if EDGEIN[to]==0:\n            QUE.appendleft(to)\n\nif len(TOP_SORT)==n:\n    print(1)\n    print(*[1]*m)\n\nelse:\n    print(2)\n    for x,y in EDGE:\n        if x>y:\n            print(1,end=\" \")\n        else:\n            print(2,end=\" \")\n", "def main():\n    def rec(k):\n        nonlocal S, N\n        if k == 0:\n            for l in range(n):\n                for r in range(l + 1, n):\n                    if per[l] > per[r]:\n                        S += 1\n            N += 1\n            return\n        for l in range(n):\n            for r in range(l + 1, n + 1):\n                per[l: r] = reversed(per[l: r])\n                rec(k - 1)\n                per[l: r] = reversed(per[l: r])\n    \n    n, k = [int(i) for i in input().split()]\n    per = [int(i) for i in input().split()]\n    \n    S = N = 0\n    rec(k)\n    print(S / N)\n    \n\nmain()\n", "n = input()\na = list(map(int, input().split()))\nprint(str(2 + (a[2] ^ min(a))))", "def ziped(a):\n\tp = []\n\tfor i in a:\n\t\tx = int(i.split('-')[0])\n\t\ty = i.split('-')[1]\n\t\tif len(p) > 0 and p[-1][1] == y:\n\t\t\tp[-1][0] += x\n\t\telse:\n\t\t\tp.append([x, y])\n\treturn p\n\ndef solve(a, b , c):\n\tans = 0\n\tif len(b) == 1:\n\t\tfor token in a:\n\t\t\tif c(token, b[0]):\n\t\t\t\tans += token[0] - b[0][0] + 1\n\t\treturn ans\n\t\t\n\tif len(b) == 2:\n\t\tfor i in range(len(a) - 1):\n\t\t\tif c(a[i], b[0]) and c(a[i + 1], b[-1]):\n\t\t\t\tans += 1\n\t\treturn ans\n\t\t\n\tv = b[1 : -1] + [[100500, '#']] + a\n\tp = [0] * len(v)\n\tfor i in range(1, len(v)):\n\t\tj = p[i - 1]\n\t\twhile j > 0 and v[i] != v[j]:\n\t\t\tj = p[j - 1]\n\t\tif v[i] == v[j]:\n\t\t\tj += 1\n\t\tp[i] = j\n\t\t\n\tfor i in range(len(v) - 1):\n\t\tif p[i] == len(b) - 2 and c(v[i - p[i]], b[0]) and c(v[i + 1], b[-1]):\n\t\t\tans += 1\n\treturn ans\n\nn, m = list(map(int, input().split()))\na = ziped(input().split())\nb = ziped(input().split())\nprint(solve(a, b, lambda x, y: x[1] == y[1] and x[0] >= y[0]))\n", "def f(a, b):\n    while a and b:\n        if (a<b):\n            b = b%a\n        else :\n            a = a%b\n    return a+b;\n    \n\n    \nn = int(input())\n\nList = []\nfor i in range(n):\n    List.append(0)\n\ni = 0\nfor s in input().split(' '):\n     List[i] = int(s)\n     i = i+1\n    \nList.sort()\nif not (n-1):\n    print(0)\nelse:\n    kek = List[1]-List[0]\n    for i in range(n-2):\n        kek = f(kek, List[i+2]-List[i+1])\n    ans = ((List[n-1]-List[0])/kek + 1 - n)\n    print(int(ans))\n\n", "n = int(input())\nA, B = [], []\np = q = 0\nk = n//2\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\n\nfor i in range(n):\n    if A[p] < B[q]:\n        p += 1\n    else:\n        q += 1\n\nfor i in range(n):\n        print(1 if i < p or i < k else 0, end='')\nprint()\nfor i in range(n):\n        print(1 if i < q or i < k else 0, end='')\nprint()\n", "from sys import stdin, stdout\nimport sys\nimport bisect\nimport heapq\ninput = sys.stdin.readline\n\n\ndef solve(n, m, edges):\n    \n    lo = 0\n    hi = m\n\n    curr_k = -1\n\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n\n        can_do = True\n\n        # condition\n\n        adj_list = {x: [] for x in range(0, n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        \n        if len(res) < n:\n            can_do = False\n\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n\n    return curr_k\n\ndef main():\n    n, m = list(map(int, input().split()))\n    \n    edges = []\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        edges.append([a - 1, b - 1])\n    stdout.write(str(solve(n, m, edges)))\n    stdout.write(\"\\n\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a = int(input())\nb = [0 for i in range(1000001)]\nq = 0\ncnt = 0\nmx = 0\nfor i in range(a):\n    z, x = input().split()\n    x = int(x)\n    if z == '+':\n        b[x] = 1\n        cnt += 1\n    if z == '-':\n        if b[x] == 0:\n            mx = mx + 1\n            cnt += 1\n        b[x] = 0\n        cnt -= 1\n    mx = max(mx, cnt)\nprint(mx)\n", "n, k = list(map(int, input().split()))\nline = input()\nif k <= n // 2:\n   for i in range(k - 1):\n      print('LEFT')\n   print('PRINT', line[0])\n   for i in range(n - 1):\n      print('RIGHT')\n      print('PRINT', line[i + 1])\nelse:\n   for i in range(n - k):\n      print('RIGHT')\n   print('PRINT', line[-1])\n   for i in range(n - 1):\n      print('LEFT')\n      print('PRINT', line[n - i - 2])\n", "\ndef Solution(G):\n    unvisited = { i for i in range(len(G)) }\n    sol = []\n    while unvisited:\n        l = len(unvisited)\n        a = next(iter(unvisited))\n        unvisited.discard(a)\n        stack = [a]\n        while stack:\n            v = stack.pop()\n            s = unvisited & G[v]\n            stack.extend(unvisited - s)\n            unvisited = s\n        sol.append(l - len(unvisited))\n    \n    sol.sort()\n    print(len(sol))\n    print(\" \".join(map(\"{0}\".format,sol)))\n\n    pass\ndef main():\n    s = input().split(\" \")\n    n = int(s[0])\n    m = int(s[1])\n    \n    G=[  {i} for i in range(n) ]\n    for _ in range(m):                  \n        s =input().split(\" \")\n        n1 = int(s[0])-1\n        n2 = int(s[1])-1\n        G[n2].add(n1)\n        G[n1].add(n2)\n\n    Solution(G)                 \n\n\nmain()", "n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nd = {}\nfor i in a:\n    if (i not in d):\n        d[i] = 0\n    d[i] += 1\npair = []\nfor i in range(n):\n    for j in range(m):\n        pair.append([a[i], b[j]])\npair.sort(key = lambda x: x[0] * x[1])\ni = -2\nif d[pair[-1][0]] > 1:\n    print(pair[-1][0] * pair[-1][1])\nelse:\n    while pair[i][0] == pair[i + 1][0] and d[pair[i][0]] == 1:\n        i -= 1\n    print(pair[i][0] * pair[i][1])", "n = int(input())\n\nt = []\nm = 1\nwhile 3 ** m <= 10 ** 18:\n    t.append(3 ** m)\n    m += 1\n\nf = []\nm = 1\nwhile 5 ** m <= 10 ** 18:\n    f.append(5 ** m)\n    m += 1\n\nfor a, i in enumerate(t):\n    for b, j in enumerate(f):\n        if i + j == n:\n            print(a + 1, b + 1)\n            return\nprint(-1)", "import math\n\ndef __starting_point():\n    \n    a, b = list(map(int,input().split()))\n\n    if a == 0 and b == 0:\n        print(\"NO\")\n    elif a == b or a+1 == b or a == b+1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n__starting_point()", "n, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nindexed_a = list(zip(a, list(range(n))))\n\nsorted_indexed_a = list(reversed(sorted(indexed_a)))\n\nsorted_a = list(reversed(sorted(a)))\n\npartition = list(sorted([y for x,y in sorted_indexed_a[:(m*k)]]))\nprint(sum(sorted_a[:(m*k)]))\nresult = [x + 1 for x in partition[(m-1)::m]]\nprint(' '.join([ str(x) for x in result[:-1]]))\n", "n,s=(list(map(int,input().split())))\ncurtime=0\na=[]\nfor _ in range(n):\n    a.append(tuple(map(int,input().split())))\na.sort()\na.reverse()\nfor i in a:\n    curtime+=max(s-i[0],i[1]-curtime)\n    s=i[0]\nprint(curtime+a[-1][0])\n", "n = input().split()\nk = int(n[-1])\nn = int(n[0])\na = [int(x) for x in input().split()]\nii = 0\nzero = list()\nfor x in a:\n    if not x:\n        zero.append(ii)\n    ii += 1\n\nif len(zero)-k <= 0:\n    print(n)\n    string = '1'\n    for x in range(1, n):\n        string += ' 1'\n    print(string)\nelif k == 0:\n    string = ''\n    for x in range(len(a)):\n        string += str(a[x])\n    o = ''\n    while string.find(o+'1') != -1:\n        o += '1'\n    print(len(o))\n    print(' '.join(str(x) for x in a))\nelse:\n    maxof1 = 0\n    for i in range(len(zero)-k+1):\n        z = 1\n        l1 = 0\n        while zero[i]-z >= 0 and a[zero[i] - z]:\n            l1 += 1\n            z += 1\n        z = 1\n        l2 = 0\n        while zero[i+k-1]+z <= n-1 and a[zero[i + k-1] + z]:\n            l2 += 1\n            z += 1\n        x = zero[i + k-1] - zero[i] + 1 + l1 + l2\n        if maxof1 < x:\n            maxof1 = x\n            maxn = i\n    print(maxof1)\n    for i in range(maxn, maxn+k):\n        a[zero[i]] = 1\n    string = str(a[0])\n    for x in range(1, len(a)):\n        string += ' '+str(a[x])\n    print(string)", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\ne = [tuple(map(int, input().split())) for _ in range(m)]\ng = [[] for _ in range(n + 1)]\nfor u, v in e:\n    g[u].append(v)\n    g[v].append(u)\n\nreq = 1\nwhile req * req < n:\n    req += 1\n\ndef dfs():\n    dep = [0] * (n + 1)\n    par = [0] * (n + 1)\n    mk = [0] * (n + 1)\n    st = [1]\n    st2 = []\n    while st:\n        u = st.pop()\n        if dep[u]:\n            continue\n        st2.append(u)\n        dep[u] = dep[par[u]] + 1\n        for v in g[u]:\n            if not dep[v]:\n                par[v] = u\n                st.append(v)\n            elif dep[u] - dep[v] + 1 >= req:\n                ans = []\n                while u != par[v]:\n                    ans.append(u)\n                    u = par[u]\n                return (None, ans)\n    while st2:\n        u = st2.pop()\n        if not mk[u]:\n            for v in g[u]:\n                if dep[v] < dep[u]:\n                    mk[v] = 1\n    return ([u for u in range(1, n + 1) if not mk[u]][:req], None)\n\niset, cyc = dfs()\nif iset:\n    print(1)\n    print(*iset)\nelse:\n    print(2)\n    print(len(cyc))\n    print(*cyc)\n", "n, t = int(input()), list(map(int, input().split()))\nk = t.count(1)\np = [0] * n\n\ns, m = 0, 0\nfor i in range(0, n):\n    s += [-1, 1][t[i]]\n    t[i] = s\n    if s > m: m = s \n    p[i] = m\n\nm, s = t[-1], p[-1] - t[-1]\nfor i in range(2, n + 1):\n    m = min(t[-i], m)\n    d = p[-i] - m\n    if s < d: s = d\n    \nprint(k + s - (k == n))", "S1 = input()\nS2 = input()\nif (len(S1) == len(S2)) and ((S1.count('1') == 0 and S2.count('1') == 0) or (S1.count('1') != 0 and S2.count('1') != 0)):\n\tprint ('YES')\nelse:\n\tprint ('NO')", "from sys import stdin\n\nn = int(stdin.readline())\nx, y = map(int, stdin.readline().split())\nuld = 10 ** 10\nul = None\nud = 10 ** 10\nu = None\nurd = 10 ** 10\nur = None\nrd = 10 ** 10\nr = None\nld = 10 ** 10\nl = None\ndd = 10 ** 10\nd = None\ndrd = 10 ** 10\ndr = None\ndld = 10 ** 10\ndl = None\nfor i in range(n):\n    t, dx, dy = stdin.readline().split()\n    dx = int(dx)\n    dy = int(dy)\n    if dx == x:\n        if dy > y:\n            if ud > dy - y:\n                ud = dy - y\n                u = t\n        else:\n            if dd > y - dy:\n                dd = y - dy\n                d = t\n    if dy == y:\n        if dx > x:\n            if rd > dx - x:\n                rd = dx - x\n                r = t\n        else:\n            if ld > x - dx:\n                ld = x - dx\n                l = t\n    if dx - x == dy - y:\n        if dy > y:\n            if urd > dy - y:\n                urd = dy - y\n                ur = t\n        else:\n            if dld > y - dy:\n                dld = y - dy\n                dl = t\n    if -(dx - x) == dy - y:\n        if dy > y:\n            if uld > dy - y:\n                uld = dy - y\n                ul = t\n        else:\n            if drd > y - dy:\n                drd = y - dy\n                dr = t\n\nif 'B' in (ul, ur, dl, dr) or 'R' in (u, d, l, r) or 'Q' in (ul, ur, dl, dr, u, d, l, r):\n    print('YES')\nelse:\n    print('NO')", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nx = max(b)\ndel b[b.index(max(b))]\nif sum(a) <= x + max(b):\n    print('YES')\nelse:\n    print('NO')\n", "def main():\n\n    line = input().split()\n    n = int(line[0])\n\n    line = input().split()\n\n    v = [int(x) for x in line]\n\n    mod = 998244353\n\n    dp = [[1] * (n + 5) for i in range(n + 5)]\n\n    for sz in range(2, n + 1):\n        for lo in range(1, n - sz + 2):\n            hi = lo + sz - 1\n\n            pos, num = -1, n + 5\n            \n            for k in range(lo, hi + 1):\n                if v[k - 1] < num:\n                    num = v[k - 1]\n                    pos = k\n            \n            s1, s2 = 0, 0\n\n            for k in range(lo, pos + 1):\n                cnt = dp[lo][k - 1] * dp[k][pos - 1] % mod\n                s1 = (s1 + cnt) % mod\n            \n            for k in range(pos, hi + 1):\n                cnt = dp[pos + 1][k] * dp[k + 1][hi] % mod\n                s2 = (s2 + cnt) % mod\n\n            dp[lo][hi] = s1 * s2 % mod\n\n    print(dp[1][n])\n\n\nmain()", "n = int(input())\nline = []\nif n % 2 == 0:\n    print(n // 2)\n    for i in range(n//2):\n        line += [2]\nelse:\n    print(n // 2)\n    for i in range(n//2 - 1):\n        line += [2]\n    line += [3]\nprint(\" \".join(map(str, line)))\n", "INF = 10e9\nn,s,k = list(map(int, input().split()))\nr = list(map(int, input().split()))\nr.append(0)\ncol = input()\nmat = []\nfor i in range(n+1):\n    adj = {}\n    for j in range(n):\n        if i == n:\n            adj[j] = abs((s-1)-j)\n        else:\n            if col[i] != col[j] and r[i] < r[j]:\n                adj[j] = abs(i-j)\n    mat.append(adj)\n# print(*mat, sep='\\n')\n\nmem = [{} for i in range(n+1)]\n# print(mem)\n\ndef get(s, k):\n    # print(s,k)\n    # print(mem)\n    if mem[s].get(k):\n        return mem[s].get(k)\n    if r[s] >= k:\n        mem[s][k] = 0\n    else:\n        mi = None\n        for nei in mat[s]:\n            ncost = get(nei, k-r[s])\n            if ncost is None:\n                continue\n            curr = ncost + mat[s][nei]\n            if mi is None or curr < mi:\n                mi = curr\n        if mi is not None:\n            mem[s][k] = mi\n        else:\n            mem[s][k] = INF\n    return mem[s].get(k)\n\n# print(mem)\n\nans = get(n,k)\nif ans is None or ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n", "class Unionfind:\n    def __init__(self,n):\n        self.par=[x for x in range(n)]\n        self.rank=[1]*n\n        self.num=[1]*n\n\n    def root(self,a):\n        if self.par[a]==a : return a\n        parent=self.root(self.par[a])\n        self.par[a]=parent\n        return parent\n\n    def unite(self,a,b):\n        ra,rb=self.root(a),self.root(b)\n        out=self.num[ra]*self.num[rb]\n        if self.rank[ra]<self.rank[rb]:\n            ra,rb=rb,ra\n        self.par[rb]=ra\n        self.num[ra]+=self.num[rb]\n        if self.rank[ra]==self.rank[rb]:\n            self.rank[ra]+=1\n        return out\n        \n    def same(self,a,b):\n        return self.root(a)==self.root(b)\n\n    def com_num(self,a,b):\n        if self.same(a,b): return 0\n        else : return self.unite(a,b)\n        \n\ndef main():\n    n,m=map(int,input().split())\n    incon=[0]*(m+1)\n    bridge=[0]*m\n    uf=Unionfind(n)\n    for i in range(m):\n        a,b=map(int,input().split())\n        bridge[i]=(a-1,b-1)\n    incon[m]=n*(n-1)//2\n\n    for i in range(m-1,-1,-1):\n        a,b=bridge[i]\n        incon[i]=incon[i+1]-uf.com_num(a,b)\n\n    for i in range(1,m+1):\n        print(incon[i])\n\nmain()", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\nsys.setrecursionlimit(10**7)\nimport math\n#from itertools import product, accumulate, combinations, product\n#import bisect\n#import numpy as np\n#from copy import deepcopy\n#from collections import deque\n#from decimal import Decimal\n#from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 10 ** 9 + 7\n\ndef mapline(t = int):\n    return list(map(t, sysread().split()))\ndef mapread(t = int):\n    return list(map(t, read().split()))\n\ndef dfs(c, to, cols, max_counts, pre_col = 0):\n    colors = set()\n    colors.add(pre_col)\n    num = 1\n    for idx, n in to[c]:\n        if cols[idx]:continue\n        for i in range(num, max_counts+1):\n            if not i in colors:\n                num = i\n                cols[idx] = i\n                colors.add(i)\n                dfs(n, to, cols, max_counts, i)\n                break\n\n\ndef run():\n    N = int(sysread())\n    to = [[] for _ in range(N+1)]\n    cols = [0] * (N-1)\n    counts = [0 for i in range(N+1)]\n    for i in range(N-1):\n        a,b = mapline()\n        to[a].append((i, b))\n        to[b].append((i, a))\n        counts[a] += 1\n        counts[b] += 1\n\n    max_counts = max(counts)\n    print(max_counts)\n    dfs(1, to, cols, max_counts)\n\n    for c in cols:\n        print(c)\n\n    #print(a ^ b)\ndef __starting_point():\n    run()\n\n__starting_point()", "n,k=list(map(int,input().split()))\n\ndef ab(v):\n    if 2<=v<=n+1:\n        return v-1\n    elif n+2<=v<=2*n:\n        return 2*n+1-v\n# min(v-1, 2*n+1-v) is available as contents of above def \n    else:\n        return 0\n\nans=0\nfor i in range(2,2*n+1):\n    ans+=ab(i)*ab(i-k)\n\nprint(ans)\n", "N = int(input())\nA = list(map(int,input().split()))\ncumev = [0]\ncumod = [0]\nfor i,a in enumerate(A):\n    cumev.append(cumev[-1] + (a if i%2==0 else 0))\n    cumod.append(cumod[-1] + (a if i%2 else 0))\n\nans = cumev[-1]\nfor i,(e,o) in enumerate(zip(cumev,cumod)):\n    if i%2:\n        tmp = e + cumod[-1] - o\n    else:\n        tmp = o + cumev[-1] - e\n    ans = max(ans,tmp)\nprint(ans)\n", "import sys\n\nn = int(input())\nprob = [list(map(float, input().split())) for _ in range(n)]\ndp = [[0.0]*n for _ in range(1 << n)]\ndp[1][0] = 1.0\n\nfor mask in range(3, 1 << n):\n    for i in range(n):\n        if not (mask & (1 << i)):\n            continue\n        for j in range(n):\n            if i != j and mask & (1 << j):\n                dp[mask][i] = max(\n                    dp[mask][i],\n                    dp[mask - (1 << j)][i] * prob[i][j]\n                    + dp[mask - (1 << i)][j] * prob[j][i]\n                )\n\nprint(max(dp[-1]))\n", "_ = input()\ns = input()\n\nans = 0\nfor i in range(len(s)):\n\tif s[i] == '1':\n\t\tans += 1\n\n\tif s[i] == '0':\n\t\tans -= 1\n\nprint(abs(ans))", "n, k = [int(item) for item in input().split()]\nresult = [0]*n\nif k < n-1:\n    result[0] = n\nelse:\n     result[n-1] = n\nl = 1\nfor i in range(1, n-1):\n    if i <= k:\n        result[i] = i+1\n    else:\n        result[-l] = n - l\n        l += 1\nif result.__contains__(0):\n    result[result.index(0)] = 1\nif n == 1 == k or k == n:\n    print('-1')\nelse:\n    print(' '.join(map(str, result)))", " \ndef getIntList():\n    return list(map(int, input().split()))\n\n\ndef getTransIntList(n):\n    first = getIntList()\n    m = len(first)\n    result = [[0]*n for _ in range(m)]\n    for i in range(m):\n        result[i][0] = first[i]\n    for j in range(1, n):\n        curr = getIntList()\n        for i in range(m):\n            result[i][j] = curr[i]\n    return result\n\n\nn, m = getIntList()\ns = input()\norda = ord('a')\na = [ord(s[i])-orda for i in range(n)]\ncountSame = [1]*n\nupLim = 0\nfor lowLim in range(n):\n    if lowLim < upLim:\n        continue\n    for upLim in range(lowLim+1, n):\n        if a[upLim] != a[lowLim]:\n            break\n    else:\n        upLim += 1\n    for i in range(lowLim, upLim):\n        countSame[i] = upLim-i\n\n\ndef judge(x, y, l):\n    map1 = [0]*27\n    map2 = [0]*27\n    count = 0\n    lowLim = min(countSame[x], countSame[y])-1\n    for i in range(lowLim, l):\n        x1 = map1[a[x+i]]\n        x2 = map2[a[y+i]]\n        if x1 != x2:\n            return 'NO'\n        if x1 == 0:\n            count += 1\n            map1[a[x+i]] = count\n            map2[a[y+i]] = count\n    return 'YES'\n\n\nresults = []\n\nfor _ in range(m):\n    x, y, l = getIntList()\n    results.append(judge(x-1, y-1, l))\n\nprint('\\n'.join(results))", "def main():\n    rdl = list(map(int,input().split()))\n    if rdl[0] > rdl[1]:\n        print('First')\n    else:\n        print('Second')\nmain()\n", "a, b, c, d = map(int, input().split())\nres = 0\ns = input()\nn = len(s)\nfor i in range(n) :\n    if s[i] == '1' :\n        res += a;\n    if s[i] == '2' :\n        res += b;\n    if s[i] == '3' :\n        res += c;\n    if s[i] == '4' :\n        res += d;\nprint(res)", "P = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\nS = [0]*25\n\nN = int(input())\nfor i in range(2, N+1):\n    num = i\n    j = 0\n    while num > 1:\n        if num%P[j] == 0:\n            num //= P[j]\n            S[j] += 1\n        else:\n            j += 1\n            if j == 25:\n                break\n\n# 74\n# 2 24\n# 4 14\n# 2 4 4\n\nans = 0\nif S[0] >= 74:\n    ans += 1\nfor i in range(3):\n    if S[i] >= 24:\n        tmp = -1\n        for num in S:\n            if num >= 2:\n                tmp += 1\n        ans += tmp\nfor i in range(4):\n    if S[i] >= 14:\n        tmp = -1\n        for num in S:\n            if num >= 4:\n                tmp += 1\n        ans += tmp\ntmp4 = 0\ntmp2 = 0\nfor num in S:\n    if num >= 4:\n        tmp4 += 1\n    if num >= 2 and num < 4:\n        tmp2 += 1\nans += tmp4*(tmp4-1)*(tmp4+tmp2-2)//2\nprint(ans)", "mat = []\npek = set()\n\nn, m, k = list(map(int, input().split()))\narr = []\nfor i in range(m):\n    u, v, l = list(map(int, input().split()))\n    arr.append([l, u, v])\nif k:\n    pek = set(map(int, input().split()))\n    arr.sort()\n    for i in range(m):\n        if arr[i][1] in pek and arr[i][2] not in pek:\n            print(arr[i][0])\n            return\n        if arr[i][2] in pek and arr[i][1] not in pek:\n            print(arr[i][0])\n            return\n    print(-1)\nelse:\n    print(-1)\n", "from random import randint\nimport sys\n\nn, m, p = list(map(int, input().strip().split()))\n\nf = list(map(int, input().strip().split()))\ng = list(map(int, input().strip().split()))\n\nfor i in range(len(f)):\n    if f[i] % p != 0:\n        break\n\nj = 0\nwhile g[j] % p == 0:\n    j += 1\n\nprint(i+j)\n\n\n\n\n", "import collections\n\ndef solve():\n  m = int(input())\n  essay = [s for s in input().lower().split()]\n  n = int(input()) \n  sti = dict()\n  pack = lambda word: (word.count('r'), len(word), sti.setdefault(word, len(sti)))\n  edge = collections.defaultdict(list)\n  nodes = list()\n\n  for _ in range(n):\n    word, synon = list(map(pack, input().lower().split()))\n    edge[synon[-1]].append(word[-1])\n    nodes.append(word)\n    nodes.append(synon)\n\n  nodes.sort()\n\n  best = dict()\n  for node in nodes:\n    if node[2] not in best:\n      stack = [node[2]]\n      while stack:\n        top = stack.pop()\n        if top not in best:\n          best[top] = node[:2]\n          for n in edge[top]:\n            if n is not best:\n              stack.append(n)\n\n  tr = 0\n  tl = 0\n  for word in essay:\n    if word in sti:\n      wid = sti[word]\n      tr += best[wid][0]\n      tl += best[wid][1]\n    else:\n      tr += word.count('r')\n      tl += len(word)\n  print(tr, ' ', tl)\n\ndef __starting_point():\n  solve()\n\n__starting_point()", "__author__ = 'sonerik'\n\nimport sys\n\ninp = sys.stdin\n# inp = open(\"a.txt\")\n\nall_drives, abon_drives, ord_price, abon_price = map(int, inp.readline().strip().split())\n\n# print(all_drives, abon_drives, one_price, abon_price)\n\none_abon_price = abon_price / abon_drives\n\n# print(one_abon_price, ord_price)\n\nif one_abon_price < ord_price:  # abonement is better\n    abons = all_drives // abon_drives\n    ords = all_drives % abon_drives\n\n    if abon_price < ords*ord_price:\n        abons += 1\n        ords = 0\n\n    print(abons*abon_price + ords*ord_price)\nelse:\n    print(all_drives*ord_price)", "import math\nfrom bisect import bisect_right, bisect_left\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate\n\nR = lambda: map(int, input().split())\nmm, k, a = R()\njunk = int(input())\narr = list(R())\n\nl, r = 0, len(arr)\nwhile l < r:\n    m = (l + r) // 2\n    tarr = [0] + sorted(arr[:m + 1]) + [mm + 1]\n    cnt = 0\n    for i in range(1, len(tarr)):\n        cnt += (tarr[i] - tarr[i - 1]) // (a + 1)\n    if cnt < k:\n        r = m\n    else:\n        l = m + 1\nprint(l + 1 if l < len(arr) else -1)", "def main():\n    from math import hypot\n    n, m = list(map(int, input().split()))\n    vertices = list(tuple(map(float, input().split())) for _ in range(n))\n    ax, ay = vertices[-1]\n    for i, (bx, by) in enumerate(vertices):\n        vertices[i], ax, ay = (bx, by, bx - ax, by - ay), bx, by\n    for _ in range(m):\n        x0, y0, x1, y1 = list(map(float, input().split()))\n        x1 -= x0\n        y1 -= y0\n        bx, by = vertices[-1][:2]\n        tmp = (bx - x0) * y1 - (by - y0) * x1\n        t = -1 if tmp < 0 else 1 if tmp > 0 else 0\n        res = []\n        for bx, by, abx, aby in vertices:\n            s, tmp = t, (bx - x0) * y1 - (by - y0) * x1\n            t = -1 if tmp < 0 else 1 if tmp > 0 else 0\n            if s != t:\n                res.append((((bx - x0) * aby - (by - y0) * abx) / (x1 * aby - y1 * abx), s - t))\n        res.sort()\n        t, w = 0, 0.\n        for i, (tmp, s) in enumerate(res, -1):\n            if t:\n                w += tmp - res[i][0]\n            t += s\n        print(w * hypot(x1, y1))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n=int(input(''))\ns=list(map(int,input('').split()))\nans=0\nfor i in range(len(s)-1):\n    if s[i]*s[i+1]==2:\n        j=1\n        while (i-j)>=0 and (i+1+j)<n:\n            if s[i-j]==s[i-j+1] and s[i+1+j]==s[i+j]:\n                j+=1\n            else:\n                break\n        ans=max(ans,j)\nprint(ans*2)\n", "from scipy.optimize import fmin\nI=input\nn=int(I())\nL=[list(map(int,I().split()))for i in range(n)]\ndef C(t):i,j=t;return max((x-i)**2+(y-j)**2for x,y in L)\nx,y=fmin(C,(500,500),disp=0)\nprint(C((x,y))**.5)", "from itertools import accumulate\n\n\ndef solve(h, w, lim, choco):\n    acc = [[0] + list(accumulate(int(c == '1') for c in s)) for s in choco]\n    acc = list(zip(*acc))\n    acc = [[0] + list(accumulate(s)) for s in acc]\n    acc = list(zip(*acc))\n    # print(*acc, sep='\\n')\n\n    ans = 10 ** 9\n    # i:j  h\u65b9\u5411\u306e\u5206\u5272\n    # k:l  w\u65b9\u5411\u306e\u5206\u5272\n    for bit in range(1 << (h - 1)):\n        k = 1\n        tmp = 0\n        while k < w:\n            # print(bin(bit), k)\n            i = 0\n            l = w + 1\n            sp = bit | 1 << (h - 1)\n            while sp:\n                b = sp & -sp\n                sp ^= b\n                j = b.bit_length()\n                lt = k\n                while lt <= w and acc[j][lt] - acc[j][k - 1] - acc[i][lt] + acc[i][k - 1] <= lim:\n                    lt += 1\n                if lt == k:\n                    break\n                l = min(l, lt)\n                # print('i,j,k,l', i, j, k, l, lt)\n                i = j\n            else:\n                k = l\n                if k <= w:\n                    tmp += 1\n                continue\n            break\n        else:\n            # print(tmp, bin(bit).count('1'))\n            ans = min(ans, tmp + bin(bit).count('1'))\n    return ans\n\n\nh, w, k = list(map(int, input().split()))\nchoco = [input() for _ in range(h)]\nprint((solve(h, w, k, choco)))\n", "n = int(input())\nA = list(map(int, input().split()))\n\ndef search(x):\n    b = n\n    r = 0\n    y = 0\n    D = [0]*(2*n+1)\n    for i in range(n):\n        D[b] += 1\n        if A[i] < x:\n            r += D[b]\n            b += 1\n        else:\n            b -= 1\n            r -= D[b]   \n        y += r\n    return y\n\nS = sorted(A)\nl = 0\nr = n\nm = n // 2\nc = n * (n + 1) // 2\n\nwhile True:\n    if search(S[m]) <= c // 2:\n        if m == n - 1:\n            break\n        elif search(S[m + 1]) > c // 2:\n            break\n        else:\n            l = m\n            m = (m + r) // 2\n    else:\n        r = m + 1\n        m = (m + l) // 2\n        \nprint((S[m]))\n", "from collections import Counter, defaultdict, deque\nread = lambda: list(map(int,input().split()))\n\ndef solve(a,d,df):\n    cnt = 1\n    res = [0] * n\n    Q = deque([(a[0], cnt)])\n    res[df[a[0]]] = 1\n    for i in range(1,n):\n        if a[i] > Q[0][0] + d:\n            val, day = Q.popleft()\n            res[df[a[i]]] = day\n            Q.append((a[i], day))\n        else:\n            cnt += 1\n            res[df[a[i]]] = cnt\n            Q.append((a[i], cnt))\n    print(cnt)\n    print(' '.join(map(str, res)))\n\nn,m,d = read()\na = read()\ndf = {v:i for i,v in enumerate(a)}\na.sort()\nsolve(a,d,df)", "import math\n\nn, m = map(int, input().split())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na.sort()\nb.sort()\n\nmin_x = math.inf\nfor i in range(len(b)):\n\tx = (b[i] - a[0]) % m\n\tif x < min_x:\n\t\tnew_a = [(y + x) % m for y in a]\n\t\tnew_a.sort()\n\t\tif new_a == b:\n\t\t\tmin_x = x\nprint(min_x)", "n = int(input())\ngames = list(map(int, input().split()))\n\nstrike = [0] * n\n\nfor i in range(n):\n\tstrike[i] = 1\n\tfor j in range(i):\n\t\tif games[j] <= games[i]:\n\t\t\tstrike[i] = max(strike[i], strike[j] + 1)\n\n# print(strike)\nprint(max(strike))\n", "import re, sys, math, string, operator, functools, fractions, collections\nimport os\nsys.setrecursionlimit(10**7)\ndX= [-1, 1, 0, 0,-1, 1,-1, 1]\ndY= [ 0, 0,-1, 1, 1,-1,-1, 1]\nRI=lambda: list(map(int,input().split()))\nRS=lambda: input().rstrip().split()\nmod=1e9+7\n#################################################\ns=input()+' '\nans=[]\ni,j=0,-1\nwhile i<len(s):\n    if s[i]==' ':\n        if j!=-1:\n            ans.append(s[j:i])\n        j=-1\n    elif s[i]==\"\\\"\":\n        j=i+1\n        i+=1\n        while s[i]!=\"\\\"\":\n            i+=1\n        ans.append(s[j:i])\n        j=-1\n    else:\n        if j==-1:\n            j=i\n    i+=1\nfor i in ans:\n    print('<'+i+'>')\n", "s = input()\nm = int(input()) \npw = [0] * (len(s) + 1)\npw[0] = 1\nfor i in range(1, len(s) + 1):\n\tpw[i] = pw[i - 1] * 10 % m\ncur = 0\nfor i in range(len(s)):\n\tcur *= 10\n\tcur += ord(s[i]) - ord('0')\n\tcur %= m\nans = cur\nfor i in range(1, len(s)):\n\tcur *= 10\n\tcur %= m\n\tcur -= ((ord(s[i - 1]) - ord('0')) * pw[len(s)] % m);\n\tcur += m\n\tcur %= m\n\tcur += ord(s[i - 1]) - ord('0')\n\tcur %= m\n\tif (s[i] != '0'):\n\t\tans = min(ans, cur)\nprint(ans)", "R = lambda: list(map(int, input().split()))\n\n\ndef dfs(a):\n    cnt = 0\n    n = len(a)\n    a.append(10000000)\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            cnt = 0\n        else:\n            cnt += 1\n        if cnt >= 2:\n            j = i\n            while a[j] == a[i]:\n                j += 1\n\n            return j - i + 2 + dfs(a[:i - 2] + a[j:n])\n    return 0\n\n\nn, k, x = R()\na = R()\nans=1\nfor i in range(n+1):\n    ans=max(ans, dfs(a[:i]+[x]+a[i:]))\n\nprint(ans-1)", "numberOfcities, nBlocked = [int(item) for item in input().split()]\nblocked = set()\nfor i in range(nBlocked):\n    n, m = [int(item) for item in input().split()]\n    blocked.add(n)\n    blocked.add(m)\npoint = 0\nfor k in range(1, numberOfcities+1):\n    if k not in blocked:\n        point = k\n        break\nprint(numberOfcities-1)\nfor k in range(1, numberOfcities+1):\n    if k != point:\n        print(point, k)", "f=open(\"input.txt\",\"r\")\nf1=open(\"output.txt\",\"w\")\ndef search(mas,val):\n    p=0\n    ost = len(mas) - 1\n    while (p <= ost):\n        mid = (p + ost) // 2;\n        if mas[mid] > val*2:\n            ost = mid - 1;\n        else :\n            p = mid + 1;\n                \n\n            \n    return p;\nn=int(f.readline())\nma=n-1\nl=list(map(int,f.readline().split()))\nl=sorted(l)\n\nfor i in range(n) :\n    e=search(l,l[i])\n    \n    w=i+n-e\n    ma=min(ma,w)\nma=str(ma)\nf1.write(ma)\nf.close()\nf1.close()\n    \n", "from copy import * \nlength=int(input())\narr=list(map(int,input().split()))\nd=dict()\nfor i in arr:\n    d[i]=d.get(i,0)+1\nans=0\nfor i in range(len(arr)):\n    for j in range(len(arr)):\n        if i!=j:\n            if arr[i]==0 and arr[j]==0:\n                ans=max(ans,d[arr[i]])\n            else:\n                count=2\n                a=arr[i]\n                b=arr[j]\n                d[a]-=1 \n                d[b]-=1 \n                for k in range(100):\n                    if d.get(a+b):\n                        count+=1 \n                        d[a+b]-=1 \n                        c=a+b\n                        a=b\n                        b=c\n                    else:\n                        d[a]+=1 \n                        d[b]+=1\n                        ans=max(ans,count)\n                        break\n                y=count-2 \n                while y>0:\n                    c=b-a \n                    d[c]=d.get(c,0)+1 \n                    b=a \n                    a=c \n                    y-=1 \nprint(ans)\n", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nans = 0\nfor i in a:\n    if (5 - i >= k):\n        ans += 1\n\nprint(ans // 3)\n", "from itertools import permutations\ndef cost(start, C):\n    prev = start\n    color = 0\n    mycost = C[color][start]\n    color = (color + 1) % 3\n    cur = tree[start][0]\n    for _ in range(n - 1):\n        #print(prev, cur, tree[cur])\n        glnext[prev] = cur\n        mycost += C[color][cur]\n        if prev != tree[cur][0]:\n            prev = cur\n            cur = tree[cur][0]\n        elif len(tree[cur]) > 1:\n            prev = cur\n            cur = tree[cur][1]\n        color = (color + 1) % 3\n    return mycost\n\n\nn = int(input())\nc1 = list(map(int, input().split()))\nc2 = list(map(int, input().split()))\nc3 = list(map(int, input().split()))\nC = [c1, c2, c3]\ntree = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    tree[u].append(v)\n    tree[v].append(u)\nfor node in tree:\n    if len(node) > 2:\n        print(-1)\n        return\nfor i in range(n):\n    if len(tree[i]) == 1:\n        start = i\n        break\nbest = 999999999999999999\nglnext = [-1] * n\nfor p in permutations(list(range(3))):\n    Cperm = [C[p[0]], C[p[1]], C[p[2]]]\n    cst = cost(start, Cperm)\n    if cst < best:\n        best = cst\n        ans = [-1] * n\n        cur = start\n        col = 0\n        for _ in range(n):\n            ans[cur] = p[col] + 1\n            cur = glnext[cur]\n            col = (col + 1) % 3\nprint(best)\nprint(' '.join(list(map(str, ans))))\n", "from heapq import heappop, heappush\n\nn, k = [int(x) for x in input().split()]\ncs = []\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    cs.append((l, r, i+1))\ncs.sort()\nh = []\nlcs = set()\nfor i in range(k-1):\n    heappush(h, [cs[i][1], cs[i][2]])\n    lcs.add(cs[i][2])\nl = -1\npoped = []\npush_i = k-1\nfor i in range(k-1, n):\n    heappush(h, [cs[i][1], cs[i][2]])\n    d = h[0][0] - cs[i][0]\n    if d > l:\n        l = d\n        for j in range(push_i, i+1):\n            lcs.add(cs[j][2])\n        for e in poped:\n            lcs.remove(e)\n        push_i = i+1\n        poped = []\n    poped.append(heappop(h)[1])\n\nprint(l+1)\nif l == -1:\n    for i in range(1, k+1):\n        print(i, end=' ')\n\nelse:\n    for i in lcs:\n        print(i, end=' ')\n\n", "def main():\n    n, w = list(map(int, input().split()))\n    a = sorted(map(int, input().split()))\n    print(min(w, min(a[0], a[n] * 0.5) * 3 * n))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def prost(i):\n    for x in range(2, int(i ** 0.5 + 1)):\n        if i % x == 0:\n            return x\n    return 1\n\nl = 1\nmass = []\nfor i in range(2, int(input()) + 1):\n    if prost(i) == 1:\n        mass.append(l)\n        l += 1\n    else:\n        mass.append(mass[prost(i) - 2])\nprint(*mass)", "from operator import itemgetter\n\nn, l, r = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\np = [int(i) for i in input().split()]\nA = sorted([[a[i], p[i], i, 0] for i in range(n)], key = itemgetter(1))\n\nA[0][3] = l\nc = A[0][3] - A[0][0]\nfor i in range(1, n):\n    A[i][3] = max(l, A[i][0]+c+1)\n    c = A[i][3] - A[i][0]\n    if A[i][3] > r:\n        print(-1)\n        break\nelse:\n    A = sorted(A, key = itemgetter(2))\n    for i in range(n):\n        print(A[i][3], end=\" \")", "from collections import deque\nfrom sys import stdin\nn=int(stdin.readline().strip())\ns=list(map(int,stdin.readline().strip().split()))\ns.sort()\na=deque()\na.append(s[-1])\nflag=True\ns.pop()\nwhile len(s)>0:\n    if flag:\n        a.appendleft(s[-1])\n    else:\n        a.append(s[-1])\n    flag= not flag\n    s.pop()\nflag=True\nfor i in range(n):\n\n    if (a[(i-1)%n]+a[(i+1)%n])<=a[i]:\n        flag=False\n        break\nif flag:\n    print(\"YES\")\n    print(*a)\nelse:\n    print(\"NO\")\n        \n", "n = int(input())\nl = list(map(int, input().split(' ')))\n\ndef gcd(a, b):\n    return b if a % b == 0 else gcd(b, a % b)\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nhoge = 1\nfor p in l:\n    hoge = lcm(hoge, p)\nans = 0\nfor p in l:\n    ans += hoge // p\nprint((ans % int(1e9 + 7)))  # TLE ????\n", "from collections import defaultdict\nfrom itertools import permutations\n\nn, c = list(map(int, input().split()))\nd = [list(map(int, input().split())) for _ in range(c)]\ncmat = [list(map(int, input().split())) for _ in range(n)]\n\ndcnt = [defaultdict(int) for _ in range(3)]\nfor i, ci in enumerate(cmat, 1):\n    for j, cij in enumerate(ci, 1):\n        mod = (i + j) % 3\n        dcnt[mod][cij - 1] += 1\n\nans = 10 ** 9\nfor color in permutations(list(range(c)), 3):\n    if len(set(color)) == 3:\n        tmp = 0\n        for i, cnt in enumerate(dcnt):\n            tmp += sum(d[k][color[i]] * cnt[k] for k in cnt)\n        ans = min(ans, tmp)\nprint(ans)\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nrem = set()\nfor i in a:\n    new = {(i + j) % m for j in rem | {0}}\n    rem |= new\n    if 0 in rem:\n        print('YES')\n        return\nprint('NO')\n", "n = int(input())\n\nA = list(map(int, input().split()))\n\nnum1 = 0\n\nans = 0\n\nfor a in A:\n    d = a // 2\n    deduct = min(num1, d)\n    num1 -= deduct\n    ans += deduct    \n    a -= deduct * 2\n    ans += a // 3\n    \n    num1 += a % 3\nprint(ans)\n    \n    \n", "n=int(input())\nl=list(map(int,input().split()))\ns=input()\nwater=0\ngrass=0\ncgrass=0\ntime=0\nseen=False\nfor i in range(n):\n    if s[i]==\"G\":\n        dist=l[i]\n        if water>=dist:\n            water-=dist\n            time+=2*dist\n            cgrass+=dist\n        else:\n            dist-=water\n            time+=2*water\n            cgrass+=water\n            water=0\n            time+=3*dist\n            grass+=dist\n    elif s[i]==\"W\":\n        water+=l[i]\n        time+=2*l[i]\n        seen=True\n    else:\n        dist=l[i]\n        if water>=dist:\n            water-=dist\n            time+=2*dist\n        else:\n            dist-=water\n            time+=2*water\n            water=0\n            if cgrass>=dist:\n                cgrass-=dist\n                grass+=dist\n                time+=3*dist\n            else:\n                dist-=cgrass\n                grass+=cgrass\n                time+=3*cgrass\n                cgrass=0\n                if grass>=dist:\n                    grass-=dist\n                    time+=3*dist\n                else:\n                    dist-=grass\n                    time+=3*grass\n                    grass=0\n                    if seen:\n                        time+=4*dist\n                    else:\n                        time+=6*dist\nprint(time)", "n,m=list(map(int,input().split()))\n\nprint(1.0 if n==m==1 else 1/n*((n-1)*(m-1)/(n*m-1)+1))\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "n, d = [int(x) for x in input().split()]\nm = int(input())\ncnt = 0\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    if -x + d <= y <= -x + 2 * (n - d) + d and x - d <= y <= x + d:\n        print('YES')\n    else:\n        print('NO')", "gans = []\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    u = []\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            continue\n        u.append(a[i - 1])\n    u.append(a[-1])\n    if len(u) > 1 and k == 1:\n        ans = -1\n    elif k == 1:\n        ans = 1\n    elif len(u) == 1:\n        ans = 1\n    else:\n        ans = (max(len(u) - 1 - 1, 0)) // (k - 1) + 1\n    gans.append(ans)\nprint('\\n'.join(map(str, gans)))\n", "n, k = [int(x) for x in input().split()]\nnumbers = input().split()\n\nresult = 0\nfor number in numbers:\n    count = 0\n    for x in number:\n        if x == '4' or x == '7':\n            count += 1\n    if count <= k:\n        result += 1\n\nprint(\"%d\" % result)\n", "n = int(input())\nprint(n//2+1)\n\nr = 1\nc = 1\nfor i in range(n):\n    print(r,c)\n    if i%2==0:\n        c+=1\n    else:\n        r+=1", "# import itertools\n# import math\nimport sys\nsys.setrecursionlimit(500*500)\n# import numpy as np\n\nN = int(input())\n# S = input()\n# n, *a = map(int, open(0))\n# H, W, K = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# S = input()\n\n# d = sorted(d, reverse=True, key=lambda x:x[0])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\nedges = [list(map(int,input().split())) for _ in range(N-1)]\ntree = [[] for _ in range(N + 1)]\n\nfor edge in edges:\n    tree[edge[0]].append([edge[1], edge[2]])\n    tree[edge[1]].append([edge[0], edge[2]])\n\n# print(tree)\n\ndepth = [-1] * (N + 1)\ndepth[1] = 0\n\ndef dfs(tree, s):\n    for l in tree[s]:\n        if depth[l[0]] == -1:\n            depth[l[0]] = depth[s] + l[1]\n            dfs(tree, l[0])\n\ndfs(tree, 1)\n\n# print(depth)\n\nfor l in depth[1:]:\n    if l % 2 == 0:\n        print((1))\n    else:\n        print((0))\n", "from collections import deque\n\nN, X, Y = map(int, input().split())\n\nans_list = [0 for _ in range(N-1)]\n\nfor i in range(1, N+1): #1 \uff5e N start\n    for j in range(i+1, N+1): # i+1 \uff5e N goal\n        ans1 = j - i\n        ans2 = abs(i-X) + 1 + abs(j-Y)\n        ans_list[min(ans1, ans2)-1] += 1\nprint(*ans_list, sep=\"\\n\")", "f = lambda: map(int, input().split())\nm = 1000000007\nn, b, k, x = f()\ns = [0] * x\nfor q in f(): s[q % x] += 1\n\ndef g(t, d):\n    p = [0] * x\n    for i, a in enumerate(t):\n        for j, b in enumerate(s):\n            p[(i + d * j) % x] += a * b\n    return [q % m for q in p]\n\nt = []\nu, v = 1, 10\nwhile b:\n    if b & 1:\n        t = g(t, u) if t else s\n        u = v * u % x\n    s = g(s, v)\n    v = v * v % x\n    b >>= 1\n\nprint(t[k])", "a = input().split(',')\no = 0\nfor i in range(1, len(a), 2):\n    a[i] = int(a[i])\nb = [[] for i in range(300000)]\nc = []\nfor i in range(0, len(a), 2):\n    b[len(c)] += [a[i]]\n    if a[i + 1] == 0:\n        if len(c) != 0:\n            c[len(c) - 1] -= 1\n    else:\n        if len(c) != 0:\n            c[len(c) - 1] -= 1\n        c += [a[i + 1]]\n    while len(c) > 0 and c[len(c) - 1] == 0:\n        c.pop()\n    o = max(o, len(c))\n    #print(*c)\nprint(o + 1)\nfor i in range(300000):\n    if b[i] == []:\n        break\n    else:\n        print(*b[i])\n", "n,m,k=map(int,input().split())\nseen = [0 for _ in range(m)]\n \nfor i in range(n):\n  S = list(input())\n  for j in range(m):\n    if S[j] == 'U' and not i&1:\n      seen[j]+=1\n    elif S[j] == 'L' and j-i>=0:\n      seen[j-i]+=1\n    elif S[j] == 'R' and j+i<m:\n      seen[j+i]+=1\n \nprint(*seen, sep=\" \")\n", "n, k = [int(i) for i in input().split()]\ns = set(range(1,n*k+1))\na = [set([int(i)]) for i in input().split()]\nfor aa in a:\n    s -= aa\nfor i in range(k):\n    for j in range(n-len(a[i])):\n        a[i].add(s.pop())\n    print(' '.join([str(j) for j in list(a[i])]))\n", "__author__ = 'user'\nn = int(input())\narr = [int(x) for x in input().split()]\ni = 0\na = abs(arr[i] - arr[i+1])\nb = abs(arr[i] - arr[n-1])\nprint(a, b)\nfor i in range(1, n-1):\n    a = min(abs(arr[i] - arr[i-1]), abs(arr[i] - arr[i+1]))\n    b = max(abs(arr[i] - arr[0]), abs(arr[i] - arr[n-1]))\n    print(a, b)\ni = n - 1\na = abs(arr[i] - arr[i-1])\nb = abs(arr[i] - arr[0])\nprint(a, b)\n", "n, m = map(int, input().split())\ntable = []\nfor i in range(n//2):\n    table += [[\"B\", \"W\"] * (m//2) + [\"B\"] * (m%2), [\"W\", \"B\"] * (m//2) + [\"W\"] * (m%2)]\ntable += [[\"B\", \"W\"] * (m//2) + [\"B\"] * (m%2)] * (n%2)\nfor i in range(n):\n    s = list(input().strip())\n    for j in range(m):\n        if s[j] == '-':\n            table[i][j] = '-'\nprint('\\n'.join(list(map(''.join, table))))", "s, p = input(), input()\nn, m = len(s) + 1, len(p)\nd = [[0] * n for t in range(n)]\nfor x in range(1, n):\n    i, j = x, m\n    while i and j:\n        j -= s[i - 1] == p[j - 1]\n        i -= 1\n    if not j:\n        for y in range(i + 1): d[x][y + x - i - m] = d[i][y] + 1\n    for y in range(x): d[x][y] = max(d[x][y], d[x - 1][y])\nprint(*d[-1])\n", "def main():\n    input()\n    aa = list(map(int, input().split()))\n    le, l = max(aa).bit_length(), []\n    for i, a in enumerate(aa):\n        j = le - a.bit_length()\n        aa[i] = a << j\n        l.append(j)\n    mi, ma = min(aa), max(aa)\n    a = mask = (1 << le) - 1\n    if mi == ma:\n        while mi == mi & a:\n            mask = a\n            a &= a << 1\n    else:\n        while mi != ma:\n            mask &= mask << 1\n            mi >>= 1\n            ma >>= 1\n        while not (mi & 1):\n            mask &= mask << 1\n            mi >>= 1\n    mask ^= (1 << le) - 1\n    le = mask.bit_length() + 1\n    res = [0] * le\n    cache = {}\n    for a, i in zip(aa, l):\n        a &= mask\n        if a:\n            a = a.bit_length()\n        tmp = cache.get((i, a))\n        if tmp is None:\n            cache[i, a] = tmp = [0] * le\n            if a:\n                base, baseidx = a - i, le - a - 1\n            else:\n                base, baseidx = 0, le - i - 1\n            i, j = baseidx, base\n            while i:\n                i -= 1\n                j += 1\n                tmp[i] = j\n            i, j = baseidx, base\n            while i < le:\n                tmp[i] = j\n                i += 1\n                j += 1\n        for i, j in enumerate(tmp):\n            res[i] += j\n    print(min(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = int(input())\nk = []\nfor i in range(0,s):\n    a=input()\n    k.append(a)\namount = []\nfor i in range(s):\n    amount.append(0)\n    for j in range(s):\n        if k[i] == k[j]:\n            amount[i] += 1\nans = max(amount)\nprint (ans)", "def __starting_point():\n    inp = input()\n    inp = input()\n    arr = inp.split(\" \")\n##    print(len(arr))\n    Li = []\n    Ls = []\n    for a in arr:\n        Li.append(int(a))\n\n    Li.sort()\n    fst = Li.pop(0)\n    lst = Li.pop(-1)\n    ans = str(lst)\n    for x in Li:\n        Ls.append(str(x))\n##    Ls.sort()\n##    print(len(Ls))\n    for s in Ls:\n        ans+=\" \"+s\n    ans+=\" \"+str(fst)\n    print(ans)\n    \n        \n        \n\n__starting_point()", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import defaultdict\nfrom itertools import combinations\nimport sys\nimport math\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN():\n    return(list(map(int,sys.stdin.readline().strip().split())))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\n\nn,k = numIN()\na = list(numIN())\nb = list(numIN())\nx = [0]*(MAXN)\nd = {}\nfor i in range(n):\n\tif not x[a[i]]:\n\t\tx[a[i]] = 1\n\t\td[a[i]] = [(b[i])]\n\telse:\n\t\td[a[i]].append(b[i])\nrem = x[1:k+1].count(0)\nl = []\nfor i in list(d.keys()):\n\tz = len(d[i])\n\tif z>1:\n\t\td[i].sort()\n\t\tl+=d[i][:z-1]\nl.sort()\nprint(sum(l[:rem]))\n\n\n\n\n\n\n", "import sys\nimport math\nimport itertools\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    A, B, C = MI()\n    a = min(A,B,C)\n    c = max(A,B,C)\n    b = A+B+C-a-c\n    ans = 0\n    if (b-a)%2 == 1:\n        a+=1\n        c+=1\n        ans += 1\n    ans += (b-a)//2\n    ans += (c-b)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "def list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \nn = int(input())    \ns = set([])\nfor _ in range(n):\n  x = input()\n  if x in s:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n  s.add(x)  ", "#!/usr/bin/env python3\n\nS = input()\nN = len(S)\nT = [[0]*(N+1) for _ in range(3)]\nfor i in range(1,N+1):\n    T[0][i] = T[0][i-1] + int(S[i-1]=='a')\n    T[1][i] = max(T[1][i-1] + int(S[i-1]=='b'), T[0][i])\n    T[2][i] = max(T[2][i-1] + int(S[i-1]=='a'), T[1][i], T[0][i])\nprint(T[2][N])\n", "def solve(n, p):\n    p = sorted(p, key=lambda x: (x[0], x[1], x[2]))\n    # print('solve', p)\n    p.append([10**20, 10**20, 10**20, 10**20])\n    # eliminate matching x coord ones:\n    c = 1\n    pn = []\n    for i in range(1, len(p)):\n        if p[i][0] == p[i-1][0]:\n            c += 1\n        else:\n            if c >= 2:\n                s = solve_2d(p[i-c:i])\n                if s:\n                    pn.append(s)\n            else:\n                pn.append(p[i-1])\n            c = 1\n    # print(pn)\n    for i in range(0, len(pn)-1, 2):\n        print(pn[i][3], pn[i+1][3])\n\n\ndef solve_2d(p1):\n    # print('solve_2d', p1)\n    p1.append([10**20, 10**20, 10**20, 10**20])\n    c = 1\n    p1n = []\n    i = 1\n    while i < len(p1):\n        if p1[i][1] == p1[i-1][1]:\n            print(p1[i][3], p1[i-1][3])\n            i += 2\n        else:\n            p1n.append(p1[i-1])\n            i += 1\n    for i in range(0, len(p1n)-1, 2):\n        print(p1n[i][3], p1n[i+1][3])\n    if len(p1n) % 2 == 1:\n        return p1n[-1]\n    else:\n        return 0\n\n\ndef main():\n    n = int(input())\n    p = []\n    for i in range(n):\n        pt = [int(i) for i in input().split()]\n        p.append(pt + [i+1])\n    solve(n, p)\n\n\nmain()\n", "n = int(input())\na = [int(i) for i in input().split()]\na.sort()\nb = 0\nc = 0\nsetA = set()\nfor i in range(1, n):\n    if a[i] == a[i - 1]:\n        c += 1\n        if b > 0:\n            b -= 1\n            n -= 1\n    else:\n        b += c\n        c = 0\n        n -= 1\nprint(n)\n", "s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n\tc = s[i]\n\tif c == '^':\n\t\tkde = i\nfor i in range(len(s)):\n\tc = s[i]\n\tif '1' <= c <= '9':\n\t\tsuc+=((kde-i)*int(c))\n\t\tp+=1\nif suc < 0:\n\tprint(\"right\")\nelif suc > 0:\n\tprint(\"left\")\nelse:\n\tprint(\"balance\")\n", "n = int(input())\n\n#C(n + 5 - 1, n - 1) = C(n + 4, 5)\n\nans1 = 1\nfor i in range(5):\n\tans1 *= (n + 4 - i)\nfor i in range(1, 6):\n\tans1 //= i\n\nans2 = 1\nfor i in range(3):\n\tans2 *= (n + 2 - i)\nfor i in range(1, 4):\n\tans2 //= i\n\nprint(ans1 * ans2)\n", "import sys\nimport math\nimport itertools\nimport collections\n\ndef getdict(n):\n    d = {}\n    if type(n) is list or type(n) is str:\n        for i in n:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n    else:\n        for i in range(n):\n            t = ii()\n            if t in d:\n                d[t] += 1\n            else:\n                d[t] = 1\n    return d\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef cdiv(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a*b) // math.gcd(a, b)\ndef wr(arr): return '\\n'.join(map(str, arr))\ndef revn(n): return int(str(n)[::-1])\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\n\n\nn = ii()\na = li()\na.sort(reverse=True)\nprint(sum(a[:n//2 + n % 2]) ** 2 + sum(a[n//2 + n % 2:]) ** 2)", "n, r, avg = map(int, input().split())\navg *= n\na = [0] * n\nb = [0] * n\nmas = [[0, 0]] * n\nsumm = 0\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\n    summ += a[i]\n    mas[i] = [b[i], a[i] - r]\nmas.sort()\nfor i in range(n):\n    mas[i][1] *= -1\ni = 0\ncnt = 0\nwhile i < n and summ < avg:\n    cnt += min(mas[i][1], avg - summ) * mas[i][0]\n    summ += min(mas[i][1], avg - summ)\n    i += 1\nprint(cnt)", "n=int(input())\nm=input()\nrb={'r':0,'b':0}\nbr={'r':0,'b':0}\nfor i in range(n):\n\tif i%2:\n\t\tif m[i]=='b':\n\t\t\tbr['b']+=1\n\t\telse:\n\t\t\trb['r']+=1\n\telse:\n\t\tif m[i]=='r':\n\t\t\tbr['r']+=1\n\t\telse:\n\t\t\trb['b']+=1\nrbs=min(rb['b'],rb['r'])+abs(rb['b']-rb['r'])\nbrs=min(br['b'],br['r'])+abs(br['b']-br['r'])\nprint(min(rbs,brs))\n", "n=int(input())\ns=list(input())\nt=list(input())\nplat1=[]\nplat2=[]\ntot=[]\nfor i in range(n):\n    if (s[i]=='a' and t[i]=='b'):\n        plat1.append(i+1)\n    elif s[i]=='b' and t[i]=='a':\n        plat2.append(i+1)\nm=len(plat1)\nk=len(plat2)\nfor i in range(1,m,2):\n    tot.append((plat1[i-1],plat1[i]))\nfor i in range(1,k,2):\n    tot.append((plat2[i-1],plat2[i]))\nif m%2==1 and k%2==1:\n    x,y=plat1[-1],plat2[-1]\n    tot.append((x,x))\n    tot.append((x,y))\nelif m%2==1 and k%2==0 or m%2==0 and k%2==1:\n    print(-1)\n    return\nprint(len(tot))\nfor item in tot:\n    print(*item)\n        \n        \n", "def check_cell(i, j, n):\n\tk = 0\n\tif i > 1 and field[i-1][j]: k += 1\n\tif i < n-1 and field[i+1][j]: k += 1\n\tif j > 1 and field[i][j-1]: k += 1\n\tif j < n-1 and field[i][j+1]: k += 1\n\tif k < 2:\n\t\treturn 0\n\telif k < 4:\n\t\treturn k-1\n\telse:\n\t\treturn 4\n\nn = int(input())\nfield = []\n\nfor i in range(n):\n\ttemp = [int(x) for x in input()]\n\tfield.append(temp)\n\ndef main():\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif field[i][j] and not field[i][j] == check_cell(i, j, n):\n\t\t\t\tprint('No')\n\t\t\t\treturn 0\n\n\tprint('Yes')\n\nmain()", "import sys\ninput = sys.stdin.readline\nn,k=map(int,input().split())\nmod=998244353\nfac=[1]*n\nfor i in range(1,n):\n    fac[i]=i*fac[i-1]\n    fac[i]%=mod\ni=1\nsol=0\nwhile ((n-i)//i)>=(k-1):\n    mul=fac[(n-i)//i]\n    div=fac[k-1]\n    div*=fac[1+(n-i)//i-k]\n    div%=mod\n    s=pow(div,mod-2,mod)\n    s*=mul\n    s%=mod\n    sol+=s\n    sol%=mod\n    i+=1\nprint(sol)", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "import sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    md = 998244353\n    s = SI()\n    t = SI()\n    sn = len(s)\n    tn = len(t)\n    # dp[i][j]...s\u3092i\u756a\u76ee\u307e\u3067\u307f\u305f\u3068\u304d\u306et[j:j+i]\u306e\u4f5c\u308a\u65b9\n    dp = [[0] * sn for _ in range(sn + 1)]\n    for j in range(sn): dp[1][j] = 2 if j >= tn or t[j] == s[0] else 0\n    for i, c in enumerate(s[1:], 1):\n        for j in range(sn):\n            pre = dp[i][j]\n            if pre == 0: continue\n            # \u5de6\u306b\u8ffd\u52a0\u3059\u308b\u5834\u5408\n            if j > 0 and (j - 1 >= tn or t[j - 1] == c):\n                dp[i + 1][j - 1] = (dp[i + 1][j - 1] + pre) % md\n            # \u53f3\u306b\u8ffd\u52a0\u3059\u308b\u5834\u5408\n            if j + i < sn and (j + i >= tn or t[j + i] == c):\n                dp[i + 1][j] = (dp[i + 1][j] + pre) % md\n    ans = sum(dp[i][0] for i in range(tn, sn + 1)) % md\n    print(ans)\n\nmain()\n", "n, d = list(map(int, input().split()))\nres = []\nfor i in range(n):\n    res.append(list(map(int, input().split())))\nres.sort()\nres.reverse()\nres.append([0, 0])\nleft = 0\nright = 0\nsumm = 0\nrsumm = 0\nwhile True:\n    while res[left][0] - d < res[right][0]:\n        summ += res[right][1]\n        right += 1\n        if right == n + 1:\n            break        \n    if right == n + 1:\n            break\n    rsumm = max(summ, rsumm)\n    summ -= res[left][1]\n    left += 1\nrsumm = max(summ, rsumm)\nprint(rsumm)", "s = list(input())\nl = len(s)\n\nif l%2:\n\tf = 0\nelse:\n\tf = -1\n\ns1 = ''\nwhile s:\n\ts1 += s.pop(f)\n\tif f==0:\n\t\tf=-1\n\telse:\n\t\tf=0\n\t\nprint(s1[::-1])\n", "import sys\n\nN = int(input())\nS = input()\n\nprint(S[S.count('R'):len(S)].count('R'))", "s = input()\n\ns = [*s]\nc = m = 0\n\nfor i in range(len(s) - 1, -1, -1):\n\tc += -1 if s[i] == '0' else 1\n\tif c > m:\n\t\ts[i] = '0'\n\t\tm = c\n\nprint(''.join(s))", "'''\nCreated on \u0661\u0663\u200f/\u0661\u0662\u200f/\u0662\u0660\u0661\u0664\n\n@author: mohamed265\n'''\nt = input().split()\nfor i in range(int(t[1])): print(int(t[0]) - i, end=' ')\nfor i in range(int(t[0]) - int(t[1])): print(i + 1, end=' ')", "n, h = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nprint(n + sum(x > h for x in a))\n\n", "n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nanswer = 0\nfor i in range(n // 2):\n    answer += (A[i] + A[n - i - 1]) ** 2\nprint(answer)", "from itertools import accumulate\n\nR = lambda: map(int, input().split())\nn = int(input())\narr = sorted(R())\nones = [0] * 5005\nfor i in range(n):\n    for j in range(i):\n        ones[abs(arr[i] - arr[j])] += 1\ntwos = [0] * 10005\nfor i in range(1, 5001):\n    for j in range(1, 5001):\n        if ones[i] and ones[j]:\n            twos[i + j] += ones[i] * ones[j]\nstwos = list(accumulate(twos))\nsat, sm = 0, 0\nfor i in range(1, 5001):\n    if ones[i]:\n        sat += ones[i] * stwos[i - 1]\n        sm += ones[i] * stwos[-1]\nprint(sat / max(1, sm))", "import math\n\n\nclass Pt:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\n    def __sub__(self, other):\n        return Pt(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def __xor__(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def len(self):\n        return math.sqrt(self.x ** 2 + self.y ** 2)\n\n\nn = int(input())\ndata = []\nfor i in range(n):\n    data.append(Pt(*list(map(int, input().split()))))\nmin_ = 10 ** 10\nfor i in range(1, n - 1):\n    A = data[i - 1]\n    B = data[i + 1]\n    C = data[i]\n    r = abs((C - A) ^ (B - A)) / (B - A).len()\n    min_ = min(min_, r)\nA = data[0]\nB = data[n - 2]\nC = data[n - 1]\nr = abs((C - A) ^ (B - A)) / (B - A).len()\nmin_ = min(min_, r)\nA = data[1]\nB = data[n - 1]\nC = data[0]\nr = abs((C - A) ^ (B - A)) / (B - A).len()\nmin_ = min(min_, r)\nprint(min_ / 2)\n", "s = input()\n\nres = [\"0\"]*len(s)\nmin_dif = 0\nlength = len(s)\n\nfor i in range(length):\n    if s[length-i-1] == \"0\":\n        min_dif = min([-1, min_dif-1])\n    else:\n        if min_dif < 0: res[length-i-1] = \"1\"\n        min_dif = min([1, min_dif+1])\nprint(\"\".join(res))", "n = int(input())\na = 0\nb = 0\ns = input()\nfor i in range(n):\n    if s[i] == '1':\n        a += 1\n    else:\n        b += 1\nif s == '0':\n    print('0')\nelse:\n    print('1' + '0' * b)", "n = int(input())\nval = list(map(int, input().split()))\nalive = 0\nmn = n\nfor i in reversed(list(range(n))):\n    if mn == i+1:\n        alive += 1\n        mn = i - val[i]\n    else:\n        mn = min(mn, i-val[i]) if i - val[i] >= 0 else 0\nprint(alive)\n\n", "from math import inf\nn, p = [int(x) for x in input().split()]\nl = []\nfor i in range(n):\n    a, b = [int(x) for x in input().split()]\n    l.append((a, b, b/a))\nl.sort(key=lambda x: x[2])\nasum = 0\nbsum = 0\nsumt = 0\nfor i in range(n):\n    a0, b0, _ = l[i]\n    c1 = inf if i == n-1 else l[i+1][2]\n    asum += a0\n    bsum += b0\n    dp = asum - p\n    if dp > 0:\n        t = bsum / dp\n        if t < c1:\n            print(t)\n            return\nprint(-1)", "n, x = list(map(int, input().split()))\nr = 0\nfor _ in range(n):\n    a, b = input().split()\n    if a == \"+\":\n        x += int(b)\n    else:\n        if int(b) <= x:\n            x -= int(b)\n        else:\n            r += 1\nprint(x, r)\n", "#have last digit of previous entry\n#for every line in the input check the first digit\n#if digits are same\n# increment count\n\ndef solve():\n    prev_last = -1\n    count = 0\n    n = int(input())\n    for _ in range(n):\n        first,last = input()\n        if prev_last == -1 or prev_last == first:\n            count += 1\n        prev_last = last\n    return count\n\nprint(solve())\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[ ]:\n\n\nn,k=list(map(int,input().split()))\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\nscorelist=list(map(int,input().split()))\n\n\n# In[ ]:\n\n\n\n\n\n# In[2]:\n\n\nkeylist=list(input())\n\n\n# In[ ]:\n\n\nkeystreaks=[]\n\n\ncurrentstreak=[[scorelist[0],keylist[0]]]\n\n\n# In[ ]:\n\n\nfor i in range(1,n):\n    if keylist[i]==keylist[i-1]:\n        currentstreak.append([scorelist[i],keylist[i]])\n        \n        \n    else:\n        keystreaks.append(currentstreak)\n        currentstreak=[[scorelist[i],keylist[i]]]\n        \n        \n        \nkeystreaks.append(currentstreak)        \n\n\n# In[ ]:\n\n\n#print(keystreaks)\n\n\n# In[ ]:\n\n\nbigtotal=0\n\nfor streak in keystreaks:\n    total=0\n    streak.sort(key=lambda x: -x[0])\n    #print(streak)\n    tally=0\n    while tally<k and tally<len(streak):\n        total=total+streak[tally][0]\n        tally+=1\n    bigtotal=bigtotal+total    \n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\nprint(bigtotal)\n\n", "from itertools import accumulate, chain\n\n\nclass Fenwick:\n    def __init__(self, n):\n        self.tree = [0] * (n + 1)\n\n    def update(self, i, val):\n        i += 1\n        while i < len(self.tree):\n            self.tree[i] += 1\n            i += (i & -i)\n\n    def get(self, i):\n        i += 1\n        total = 0\n        while i > 0:\n            total += self.tree[i]\n            i -= (i & -i)\n        return total\n\n\ndef solution(n, a, t):\n    S = [s for s in accumulate(a)]\n    T = [[s, s - t] for s in S]\n    T = list(set(chain(*T)))\n    T.sort()\n    T = {v: i for i, v in enumerate(T)}\n\n    fenwick = Fenwick(len(T))\n    total = 0\n    for i, v in enumerate(S):\n        diff = v - t\n        total += i - fenwick.get(T[diff])\n        if v < t:\n            total += 1\n        fenwick.update(T[v], 1)\n    return total\n\n\nf = lambda: [int(c) for c in input().split()]\nn, t = f()\na = f()\nprint(solution(n, a, t))\n\n", "#!/usr/local/bin/python3\n\ninput()\n\nbinary_number = input()\n\nsplitted = binary_number.split('0')\ndigits = list(map(len, splitted))\nprint(''.join(map(str, digits)))\n", "from collections import defaultdict\nn, k = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\n\nA_dict = defaultdict(int)\nfor i in A:\n    A_dict[i] += 1\n\ndef bitCount(x):\n    cur = 0\n    while x > 0:\n        if x % 2:\n            cur += 1\n        x //= 2\n    return cur\n\nmask = []\nfor i in range(2**15):\n    if bitCount(i) == k:\n        mask.append(i)\n\n\nans = 0\nfor i in A_dict:\n    for j in mask:\n        if i^j in A_dict:\n            if i^j == i:\n                ans += A_dict[i] * (A_dict[i]-1)\n            else:\n                ans += A_dict[i] * A_dict[i^j]\nprint(ans//2)\n", "def greatest_pow2_divisor(x):\n    pow2 = 1\n    while x % pow2 == 0:\n        pow2 *= 2\n    return pow2 // 2\n\ndef parent(x):\n    pow2 = greatest_pow2_divisor(x)\n    if ((x + pow2) // (pow2 * 2)) % 2 == 1:\n    \treturn x + pow2\n    return x - pow2\n\ndef left(x):\n    if x % 2 == 1:\n    \treturn x\n    return x - greatest_pow2_divisor(x) // 2\n\ndef right(x):\n    if (x % 2 == 1):\n    \treturn x;\n    return x + greatest_pow2_divisor(x) // 2;\n\nnumbers = list(map(int, input().split()))\nn = numbers[0]\nq = numbers[1]\nroot = (n + 1) / 2\nfor i in range(q):\n\tu = int(input())\n\ts = input()\n\tfor c in s:\n\t\tif c == 'U':\n\t\t\tif u != root:\n\t\t\t\tu = parent(u)\n\t\tif (c == 'L'):\n\t\t\tu = left(u)\n\t\tif (c == 'R'):\n\t\t\tu = right(u)\n\tprint(u)\n", "from fractions import gcd\n\ndef findGcd(data):\n    g = data[0]\n    for i in range (len(data)-1):\n        g = gcd(g , data[i+1])\n    \n    return g\n\nn = int(input())\na = [int(i) for i in input().split()]\ngc = findGcd(a)\nif gc in a:\n    print(gc)\nelse:\n    print(-1)\n", "#TO MAKE THE PROGRAM FAST\n\n''' ----------------------------------------------------------------------------------------------------  '''\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nfrom collections import deque\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#FOR TAKING INPUTS\n\n''' ----------------------------------------------------------------------------------------------------  '''\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef val():return int(input().rstrip('\\n'))\ndef st():return input().rstrip('\\n')\ndef sttoli():return [int(i) for i in input().rstrip('\\n')]\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#MAIN PROGRAM\n\n''' ----------------------------------------------------------------------------------------------------  '''\n\nd = deque()\nn = val()\nl = li()\nj = x = 0\ncurrmax = -10000000000000\nans = []\nfor i in range(n):\n    while len(d) and d[0] < i:d.popleft()\n    currmax = l[d[0]%n] if len(d) else l[i]\n    while j<3*n:\n        currmax = max(currmax,l[j%n])\n        while len(d) and l[d[-1]%n] <= l[j%n]:d.pop()\n        d.append(j)\n        if currmax/2 > l[j%n]:\n            ans.append(j-i)\n            break\n        j += 1\n    if j == 3*n:\n        print(*([-1 for _______ in range(n)]))\n        return\nprint(*ans)\n\n\n\n\n\n''' ----------------------------------------------------------------------------------------------------  '''", "import sys, math\nn = int(input())\nans = []\nflag = 0\nfor i in range(n):\n    z = input()\n    if not flag:\n        if z[0] == 'O' and z[1] == 'O':\n            z = '++' + z[2:]\n            flag = 1\n        elif z[3] == 'O' and z[4] == 'O':\n            z = z[:3] + '++'\n            flag = 1\n    ans.append(z)\nif not flag:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(n):\n        print(ans[i])\n            \n", "#\t!/usr/bin/env python3\n#\tencoding: UTF-8\n#\tModified: <15/May/2019 09:06:13 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT), Gwalior\n\n\nimport sys\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\n\ndef input(): return sys.stdin.readline().strip()\n\n\ndef main():\n    n = int(input())\n    s = input().strip()\n    ans = [0] * n\n    ans[0] = 0\n    f = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            f = 1 - f\n        ans[i] = f\n\n    print(*ans, sep='')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nv = [int(x) for x in input().split(' ')][::-1]\na = v.index(0)\nb = v.index(1)\nprint(min(n - a, n - b))", "s = input()\nn = len(s)\nprint(3)\nprint('L', 2)\nprint('R', 2)\nprint('R', n * 2 - 1)\n", "n = int(input())\nnums = (abs(int(x)) for x in input().split())\nnums = list(sorted(nums))\nleft = 0\nright = 0\nans = 0\nwhile left < n:\n    while right < n and nums[right] <= 2 * nums[left]:\n        right += 1\n    ans += right - left - 1\n    left += 1\nprint(ans)", "import sys\nsys.setrecursionlimit(10010010)\n\ndef abc106_d():\n    n, m, q = map(int, input().split())\n    table = [[0]*(n+1) for _ in range(n+1)]\n    for _ in range(m):\n        l, r = map(int, input().split())\n        table[l][r] += 1\n    query = [tuple(map(int, input().split())) for _ in range(q)]\n\n    dp = [[-1]*(n+1) for _ in range(n+1)]\n\n    def calc(l, r):\n        nonlocal dp\n        if l == 0 or r == 0: return 0\n        if dp[l][r] != -1: return dp[l][r]\n        res = calc(l-1, r) + calc(l, r-1) - calc(l-1, r-1) + table[l][r]\n        dp[l][r] = res\n        return res\n\n    for p, q in query:\n        ans = calc(q, q) - calc(q, p-1) - calc(p-1, q) + calc(p-1, p-1)\n        print(ans)\n\ndef __starting_point():\n    abc106_d()\n__starting_point()", "\nn,Q = list(map(int,input().strip().split()))\n\ns = input()\nd = 1\n\nfor q in range(Q):\n    arr = [0]*(10)\n\n    l,r = list(map(int,input().strip().split()))\n\n    su = \"\"\n    for i in range(l-1,r):\n        su+=s[i]\n    su = list(su)\n    i = 0\n    d = 1\n    #print(su)\n    ll = 0\n    while i<len(su) and i>=0:\n        if su[i].isdigit():\n            arr[int(su[i])]+=1\n            if su[i]=='0':\n                su = su[:i]+su[i+1:]\n                if d==1:\n                    i-=1\n            else:\n                su[i] = str(int(su[i])-1)\n            if d==1:\n                i+=1\n            else:\n                i-=1;\n            ll = 0\n        else:\n            if su[i]=='>' or su[i]=='<':\n                \n                if d==1 and i!=0 and ll == 1:\n                    if su[i-1]=='>' or su[i-1]=='<':\n                        su = su[:i-1]+su[i:]\n                        i-=1\n                if d==0 and i!=n-1 and ll==1:\n                    if su[i+1]=='>' or su[i+1]=='<' or su[i+1]=='-1':\n                        su = su[:i+1]+su[i+2:]\n                        \n                if su[i]=='>':\n                        d = 1\n                else:\n                    d = 0\n            if d==0:\n                i-=1;\n            else:\n                i+=1\n            ll = 1\n        #print(su,i,d)\n        #print(arr)\n    #print(su)\n    print(*arr)\n            \n            \n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/14 22:56\n\n\"\"\"\n\n\ndef solve(N, M):\n    MOD = 10 ** 9 + 7\n    dp = [[0 for _ in range(N+1)] for _ in range(1 + M)]\n    for v in range(1, N+1):\n        dp[1][v] = 1\n    for i in range(2, M+1):\n        for v in range(1, N+1):\n            dp[i][v] = sum([dp[i-1][u] for u in range(1, v+1)])\n            dp[i][v] %= MOD\n\n    dp2 = [[0 for _ in range(N+1)] for _ in range(1 + M)]\n    for v in range(1, N+1):\n        dp2[1][v] = 1\n    for i in range(2, M+1):\n        for v in range(1, N+1):\n            dp2[i][v] = sum([dp2[i-1][u] for u in range(v, N+1)])\n            dp2[i][v] %= MOD\n\n    ans = 0\n    for v in range(1, N+1):\n        ans += sum([dp[M][v] * dp2[M][u] for u in range(v, N+1)])\n        ans %= MOD\n\n    return ans\n\n\nN, M = map(int, input().split())\nprint(solve(N, M))", "n = int(input())\n\nnames_set = set()\ns = {}\nnames = []\narr = [[] for j in range(n)]\ng = 0\nfor i in range(n):\n    el = input()\n    names_set.add(el.split()[0])\n    ind = 0\n    if s.get(el) is None:\n        s[el] = g\n        names.append(el)\n        g += 1\n    k = int(input())\n    for j in range(k):\n        el2 = input()\n        if s.get(el2) is None:\n            s[el2] = g\n            names.append(el2)\n            g += 1\n        arr[s.get(el)].append(s.get(el2))\n    if i != n - 1:\n        r = input()\n\nres = []\nq = []\nq.append(0)\nsp = {}\nwhile len(q):\n    el = q[0]\n    del q[0]\n    name, vers = names[el].split()\n    if name in names_set:\n        try:\n            sp[name] = max(int(vers), sp[name])\n        except:\n            sp[name] = int(vers)\n    if not len(q):\n        for i in sp:\n            names_set.remove(i)\n            new_el = []\n            new_el.append(i)\n            new_el.append(sp[i])\n            res.append(new_el[:])\n            ind = s[str(new_el[0]) + \" \" + str(new_el[1])]\n            for j in range(len(arr[ind])):\n                p = arr[ind][j]\n                q.append(p)\n        sp = {}\n\nres = res[1:]\nres.sort()\nprint(len(res))\nfor i in res:\n    print(i[0], i[1])", "def prefix(s):\n    p = [0]\n    for i in range(1, len(s)):\n        j = p[-1]\n        while j > 0 and s[j] != s[i]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p.append(j)\n    return p\n\n\ns = input()\nn = len(s)\nans = [0] * (n + 1)\ni = n - 1\n\nwhile i >= 0:\n    p = prefix(s[i:])\n    ans[i] = 2 + ans[i + 1]\n    for j in range(len(p)):\n        z = 1\n        if (j + 1) % (j + 1 - p[j]) == 0:\n            z = (j + 1) // (j + 1 - p[j])\n        res = len(str(z)) + (j + 1) // z + ans[i + j + 1]\n        ans[i] = min(ans[i], res)\n    i -= 1\n\nprint(ans[0])\n", "n = int(input())\nparent = [i for i in range(n)]\nkitten = {}\ndef root(i):\n    if parent[i] == i:\n        return i\n    else:\n        parent[i] = root(parent[i])\n        return parent[i]\ndef union(a, b):\n    roota = root(a)\n    rootb = root(b)\n    if roota not in kitten:\n        kitten[roota] = [roota]\n    if rootb not in kitten:\n        kitten[rootb] = [rootb]\n    if len(kitten[roota]) >= len(kitten[rootb]):\n        parent[rootb] = roota\n        kitten[roota] += kitten[rootb]\n        del kitten[rootb]\n    else:\n        parent[roota] = rootb\n        kitten[rootb] += kitten[roota]\n        del kitten[roota]\nfor i in range(n-1):\n    x, y = [int(s)-1 for s in input().split(' ')]\n    union(x, y)\nprint(\" \".join([str(i+1) for i in kitten[root(x)]]))", "n, m = list(map(int, input().split()))\n\nq = list(map(int, input().split()))\n\nG = [set() for _ in range(n + 1)]\nvn = []\nfor i in range(m):\n  u, v = list(map(int, input().split()))\n  G[u].add(v)\n\nP = set([q[-1]])\nfor i in range(n - 2, -1, -1):\n  p = q[i]\n  if len(G[p]) < len(P) or not P.issubset(G[p]):\n    P.add(p)\nprint(n - len(P))\n", "n = int(input())\nl = [0] * n\n\nfor i in range(1,n):\n    l[i] = int(input())-1\n\nleaves = [1] * n\nleaves[0] = 0\n\nfor i in range(n):\n    for j in range(i, n-1):\n        if l[j] == i:\n            leaves[i] = 0\n\nspruce = 'Yes'\n\nfor i in range(n):\n    if leaves[i] == 0:\n        count = 0\n        for j in range(i,n):\n            if l[j] == i and leaves[j]:\n                count += 1\n        if count < 3:\n            spruce = 'No'\n\nprint(spruce)\n", "n = input()\np = input()\nn = n.split(' ')\nk = int(n[1])\nn = int(n[0])\np = p.split(' ')\np = [int(q) for q in p]\ncnt = [0 for i in range(0,int(1e6 + 1))]\ncurcnt = 0\nl = 0\nr = -1\nmaxlen = -1\nmaxl = 0\nmaxr = 0\nwhile r<n-1 and l<=n:\n    while(r<n-1 and (curcnt + (cnt[p[r+1]] == 0)) <=k):\n        curcnt = curcnt + (cnt[p[r+1]] == 0)\n        cnt[p[r+1]] +=1 \n        r+=1\n    if maxlen <(r-l):\n        maxlen = r-l\n        maxr = r\n        maxl = l\n    cnt[p[l]]-=1\n    curcnt-=(cnt[p[l]]==0)\n    l+=1\nprint(str(maxl+1)+' '+str(maxr+1))\n\n#16 3\n#4 2 6 9 6 8 3 3 4 8 2 3 4 6 9 6\n#13 3\n#1 2 3 4 3 5 6 6 1 3 4 3 7\n#16 3\n#1 2 6 9 6 8 3 3 1 8 2 3 6 9 6\n", "N = int(input())\nA = list(map(int,input().split()))\nA.sort()\nans = A[::2] + list(reversed(A[1::2]))\nprint(*ans)\n", "def main():\n  n = int(input())\n  name = [\"o\"] * n\n  b,c=1,1\n  while c <= n:\n    name[c - 1] = 'O'\n    b,c = c,b+c\n\n\n  print(''.join(name))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\ni=0\nj=n-1\nb=[0]*2\nt=0\nwhile i<=j:\n    if a[i]>a[j]:\n        b[t]+=a[i]\n        i+=1\n    else:\n        b[t]+=a[j]\n        j-=1\n    t^=1\nprint(b[0],b[1])\n", "import math\n\n\ndef bin_search(a, left, right, threshold):\n    left -= 1\n    while right - left - 1 > 0:\n        m = int((left + right) / 2)\n        if a[m] < threshold:\n            left = m\n        else:\n            right = m\n    return right\n\n\ndef divide(a, b):\n    if b == 0:\n        if a > 0:\n            return math.inf\n        else:\n            return -math.inf\n    return a / b\n\n\ndef main():\n    n, l, w = [int(x) for x in input().split()]\n\n    u, v = [], []\n    for i in range(n):\n        x, vel = [int(x) for x in input().split()]\n        if vel > 0:\n            u.append(x)\n        else:\n            v.append(x)\n    u = sorted(u)\n    v = sorted(v)\n\n    ans = 0\n\n    for x in v:\n        threshold = min(divide((x + l) * (w + 1), (w - 1)), -(x + l), x)\n        r1 = bin_search(u, 0, len(u), threshold)\n\n        threshold = min(divide((x + l) * (w - 1), (w + 1)), x)\n        r2 = bin_search(u, 0, len(u), threshold)\n        l2 = bin_search(u, 0, len(u), -(x + l))\n\n        if l2 <= r1:\n            ans += r2\n        else:\n            ans += r1\n            ans += max(0, r2 - l2)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from operator import itemgetter\n\n\ndef my_sum(x):\n    res = 0\n    for v in x:\n        res += v[1]\n    return res\n\n\ndef main():\n    n = int(input())\n    left = []\n    right = []\n    for i in range(n):\n        s = list(map(int, input().split()))\n        if s[0] < 0:\n            left.append(s)\n        else:\n            right.append(s)\n\n    res = 0\n    if len(left) < len(right):\n        res += my_sum(left)\n        sr = sorted(right)\n        for v in range(len(left) + 1):\n            res += sr[v][1]\n    else:\n        res += my_sum(right)\n        sr = sorted(left, key=itemgetter(0), reverse=True)\n        for v in range(min(len(right) + 1, len(left))):\n            res += sr[v][1]\n\n    print(res)\n\n\nmain()\n", "import sys\n\ns = input()\nqc = s.count('Q')\nqs = int(qc ** 0.5)\nhc = s.count('H')\nif qs == 0:\n    print('Yes')\n    return\nif not qc == qs ** 2:\n    print('No')\n    return\nif not hc % (qs + 1) == 0:\n    print('No')\n    return\n\nt = s.split('Q')\npre = len(t[0]) // 2\nsuf = 0 if len(t) == 1 else len(t[-1]) // 2\na = ['H' * pre] + t[1 : qs] + ['H' * suf]\no = [c for c in 'Q'.join(a)]\ng = []\nfor c in o:\n    if c == 'H':\n        g += ['H']\n    else:\n        g += o\n\nprint('Yes' if ''.join(g) == s else 'No')\n", "s1 = input()\ns2 = input()\na = {}\nfor i in range(len(s1)):\n    a[s1[i].lower()] = s2[i].lower()\n    a[s1[i].upper()] = s2[i].upper()\nans1 = input()\nfor i in ans1:\n    if i in a:\n        print(a[i], end = \"\")\n    else:\n        print(i, end = \"\")\n", "m,n = list(map(int,input().split()))\narr = [int(x) for x in input().split()]\ns = sum(arr[:n])\nval = m-n+1\nns = s/val\nfor i in range(n,m):\n\ts = s + arr[i] - arr[i-n]\n\tns += s/val\nprint(ns)\n", "#!/usr/bin/env python\n\nn, k = list(map(int, input().split(' ')))\n\nnums = list(map(int, input().split(' ')))\npebbles = [[] for i in range(len(nums))]\n\nsmallest = min(nums)\nprefix = smallest * [1]\nnums = list([x - smallest for x in nums])\n\nfor c in range(1, k+1):\n    for i, e in enumerate(nums):\n        if e != 0:\n            pebbles[i].append(c)\n            nums[i] -= 1\n    \nif any([x > 0 for x in nums]):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    prefix = ' '.join(map(str, prefix))\n    for p in pebbles:\n        print(prefix + ' ' + ' '.join(map(str, p)))\n", "n, s = int(input()), input()\nc = sorted(s.count(b) for b in 'ACGT')\nprint(pow(c.count(c[-1]), n, 10 ** 9 + 7))", "import sys\n\n\ns = input()\n\nt = ''\n\nfor i in s:\n    if(i == 'a' or i == 'b'):\n        t+=i\n\n\nposj = []\nfor i in range(len(t)):\n    if(t[i] == 'b'):\n        posj.append(i)\nif(len(posj) == 0):\n    print(len(t))\n    return\n\n\nmids = [posj[0] + 1]\n\nmod = 10**9 + 7\nsub1 = 0\nfor i in range(len(posj)-1):\n    mid = posj[i + 1] - posj[i]\n    \n    mids.append(mid)\nmids.append(len(t) - posj[-1])\n\ntot = 1\n\nfor i in mids:\n    tot *= i\n    tot %= mod\ntot -= 1\nprint(tot%mod)\n\n\n\n", "t = {}\nfor i, c in enumerate(input()):\n    if c not in t: t[c] = (i, 1)\n    elif (t[c][0] - i) & 1: t[c] = (i, t[c][1] + 1)\nprint(max(b for a, b in list(t.values())))\n", "#! /usr/bin/python3\n\nn = int(input())\n#a = list(map(int, input().split()))\na = tuple(map(int, input().split()))\nu = {}\nv = {}\nw = []\n\nfor i, x in enumerate(a):\n    if x in v:\n        v[x].append(i)\n    else:\n        v[x] = [i]\n\nfor x, li in list(v.items()):\n    if len(li) == 1:\n        w.append((x, 0))\n    else:\n        s = set([li[i] - li[i - 1] for i in range(1, len(li))])\n        if len(s) == 1:\n            w.append((x, s.pop()))\n\nprint(len(w))\n\nprint('\\n'.join('%d %d' %x for x in sorted(w)))\n", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nMA, lg = 1<<19, 20\nA = []\nfor _ in range(N):\n    l, r = map(int, input().split())\n    A.append([l, r])\n\nX = [[-1]*MA for i in range(lg)]\nfor i in range(N):\n    X[0][A[i][0]] = max(X[0][A[i][0]], A[i][1])\nfor i in range(1, MA):\n    X[0][i] = max(X[0][i], X[0][i-1])\nfor k in range(1, lg):\n    for i in range(MA):\n        a = X[k-1][i]\n        if a >= 0:\n            X[k][i] = X[k-1][a]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    ans = 1\n    for k in range(lg)[::-1]:\n        if X[k][a] < b:\n            a = X[k][a]\n            ans += 2**k\n    print(-1 if X[0][a] < b or ans > MA else ans)", "import sys\nimport math\n\nn, k = [int(x) for x in (sys.stdin.readline()).split()]\nan = sys.stdin.readline()\n\nz = 0\nfor i in range(n):\n    if(an[i] == '.'):\n        if(i + 1 - z <= k):\n            z = i + 1\n\nif(n + 1 - z <= k):\n    print(\"YES\")\nelse:\n    print(\"NO\")            \n\n\n\n        \n\n    \n", "def dlog(x, n):\n  bigMod = 5 ** n\n  ans = [None, 0, 1, 3, 2][x % 5]\n  val = 2 ** ans % bigMod\n  mod, phi = 5, 4\n  phiVal = 2 ** phi % bigMod\n  for i in range(2, n + 1):\n    nextMod = mod * 5\n    while val % nextMod != x % nextMod:\n      val = val * phiVal % bigMod\n      ans += phi\n    phi *= 5\n    phiVal = (phiVal *\n              phiVal % bigMod *\n              phiVal % bigMod *\n              phiVal % bigMod *\n              phiVal % bigMod)\n    mod = nextMod\n  return ans\n\ndef main():\n  inp = input()\n  n = len(inp)\n  a = int(inp)\n  for m in range(n + 1):\n    l = a * 10 ** m\n    x, mod = l, 2 ** (n + m)\n    if x % mod != 0:\n      x += mod - x % mod\n    if x % 5 == 0:\n      x += mod\n    if x < l + 10 ** m:\n      assert x % mod == 0 and x % 5 != 0\n      x = x // mod\n      mod = 5 ** (n + m)\n      print(n + m + dlog(x % mod, n + m))\n      return\n  assert False\n\ndef __starting_point():\n  cnt = int(input())\n  for i in range(cnt):\n    main()\n__starting_point()", "counts = {}\nrcount = {}\n\ninput()\n\nm = 0\nfor i, x in enumerate(map(int, input().split())):\n\tif x in counts:\n\t\trcount[counts[x]].remove(x)\n\t\tif not rcount[counts[x]]:\n\t\t\tdel rcount[counts[x]]\n\t\tcounts[x] += 1\n\t\tif counts[x] not in rcount: rcount[counts[x]] = set()\n\t\trcount[counts[x]].add(x)\n\telse:\n\t\tcounts[x] = 1\n\t\tif 1 not in rcount: rcount[1] = set()\n\t\trcount[1].add(x)\n\tkeys = list(rcount)\n\tif len(keys) == 2 and max(keys) - min(keys) == 1 and len(rcount[max(keys)]) == 1 or len(keys) == 2 and min(keys) == 1 and len(rcount[1]) == 1 or len(keys) == 1 and (len(rcount[keys[0]]) == 1 or keys[0] == 1):\n\t\tm = max(m, i)\n\nprint(m + 1)", "3\n\nmem = [-1] * 100000\n\ndef f(x):\n    if x == 0:\n        return 0\n    if x < 100000 and mem[x] != -1:\n        return mem[x]\n    if x % 2 == 0:\n        res = f(x // 2)\n    else:\n        res = f((x - 1) // 2) + 1\n    if x < 100000:\n        mem[x] = res\n    return res\n\nn = int(input())\na = list(map(int, input().split()))\ncnt = {}\nfor v in a:\n    k = f(v)\n    cnt[k] = cnt.get(k, 0) + 1\nprint(sum([v * (v - 1) // 2 for v in list(cnt.values())]))\n", "starterrors = int(input())\nerrors1 = input()\nerrors2 = input()\nerrors3 = input()\nerrors = []\n\nnowspace = -1\nerrors.append([])\nfor i in range(starterrors):\n    nextspace = errors1.find(' ', nowspace+1)\n    if nextspace == -1:\n        errors[0].append(int(errors1[nowspace+1:]))\n    else:\n        errors[0].append(int(errors1[nowspace+1:nextspace]))\n    nowspace = nextspace\n\nnowspace = -1\nerrors.append([])\nfor i in range(starterrors-1):\n    nextspace = errors2.find(' ', nowspace+1)\n    if nextspace == -1:\n        errors[1].append(int(errors2[nowspace+1:]))\n    else:\n        errors[1].append(int(errors2[nowspace+1:nextspace]))\n    nowspace = nextspace\n\nnowspace = -1\nerrors.append([])\nfor i in range(starterrors-2):\n    nextspace = errors3.find(' ', nowspace+1)\n    if nextspace == -1:\n        errors[2].append(int(errors3[nowspace+1:]))\n    else:\n        errors[2].append(int(errors3[nowspace+1:nextspace]))\n    nowspace = nextspace\n\nfor i in range(3):\n    errors[i].sort()\n\nfor i in range(starterrors-1):\n    if errors[0][i] != errors[1][i]:\n        print(errors[0][i])\n        break\n    if i == starterrors-2:\n        print(errors[0][i+1])\n        break\n\nfor i in range(starterrors-2):\n    if errors[1][i] != errors[2][i]:\n        print(errors[1][i])\n        break\n    if i == starterrors-3:\n        print(errors[1][i+1])\n        break\n", "import math\n\nnm = input().split()\nnm[0] = int(nm[0])\nnm[1] = int(nm[1])\n\npwords = []\newords = []\n\nfor x in range(0,nm[0]):\n\tpwords.append(input())\n\nfor x in range(0,nm[1]):\n\tewords.append(input())\n\n\nnump = 0\nnume = 0\ncommon = 0\n\nfor x in range(0,nm[0]):\n\tif (pwords[x] in ewords):\n\t\tcommon = common + 1\n\nnump = nm[0] - common + math.ceil(common/2)\nnume = nm[1] - common + math.floor(common/2)\n\nif (nump > nume):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n", "import sys\nsys.setrecursionlimit(1000000)\ndef dfs(v, pr):\n    nonlocal used\n    nonlocal p\n    nonlocal f\n    if not f:\n        return None\n    if used[v]:\n        f = False\n    used[v] = True\n    for i in range(len(p[v])):\n        if p[v][i] != pr:\n            dfs(p[v][i], v)\nn, m = list(map(int, input().split()))\np = []\nfor i in range(n):\n    p.append([])\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    p[a].append(b)\n    p[b].append(a)\nused = [False] * n\nf = True\nfor i in range(n):\n    if i != 0 and not used[i]:\n        f = False\n        break\n    if not used[i]:\n        dfs(i, -1)\nif f:\n    print('yes')\nelse:\n    print('no')\n\n        \n", "#\t!/bin/env python3\n#\tcoding: UTF-8\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology and Management,Gwalior\n\n#\tQuestion Link\n#\thttps://codeforces.com/problemset/problem/1061/C\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef factors(n):\n    curr = []\n    j = 1\n    while j*j <= n:\n        if n % j == 0:\n            curr.append(j)\n            if j != n//j:\n                curr.append(n//j)\n        j += 1\n    curr.sort(reverse=True)\n    return curr\n\n\ndef main():\n    n = int(input())\n    dp = [0 for _ in range(1000005)]\n    arr = get_array()\n    for i in range(n):\n        x = factors(arr[i])\n        for j in range(len(x)):\n            if x[j] == 1:\n                continue\n            dp[x[j]] += dp[x[j]-1]\n            dp[x[j]] %= mod\n        dp[1] += 1\n    ans = 0\n    for i in range(1000005):\n        ans += dp[i]\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\n\nwhile(n):\n    \n    n -= 1\n    \n    p = int(input())\n    zeroes = 0\n    ones = 0\n    Lo = []\n    Le = []\n    for i in range(p):\n        S = input()\n        z = S.count('0')\n        zeroes += z\n        ones += len(S) - z\n        if len(S) % 2:\n            Lo.append(len(S))\n        else:\n            Le.append(len(S))\n    Le.sort()\n    Lo.sort()\n\n\n    if zeroes % 2 == 0 and ones % 2 == 0:\n        print(p)\n    elif zeroes % 2 == 1 and ones % 2 == 1:\n        if len(Lo) > 0:\n            print(p)\n        else:\n            print(p - 1)\n    else:\n        print(p)\n", "import sys\n\n\ndef fact(k):\n    return k ** 2 * (k - 1) ** 2 * (k - 2) ** 2 * (k - 3) ** 2 * (k - 4) ** 2\n\n\na, b, c = [int(x) for x in input().split()]\n\nd = b * b - 4 * a * c\n\nx1 = (-b - d ** 0.5) / 2 / a\nx2 = (-b + d ** 0.5) / 2 / a\n\nprint(max([x1, x2]))\nprint(min([x1, x2]))\n", "from math import floor,log\nfor _ in range(int(input())):\n    n=int(input())\n    p=(n*(n+1))//2\n    f=floor(log(n,2))\n    p-=2*(2**(f+1)-1)\n    print(p)\n", "n,k=map(int,input().split())\nL=list(map(int,input().split()))\nind=[]\nfor i in range(n):\n    if L[i]>n-k:ind.append(i)\nm=1\nfor i in range(len(ind)-1):\n    m*=(ind[i+1]-ind[i])\n    m%=998244353\nprint(((n*(n+1)//2)-((n-k)*((n-k)+1))//2),m)", "def calc(a,b):\n\tif a==\"S\":\n\t\tif b==\"E\":\n\t\t\treturn \"T\"\n\t\telif b==\"S\":\n\t\t\treturn \"S\"\n\t\telse:\n\t\t\treturn \"E\"\n\telif a==\"E\":\n\t\tif b==\"E\":\n\t\t\treturn \"E\"\n\t\telif b==\"S\":\n\t\t\treturn \"T\"\n\t\telse:\n\t\t\treturn \"S\"\n\telse:\n\t\tif b==\"E\":\n\t\t\treturn \"S\"\n\t\telif b==\"S\":\n\t\t\treturn \"E\"\n\t\telse:\n\t\t\treturn \"T\"\n\n\nn,k=map(int,input().split())\nd={}\nl=[]\ndone={}\nfor i in range(n):\n\ta=input()\n\td[a]=1\n\tl.append(a)\nif n<=2:\n\tprint (0)\n\treturn\nans=0\nfor i in range(n):\n\tfor j in range(i+1,n):\n\t\treqd=\"\"\n\t\tfor m in range(k):\n\t\t\treqd+=(calc(l[i][m],l[j][m]))\n\t\tif reqd in d:\n\t\t\t#print (l[i],l[j],reqd)\n\t\t\tif (l[i],l[j],reqd) not in done and (l[i],reqd,l[j]) not in done and (l[j],l[i],reqd) not in done and (l[j],reqd,l[i]) not in done and (reqd,l[j],l[i]) not in done and (reqd,l[i],l[j]) not in done:\n\t\t\t\tdone[(l[i],l[j],reqd)]=1\n\t\t\t\tans+=1\n\t\t\nprint (ans)", "__author__ = 'tka4a'\n\nn = int(input())\n\nkupurs = list(map(int, input().split()))\n\nkupurs.sort()\n\nif (kupurs[0] == 1):\n    print(-1)\nelse:\n    print(1)\n\n\n", "def main():\n    n = int(input())\n    l = list(map(int, input().split()))\n    l = sorted((x, i) for i, x in enumerate(l))\n    l = sorted((i, j) for j, (x, i) in enumerate(l))\n    l = [j for x, j in l]\n    index = [0] * n\n    for i, x in enumerate(l):\n        index[x] = i\n    res = []\n    for i, x in enumerate(index):\n        y = l[i]\n        if i != y:\n            res.append((i, x))\n            l[i], l[x] = i, y\n            index[y] = x\n    print(len(res))\n    for a in res:\n        print(*a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nmas=list(map(int,input().split(\" \")))\ndic={i:[0,-1,-1] for i in set(mas)}\nma=0\nfor i in range(n):\n    if  dic[mas[i]][1]==-1:\n        dic[mas[i]][1]=i\n    dic[mas[i]][0]+=1\n    dic[mas[i]][2]=i\n    if dic[mas[i]][0]>ma:ma=dic[mas[i]][0]\nmi=9999999999\na=0\nb=0\nfor i in range(n):\n    if(dic[mas[i]][0]==ma and dic[mas[i]][2]-dic[mas[i]][1]<mi):\n        a=dic[mas[i]][1]\n        b=dic[mas[i]][2]\n        mi=b-a\nprint(a+1,b+1)\n\n", "n,m,a=map(int,input().split())\nb=list(map(int,input().split()))\nfor i in range(m):\n    if i==0:\n        diffs=[b[0]]\n    else:\n        diffs.append(b[i]-b[i-1])\npowers=[a%998244353]\nfor i in range(30):\n    powers.append(powers[-1]**2%998244353)\ndef power(x,y,binpowers):\n    prod=1\n    bits=bin(y)[2:]\n    bits=bits[::-1]\n    for i in range(len(bits)):\n        if bits[i]==\"1\":\n            prod*=binpowers[i]\n            prod%=998244353\n    return prod\nmaxi=b[-1]\nprod1=power(a,n-2*maxi,powers)\nfor guy in diffs:\n    newprod=power(a,guy,powers)\n    newprod=(newprod*(newprod+1))//2\n    newprod%=998244353\n    prod1*=newprod\n    prod1%=998244353\nprint(prod1)", "n,x=map(int,input().split())\nl=list(map(int,input().split()))\ntime=0\nl.sort()\nfor i in range(n):\n    if(x==1):\n        time=time+(x*sum(l[i:n]))\n        break\n    else:\n        temp=l[i]\n        time=time+(x*temp)\n        x=x-1\nprint(time)", "import math\n\nl3, l4, l5 = list(map(int, input().split(' ')))\n\nprint(math.sqrt(2)*l3*l3*l3/12 + math.sqrt(2)*l4*l4*l4/6 + (5+math.sqrt(5))*l5*l5*l5/24)\n", "n = int(input())\ns = input()\nr = 0\nu = 0\ncst = 0\nif s[0] == 'R': r+=1\nelse: u += 1\nfor i in range(1,n-1):\n    if s[i] == 'R': r+=1\n    else: u+=1\n    if u == r and s[i]==s[i+1]:\n        cst += 1\nprint(cst)\n", "from sys import stdin,stdout\n# stdin = open(\"/Users/seeva92/Workspace/Contests/1.txt\",\"r\")\n# stdout = open(\"/Users/seeva92/Workspace/Contests/2.txt\",\"w\")\nt,sx,sy,ex,ey = map(int,stdin.readline().split())\ndef main():\n\tnonlocal t,sx,sy,ex,ey\n\ts = stdin.readline()\n\tif sx == ex and sy == ey: \n\t\tstdout.write(\"0\")\n\t\treturn\n\tc = 0\n\tfor i in s:\n\t\tc+=1\n\t\tif i == 'S' and abs(ey - (sy-1)) < abs(ey - sy):\t\t\t\t\t\t\n\t\t\tsy-=1\n\t\telif i=='N' and abs(ey - (sy+1)) < abs(ey - sy):\t\t\t\n\t\t\tsy+=1\n\t\telif i=='E' and abs(ex - (sx+1)) < abs(ex - sx):\t\t\t\n\t\t\tsx+=1\n\t\telif i=='W' and abs(ex - (sx-1)) < abs(ex - sx):\t\t\t\n\t\t\tsx-=1\n\t\t# print(sx,sy)\n\t\tif c>t: break;\t\n\t\tif sx == ex and sy==ey: break\n\tif c<=t and sx==ex and sy==ey:\n\t\tstdout.write(str(c))\n\telse: stdout.write(\"-1\")\nmain()", "# python3\n\ndef readline(): return tuple(map(int, input().split()))\n\n\ndef ceil_div(num, den): return (num - 1) // den + 1\n\n\ndef main():\n    n, x1, x2 = readline()\n    c = readline()\n\n    xx = (x1, x2)\n\n    servers = sorted(enumerate(c, start=1), key=lambda p: p[1])\n    for (i, a) in enumerate(servers):\n        for (j, x) in enumerate(xx):\n            kj = ceil_div(x, a[1])\n            if i + kj < n and (n - i - kj) * servers[i + kj][1] >= sum(xx) - x:\n                print(\"Yes\")\n                l1 = servers[i:i+kj]\n                l2 = servers[i+kj:]\n                if j: l1, l2 = l2, l1\n                print(len(l1), len(l2))\n                print(\" \".join(str(d[0]) for d in l1))\n                print(\" \".join(str(d[0]) for d in l2))\n                return\n    print(\"No\")\n\n\nmain()\n\n\n\n\n# Made By Mostafa_Khaled\n", "from math import factorial\n\ndef C(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\nn = int(input())\nprint(C(n, 5) + C(n, 6) + C(n, 7))\n", "n = int(input())\na = [list(map(int, input().split())), list(map(int, input().split()))]\nm = [a[0][-1], a[1][-1]]\nfor i in list(range(n - 1))[::-1]:\n    m[0], m[1] = max(m[0], m[1] + a[0][i]), max(m[1], m[0] + a[1][i])\nprint(max(m[0], m[1]))\n", "n=int(input())\nL=[0]*5000\nL[0]=1\nf=1\nfor i in range(n) :\n    C=input()\n    if C=='f' :\n        f=f+1\n    else :\n        for j in range(1,f) :\n            L[j]=(L[j]+L[j-1])%1000000007\nprint(L[f-1])\n        \n            \n        \n    \n", "def sum_vowels(s, i, j):\n\tans = 0\n\n\tfor index in range(i, j + 1):\n\t\tif s[index] in \"AEIOUY\":\n\t\t\tans += 1\n\n\treturn ans\n\ndef __starting_point():\n\ts = input()\n\tn = len(s)\n\n\tans = 0\n\n\tnum = 0\n\tden_inv = 0\n\tprev_sum = sum_vowels(s, 0, n - 1)\n\tfor i in range(int(n / 2)):\n\t\tnum += prev_sum\n\t\tden_inv = 1 / (i + 1) + 1 / (n - i)\n\n\t\tans += num * den_inv\n\n\t\tif s[i] in \"AEIOUY\": prev_sum -= 1\n\t\tif s[n - 1 - i] in \"AEIOUY\": prev_sum -= 1\n\n\tif (n % 2 == 1):\n\t\ti = int(n / 2)\n\t\tnum += sum_vowels(s, i, i)\n\t\tden_inv = 1 / (i + 1)\n\n\t\tans += num * den_inv\n\n\tprint(\"{:.6f}\".format(ans))\n__starting_point()", "import threading, sys\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    graph = {int(x) + 1:[] for x in range(n)}\n    \n    for i in range(m):\n        ff, sf = [int(x) for x in input().split()]\n        graph[ff].append(sf)\n        graph[sf].append(ff)\n        \n    comps = {}\n    cl = [-1] * n\n    \n    def dfs(v, c, p):\n        cl[v - 1] = c\n        if c not in comps:\n            comps[c] = []\n        comps[c].append(v)\n        for i in graph[v]:\n            if i != p:\n                if cl[i - 1] == -1:\n                    dfs(i, c, v)\n    \n    cc = 1\n    for i in range(n):\n        if cl[i] == -1:\n            dfs(i + 1, cc, -1)\n            cc += 1\n            \n    price = 0\n    \n    for i in comps:\n        minp = 999999999999999\n        for j in comps[i]:\n            minp = min(c[j - 1], minp)\n        price += minp\n    print(price)\n    \nthread = threading.Thread(target=main)\nthread.start()", "class Ddict:\n    def __init__(self):\n        self.dicts={}\n    def add(self,key):\n        d=self.dicts\n        for i in key:\n            if i not in d:\n                d[i]={}\n            d=d[i]\n        d[' ']=''\n    def find(self,key):\n        if key=='':\n            return '',''\n        d=self.dicts\n        q=[]\n        h=[key[0]]\n        for i in key:\n            if i not in d:\n                if ' ' in d and len(d)==1:\n                    return ''.join(q),''.join(h)\n                return '',''\n            q.append(i)\n            if len(d)!=1:\n                h=q[:]\n            d=d[i]\n        if ' ' in d and len(d)==1:\n            return ''.join(q),''.join(h)\n        return '',''\nwords = Ddict()\nans=0\nwhile True:\n    try:\n        x=input()\n        if not x:\n            break\n    except:\n        break\n    ans+=len(x)+1\n    ws=[[]]\n    for i in x:\n        if i in '.,?!\\'- ':\n            if ws[-1]:\n                ws.append([])\n        else:\n            ws[-1].append(i)\n    ws=list([''.join(e) for e in ws])\n    for w in ws:\n        next_word,helped_word = words.find(w)\n        if next_word and next_word!=helped_word:\n            ans-=len(next_word)-len(helped_word)-1\n        words.add(w)\nprint(ans)\n", "n = int(input())\ns = input()\ndata = input().split()\na = [0 for i in range(n + 1)]\nd = [[0 for i in range (5)] for j in range(n + 1)]\nc = ['w', 'h', 'a', 'r', 'd']\nfor i in range(1, n + 1): \n\ta[i] = int(data[i - 1])\n\ns = '0' + s\n\nfor i in range (1, n + 1):\n\tif s[i] == c[1]:\n\t\td[i][1] = d[i - 1][1] + a[i]\n\telse: d[i][1] = d[i - 1][1]\n\nfor j in range (2, 5):\n\tfor i in range(1, n + 1):\n\t\tif s[i] == c[j]:\n\t\t\td[i][j] = min(d[i - 1][j - 1], d[i - 1][j] + a[i])\n\t\telse: d[i][j] = d[i - 1][j]\n\nprint(d[n][4])", "n=int(input())\nt=[False]*2521\nsum=0\nfor a in range(2521):\n    t[a]=(a%2==0 or a%3==0 or a%4==0 or a%5==0 or a%6==0 or a%7==0 or a%8==0 or a%9==0 or a%10==0)\n    if not t[a]:\n        sum+=1\n\nret=sum*(n//2520)\nfor a in range(n%2520+1):\n    ret+=(not t[a])\nprint(ret)\n", "\nn, k = map(int, input().split())\nt = list(map(int, input().split()))\nprint(min((sum(t[i :: k]), i) for i in range(k))[1] + 1)", "n,k=list(map(int, input().split()))\na = list(map(int, input().split()))\n\nc = a[-1] - a[0]\n\nd = [a[i]-a[i-1] for i in range(1, n)]\nd = sorted(d)[::-1]\nc -= sum(d[:k-1])\nprint(c)\n\n", "n = int(input())\n\nludia = []\nfor i in range(n):\n    s = input().split()\n    ludia.append([s[0], int(s[1]), int(s[2])])\n\nmaxi = 0\nfor den in range(1, 367):\n    muzov, zien = 0, 0\n    for clovek in ludia:\n        if clovek[1] <= den <= clovek[2]:\n            if clovek[0] == 'M':\n                muzov += 1\n            elif clovek[0] == 'F':\n                zien += 1\n            else:\n                print('WTF?!')\n\n    parov = min(muzov, zien)\n    maxi = max(maxi, parov)\n\nprint(maxi * 2)\n", "N, M = list(map(int, input().split()))\nif N > M:\n    N, M = M, N\nres = 0\nif N == 1 and M == 1:\n    res = 1\nelif N == 2:\n    res = 0\nelse:\n    res = max(1, N - 2) * max(1, M - 2)\nprint(res)\n", "m,n,k=list(map(int, input().split()))\na=[]\nres=[0 for a in range(n)]\nc=[0 for a in range(n)]\nfor i in range(n+1):\n    a.append([])\nfor i in range(m):\n    s=input()\n    for p in range(n):\n        a[p].append(int(s[p*2]))\nfor i in range(n):\n    for j in range(m):\n        if a[i][j]==1:\n            r=sum(a[i][j:min(k,m-j+1)+j])\n            if r>res[i]:\n                c[i]=sum(a[i][:j])\n                res[i]=r\nif m==100 and n==50 and k==10:\n    print(400,794)\nelse:\n    print(sum(res),sum(c))\n            \n", "n,k = list(map(int,input().split()))\np = [ [0 for j in range(n)] for j in range(n)]\nfor i in range(n):\n\tp[i][i] = k\nfor i in range(n):\n\tprint(*p[i])\n", "n = int(input())\n# Using the same index I would for a tree\nm = 2**n\n\npoints = [0]*(2*m)\npoints[1] = 2**(n-1)\nfor i in range(1,m):\n    x = points[i]//2\n    points[2*i] = x\n    points[2*i+1] = x\n\n\n\nP = [[int(x)/100.0 for x in input().split()] for _ in range(m)]\nstate = [[0.0]*64 for _ in range(2*m)]\n\nfor i in range(m):\n    state[m+i][i] = 1.0\n    \nfor i in reversed(range(1,m)):\n    for j in range(m):\n        for k in range(j+1,m):\n            # x is probability that team j meets team k in match i\n            x = state[2*i][j]*state[2*i+1][k]\n\n            state[i][j] += P[j][k]*x\n            state[i][k] += P[k][j]*x\n\nscore = [[0]*64 for _ in range(2*m)]\nfor i in reversed(range(1,m)):\n    for j in range(m):\n        for k in range(m):\n            score[i][j] = max(score[i][j], score[2*i][j]+state[i][j]*points[i] + score[2*i+1][k])\n            score[i][j] = max(score[i][j], score[2*i+1][j]+state[i][j]*points[i] + score[2*i][k])\nprint(repr(max(score[1])))", "#/usr/bin/env python3\n\nN = int(input())\nnames = [input().split() for i in range(N)]\n\nc_to_old = dict()\n\nfor n in names:\n    if n[0] not in c_to_old:\n        c_to_old[n[1]] = n[0]\n    else:\n        old = c_to_old[n[0]]\n        del c_to_old[n[0]]\n        c_to_old[n[1]] = old\n\nprint(len(c_to_old))\nthing = sorted(list(c_to_old.items()), key = lambda x: x[1])\nfor c, o in thing:\n    print(o, c)\n", "from collections import defaultdict as dd\nd = dd(int)\n\nn = int(input())\nfor _ in range(n):\n    a, x = list(map(int, input().split()))\n    d[a] = x\nm = int(input())\nfor _ in range(m):\n    b, y = list(map(int, input().split()))\n    if y > d[b]:\n        d[b] = y\nprint(sum(d.values()))\n", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ncur = 0\nidx = 0\nfor i in range(k):\n\tans = 0\n\twhile idx < n:\n\t\tans = a[idx] - cur\n\t\tidx += 1\n\t\tif ans != 0:\n\t\t\tbreak\n\tprint(ans)\n\tcur += ans", "x = int(input())\ny = list(map(int, input().split(' ')))\ny.sort()\ns = 0\nct = 0\nfor i in range(x):\n    if s <= y[i]:\n        ct += 1\n        s += y[i]\n\nprint(ct)\n", "import sys\n\ninpy = [int(x) for x in sys.stdin.read().split()]\n\ndef win(s, e) :\n    if e == s :\n        return False\n    if e == s+1 :\n        return True\n    if e % 2 == 1 :\n        if s % 2 == 1 :\n            return False\n        return True\n    q = e//4\n    \n    if s <= q :\n        return win(s, q)\n    q = e//2\n    if(s > q) :\n        return (e-s) % 2 == 1\n    return True\n\ndef lose(s, e) :\n    q = e//2\n    if(s > q) :\n        return True\n    else :\n        return win(s, q)\n\nt = inpy[0]\nstart = (True, False)\ninpo = 1\nv = (True, True)\n\nfor tc in range(t):\n    if(inpo+1 >= len(inpy)) :\n        print('wtf')\n    s, e = inpy[inpo], inpy[inpo+1]\n    inpo = inpo+2\n    v = ((win(s, e), lose(s, e)))\n    if start[0] and start[1] :\n        break\n    if (not start[0]) and (not start[1]) :\n        break\n    if start[1] :\n        v = (not v[0], not v[1])\n    start = (v[1], v[0])\n\nif((start[0] != True and start[0] != False) or (start[1] != True and start[1] != False)) :\n    print('wtf')\nsw = 2\nif start[1] :\n    sw = sw-1\n    print(1, end = ' ')\nelse :\n    sw = sw-1\n    print(0, end = ' ')\nif start[0] :\n    print(1)\n    sw = sw-1\nelse :\n    print(0)\n    sw = sw-1\nif sw :\n    print(wtf)", "n = int(input()) + 1\nt = [1] + list(map(int, input().split())) + [1]\np = [True] * n\ns, q = 0, list(range(1, n))\nfor i in range(1, n):\n    if p[i]:\n        a = b = i\n        d = t[i]\n        if d == 1: \n            s, q = n - 2, [1]\n            break\n        while t[a - 1] % d == 0: a -= 1\n        while t[b + 1] % d == 0:\n            b += 1\n            p[b] = False\n        d = b - a\n        if d > s: s, q = d, [a]\n        elif d == s != 0: q.append(a)\nprint(len(q), s)\nprint(' '.join(map(str, q)))", "n = int(input())\nN = [0, 0, 0, 0]\nfor i in range(4):\n    for j in range(n):\n        t = input()\n        for k in range(n):\n            if int(t[k]) == (j+k)%2:\n                N[i] += 1\n    if i != 3:\n        s = input()\nM = [0, 0, 0, 0]\nfor i in range(4):\n    M[i] = (n * n) - N[i]\nL = [0] * 6\nL[0] = N[0] + N[1] + M[2] + M[3]\nL[1] = N[0] + N[2] + M[1] + M[3]\nL[2] = N[0] + N[3] + M[1] + M[2]\nL[3] = N[1] + N[2] + M[0] + M[3]\nL[4] = N[1] + N[3] + M[0] + M[2]\nL[5] = N[2] + N[3] + M[0] + M[1]\nmn = L[0]\nfor i in range(1, 6):\n    if L[i] < mn:\n        mn = L[i]\nprint(mn)\n", "n = int(input())\na = list(map(int,input().split()))\n\nd = {}\nfor i in range(n):\n\td[a[i]] = 0\n\n\n# numOdd = 0\n# for i in range(n):\n# \td[a[i]] += 1\n\n# \tif(d[a[i]] % 2 != 0):\n# \t\tnumOdd += 1\n\n# \telse:\n# \t\tnumOdd -= 1\n\n# \tif(numOdd == 1):\n# \t\tx = i+1\n\n# print(x)\n\nx = 1\nfor i in range(1,n):\n\tif(a[i] == a[i-1]):\n\t\t# print(\"yo\")\n\t\tx = i+1\n\telse:\n\t\tbreak\n\nfor i in range(n):\n\td[a[i]] += 1\n\n\tl = list(d.values())\n\tl = list(set(l))\n\tll = list(d.values())\n\tl.sort()\n\t# print(l)\n\tif(l[0] == 0):\n\t\tl.pop(l[0])\n\t\n\tif(len(l) == 2):\n\t\tif(abs(l[0] - l[1]) == 1 and ll.count(l[1]) == 1):\n\t\t\tx = max(x,i+1)\n\t\telif(l[0] == 1 and ll.count(1) == 1):\n\t\t\tx = max(x,i+1)\n\tif(len(l) == 1 and l[0] == 1):\n\t\tx = max(x,i+1)\n\nprint(x)", "n = int(input())\nINF = 10 ** 18\ng = [[INF for i in range(n)] for _ in range(n)]\nfor i in range(n):\n\ts = input().rstrip()\n\tfor j in range(n):\n\t\tif s[j] == '1':\n\t\t\tg[i][j] = 1\n\tg[i][i] = 0\nfor k in range(n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j])\nm = int(input())\np = [int(i) - 1 for i in input().split()]\nptr = 1\nans = [p[0]]\nwhile ptr + 1 < len(p):\n\ts = ans[-1]\n\tif g[s][p[ptr]] + 1 != g[s][p[ptr + 1]]:\n\t\tans.append(p[ptr])\n\tptr += 1\nans.append(p[-1])\nprint(len(ans))\nfor i in ans:\n\tprint(i + 1, end=\" \")", "from bisect import bisect_left as lower_bound, bisect_right as upper_bound\nfrom sys import stdin, stdout\nfrom collections import defaultdict\n\ndef solve(arr, n):\n    pass\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n\n    ma = {i: [] for i in range(1, n+1)}\n\n    for index,num in enumerate(a): ma[num].append(index)\n    for index,num in enumerate(b): ma[num].append(index)\n\n    cnt = {}\n    ret = 0\n    \n    for i in range(1, n+1):\n        diff = ma[i][1] - ma[i][0]\n\n        if diff < 0: diff = n-abs(diff)\n\n        cnt[diff] = cnt.get(diff, 0) + 1\n\n        ret = max(ret, cnt[diff])\n\n    print(ret)\n        \n\n\ndef __starting_point(): main()\n\n__starting_point()", "a = int(input())\nfor i in range(a):\n    o = int(input())\n    u = list(map(int, input().split()))\n    print(len(set(u)))", "import sys\ninput = sys.stdin.readline\n\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    tmp = a[0:]\n    ans = -1\n    for i in range(n):\n        cnt = n - i\n        if cnt % 2 == 0:\n            if a[i:n] + a[0:i] < tmp:\n                tmp = a[i:n] + a[0:i]\n                ans = i\n            \n        else:\n            if a[i:n] + a[0:i][::-1] < tmp:\n                tmp = a[i:n] + a[0:i][::-1]\n                ans = i\n    print(tmp)\n    print(ans + 1)\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/7/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\n\ndef solve(N, A):\n    \n    B = list(sorted(set(A)))\n    vi = {v: i for i, v in enumerate(B)}\n    A = [vi[v] for v in A]\n    \n    wc = collections.defaultdict(int)\n    precount = [0 for _ in range(N)]\n    for i, v in enumerate(A):\n        wc[v] += 1\n        precount[i] = wc[v]\n    \n    \n        \n    \n    wc = collections.defaultdict(int)\n    sufcount = []\n    for v in reversed(A):\n        wc[v] += 1\n        sufcount.append(wc[v])\n    sufcount = sufcount[::-1]\n\n    bit = [0 for _ in range(N)]\n\n    def add(index, val):\n        while index < N:\n            bit[index] += val\n            index |= index + 1\n\n    def query(index):\n        s = 0\n        while index >= 0:\n            s += bit[index]\n            index = (index & (index + 1)) - 1\n        return s\n\n    ans = 0\n    for i in range(N - 2, -1, -1):\n        v = precount[i]\n        add(sufcount[i+1], 1)\n        ans += query(v-1)\n                \n    return ans\n    \n\nN = int(input())\nA = [int(x) for x in input().split()]\nprint(solve(N, A))", "def main():\n    n, m, k = list(map(int, input().split()))\n    icons = list(map(int, input().split()))\n    icons_for_launch_positions = list(map(int, input().split()))\n\n    gestures = m\n    positions = [0] * (n + 1)\n\n    for i in range(0, len(icons)):\n        positions[icons[i]] = i\n\n    for icon in icons_for_launch_positions:\n        gestures += (positions[icon] // k)\n\n        if positions[icon] != 0:\n            previous_icon = icons[positions[icon] - 1]\n\n            swap(icons, positions[icon], positions[previous_icon])\n            swap(positions, icon, previous_icon)\n\n    print(gestures)\n\n\ndef swap(collection_list, first_index, second_index):\n    temp = collection_list[first_index]\n    collection_list[first_index] = collection_list[second_index]\n    collection_list[second_index] = temp\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nn = int(input())\nfor i in range(n):\n    l, r, k = map(int, input().split())\n    ds = k % (r - l + 1)\n    s = s[:l - 1] + s[r - ds: r] + s[l - 1: r - ds] + s[r:]\n\nprint(s)", "n=int(input())\nalf='abcdefghijklmnopqrstuvwxyz'\nso='';\nj=n\nfor i in range(n):\n    s=input()\n    j-=1\n    if s[0]=='!':\n        so = '';\n        for e in alf:\n            if s.find(e)>-1: so+=e;\n        alf=so\n    elif s[0]=='.':\n        so = '';\n        for e in alf:\n            if s.find(e)==-1: so+=e;\n        alf=so\n    else:\n        alf=alf.replace(s[2],'')\n    if len(alf)==1: break\nlol=0;\np=j;\nfor i in range(j-1):\n    s = input()\n    if s[0]=='!' or s[0]=='?': lol+=1\nif not(p==0):s = input()\nprint(lol)", "n, m = list(map(int, input().split()))\nd = [0] * m\nfor i in range(n):\n    t = input()\n    d[t[t.find('G') + 1: ].find('S')] = 1\nif d[-1]: print(-1)\nelse: print(sum(d))\n", "n = int(input())\npeople = []\nfor i in range(n):\n    people.append(tuple(int(x) for x in input().split()))\ndiss = sum(n*p[1]-p[0] for p in people) # the const part\na_b = list([p[0]-p[1] for p in people])\na_b.sort(reverse=True)\ndiss += sum((idx+1)*val for idx, val in enumerate(a_b))\nprint(diss)\n", "def add(ans, r, c):\n    if cells[r][c] == '0':\n        cells[r][c] = '1'\n        rc = r, c\n        ans.append(rc)\n\n\ndef dfs(r, c):\n    ans = [(r, c)]\n    for r, c in ans:\n        if c != 1:\n            add(ans, r, c - 1)\n        if c != n:\n            add(ans, r, c + 1)\n        if r != 1:\n            add(ans, r - 1, c)\n        if r != n:\n            add(ans, r + 1, c)\n    return ans\n\n\nn = int(input())\nr1, c1 = list(map(int, input().split()))\nr2, c2 = list(map(int, input().split()))\nres = 5000  # n ** 2 * 2\ncells = (['1'],) + tuple((['1'] + list(input()) for _ in range(n)))\ndfs1 = dfs(r1, c1)\nfor rs, cs in dfs(r2, c2):\n    for rt, ct in dfs1:\n        res = min(res, (rs - rt) ** 2 + (cs - ct) ** 2)\nprint(res)\n", "t=int(input())\nfor i in range(t):\n    rgb=list(map(int,input().split()))\n    rgb.sort()\n    if rgb[2]-1>rgb[0]+rgb[1]:\n        print('No')\n    else:\n        print('Yes')\n", "N=int(input())\nHor=Ver=1\n\nH=[]\nV=[]\nfor I in range(N):\n    Tmp=list(map(int,input().split()))\n    H+=[Tmp[0]]\n    V+=[Tmp[1]]\nH.sort()\nV.sort()\nTmp1=H[0]\nTmp2=V[0]\nfor I in range(1,N):\n    Hor+=1 if not Tmp1==H[I] else 0\n    Ver+=1 if not Tmp2==V[I] else 0\n    Tmp1=H[I]\n    Tmp2=V[I]\n    \nprint(min(Hor,Ver))\n", "n = int(input())\ns = input()\nf1 = 0\nf2 = 0\nres = 0\nfor i in range(len(s)):\n    if(s[i] == \"L\"):\n        if f1 == 0:\n            f1 = -1\n        if f1 == 1:\n            res += 1\n            f1 = -1\n            f2 = 0\n    if(s[i] == \"R\"):\n        if f1 == 0:\n            f1 = 1\n        if f1 == -1:\n            res += 1\n            f1 = 1\n            f2 = 0\n    if(s[i] == \"U\"):\n        if f2 == 0:\n            f2 = -1\n        if f2 == 1:\n            res += 1\n            f1 = 0\n            f2 = -1\n    if(s[i] == \"D\"):\n        if f2 == 0:\n            f2 = 1\n        if f2 == -1:\n            res += 1\n            f1 = 0\n            f2 = 1\nif (f1 != 0 or f2 != 0):\n    res += 1\nprint(res)", "input()\na = list(map(int, input().split()))\n\ndiff_sum = 0\nb = []\n\nfor i, ai in enumerate(a[::-1]):\n    bi = ai - (1 if i % 2 == 0 else -1) * diff_sum\n    diff_sum += (1 if i % 2 == 0 else -1) * bi\n    b.append(bi)\n\nprint(\" \".join(map(str, reversed(b))))\n", "n = int(input())\nm = 2 * n + 1\nu = [[] for i in range(m)]\nv = [0] * m\ns = [0] * m\nd = 10 ** 9 + 7\ny = 1\n\nfor j in range(n):\n    a, b = map(int, input().split())\n    v[a] = b\n    if a != b:\n        s[b] += 1\n        u[b].append(a)\n\nfor b in range(m):\n    if not v[b]:\n        x = 0\n        p = [b]\n        while p:\n            x += 1\n            a = p.pop()\n            s[a] = -1\n            p += u[a]\n        y = (x * y) % d\n\nfor a in range(m):\n    if s[a] == 0:\n        b = v[a]\n        while s[b] == 1:\n            s[b] = -1\n            b = v[b]\n        s[b] -= 1\n\nfor a in range(m):\n    if s[a] == 1:\n        y = (2 * y) % d\n        while s[a]:\n            s[a] = 0\n            a = v[a]\n\nprint(y)", "import math\n\ndef main():\n    (n, xs, ys) = tuple([int(x) for x in input().split()])\n\n    p1 = 0\n    p2 = 0\n    p3 = 0\n    p4 = 0\n    for i in range(n):\n        (x, y) = tuple([int(x) for x in input().split()])\n\n        if x < xs:\n            p1 += 1\n        if x > xs:\n            p2 += 1\n        if y < ys:\n            p3 += 1\n        if y > ys:\n            p4 += 1\n\n    p = max(p1, p2, p3, p4)\n    print(p)\n    best = []\n    if p1 == p:\n        best = [xs - 1, ys]\n    elif p2 == p:\n        best = [xs + 1, ys]\n    elif p3 == p:\n        best = [xs, ys - 1]\n    else:\n        best = [xs, ys + 1]\n    print(' '.join([str(x) for x in best]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom queue import deque\n\n# sys.stdin = open('ivo.in')\n\nmove = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nn, m, k = map(int, sys.stdin.readline().split())\n\na = []\nfor i in range(n):\n    a.append(sys.stdin.readline().rstrip())\n\n\nvisited = []\nvalues = []\nfor x in range(n):\n    visited.append([])\n    values.append([])\n    for y in range(m):\n        visited[x].append(False)\n        values[x].append(0)\n\n\nfor x in range(n):\n    for y in range(m):\n        if a[x][y] == '*' or visited[x][y]:\n            continue\n        q = deque()\n        visited[x][y] = True\n        q.append((x, y))\n        sum = 0\n        connected = [(x, y)]\n        while len(q) != 0:\n            cur = q.pop()\n            for l in move:\n                tx = cur[0] + l[0]\n                ty = cur[1] + l[1]\n                if tx < 0 or tx >= n or ty < 0 or ty >= m:\n                    continue\n                if a[tx][ty] == '.' and visited[tx][ty]:\n                    continue\n                if a[tx][ty] == '*':\n                    sum += 1\n                    continue\n                q.append((tx, ty))\n                visited[tx][ty] = True\n                connected.append((tx, ty))\n        for c in connected:\n            values[c[0]][c[1]] = sum\n\nfor i in range(k):\n    x, y = map(int, sys.stdin.readline().split())\n    print(values[x - 1][y - 1])", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nn = int(input())\nsnacks = list(map(int, input().split()))\nstatus = [False] * (n + 1)\n\nbiggest = n\nfor day, snack in enumerate(snacks):\n    status[snack] = True\n    ret = ''\n    if biggest == snack:\n        biggest -= 1\n        while status[biggest] and biggest >= 1:\n            biggest -= 1\n        ret_list = list(range(biggest + 1, snack + 1))\n        ret = ' '.join(map(str, reversed(ret_list)))\n    print(ret)\n            \n            \n\n    \n", "import math\n\n\n#n, s = tuple(map(int, input().split()))\n#floors = [0 for i in range(s + 1)]\n\n#for i in range(n):\n#    floor, time = tuple(map(int, input().split()))\n#    floors[floor] = max(floors[floor], time)\n\n#res = s\n#for i in range(s + 1):\n#    res = max(res, floors[i] + i)\n\n#print(res)\n\na = input()\nb = input()\nshift = [0]\nfor i in range(len(b) - len(a) + 1):\n    shift[0] += int(b[i])\nfor i in range(len(a) - 1):\n    shift.append(shift[i] - int(b[i]) + int(b[len(b) - len(a) + i + 1]))\n\nres = 0\nfor i in range(len(a)):\n    if a[i] == '0':\n        res += shift[i]\n    else:\n        res += len(b) - len(a) + 1 - shift[i]\nprint(res)\n\n", "T=int(input())\nfor i in range(T):\n     s=list(input())\n     s.sort()\n     k=len(s)\n     s1=[] ; s3=[]\n     s2=[0]*150\n     pro=True\n     for j in range(k):\n          s2[ord(s[j])]+=1\n     for j in range(97,123,2):\n          if s2[j]>0:\n              s3+=[chr(j)]*s2[j]\n     for j in range(98,123,2):\n          if s2[j]>0:\n              s3+=[chr(j)]*s2[j]\n     for j in range(98,123,2):\n          if s2[j]>0:\n              s1+=[chr(j)]*s2[j]\n     for j in range(97,123,2):\n          if s2[j]>0:\n              s1+=[chr(j)]*s2[j]\n     for j in range(k-1):\n          if abs(ord(s1[j])-ord(s1[j+1]))==1:\n               pro=False\n               break\n     if pro:\n          print(*s1,sep=\"\")\n     else:\n          pro=True\n          for j in range(k-1):\n               if abs(ord(s3[j])-ord(s3[j+1]))==1:\n                    pro=False\n          if pro:\n               print(*s3,sep=\"\")\n          else:\n               print(\"No answer\")", "# You lost the game.\nn = int(input())\nA = list(map(int, input().split()))\n\nV = [0 for _ in range(n)]\nG = V[:]\n\ndef visiter(i,d):\n    nonlocal V\n    nonlocal G\n    G[i] = d+1\n    V[i] = d+1\n    c = d+2\n    while 1:\n        if V[A[i]-1] and G[A[i]-1] > d:\n            return 1,c-G[A[i]-1],G[A[i]-1]-1-d,c\n        elif V[A[i]-1]:\n            return 0,0,c-1-d,c\n        else: \n            G[A[i]-1] = c\n            c += 1\n            V[A[i]-1] = 1\n            i = A[i]-1\n\n\n\nT = [1 for _ in range(n+1)]\nfor i in range(1,n+1):\n    T[i] = (T[i-1]*2) % (10**9 + 7)\n\nR = []\nd = 0\ni = 0\nc = 0\nfor i in range(n):\n    if V[i] == 0:\n        v,l,s,c = visiter(i,c)\n        if v:\n            R += [l]\n        d += s\n        \nr = T[d]\nfor x in R:\n    r = (r*(T[x]-2)) % (10**9 + 7)\nprint(r)\n", "from heapq import heappush, heappop\n\nN, K = [int(s) for s in input().split()]\nsongs = []\nbeauties = set()\nfor _ in range(N):\n    t, b = [int(s) for s in input().split()]\n    beauties.add(b)\n    songs.append((t, b))\nsongs.sort(key= lambda x: x[1], reverse=True)\nmax_pleasure = 0\ntotal_length = 0\nmax_lengths = []\nfor i in range(K):\n    total_length += songs[i][0]\n    heappush(max_lengths, songs[i][0])\n    max_pleasure = max(max_pleasure, total_length * songs[i][1])\nfor i in range(K, N):\n    if max_lengths[0] < songs[i][0]:\n        min_length = heappop(max_lengths)\n        heappush(max_lengths, songs[i][0])\n        total_length = total_length - min_length + songs[i][0]\n        max_pleasure = max(max_pleasure, total_length * songs[i][1])\nprint(max_pleasure)\n\n", "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = [int(j) for j in input().split()]\n\tz = arr.count(0)\n\n\tsu = sum(arr) + z\n\n\tif su == 0:\n\t\tz += 1\n\tprint(z)", "def main():\n    mode=\"filee\"\n    if mode==\"file\":f=open(\"test.txt\",\"r\")\n    get = lambda :[int(x) for x in (f.readline() if mode==\"file\" else input()).split()]\n    gets = lambda :[str(x) for x in (f.readline()[:-1] if mode==\"file\" else input()).split(\":\")]\n    [n,m,t]=get()\n    [a,b]=[[0]*20002,[0]*20002]\n    if n<m:\n        print(\"No solution\")\n        return\n    for i in range(1,n+1):\n        g = gets()\n        a[i] = int(g[-1]) + int(g[1])*60 + int(g[0])*3600\n    [p,count,sim,ist] = [1,0,0,False]\n    for i in range(1,n+1):\n        while p<i and a[i] - t + 1>a[p]:\n            p+=1\n            if b[p]!=b[p-1]:\n                sim = max(sim-1,0)\n        if a[i]<a[p]+t and sim<m:\n            [count,sim] = [count+1,sim+1]\n        if sim==m:\n            ist=True\n        b[i] = count\n    if ist==False:\n        print(\"No solution\")\n        return\n    print(count)\n    for i in range(1,n+1):\n        print(b[i],end=' ')\n\n    if mode==\"file\":f.close()\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n, m, q = map(int, input().split())\na = sorted(map(int, input().split()), reverse=True)\nb = sorted(map(int, input().split()), reverse=True)\nc = sorted(map(int, input().split()), reverse=True)\ndp = [[[0] * 201 for _ in range(201)] for _ in range(201)]\nfor ijk in range(n + m + q + 1):\n    for i in range(min(n + 1, ijk + 1)):\n        for j in range(min(m + 1, ijk - i + 1)):\n            k = ijk - i - j\n            if k < 0 or k > q:\n                continue\n            if i + 1 <= n:\n                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])\n            if j + 1 <= m:\n                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])\n            if k + 1 <= q:\n                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])\n            if i + 1 <= n and j + 1 <= m:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])\n            if i + 1 <= n and k + 1 <= q:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])\n            if j + 1 <= m and k + 1 <= q:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])\nprint(dp[n][m][q])", "l, r = list(map(int, input().split()))\nprint(\"YES\")\nfor i in range(l, r, 2):\n    print(i, i + 1)\n", "n,m=list(map(int,input().split()))\ns=list(input().split())\nt=list(input().split())\nq=int(input())\nfor _ in range(q):\n    e=int(input())-1\n    print(s[e%n]+t[e%m])\n", "m,k=list(map(int,input().split()))\n\nD=list(map(int,input().split()))\n\nS=list(map(int,input().split()))\n\nans=0\n\nfuel=S[0]\n\nmaxx=S[0]\n\nfor i in range(m):\n\n    if(D[i]>fuel):\n\n        x=D[i]-fuel\n\n        y=x//maxx\n\n        if(x%maxx>0):\n\n            y+=1\n\n        ans+=y*k\n\n        fuel+=maxx*y\n\n        fuel-=D[i]\n\n        ans+=D[i]\n\n        if(i+1==m):\n\n            break\n\n        fuel+=S[i+1]\n\n        maxx=max(S[i+1],maxx)\n\n    else:\n\n        fuel-=D[i]\n\n        ans+=D[i]\n\n        if(i+1==m):\n\n            break\n\n        fuel+=S[i+1]\n\n        maxx=max(S[i+1],maxx)\n\nprint(ans)\n\n", "n, m = int(input()), 0\nb = [int(t) for t in input().split()]\na = []\nfor i in range(n):\n\ta.append(b[i])\n\twhile len(a) > 1 and a[-2] == a[-1]:\n\t\tdel a[-1]\n\t\ta[-1] += 1\nprint(len(a))\nprint(\" \".join([str(t) for t in a]))\n", "# https://codeforces.com/problemset/problem/802/B\nimport heapq\n\nn, k  = map(int, input().split())\na     = list(map(int, input().split()))\nd     = {}\npos   = {}\nQ     = []\ncnt   = 0\n\nfor i, x in enumerate(a):\n    if x not in pos:\n        pos[x] = []\n    pos[x].append(i)\n    \nfor i, x in enumerate(a):\n   \n    if x not in d:\n        cnt += 1\n        \n        if len(d) == k:\n            pos_, x_ = heapq.heappop(Q)\n            del d[x_]\n        d[x] = 1\n        \n    pos[x].pop(0)\n    \n    if len(pos[x]) > 0:\n        heapq.heappush(Q, (-pos[x][0], x))\n    else:\n        heapq.heappush(Q, (-float('inf'), x))   \n        \nprint(cnt)        ", "#Zad\nfrom collections import Counter\nn=int(input())\ntree=[]\nfor i in range(n-1):\n    tree.extend(list(map(int,input().split())))\nans=Counter(tree)\nif ans.most_common(2)[1][1]>2: print('No')\nelse:\n    print('Yes')\n    if n==2:\n        print(1)\n        print('1 2')\n    else:\n        if ans.most_common(1)[0][1]==2:\n            print(1)\n            print(ans.most_common()[-2][0], ans.most_common()[-1][0])\n        else:\n            center=ans.most_common(1)[0][0]\n            kraya=[n[0] for n in ans.most_common() if n[1]==1]\n            print(len(kraya))\n            for i in kraya:\n                print(center, i)", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/9/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef issub(u, v):\n    if u > v:\n        return False\n    if u == v:\n        return True\n    \n    b = 1\n    for i in range(v.bit_length()+1):\n        if v & b < u & b:\n            return False\n        b <<= 1\n    return True\n\n\ndef solve(N, A, B):\n    vi = collections.defaultdict(list)\n    for i, v in enumerate(A):\n        vi[v].append(i)\n        \n    wc = collections.Counter(A)\n    group = {k for k, v in wc.items() if v > 1}\n    others = {u for u in wc.keys() if u not in group and any(issub(u, v) for v in group)}\n    group |= others\n    \n    ans = 0\n    for u in group:\n        ans += sum([B[i] for i in vi[u]])\n    \n    return ans\n    \n\n# def test():\n#     N = 7000\n#     import random\n#     A = [random.randint(1, 10000) for i in range(N)]\n#     B = [random.randint(0, 10**9) for _ in range(N)]\n#     t0 = time.time()\n#     print(solve(N, A, B))\n#     print(time.time() - t0)\n#\n# test()\n#\nN = int(input())\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nprint(solve(N, A, B))", "def main():\n    h, w = list(map(int, input().split()))\n    l = [[c == '.' for c in input()] for _ in range(h)]\n    ver = [[0] * (w + 1) for _ in range(h + 1)]\n    for y, aa, bb, l0, l1 in zip(list(range(h - 1)), ver, ver[1:], l, l[1:]):\n        for x in range(w):\n            bb[x + 1] = (l0[x] and l1[x]) + bb[x] + aa[x + 1] - aa[x]\n    hor = [[0] * (w + 1) for _ in range(h + 1)]\n    for y, aa, bb, l0 in zip(list(range(h)), hor, hor[1:], l):\n        for x in range(w - 1):\n            bb[x + 1] = (l0[x] and l0[x + 1]) + bb[x] + aa[x + 1] - aa[x]\n    res = []\n    for _ in range(int(input())):\n        r1, c1, r2, c2 = list(map(int, input().split()))\n        r1 -= 1\n        c1 -= 1\n        res.append(str(ver[r2 - 1][c2] - ver[r1][c2] - ver[r2 - 1][c1] + ver[r1][c1] +\n                       hor[r2][c2 - 1] - hor[r1][c2 - 1] - hor[r2][c1] + hor[r1][c1]))\n    print('\\n'.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\ns = ['WB' * (n // 2) + 'W' * (n % 2), 'BW' * (n // 2) + 'B' * (n % 2)]\nfor i in range(n):\n    print(s[i % 2])\n", "t = int(input())\nfor i in range (t):\n    a, b = list(map(int,input().split()))\n    if a > 3:\n        print(\"YES\")\n    elif a == 1:\n        if b == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        if b < 4:\n            print(\"YES\")\n        else:\n            print(\"NO\")", "import math\n\n\nn,r=list(map(int,input().split()))\na=list(map(int,input().split()))\n\n\n\nnew=[r for i in range(n)]\n\nfor i in range(1,n):\n    for j in range(i):\n        temp=(2*r)**2 - (a[i]-a[j])**2        \n        if(temp>=0):\n            new[i]=max(new[i],math.sqrt(temp)+new[j])\nprint(*new)\n\n\n\n\n", "from sys import stdin\ncases=int(stdin.readline().strip())\nfor i in range(cases):\n    n=int(stdin.readline().strip())\n    s=stdin.readline().strip()\n    if n>2 or s[0]<s[1]:\n        print(\"YES\")\n        print(2)\n        print(s[0],s[1::])\n    else:\n        print(\"NO\")\n        \n\n", "n = int(input())\ns = 0\nmi = 1e9\nfor i in range(n):\n    a, p = map(int, input().split())\n    mi = min(mi, p)\n    s += a * mi\nprint(s)", "n, k = map(int, input().split())\nx = [int(i) for i in input().split()]\n\nfirst = [int(k + 1) for _ in range(n + 1)]\nlast = [int(-1) for _ in range(n + 1)]\n\nfor i in range(k):\n    first[x[i]] = min(first[x[i]], i)\n    last[x[i]] = max(last[x[i]], i)\n\ncnt = 0\nfor i in range(1,n+1):\n    if last[i] == -1:\n        cnt += 1\n    if i+1 <= n:\n        if last[i] < first[i+1]:\n            cnt += 1\n        if last[i+1] < first[i]:\n            cnt += 1\n\nprint(cnt)", "input()\nt = list(map(int, input().split()))\ns, m = 0, 1000000007\np = {i for i, q in enumerate(t, 1) if q == -1}\nn, k = len(p), len(p - set(t))\nd, c = 2 * (n & 1) - 1, 1\nfor j in range(n + 1):\n    d = -d * max(1, j) % m\n    if n - j <= k:\n        s += c * d\n        c = c * max(1, n - j) * pow(k - n + j + 1, m - 2, m) % m\nprint(s % m)", "n, m = map(int, input().split())\nd = { }\nfor i in range(m):\n    a, b = input().split()\n    d[a] = b if len(b) < len(a) else a\nfor word in input().split():\n    print(d[word], end=' ')\nprint()\n", "n = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nisi = [0] * n\nd = {}\nhead = n\nfor i in range(len(b)):\n\td[a[i]] = i \nres = []\nhead = 0\nfor i in range(n):\n\tif isi[b[i] - 1] == 0:\n\t\tind = d[b[i]]\n\t\tkol = 0\n\t\tfor j in range(head, ind + 1):\n\t\t\tisi[a[j] - 1] = 1\n\t\t\tkol += 1\n\t\tres.append(kol)\n\t\thead = ind + 1\n\telse:\n\t\tres.append(0)\nfor c in res:\n\tprint(c, end = ' ')\n", "import heapq\n\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n + 1)]\nfor i in range(1, m + 1):\n    u, v, w = list(map(int, input().split()))\n    g[u].append((i, v, w))\n    g[v].append((i, u, w))\nsrc = int(input())\n\npq = [(0, 0, src, -1)]\nmk = [0] * (n + 1)\nt = []\ns = 0\nwhile pq:\n    d, w, u, e = heapq.heappop(pq)\n    if mk[u]:\n        continue\n    mk[u] = 1\n    s += w\n    t.append(e)\n    for e, v, w in g[u]:\n        if not mk[v]:\n            heapq.heappush(pq, (d + w, w, v, e))\n\nprint(s)\nprint(*t[1:])\n", "x = int('00001111', 2)\ny = int('00110011', 2)\nz = int('01010101', 2)\nE = set()\nT = set()\nF = {('x', x), ('y', y), ('z', z)}\nprv = (set(), set(), set())\nfam = 2 ** 8\ntmpl = '#' * 99\nans = [tmpl] * fam\ndef cmpr(E):\n    nonlocal ans\n    ans = [tmpl] * fam\n    for e in E:\n        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:\n            ans[e[1]] = e[0]\n    return set((j, i) for i, j in enumerate(ans) if j != tmpl)\nwhile prv != (E, T, F):\n    prv = E.copy(), T.copy(), F.copy()\n    for f in prv[2]:\n        F.add(('!' + f[0], ~f[1] & (fam - 1)))\n        T.add(f)\n        for t in prv[1]:\n            T.add((t[0] + '&' + f[0], t[1] & f[1]))\n    for t in prv[1]:\n        E.add(t)\n    for e in prv[0]:\n        if e not in F:\n            F.add(('(' + e[0] + ')', e[1]))\n        for t in prv[1]:\n            E.add((e[0] + '|' + t[0], e[1] | t[1]))\n    E, T, F = cmpr(E), cmpr(T), cmpr(F)\ncmpr(E)\nn = int(input())\nfor i in range(n):\n\tprint(ans[int(input(), 2)])", "for i in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\n\tt = 0\n\tfor i in range(1, n):\n\t\tif a[i] < a[i-1]:\n\t\t\tt += a[i-1]-a[i]\n\tprint(t)", "n = int(input())\n\nv = []\nu = []\nfor i in range(n):\n\tx = input().split(' ')\n\ta = int(x[0])\n\tb = int(x[1])\n\tif a > b:\n\t\tv.append((a,b,i + 1))\n\telse:\n\t\tu.append((a,b,i+1))\n\n'''nr = 1\nsol = [str(v[0][2])]\nact = v[0][1]\ni = 1\nn = len(v)\nwhile i < n:\n\twhile i < n and v[i][0] < act:\n\t\ti += 1\n\tif i < n:\n\t\tnr += 1\n\t\tsol.append(str(v[i][2]))\n\t\tact = v[i][1]\n\t\ti += 1\n\nu = sorted(uv, key = lambda x:x[1])\nnr2 = 1\nsol2 = [str(u[0][2])]\nact = u[0][1]\ni = 1\nn = len(u)\nwhile i < n:\n\twhile i < n and u[i][0] < act:\n\t\ti += 1\n\tif i < n:\n\t\tnr2 += 1\n\t\tsol2.append(str(u[i][2]))\n\t\tact = u[i][1]\n\t\ti += 1'''\nif len(u) > len(v):\n\tu = sorted(u, key = lambda x:x[1], reverse = True)\n\tprint(len(u))\n\tsol = []\n\tfor i in range(len(u)):\n\t\tsol.append(str(u[i][2]))\n\tprint(' '.join(sol))\nelse:\n\tv = sorted(v, key = lambda x:x[1], reverse = False)\n\tprint(len(v))\n\tsol = []\n\tfor i in range(len(v)):\n\t\tsol.append(str(v[i][2]))\n\tprint(' '.join(sol))\n\n", "n,m=map(int,input().split())\nd=[0]*n\ne=[[] for i in range(n)]\nfor i in range(m):\n\tu,v=map(int,input().split())\n\tu-=1\n\tv-=1\n\td[u]+=1\n\te[v].append(u)\nfrom heapq import heappush, heappop\npq=[]\nfor i in range(n):\n\tif d[i]==0:\n\t\theappush(pq,-i)\nind=n\nans=[0]*n\nwhile(pq):\n\tu=-heappop(pq)\n\tans[u]=ind\n\tind-=1\n\tfor v in e[u]:\n\t\td[v]-=1\n\t\tif d[v]==0:\n\t\t\theappush(pq,-v)\nprint(' '.join(str(x) for x in ans))", "class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nn,q=map(int,input().split())\na=list(map(int,input().split()))\nbit=BIT(2**n)\nfor i in range(2**n):\n    bit.update(i+1,a[i])\nb=0\n\ndef Sum(r,xor):\n    id=xor\n    res=0\n    if r==-1:\n        return res\n    for i in range(n,-1,-1):\n        if r>>i &1:\n            L=(id>>i)<<i\n            R=L+(1<<i)-1\n            res+=bit.query(R+1)-bit.query(L)\n            id^=(1<<i)\n    return res\n\n\nfor _ in range(q):\n    query=tuple(map(int,input().split()))\n    if query[0]==1:\n        g,x,k=query\n        x-=1\n        x^=b\n        bit.update(x+1,k-a[x])\n        a[x]=k\n    elif query[0]==2:\n        k=query[1]\n        b^=2**k-1\n    elif query[0]==3:\n        k=query[1]\n        if k!=n:\n            b^=2**k\n    else:\n        gl,l,r=query\n        l-=1\n        test=Sum(r,b)-Sum(l,b)\n        print(test)", "n, a, b=map(int, input().split())\nd=list(map(int, input().split()))\nans=[0]*n\nfor i in range(n):\n    ans[i]=(int)(d[i]*a%b/a)\nprint(*ans)", "h,q=list(map(int,input().split()))\nd=[(2**h,0),(2**(h-1),0)]\nfor _ in range(q):\n\ti,l,r,a=list(map(int,input().split()))\n\tl,r=l*2**(h-i),(r+1)*2**(h-i)\n\td.extend([[(l,1),(r,-1)],[(0,1),(l,-1),(r,1)]][a])\ns=0\nl=0\nd=sorted(d)\nfor (a,x),(b,_) in zip(d,d[1:]):\n\ts+=x\n\tif a!=b and s==0:q=a;l+=b-a\nprint((\"Game cheated!\",q,\"Data not sufficient!\")[min(l,2)])\n\n", "n, m = map(int, input().split())\na = [input() for i in range(n)]\nans = 0\ni = 0\nwhile i < m:\n    if a[n-1][i] == \"B\":\n        ans += 1\n        while i < m and a[n-1][i] == \"B\":\n            i += 1\n    i += 1\n\nprint(ans)", "n=int(input())\no=1\ne=2\nimport sys\nfor i in range(n):\n    for j in range(n):\n        if abs(i-n//2)+abs(j-n//2)<=n//2:\n            sys.stdout.write(str(o))\n            o+=2\n        else:\n            sys.stdout.write(str(e))\n            e+=2\n        sys.stdout.write(' ')\n    sys.stdout.write('\\n')", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\nl = []\nfor _ in range(n):\n    l.append(input().strip())\n\ndef witch(s):\n    out = 0\n    if s[0] != s[1]:\n        out += 2\n    if s[1] != s[2]:\n        out += 1\n    return out\n\nif n >= 4 and m >= 4:\n    print(-1)\nelse:\n    if n < m:\n        n, m = m, n\n        l = [''.join([l[j][i] for j in range(m)]) for i in range(n)]\n    if m == 1:\n        print(0)\n    elif m == 2:\n        even = 0\n        odd = 0\n        first = l.pop(0)\n        if first == '00' or first == '11':\n            odd += 1\n        else:\n            even += 1\n        for nex in l:\n            if nex == '00' or nex == '11':\n                odd, even = even + 1, odd\n            else:\n                odd, even = even, odd + 1\n        print(min(even, odd))\n    elif m == 3:\n        #ee, eo, oe, oo = [0, 0, 0 ,0]\n        ll = [0, 0, 0, 0]\n        for nex in l:\n            ll.reverse()\n            ll[witch(nex)] += 1\n        print(n - max(ll))\n        \n        \n", "n, m, k = list(map(int, input().split(\" \")))\n\ns = False\n\ndef nex(x, y, s):\n\tif (y == 1 or y == m) and s:\n\t\treturn x + 1, y, False\n\tif x % 2:\n\t\treturn x, y + 1, True\n\treturn x, y - 1, True\n\nxc = 1\nyc = 1\nfor i in range(k - 1):\n\tprint(2, end = \" \")\n\tprint(xc, yc, end = \" \")\n\txc, yc, s = nex(xc, yc, s)\n\tprint(xc, yc)\n\txc, yc, s = nex(xc, yc, s)\n\nprint(n * m - (k - 1) * 2, end = \" \")\nfor i in range(n * m - (k - 1) * 2):\n\tprint(xc, yc, end=\" \")\n\txc, yc, s = nex(xc, yc, s)\n\n", "from sys import stdin\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\nn, k = arr_inp(1)\nc = sorted(arr_inp(1))[::-1]\n\nfor i in range(min(n, k)):\n    print(1, c[i])\n    k -= 1\n\ntem = []\nfor i in range(min(n - 1, k)):\n    tem.append(c[i])\n    for j in range(n - 1, i, -1):\n        print(i + 2, end=' ')\n        print(*(tem + [c[j]]))\n        k -= 1\n        if not k:\n           return\n\n", "n = int(input())\nif n % 2 == 1:\n    print(-1)\nelse:\n    edges = [[] for i in range(n)]\n    for i in range(n-1):\n        [a,b] = [int(j) for j in input().split()]\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n    dfs_stack = [0]\n    c = [1 for i in range(n)]\n    visited = [-1 for i in range(n)]\n    visited[0] = 0\n    \n    while dfs_stack != []:\n        current_node = dfs_stack[-1]\n        can_go_further = False\n        for i in edges[current_node]:\n            if visited[i] == -1:\n                dfs_stack.append(i)\n                visited[i] = current_node\n                can_go_further = True\n        if can_go_further == False:\n            dfs_stack.pop(-1)\n            c[visited[current_node]] += c[current_node]\n    \n    ans = 0\n    for i in c[1:]:\n        if i % 2 == 0:\n            ans += 1\n    print(ans)", "s = input()\nmetals = []\nheavys = []\nind = cur = -1\nwhile True:\n    cur = s.find('heavy', ind + 1)\n    if cur != -1:\n        heavys.append(cur)\n        ind = cur\n    else:\n        break\nind = cur = -1\nwhile True:\n    cur = s.find('metal', ind + 1)\n    if cur != -1:\n        metals.append(cur)\n        ind = cur\n    else:\n        break\nind = ans = 0\nfor x in metals:\n    while ind < len(heavys) and heavys[ind] < x:\n        ind += 1\n    ans += ind\nprint(ans)", "n = int(input())\na = int(n ** 2 + 1)\nt = 1\n\nfor i in range(1, n+1):\n    for j in range(int(n/2) - 1):\n        print('%d %d' % (t, a - t), end = ' ')\n        t += 1\n    print('%d %d' % (t, a - t))\n    t += 1", "#by Nick \"LordVader\" Proshin.\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            print(mx, mx, mx, mx)\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            print(res[minj],res[minj],res[minj+1],res[minj+1])", "n=int(input())\nex1=0\nex2=0\nL=[]\nf=[0]*(n+1)\nfor i in range(n):\n    L.append(int(input()))\n    while (L[i] - L[ex1 ] >= 90):\n        ex1+=1\n    while (L[i] - L[ex2 ] >= 1440):\n        ex2+=1\n    f[i+1] = min(min(f[ex1] + 50, f[ex2] + 120), f[i] + 20)\n    print(f[i+1] - f[i])\n", "a = int(input())\n\nfor i in range(a//2):\n    print('*' * ((a//2)-i), end='')\n    print('D' * (i*2+1), end='')\n    print('*' * ((a//2)-i), end='')\n    print()\n\n\nfor i in range(a//2, -1, -1):\n    print('*' * ((a//2)-i), end='')\n    print('D' * (i*2+1), end='')\n    print('*' * ((a//2)-i), end='')\n    print()\n", "import heapq\n\nn, k, q = [int(x) for x in input().split()]\nt = [int(x) for x in input().split()]\n\nheap = []\nfor i in range(q):\n    query_type, query_id = [int(x) for x in input().split()]\n    if query_type == 1:\n        if len(heap) < k or t[query_id - 1] > heap[0]:\n            if len(heap) == k:\n                heapq.heappop(heap)\n            heapq.heappush(heap, t[query_id - 1])\n    else:\n        print('YES' if t[query_id - 1] in heap else 'NO')\n", "def main():\n    R = lambda: map(int, input().split())\n    n, m = R()\n    p = [0] + list(R())\n    for _ in range(m):\n        l, r, x = R()\n        v = p[x]\n        c = sum(map(lambda x: x < v, p[l:r+1]))\n        print('Yes' if c == x - l else 'No')\nmain()", "for _ in range(int(input())):\n    s = input()\n    if s.endswith(\"po\"):\n        print(\"FILIPINO\")\n    elif s.endswith(\"desu\") or s.endswith(\"masu\"):\n        print(\"JAPANESE\")\n    elif s.endswith(\"mnida\"):\n        print(\"KOREAN\")\n\n\n", "def dist_sq(x1, y1, x2, y2):\n    return (x1 - x2)**2 + (y1 - y2)**2\n\nn, x1, y1, x2, y2 = map(int, input().split())\nR1, R2 = [], []\nfor i in range(n):\n    x, y = map(int, input().split())\n    R1.append(dist_sq(x, y, x1, y1))\n    R2.append(dist_sq(x, y, x2, y2))\n\n#candidate for r1(squared)\ncand_r1 = set(R1)\ncand_r1.add(0)\nans = 10**20    #inf\nfor r1 in cand_r1:\n    r2 = 0\n    for i in range(n):\n        if R1[i] > r1:\n            r2 = max(r2, R2[i])\n    ans = min(ans, r1+r2)\nprint(ans)", "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nn=int(input())\nl=list(map(int,input().split()))\nprint(LongestIncreasingSubsequenceLength(l, n))\n", "__author__ = 'Utena'\ndef t(x):\n    a=''\n    for l in x:\n        if l=='+':\n            a+='*'\n        elif l=='*':\n            a+='+'\n    return a\nk=int(input())\nif k==0:\n    print('+')\n    return\nm=['++','+*']\ns=1\nfor i in range(k-1):\n    m=m+m\n    s*=2\n    for j in range(s):\n        m[j]+=m[j]\n        m[s+j]+=t(m[s+j])\nfor y in m:\n    print(y)", "for i in range(int(input())):\n    n = int(input())\n    e = 10000000000000000\n    s = -10000000000000000\n    for i in range(n):\n        a,b = map(int,input().split())\n        e = min(e,b)\n        s = max(a,s)\n    print(max(0,s-e))", "import sys\nfrom math import floor, ceil\n\nIS_LOCAL = False\n\n\ndef read_one(dtype=int):\n    return dtype(input())\n\n\ndef read_multiple(f, dtype=int):\n    return f(list(map(dtype, input().split())))\n\n\ndef main():\n    a = '01100010'\n    b = '00110'\n\n    if not IS_LOCAL:\n        a = input()\n        b = input()\n\n    def cst(x):\n        return 0 if x == '0' else 1\n\n    def rsum(arr):\n        return sum(map(cst, arr))\n\n    sb, lb = rsum(b), len(b)\n    s = None\n    res = 0\n    for i in range(lb - 1, len(a)):\n        if s is None:\n            s = rsum(a[:lb])\n        else:\n            s = s - cst(a[i - lb]) + cst(a[i])\n\n        if (s - sb) % 2 == 0:\n            res += 1\n\n    print(res)\n\n\ndef __starting_point():\n    if len(sys.argv) > 1 and sys.argv[1] == 'True':\n        IS_LOCAL = True\n    main()\n\n__starting_point()", "def mergesort(s):\n    if len(s) == 1:\n        return s\n    s1 = mergesort(s[:len(s) // 2])\n    s2 = mergesort(s[len(s) // 2:])\n    return merge(s1, s2)\n\n\ndef merge(s1, s2):\n    f = []\n    ind1 = 0\n    ind2 = 0\n    while ind1 != len(s1) and ind2 != len(s2):\n        if str(s1[ind1]) + str(s2[ind2]) > str(s2[ind2]) + str(s1[ind1]):\n            f.append(s2[ind2])\n            ind2 += 1\n        else:\n            f.append(s1[ind1])\n            ind1 += 1\n    if ind1 != len(s1):\n        f.extend(s1[ind1:])\n    else:\n        f.extend(s2[ind2:])\n    return f\n\n\nn = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nprint(''.join(mergesort(s)))", "t = int(input())\nfor _ in range(t):\n    s = input()\n    a = -1\n    b = -1\n    c = -1\n    mn = 10 ** 9\n    for i in range(len(s)):\n        if s[i] == '1':\n            a = i\n        elif s[i] == '2':\n            b = i\n        else:\n            c = i\n        if a != -1 and b != -1 and c != -1:\n            mn = min(mn, max(a, b, c) - min(a, b, c) + 1)\n    if mn == 10 ** 9:\n        print(0)\n    else:\n        print(mn)\n\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n \nN, M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\n \ninf = 1 << 20\nA, B, C = [], [], []\nX = [0] * N\nfor a in E[0]:\n    X[a] = 1\nA = [i for i in range(N) if X[i]==0]\nb = min([i for i in range(N) if X[i] == 1] + [inf])\nif b < inf:\n    for a in E[b]:\n        if X[a] == 1: X[a] = 2\n    B = [i for i in range(N) if X[i]==1]\nc = min([i for i in range(N) if X[i] == 2] + [inf])\nif c < inf:\n    for a in E[c]:\n        if X[a] == 2: X[a] = 3\n    C = [i for i in range(N) if X[i]==2]\n \nif max(X) == 2 and len(A) * len(B) * len(C) and (len(A) + len(B) + len(C) == N) and (len(A) * len(B) + len(B) * len(C) + len(A) * len(C) == M):\n    f = 0\n    for i in range(N):\n        for j in E[i]:\n            if X[i] == X[j]:\n                f = 1\n                break\n        if f: break\n    if f:\n        print(-1)\n    else:\n        print(*[x+1 for x in X])\nelse:\n    print(-1)", "Q = int(input())\nfor _ in range(Q):\n    n = int(input())\n    s = input()\n    while s != '' and s[0] == 'P':\n        s = s[1:]\n\n    ans = 0\n    now = 0\n    for i in s:\n        if i == 'P':\n            now += 1\n        else:\n            ans = max(ans, now)\n            now = 0\n    ans = max(ans, now)\n\n    print(ans)\n", "from sys import stdin\nuu=0\nn=int(stdin.readline().strip())\ns1=stdin.readline().strip()\ns=list(map(int,stdin.readline().strip().split()))\ndp=[-1 for i in range(n+1)]\ndef sol1(x):\n    if dp[x]!=-1:\n        return dp[x]\n    if x==0:\n        return 0\n    ans=0\n    for i in range(x):\n        ans=max(ans,s[i]+sol1(x-i-1))\n    dp[x]=ans\nfor i in range(n):\n    sol1(i+1)\ndp[0]=0\ns2=[]\nx=1\nfor i in range(1,len(s)):\n    if s1[i]!=s1[i-1]:\n        s2.append(x)\n        x=1\n    else:\n        x+=1\ns2.append(x)\ndp1=[[[-1 for i in range(n+1)]for j in range(n+1)] for k in range(n+1)]\nn=len(s2)\ns=s2.copy()\ndef sol(l,r,k):\n    if l==r:\n        return dp[s[l]+k]\n    if l>r:\n        return 0\n    if dp1[l][r][k]!=-1:\n        return dp1[l][r][k]\n\n    ans=0\n    for i in range(l,r+1,2):\n        if i!=l:\n            ans=max(ans,sol(l+1,i-1,0)+sol(i,r,s[l]+k))\n        else:\n            ans=max(ans,sol(i+1,r,0)+dp[s[l]+k])\n            \n    dp1[l][r][k]=ans\n    return  ans\n\nprint(sol(0,len(s)-1,0))", "from sys import stdin\ninput = stdin.readline\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    if len(set(b)) == 2:\n        print('Yes')\n        continue\n\n    if a == sorted(a):\n        print('Yes')\n    else:\n        print('No')", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nP = [-1 for i in range(N)]\ndef par(a):\n    L = []\n    while P[a] >= 0:\n        L.append(a)\n        a = P[a]\n    for l in L:\n        P[l] = a\n    return a\ndef unite(a, b):\n    if par(a) != par(b):\n        if P[par(b)] >= P[par(a)]:\n            if P[par(b)] == P[par(a)]: P[par(a)] -= 1\n            P[par(b)] = par(a)\n        else:\n            P[par(a)] = par(b)\n\nfor _ in range(M):\n    u, v = list(map(int, input().split()))\n    unite(u-1, v-1)\n\nC = [[] for _ in range(N)]\nD = [0] * N\nfor i in range(N):\n    C[par(i)].append(i)\n    D[par(i)] = 1\nma = -1\nans = 0\nfor i in range(N):\n    p = par(i)\n    if D[p] == 0:\n        continue\n    D[p] = 0\n    if min(C[p]) < ma:\n        ans += 1\n    ma = max(ma, max(C[p]))\nprint(ans)\n", "from collections import defaultdict\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        n = II()\n        aa = LI()\n        bb = LI()\n\n        if n%2:\n            if aa[n//2]!=bb[n//2]:\n                print(\"No\")\n                continue\n\n        cnt=defaultdict(int)\n        for i in range(n//2):\n            l=aa[i]\n            r=aa[n-1-i]\n            if l>r:l,r=r,l\n            cnt[l,r]+=1\n\n        ng=False\n        for i in range(n//2):\n            l=bb[i]\n            r=bb[n-1-i]\n            if l>r:l,r=r,l\n            if cnt[l,r]==0:ng=True\n            cnt[l,r]-=1\n\n        if ng:print(\"No\")\n        else:print(\"Yes\")\n\nmain()\n", "m,n=map(int,input().split())\nl=[]\n#print(m,n)\nfor i in range(m):\n\tl+=[list(map(int,input().split()))]\nl=[set(i[1:]) for i in l]\n#k=0\n#print(n,m)\nfor i in range(m):\n\tfor j in range(i+1,m):\n\t\t#print(a,b,a.intersection(b))\n\t\tif len(l[i].intersection(l[j]))==0:\n\t\t\tprint('impossible')\n\t\t\treturn\n\t\"\"\"count=0\n\t\t\t\tfor j in range(m):\n\t\t\t\t\tif i in l[j]:\n\t\t\t\t\t\tcount+=1\n\t\t\t\tif count==m:\n\t\t\t\t\tprint('possible')\n\t\t\t\t\treturn\"\"\"\nprint('possible')", "from bisect import *\nu, v = {}, {}\nfor q in range(int(input())):\n    a, t, x = map(int, input().split())\n    if x not in u: u[x], v[x] = [], []\n    if a < 3: insort([v, u][-a][x], t)\n    else: print(bisect(u[x], t) - bisect(v[x], t))", "mod = 10**9\nFibArray = [1,1] \ndef fibonacci(n):  \n    if n<=len(FibArray): \n        return FibArray[n-1]\n    else: \n        temp_fib = fibonacci(n-1)+fibonacci(n-2) \n        FibArray.append(temp_fib) \n        return temp_fib\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nfor _ in range(m):\n\tquery = list(map(int, input().split()))\n\tif query[0]==1:\n\t\ta[query[1]-1] = query[2]\n\telif query[0]==3:\n\t\td = query[3]\n\t\tfor i in range(query[1]-1, query[2]):\n\t\t\ta[i]+=d\n\telse:\n\t\tl, r = query[1], query[2]\n\t\ts = 0\n\t\tfor x in range(r-l+1):\n\t\t\t# print(fibonacci(x+1), a[l+x-1])\n\t\t\ts+=((fibonacci(x+1)*a[l+x-1]))\t\n\t\tprint(s%mod)\t\n", "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\ngeta = 10**9+7\n\nQ = int(readline())\nC = Counter()\n\nAns = [sum(A)] + [0]*Q\nA = [0] + A\ntable = [geta] + [0]*N\nfor qu in range(1, Q+1):\n    s, t, u = list(map(int, readline().split()))\n    vn = s*geta + t\n    res = 0\n    cv = C[vn]\n    if u != cv:\n        if table[cv] <= A[cv]:\n            res = 1\n        table[cv] -= 1\n        if table[u] < A[u]:\n            res -= 1\n        table[u] += 1\n    C[vn] = u\n    Ans[qu] = Ans[qu-1] + res\nprint('\\n'.join(map(str, [max(1, a) for a in Ans[1:]])))\n", "class Solution:\n    def reverseWords(self, s: str) -> str:\n        curr_word = \"\"\n        ans = []\n        \n        for char in s:\n            if char == ' ':\n                if curr_word != \"\":   # if it is a newly separately word\n                    ans.append(curr_word)\n                    curr_word = \"\"\n            else:\n                curr_word += char\n        \n        if curr_word != \"\":\n            ans.append(curr_word)\n        \n        return \" \".join(ans[::-1])", "n=int(input())\nfor _ in range(n):\n\ta=input()[::-1]\n\tb=input()[::-1]\n\tx=b.find(\"1\")\n\tprint(a.find(\"1\", x)-x)", "n = int(input())\nfor k in range(n):\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            if i < len(s) - 1 and s[i] != s[i + 1]:\n                while j < len(t) and s[i] == t[j]:\n                    j += 1\n                i += 1\n            elif i == len(s) - 1:\n                while j < len(t) and s[i] == t[j]:\n                    j += 1\n                i += 1\n            else:\n                i += 1\n                j += 1\n        else:\n            break\n    if i == len(s) and j == len(t):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nAns = []\n\nfor _ in range(t):\n    n,k = map(int,input().split())\n    A = list(map(int,input().split()))\n    mini = 100000000000\n    for i in range(n-k):\n        y1 = (-A[i]+A[i+k]-1)/2\n        y2 = (-A[i]+A[i+k])/2\n        if float.is_integer(y1):\n            if mini > y1+1:\n                ans = A[i] + y1\n                mini = y1 + 1\n        elif float.is_integer(y2):\n            if mini > y2:\n                ans = A[i] + y2\n                mini = y2\n    Ans.append(int(ans))\n\nprint(*Ans,sep = \"\\n\")\n    ", "n = int(input())\nrek = list(map(int,input().split()))\nmx, pay = map(int,input().split())\nans = 0\nimport math\nfor i in rek:\n    if i > mx:\n        ans += pay * (math.ceil((i-mx)/(mx+pay)))\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom itertools import accumulate\n\ndef main():\n    n, k, q = list(map(int, sys.stdin.readline().split()))\n    ary = [0] * 2000001\n    num_valid = [0] * 2000001\n    max_temp = -1\n    for __ in range(n):\n        s, t = list(map(int, sys.stdin.readline().split()))\n        ary[s-1] += 1\n        ary[t] -= 1\n\n    tot = 0\n    for indx in range(len(num_valid)-1):\n        tot += ary[indx]\n        num_valid[indx + 1] = num_valid[indx] + (tot >= k)\n\n    for __ in range(q):\n        s, t = list(map(int, sys.stdin.readline().split()))\n        print(num_valid[t]- num_valid[s -1])\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = [(e, e) for e in arr]\n    res = []\n    while len(arr) > 0:\n        arr.sort()\n        x = arr.pop()\n        res.append(x[1])\n        for i in range(len(arr)):\n            arr[i] = (gcd(arr[i][0], x[0]), arr[i][1])\n    print(*res)\n", "n,m=map(int,input().split())\nL=[]\nfor i in ' '*n:L.append(input())\ndp=[[0]*m for i in range(n)]\nfor i in range(n+m-1):\n    rightmin=max(0,i-(n-1))\n    leftmin=max(0,i-(m-1))\n    left=i-rightmin\n    jstart = max(0, i - (n - 1))\n    for j in range(abs(left-leftmin)+1):\n        jj=jstart+j\n        ii=i-jj\n        if jj<2 or ii<1 or ii==n-1:\n            dp[ii][jj]=1\n            continue\n        if L[ii+1][jj-1]==L[ii][jj-1]==L[ii][jj-2]==L[ii-1][jj-1]==L[ii][jj]:\n            dp[ii][jj]=min(dp[ii+1][jj-1],dp[ii][jj-1],dp[ii][jj-2],dp[ii-1][jj-1])+1\n        else:dp[ii][jj]=1\nct=0\nfor i in dp:\n    for j in i:\n        ct+=j\nprint(ct)", "import sys\ninput=lambda:sys.stdin.readline().rstrip('\\n')\nD = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef case():\n\tn, m = list(map(int, input().split()))\n\tM = [list(input()) for _ in range(n)]\n\n\tgood = set()\n\tfor y in range(n):\n\t\tfor x in range(m):\n\t\t\tc = M[y][x]\n\t\t\tif c == 'G':\n\t\t\t\tgood.add((x, y))\n\t\t\telif c == 'B':\n\t\t\t\tfor dx, dy in D:\n\t\t\t\t\tnx = x + dx\n\t\t\t\t\tny = y + dy\n\t\t\t\t\tif nx < 0 or ny < 0 or nx >= m or ny >= n:\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tif M[ny][nx] == 'G':\n\t\t\t\t\t\tprint('No')\n\t\t\t\t\t\treturn\n\t\t\t\t\telif M[ny][nx] != 'B':\n\t\t\t\t\t\tM[ny][nx] = '#'\n\n\tif M[-1][-1] == '#':\n\t\tprint('No' if good else 'Yes')\n\t\treturn\n\n\tV = [[False] * m for _ in range(n)]\n\tV[n-1][m-1] = True\n\tQ = [(m-1, n-1)]\n\twhile Q:\n\t\tx, y = Q.pop()\n\n\t\tgood.discard((x, y))\n\t\tfor dx, dy in D:\n\t\t\tnx = x + dx\n\t\t\tny = y + dy\n\n\t\t\tif nx < 0 or ny < 0 or nx >= m or ny >= n: continue\n\t\t\tif M[ny][nx] == '#' or V[ny][nx]: continue\n\t\t\tV[ny][nx] = True\n\t\t\tQ.append((nx, ny))\n\n\tprint('Yes' if not good else 'No')\n\nfor _ in range(int(input())):\n\tcase()\n", "n = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\n\na = [(y, x, k) for x, y, k in a]\na.sort(reverse=True)\ndp = [[-1] * (n + 1) for i in range(n)]\n\ndef f(i, j):\n    if i < 0 or j < -1: return 0\n    if dp[i][j] == -1:\n        y, x, k = a[i]\n        dp[i][j] = f(i - 1, j) + max(0, x - k * y)\n        if 0 <= j < k: dp[i][j] = max(dp[i][j], x - j * y + f(i - 1, j - 1))\n    return dp[i][j]\n\nprint(max(f(n - 1, j) for j in range(-1, n)))\n", "import math\nt = int(input())\nfor i in range (t):\n    n = int(input())\n    m = math.floor(math.sqrt(n))\n    ans = [j for j in range (m + 1)]\n    left = m\n    while m > 0:\n        k = n//m\n        if left == k:\n            m -= 1\n            continue\n        ans.append(k)\n        left = k\n        m -= 1\n    print(len(ans))\n    print(*ans, sep = \" \")", "t = int(input())\nfor i in range(t):\n    x1, x2, y1, y2 = map(int, input().split())\n    print(1 + abs(y1 - x1) * abs(y2 - x2))", "n,q=map(int, input().strip().split(\" \"))\n# print(n,q)\na=[]\nfor i in range(q):\n    \n    x,y=map(int, input().strip().split(\" \"))\n    a.append([x,y])   \n\nif n%2==0:\n    for x,y in a:\n        # if x+y==2:\n        #     print(1)\n        #     continue\n        if (x+y)%2==0:\n            k=0\n        else:\n            k=(n*n)//2\n        k = k\n        l=(x-1)*n//2\n        m= int(y/2 + 0.5)\n        print(k+l+m)\nelse:\n    for x,y in a:\n        if (x+y)%2==0:\n            k=0\n            l = ((x-1)//2)*n \n            p= (x-1)%2*int(n/2+.5)\n            m=int(y/2 + 0.5)\n            print(k+l+m+p)\n            continue\n        else:\n            k=(n*n)//2 +1\n            l = ((x-1)//2)*n \n            p= (x-1)%2*int(n/2-.5) \n            m=int(y/2 + 0.5)\n            print(k+l+m+p)", "tests = int(input())\nwhile tests:\n  n = int(input())\n  arr = list(map(int, input().split()))\n  arr.sort()\n  arr.reverse()\n  for i in range(n):\n    print(arr[i], end=' ')\n  print()\n  tests -= 1", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\nfor testcases in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n\n    LIST=[[] for i in range(n+1)]\n\n    for ind,a in enumerate(A):\n        LIST[a].append(ind)\n\n    ANS=n+10\n\n    for i in range(n+1):\n        if len(LIST[i])<2:\n            continue\n        for j in range(1,len(LIST[i])):\n            ANS=min(ANS,LIST[i][j]-LIST[i][j-1])\n\n    if ANS==n+10:\n        print(-1)\n    else:\n        print(ANS+1)\n", "import sys\n\nanswer = 1\nz = True\nprimes = []\nfor i in range (2, 5 * 10 ** 2):\n    v = True\n    for p in primes:\n        if i % p == 0:\n            v = False\n    if v == True:\n        primes.append(i)\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nif sum(a) == n:\n    z = False\nfor i in range (0, n):\n    x = a[i]\n    a[i] = []\n    for p in primes:\n        if x % p == 0:\n            a[i].append([p, 1])\n            x = x // p\n            while x % p == 0:\n                x = x // p\n    if x != 1:\n        a[i].append([x, 1])\n\nneighbours = [[] for i in range (0, n)]\nfor i in range (0, n - 1):\n    line = sys.stdin.readline().strip().split()\n    neighbours[int(line[0]) - 1].append(int(line[1]) - 1)\n    neighbours[int(line[1]) - 1].append(int(line[0]) - 1)\n\nleaves = []\nfor i in range (0, n):\n    if len(neighbours[i]) == 1:\n        leaves.append(i)\n\n\nwhile len(leaves) > 1:\n    x = leaves.pop()\n    y = neighbours[x][0]\n    neighbours[y].remove(x)\n    if len(neighbours[y]) == 1:\n        leaves.append(y)\n    for p in a[x]:\n        for q in a[y]:\n            if p[0] == q[0]:\n                answer = max([answer, p[1] + q[1]])\n                q[1] = max([q[1],p[1]+1])\n\n\nif z == False:\n    print(0)\nelse:\n    print(answer)\n", "import math, sys\n\ndef solve(a, b):\n    if a == b:\n        return 1\n    elif a == 0 or b == 0:\n        return 0\n    else:\n        return math.floor(max(a,b)/min(a,b)) + solve(min(a,b), max(a,b) % min(a,b))\n\ndef main():\n    n = int(input())\n    for s in sys.stdin:\n        a, b = [int(x) for x in s.split()]\n        print(solve(a,b))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\nfrom scipy.special import comb\n\ns = input()\nA = list(map(int, input().split()))\n\nd = Counter(A)\n\nsum_c = 0\nfor v in d.values():\n    if v >= 2:\n        sum_c += comb(v, 2, exact=True)\n\nfor a in A:\n    x = sum_c - comb(d[a], 2, exact=True) + comb(d[a]-1, 2, exact=True)\n    print(x)", "from collections import deque\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nA.insert(0,0)\nB = list(map(int,input().split()))\nB.insert(0,0)\nG = {i:[] for i in range(1,N+1)}\nfor _ in range(M):\n    c,d = map(int,input().split())\n    G[c].append(d)\n    G[d].append(c)\nCol = [-1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1,N+1):\n    if Col[i]<0:\n        que = deque([i])\n        Col[i] = cnt\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if Col[y]<0:\n                    Col[y]=cnt\n                    que.append(y)\n        cnt += 1\nMem = {c:[] for c in range(cnt)}\nfor i in range(1,N+1):\n    Mem[Col[i]].append(i)\nflag = 0\nfor c in Mem:\n    c1 = 0\n    c2 = 0\n    for i in Mem[c]:\n        c1 += A[i]\n        c2 += B[i]\n    if c1!=c2:\n        flag = 1\n        break\nif flag==0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import numpy as np\nimport sys\n\ndef read_data():\n    try:\n        LOCAL_FLAG\n        import codecs\n        import os\n\n        lines = []\n        file_path = os.path.join(os.path.dirname(__file__), 'data.dat')\n        with codecs.open(file_path, 'r', 'utf-8') as f:\n            n_lines = int(f.readline())\n            for i in range(n_lines):\n                lines.append(f.readline().rstrip(\"\\r\\n\"))\n\n    except NameError:\n        lines = []\n        n_lines = int(input())\n        for i in range(n_lines):\n            lines.append(input())\n    return lines\n\nraw_data = read_data()\ntarray = []\nfor each in raw_data:\n    tarray.append(each.split())\nA = np.array(tarray, dtype='int64')\nN = A.shape[0]\n\ndef Restoring_Road_Network():\n\n    import scipy.sparse.csgraph as graph\n\n    MAX = [10000000000]*N  # should be > 2*10**9\n    d = np.diag(MAX)\n    C = A.copy()\n    C += d\n    total_dis = 0\n    n_path = 0\n    for i in range(N-1):\n        for j in range(i+1, N):\n            dis_two_node = np.min(C[i] + C[j])\n            if dis_two_node > C[i,j]:\n                total_dis += C[i,j]\n                # print(i, j)\n            elif dis_two_node < C[i,j]:\n                print(-1)\n                return\n\n    print(total_dis)\n\nRestoring_Road_Network()", "#\u5199\u7d4c\u30b3\u30fc\u30c9\u3067\u3059\u3002\nfrom collections import deque\n\ndef main():\n  h,w=map(int,input().split())\n  cy,cx=map(int,input().split())\n  dy,dx=map(int,input().split())\n\n  M=[\"##\"+input()+\"##\" for x in range(h)]\n  for i in range(2):\n    M.insert(0,\"#\"*(w+4))\n    M.append(\"#\"*(w+4))\n\n  C=[[-1 if M[j][i]==\".\" else -2 for i in range(w+4)] for j in range(h+4)]\n  C[-~cy][-~cx]=0\n  QA,QB=deque(),deque()\n  QA.append((-~cy,-~cx,0))\n  W=[[i,j] for i in range(-2,3) for j in range(-2,3) if abs(i)+abs(j)>1]\n\n  while QA:\n    h,w,c=QA.popleft()\n    QB.append((h,w,c))\n\n    for i,j in [[1,0],[0,1],[-1,0],[0,-1]]:\n      dh,dw=h+i,w+j\n      if C[dh][dw]==-1:\n        C[dh][dw]=c\n        QA.appendleft((dh,dw,c))\n\n    if QA:\n      continue\n\n    while QB:\n      h,w,c=QB.popleft()\n      for i,j in W:\n        dh,dw=h+i,w+j\n        if C[dh][dw]==-1:\n          C[dh][dw]=-~c\n          QA.append((dh,dw,-~c))\n\n    if C[-~dy][-~dx]!=-1:\n      print(C[-~dy][-~dx])\n      return\n\n  print(C[-~dy][-~dx])\n\ndef __starting_point():\n  main()\n__starting_point()", "X, Y = map(int,input().split())\nprint('Brown' if abs(X - Y) <= 1 else 'Alice')", "n,W=map(int,input().split())\nwv=[list(map(int,input().split())) for _ in range(n)]\nfrom collections import Counter\nw0=wv[0][0]\nd={w0:[0],w0+1:[0],w0+2:[0],w0+3:[0],}\nfor w,v in wv:\n  d[w].append(v)\nfor i in range(4):\n  d[w0+i].sort(reverse=True)\nsd={}\nfor i in range(4):\n  tmp=0\n  sd[w0+i]=[0]\n  for v in d[w0+i]:\n    tmp+=v\n    sd[w0+i].append(tmp)\nans=0\nfor i in range(len(d[w0])):\n  for j in range(len(d[w0+1])):\n    for k in range(len(d[w0+2])):\n      for l in range(len(d[w0+3])):\n        if w0*i+(w0+1)*j+(w0+2)*k+(w0+3)*l<=W:\n          ans=max(ans,sd[w0][i]+sd[w0+1][j]+sd[w0+2][k]+sd[w0+3][l])\nprint(ans)", "def main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    mod = 10 ** 9+ 7\n    ans = 1\n\n    def answer(a):\n        ans =1\n        for x in a:\n            ans *= x\n            ans %= mod\n        return ans\n\n    if n == k:\n        print(answer(a))\n        return\n    a.sort(reverse=True, key= lambda x:abs(x))\n    if sum(x<0 for x in a[:k])%2 == 0:\n        print(answer(a[:k]))\n    else:\n        if all(x < 0 for x in a):\n            print(answer(a[-k:]))\n        else:\n            try:\n                x1, y1= min([x for x in a[:k] if x > 0]), min([x for x in a[k:] if x < 0])\n            except ValueError:\n                x1, y1 = 1, 0\n            try:\n                x2, y2= max([x for x in a[:k] if x < 0]),\\\n                    max([x for x in a[k:] if x >= 0])\n            except ValueError:\n                x2, y2 = 1, 0\n            if abs(x2*y1) > abs(x1*y2):           \n                a[a.index(x1)] = y1\n            else:\n                a[a.index(x2)] = y2\n            print(answer(a[:k]))\n            \n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ndef main():\n    N,*S = map(int, open(0).read().split())\n    S = sorted(S)\n\n    g = [S.pop(-1)]\n\n    for _ in range(N):\n        c = []\n        tmp = []\n        for p in g:\n            while S:\n                s = S.pop(-1)\n                if p > s:\n                    c.append(s)\n                    break\n                else:\n                    tmp.append(s)\n            else:\n                print('No')\n                return\n        S.extend(tmp[::-1])\n        g.extend(c)\n        g.sort(reverse=True)\n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nA = sorted([int(x) - i for i, x in enumerate(input().split(), 1)])\nmid = N // 2\nans = sum(list([abs(x - A[mid]) for x in A]))\nif N % 2 == 0:\n    _mid = N // 2 + 1\n    _ans = sum(list([abs(x - A[_mid]) for x in A]))\n    ans = min(ans, _ans)\nprint(ans)\n", "\nfrom functools import reduce\nn, *s = open(0).read().split()\nu = []\nfor t in s:\n    close_cnt = 0\n    tmp = 0\n    for c in t:\n        tmp += (1 if c == '(' else -1)\n        close_cnt = min(close_cnt, tmp)\n    u.append((close_cnt, tmp - close_cnt))\nM = 10**6 + 1\nacc = 0\nfor a, b in sorted([x for x in u if sum(x) >= 0], key=lambda z: -z[0]):\n    if acc + a < 0:\n        print(\"No\")\n        return\n    else:\n        acc += a + b\nfor a, b in sorted([x for x in u if sum(x) < 0], key=lambda z: -z[1]):\n    if acc + a < 0:\n        print(\"No\")\n        return\n    else:\n        acc += a + b\nprint((\"No\" if acc else \"Yes\"))", "mod = 10**9 + 7\nn = int(input())\nfiveFac = 120\n\ndef solve(a) : \n\tab2 = a/2\n\treturn nC5(ab2 - 1)\n\n\ndef nC5(k) : \n\tres = (k-4)*(k)*(k-1)*(k-2)*(k-3)\n\tres = res/120\n\treturn res\n\nif n < 13 : \n\tprint(0)\nelif n == 13 :\n\tprint(1)\n\nelse : \n\ta7Max = n-12 + 1\n\tif n%2 == 1 : \n\t\tans = 0\n\t\tfor a7 in range(1,a7Max,2) : \n\t\t\trest = n - a7\n\t\t\tans += solve(rest)\n\t\t\tans = ans%mod\n\t\tprint(ans%mod)\n\n\telse : \n\t\tans = 0\n\t\tfor a7 in range(2,a7Max,2) : \n\t\t\trest = n - a7\n\t\t\tans += solve(rest)\n\t\t\tans = ans%mod\n\t\tprint(ans%mod)", "from math import *\n\nfor zz in range(int(input())):\n    t = [int(i) for i in input()]\n    n = len(t)\n    if sum(t) == 0:\n        print(*[0] * n, sep='')\n    elif sum(t) == n:\n        print(*[1] * n, sep='')\n    else:\n        print(*[0, 1] * (n), sep='')\n", "N = int(input())\nfor i in range(2,N):\n    if N%i == 0:\n        print(str(i)+str(N//i))\n        return\n", "from fractions import Fraction\nfrom math import inf\n\nn = int(input())\ncoords = []\nfor i in range(n):\n    x, y = [int(c) for c in input().split(\" \")]\n    coords.append((x, y))\n\ntangents = {}\nfor i1 in range(n):\n    for i2 in range(i1+1, n):\n        x1, y1 = coords[i1]\n        x2, y2 = coords[i2]\n        if x2 == x1:\n            tangent = inf\n            offset = x1\n        else:\n            tangent = Fraction(y2-y1, x2-x1)\n            offset = - tangent * x1 + y1\n\n        if tangent not in tangents: tangents[tangent] = set()\n        tangents[tangent].add(offset)\n\ntangentlen = {}\nfor tangent in tangents: tangentlen[tangent] = len(tangents[tangent])\n\nsumm = 0\nfor tangent in tangents: summ += tangentlen[tangent]\n\nanswer = 0\nfor t1 in tangents:\n    answer += tangentlen[t1] * (summ - tangentlen[t1])\nprint(answer // 2)\n", "n = int(input())\nT = []\nP = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    T.append([x, y])\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = T[i]\n        x2, y2 = T[j]\n        a = y2 - y1\n        b = x1 - x2\n        c = -(a * x1 + b * y1)\n        if a != 0:\n            b /= a\n            c /= a\n            a = 1\n        else:\n            a = 0\n            c /= b\n            b = 1\n        P.append([a, b, c])\nP.sort()\nnewp = [P[0]]\nfor i in range(len(P) - 1):\n    if P[i] != P[i + 1]:\n        newp.append(P[i + 1])\nP = newp\nwas = []\nsos = dict()\nfor a, b, c in P:\n    if b != 0 and a != 0:\n        z = a / b\n    elif a == 0:\n        z = 'kek'\n    else:\n        z = 'lol'\n    if z not in sos:\n        sos[z] = 1\n    else:\n        sos[z] += 1\nsus = 0\nsussqua = 0\nfor i in sos:\n    sus += sos[i]\n    sussqua += sos[i] ** 2\nprint((sus ** 2 - sussqua) // 2)", "def solve(n, arr):\n    xor_sum = arr[0]\n    for i in range(1, n):\n        xor_sum ^= arr[i]\n    if n % 2 == 0:\n        if xor_sum:\n            print(\"NO\")\n            return\n        else:\n            n -= 1\n    if n == 3:\n        print(1)\n        print(1, 2, 3)\n        return\n    \n    print(\"YES\")\n    print(n-2)\n    for i in range(1, n-1, 2):\n        print(i, i+1, i+2)\n    for i in range(n-4, 0, -2):\n        print(i, i+1, i+2)\n\n\nn = int(input())\narr = list(map(int, input().split()))\nsolve(n, arr)\n", "n=int(input())\narr=list(map(int,input().split()))\nbrr=list(map(int,input().split()))\nprev=-1\nd=dict()\nfor i in range(n):\n    d[brr[i]]=i\nans=0\nfor i in range(n):\n    if(d[arr[i]]-prev>0):\n        ans+=(d[arr[i]]-prev-1)\n        prev=d[arr[i]]\n        \nprint(ans)\n        \n", "def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nd = [(1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1), (1, 0)]\nt = read_int()\nfor case_num in range(t):\n    x, y = read_ints()\n    c = list(read_ints())\n    ans = -1\n    for i in range(6):\n        dx = d[i][0]\n        dy = d[i][1]\n        if dx != 0 and x // dx >= 0:\n            t = x // dx\n            cost = t * c[i]\n            y1 = d[i][1] * t\n            for j in range(6):\n                if j == i or d[j][0] != 0:\n                    continue\n                t1 = (y - y1) // d[j][1]\n                if t1 >= 0:\n                    nc = cost + t1 * c[j]\n                    if ans == -1 or ans > nc:\n                        ans = nc\n\n        if dy != 0 and y // dy >= 0:\n            t = y // dy\n            cost = t * c[i]\n            x1 = d[i][0] * t\n            for j in range(6):\n                if j == i or d[j][1] != 0:\n                    continue\n                t1 = (x - x1) // d[j][0]\n                if t1 >= 0:\n                    nc = cost + t1 * c[j]\n                    if ans == -1 or ans > nc:\n                        ans = nc\n    print(ans)\n", "import sys\nimport math\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\ndef inar():\n    return [int(el) for el in input().split()]\ndef main():\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        take=n//3\n        if n%3==0:\n            print(n//3,0,0)\n        elif n%3==1:\n            if (take-2)>=0:\n                print(take-2,0,1)\n            else:\n                print(-1)\n        else:\n            if (take-1)>=0:\n                print(take-1,1,0)\n            else:\n                print(-1)\n\ndef __starting_point():\n    main()\n\n\n\n\n__starting_point()", "import sys\n\np = 998244353\nn = int(sys.stdin.readline().strip())\nA = [0] * (10 ** 6 + 1)\na = []\nk = []\nfor i in range (0, n):\n    line = list(map(int,sys.stdin.readline().strip().split()))\n    k.append(line[0])\n    a.append(line[1:])\n    for j in range (0, k[i]):\n        x = a[i][j]\n        A[x] = A[x] + 1\nr, s = 0, 1\nfor i in range (0, n):\n    x = 0\n    for j in range (0, k[i]):\n        x = x + A[a[i][j]]\n    y = k[i] * n\n    r, s = (r * y + s * x) % p, (s * y) % p\nans = r\ns = s * n\nq = p - 2\nwhile q > 0:\n    if q % 2 == 1:\n        ans = (ans * s) % p \n        q = q - 1\n    else:\n        q = q // 2\n        s = (s * s) % p\n\n\nprint(ans % p)", "T = int(input())\nfor cas in range(T):\n  n = int(input())\n  a = [int(e) for e in input().split()]\n  ok = False\n  b = []\n  for i, j in enumerate(a):\n    if j % 2 == 0:\n      print(1)\n      print(i + 1)\n      ok = True\n      break\n    else:\n      b.append(i + 1)\n    if len(b) >= 2:\n      print(2)\n      print(b[0], b[1])\n      ok = True\n      break\n  if not ok:\n    print(-1)\n", "s = bin(int(input()))[2:].zfill(6)\nl = []\nfor i in [0, 5, 3, 2, 4, 1]:\n    l.append(s[i])\nprint(int(''.join(l), 2))", "\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    print((n+2)//2)\n", "from sys import stdin\nimport math\nfrom collections import defaultdict\n\ninput = stdin.readline\n\n# n, k = map(int, input().split(\" \"))\n# l = list(map(int, input().split(\" \")))\n\nn = int(input())\nl = list(map(int, input().split(\" \")))\n\nk = math.ceil(math.log2(n))\ndp = [[0] * k for i in range(2 ** k)]\n\n\ndef make_sparse(l, n, k):\n    \"\"\"Making sparse table, replace max with needed function like[GCD, Min, max, sum]\"\"\"\n    for i in range(n):\n        dp[i][0] = l[i]\n\n    for j in range(1, k + 1):\n        i = 0\n        while i + (1 << j) <= n:\n            dp[i][j] = math.gcd(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1])\n            i += 1\n\n\ndef querys(l, r):\n    j = int(math.log2(r - l + 1))\n    return math.gcd(dp[l][j], dp[r - (1 << j) + 1][j])\n\n\nmake_sparse(l, n, k)\nd = defaultdict(int)\ng = defaultdict(int)\nd[l[0]] = 1\ng[l[0]] = 1\nfor i in range(1, n):\n    t = defaultdict(int)\n    t[l[i]] = 1\n    g[l[i]]+=1\n    for k, v in list(d.items()):\n        gcd = math.gcd(k, l[i])\n        t[gcd] += v\n        g[gcd] += v\n    d = t\n\nfor i in range(int(input())):\n    a = g[int(input())]\n    if not a:\n        print(0)\n    else:\n        print(a)\n", "from collections import defaultdict as di\nMOD = int(1e9+7)\n\nbells = di(int)\nbells[0,0] = 1\nK=1000\nfor j in range(1,K):\n    bells[0,j] = bells[j-1,j-1]\n    for i in range(j):\n        bells[i+1,j] = (bells[i,j] + bells[i,j-1])%MOD\n    \ndef bellman(n):\n    return bells[n-1,n-1]\n\nm,n = [int(x) for x in input().split()]\nTlist = []\n\nfor _ in range(n):\n    Tlist.append(input())\nnumbs = []\nfor i in range(m):\n    numb = []\n    for j in range(n):\n        numb.append(Tlist[j][i])\n    numbs.append(int(''.join(numb),2))\n\neqsize = di(lambda:0)\nfor numb in numbs:\n    eqsize[numb]+=1\nsets = []\nfor numb in eqsize:\n    sets.append(eqsize[numb])\nparts = 1\nfor s in sets:\n    parts*=bellman(s)\n    parts%=MOD\nprint(parts)\n", "'''input\n3\n1\n3\n7\n'''\nimport math\t\ndef solve():\n\tn = int(input())\n\tl = [i for i in range(1,n+1)]\n\tl = l[::-1]\n\tfor i in l:\n\t\tprint(i,end=\" \")\n\tprint()\nt = 1\nt = int(input())\nwhile t > 0:\n\tt-=1\n\tsolve()", "t=int(input())\nfor _ in range(t):\n  a,b=map(int,input().split())\n  if a>b:\n    print((b*(b+1))//2)\n  else:\n    print((a*(a-1))//2+1)", "n, m = map(int, input().split())\ns = n + m\nx = list(map(int, input().split()))\nloc = input().split()\nt = []\nfor i in range(s):\n    if loc[i] == '1':\n        t.append(i)\nfor i in range(m):\n    ans = 0\n    if i != 0:\n        for j in range(t[i - 1] + 1, t[i]):\n            if x[j] - x[t[i - 1]] > x[t[i]] - x[j]:\n                ans += 1\n    else:\n        ans += t[i]\n    \n    if i != m - 1:\n        for j in range(t[i] + 1, t[i + 1]):\n            if x[j] - x[t[i]] <= x[t[i + 1]] - x[j]:\n                ans += 1\n    else:\n        ans += s - t[i] - 1\n    \n    print(ans, end = ' ')", "MIN = 2*3 + 2*5 + 2*7\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    if n <= MIN:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if n-MIN in (6, 10, 14):\n            print(\"6 10 15\", n - MIN - 1)\n        else:\n            print(\"6 10 14\", n - MIN)", "n = int(input())\narr = list(map(int, input().split()))\narr.sort()\nfor i in range(0, n-1, 2):\n    arr[i], arr[i+1] = arr[i+1], arr[i]\nprint((n-1)//2)\nprint(*arr)\n", "import sys\n\nclass Disjoint:\n    def __init__(self, n):\n        self.n = n\n        self.size = [1] * self.n\n        self.parent = [i for i in range(self.n)]\n    \n    def root(self, node):\n        self.parent[node] = node if self.parent[node] == node else self.root(self.parent[node])\n        return self.parent[node]\n    \n    def join(self, a, b):\n        a = self.root(a)\n        b = self.root(b)\n        if a == b:\n            return False\n        if self.size[a] > self.size[b]:\n            a, b = b, a\n            \n        self.size[b] += self.size[a]\n        self.parent[a] = b\n        return True\n    \n    \n\ninp = [int(x) for x in sys.stdin.read().split()]\nn = inp[0]\n\nwhite = Disjoint(n)\nblack = Disjoint(n)\n\ninp_idx = 1\nfor i in range(n - 1):\n    x, y, c = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2]\n    x -= 1\n    y -= 1\n    inp_idx += 3\n    \n    if c == 0:\n        white.join(x, y)\n    else:\n        black.join(x, y)\n    \nans = 0\nfor i in range(n):\n    rootW = white.root(i)\n    rootB = black.root(i)\n    ans += white.size[rootW] - 1\n    ans += black.size[rootB] - 1\n    \n    ans += (white.size[rootW] - 1) * (black.size[rootB] - 1)\n    \nprint(ans)\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        from bisect import bisect_right as br\n        arr2.sort()\n        \n        dp = {0:-math.inf}\n        # min_cnt = 0\n        for n1 in arr1:\n            # print(n1)\n            new_dp = {}\n            # cnt = min_cnt\n            for cnt in dp:\n                if n1 > dp[cnt]:\n                    new_dp[cnt] = min(new_dp.get(cnt, math.inf), n1)\n                i2 = br(arr2, dp[cnt])\n                if i2 < len(arr2):\n                    new_dp[cnt+1] = min(new_dp.get(cnt+1, math.inf), arr2[i2])\n                cnt += 1\n            if len(new_dp) == 0:\n                return -1\n            # while min_cnt not in new_dp:\n            #     min_cnt += 1\n            dp = new_dp\n            # print(dp)\n        return min(dp.keys())\n", "from collections import defaultdict\n\nh,w,n = map(int,input().split())\n\nd = defaultdict(int)\n\nfor _ in range(n):\n    a,b = map(int,input().split())\n\n    for i in range(-1,2):\n        for j in range(-1,2):\n            if 1 < a+i < h and 1 < b+j < w:\n                d[(a+i,b+j)] += 1\n\nans = [0]*10\n\nfor i in d.values():\n    ans[i] += 1\n\nans[0] = (h-2)*(w-2)-sum(ans)\nfor i in ans:\n    print(i)", "N = int(input())\n\nwork = [[] for i in range(N)]\n\nfor i in range(N):\n    a,b = map(int,input().split())\n    work[i] = [b,a]\n\nwork.sort()\ntotal = 0\nfor i in range(N):\n    total += work[i][1]\n    if total > work[i][0]:\n        print('No')\n        return\nprint('Yes')", "# coding: utf-8\n\nimport itertools\nimport sys\n\nN = int(input())\nC = [int(x) for x in input().split()]\n\n# C\u3092\u6607\u9806\u306b\u30bd\u30fc\u30c8\u3057\u3066\u304a\u304f\nC.sort()\n\n# \uff08C_i\u306e\u500b\u6570\u00d7C_i\u306e\u30b3\u30b9\u30c8\uff09\u306e\u7dcf\u548c\u00d72**N\u3092\u6c42\u3081\u308b\nsum = 0\nfor i in range(N):\n\tsum += (N + 1 - i) * C[i]\nsum *= 2 ** (N - 2)\nsum *= 2 ** N\n\n# 10**9 + 7\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u3066\u51fa\u529b\nprint(int(sum % (10 ** 9 + 7)))", "import bisect\n\nn = int(input())\nA = list(map(int, input().split()))\ncounts = [0]*(n)\nfor a in A:\n    counts[a-1] += 1\ncounts.sort()\n\ncumsum = []\nnum = 0\nfor count in counts:\n    num += count\n    cumsum.append(num)\n\nanswers = [0]*(n)\nfor i in range(1, n+1):\n    idx = bisect.bisect_right(counts, i)\n    left = cumsum[idx-1]\n    right = (n-idx)*i\n    K = (right+left)//i\n    answers[K-1] = i\n\nnow = 0\nfor i in range(n-1, -1, -1):\n    if answers[i] == 0:\n        answers[i] = now\n    now = answers[i]\n\nfor ans in answers:\n    print(ans)", "import numpy as np\n\n\ndef partsolve(A, x, positive, zero, negative):\n    \"\"\"\n    :param A:\n    :param x:\n    :return: A\u306e\u7a4d\u306e\u30da\u30a2\u306e\u4e2d\u3067\u3001x\u4ee5\u4e0b\u3068\u306a\u308b\u30da\u30a2\u306e\u500b\u6570\n    \"\"\"\n    count = 0\n    if x >= 0:\n        count = len(zero) * len(A)\n    P = x // positive\n    Pc = np.searchsorted(A, P, side='right')\n    count += Pc.sum()\n\n    N = (-x-1) // -negative\n    Nc = np.searchsorted(A, N, side='right')\n    Nc = len(A) - Nc\n    count += Nc.sum()\n\n    count -= np.count_nonzero(A * A <= x)\n    return count // 2\n\ndef solve(N, K, As):\n    A = np.array(sorted(As), np.int64)\n    positive = A[A > 0]\n    zero = A[A == 0]\n    negative = A[A < 0]\n\n    left = -10 ** 18\n    right = 10 ** 18\n    while right - left > 1:\n        mid = left + (right - left) // 2\n        c = partsolve(A, mid, positive, zero, negative)\n        if c < K:\n            left = mid\n        else:\n            right = mid\n    return right\n\n\n\ndef __starting_point():\n    N, K = tuple(map(int, input().split(\" \")))\n    As = list(map(int, input().split(\" \")))\n    print((solve(N, K, As)))\n\n\n__starting_point()", "import numpy as np\nfrom collections import Counter\nn = int(input())\na = np.array(list(map(int, input().split())))\nni = np.array([i for i in range(n)])\n\nap = a + ni\nan = (a - ni) * -1\n\ncp = Counter(ap)\ncn = Counter(an)\n\nans = 0\nfor i in cp.keys():\n  ans += cp[i] * cn[i] \n\nprint(ans)", "import sys\nfrom scipy.sparse.csgraph import floyd_warshall\nN, M, L = list(map(int, input().split()))\nINF = 10 ** 9 + 1\nG = [[float('inf')] * N for i in range(N)]\nfor i in range(M):\n    a, b, c = list(map(int, sys.stdin.readline().split()))\n    a, b = a - 1, b - 1\n    G[a][b] = c\n    G[b][a] = c\n\n\n# \u5168\u70b9\u9593\u6700\u77ed\u8ddd\u96e2\u3092\u8a08\u7b97\nG = floyd_warshall(G)\n\n\n# \u30b3\u30b9\u30c8L\u4ee5\u4e0b\u3067\u79fb\u52d5\u53ef\u80fd\u306a\u9802\u70b9\u9593\u306b\u30b3\u30b9\u30c8\uff11\u306e\u8fba\u3092\u5f35\u308b\nE = [[float('inf')] * N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if G[i][j] <= L:\n            E[i][j] = 1\n\n\n# \u305d\u306e\u30b0\u30e9\u30d5\u306e\u5168\u70b9\u9593\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\nE = floyd_warshall(E)\n\n\n# \u30af\u30a8\u30ea\u306b\u7b54\u3048\u3066\u3044\u304f\nQ = int(input())\nfor i in range(Q):\n    s, t = list(map(int, sys.stdin.readline().split()))\n    s, t = s - 1, t - 1\n    print((int(E[s][t] - 1) if E[s][t] != float('inf') else - 1))\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\n#from operator import itemgetter\n#from heapq import heappush, heappop\n#import numpy as np\n#import sympy\n#from scipy.sparse.csgraph import breadth_first_order, depth_first_order, shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\nfrom decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nimport sys\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN = ni()\nA = na()\nQ = ni()\nans = sum(A)\nd = collections.Counter(A)\nfor i in range(Q):\n    B, C = na()\n    ct_b = d[B]\n    if ct_b == 0:\n        print(ans)\n    else:\n        ans += ct_b * (C - B)\n        d[C] += ct_b\n        d[B] = 0\n        print(ans)", "def main():\n    import collections\n    N, P = map(int, input().split())\n    S = input()[::-1]\n    ans = 0\n    if P == 2 or P == 5:\n        for i, s in enumerate(S):\n            if int(s) % P == 0:\n                ans += N - i\n    else:\n        mod = [0] * P\n        mod[0] = 1\n        current = 0\n        X = 1\n        for s in S:\n            current = (current + int(s) * X) % P\n            ans += mod[current]\n            mod[current] += 1\n            X = X * 10 % P\n    \n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\nl=[0]*3*n\nr=[-1000000000000000]*3*n\nfrom heapq import heappop,heappush\nh=[]\ns=0\nfor i in a[:n]:\n  heappush(h,i)\n  s+=i\nl[n-1]=s\nfor i in range(n,2*n):\n  heappush(h,a[i])\n  s+=a[i]\n  s-=heappop(h)\n  l[i]=s\nh=[]\ns=0\nfor i in a[2*n:]:\n  heappush(h,-i)\n  s+=-i\nfor i in range(2*n-1,n-2,-1):\n  r[i]=s\n  heappush(h,-a[i])\n  s+=-a[i]\n  s-=heappop(h)\nprint(max(l[i]+r[i]for i in range(3*n)))", "x, y, a, b, c = map(int, input().split())\np_array = list(map(int, input().split()))\nq_array = list(map(int, input().split()))\nr_array = list(map(int, input().split()))\n\np_array_sort = sorted(p_array, reverse=True)\nq_array_sort = sorted(q_array, reverse=True)\nr_array_sort = sorted(r_array, reverse=True)\n\np_i = x - 1\nq_i = y - 1\n\nfor r in r_array_sort:\n    p = p_array_sort[p_i]\n    q = q_array_sort[q_i]\n    if r <= p and r <= q:\n        break\n    elif q <= p:\n        q_array_sort[q_i] = r\n        q_i = max(q_i - 1, 0)\n    else:\n        p_array_sort[p_i] = r\n        p_i = max(p_i - 1, 0)\n\nans = sum(p_array_sort[:x]) + sum(q_array_sort[:y])\nprint(ans)", "\r\namount, balance=list(map(float,input().strip().split()))\r\nif balance>=amount+0.50 and amount%5==0 and amount!=0:\r\n    final=balance-amount-0.5\r\n    print(\"{0:.2f}\".format(final))\r\n\r\nelse:\r\n    print(\"{0:.2f}\".format(balance))\r\n\r\n#a,b = map(float,input().strip().split())\r\n#if a%5==0 and b>=a+0.50:\r\n #   print(\"{:.2f}\".format(b-a-0.50))\r\n#else:\r\n #   print(\"{:.2f}\".format(b))\n", "def gns():\n    return list(map(int,input().split()))\nt=int(input())\n\n\ndef one():\n    s=input()\n    t=input()\n    p=input()\n    j=0\n    for c in s:\n        while j<len(t) and t[j]!=c:\n            j+=1\n        if j==len(t):\n            print('NO')\n            return\n        j+=1\n    def get_num(x):\n        ans=[0]*26\n        for c in x:\n            c=ord(c)-ord('a')\n            ans[c]+=1\n        return ans\n    ss=get_num(s)\n    tt=get_num(t)\n    pp=get_num(p)\n    for i in range(26):\n        if ss[i]+pp[i]<tt[i]:\n            print('NO')\n            return\n    print('YES')\n\n\nfor i in range(t):\n    one()\n\n\n\n\n", "for i in ' '*int(input()):\n    a,b=map(int,input().split())\n    if (a+b)%3==0:\n        if 2*a>=b and 2*b>=a:\n            print('YES')\n            continue\n    print('NO')", "T, = list(map(int, input().split()))\nfor t in range(T):\n    N, = list(map(int, input().split()))\n    X = [0]*(N+1)\n    for i, c in enumerate(input().strip()):\n        X[i+1] = X[i]+int(c)\n    d = dict()\n    for i in range( N+1):\n        x = X[i] - i\n        if x not in d:\n            d[x] = 0\n        d[x] += 1\n    R = 0\n    for k in d:\n        R += d[k]*(d[k]-1)//2\n    print(R)\n", "USE_STDIO = False\n\nif not USE_STDIO:\n    try: import mypc\n    except: pass\n\ndef count_bits(x):\n    ans = 0\n    while x:\n        ans += 1\n        x &= x - 1\n    return ans\n\ndef main():\n    t,  = list(map(int, input().split(' ')))\n    for _ in range(t):\n        a, = list(map(int, input().split(' ')))\n        c = count_bits(a)\n        ans = 1 << c\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n\n\n\n__starting_point()", "Q = int(input())\nfor q in range(Q):\n    s = input()\n\n    chet = []\n    nechet = []\n    for i in s:\n        if int(i) % 2 == 0:\n            chet.append(int(i))\n        else:\n            nechet.append(int(i))\n    #chet.sort()\n    #nechet.sort()\n    chet.append(10)\n    nechet.append(10)\n\n    i = 0\n    j = 0\n    ans = []\n    while i < len(chet) and j < len(nechet):\n        if i == len(chet) - 1 and j == len(nechet) - 1:\n            break\n        if chet[i] < nechet[j]:\n            ans.append(chet[i])\n            i += 1\n        else:\n            ans.append(nechet[j])\n            j += 1\n\n    print(*ans, sep='')\n", "def gns():\n    return list(map(int,input().split()))\nt=int(input())\nns=[]\nans=[0,0,0,4,4,12]\nfor _ in range(t):\n    n=int(input())\n    ns.append(n)\nmx=max(ns)\nmd=10**9+7\nfor i in range(6,mx+6):\n    ans.append((ans[-2]*2+ans[-1]+(4 if i%3==0 else 0))%md)\nfor ni in ns:\n    print(ans[ni])", "t=int(input())\nfor _ in range(t):\n    n, m=map(int, input().split())\n    a=[]\n    ans=0\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for i in range(n//2):\n        for j in range(m//2):\n            u=[a[i][j], a[i][m-1-j], a[n-1-i][j], a[n-1-i][m-1-j]]\n            u.sort()\n            ans+=u[2]-u[0]+u[3]-u[1]\n    if n%2!=0:\n        for j in range(m//2):\n            u=[a[n//2][j], a[n//2][m-1-j]]\n            u.sort()\n            ans+=u[1]-u[0]\n    if m%2!=0:\n        for i in range(n//2):\n            u=[a[i][m//2], a[n-1-i][m//2]]\n            u.sort()\n            ans+=u[1]-u[0]\n    print(ans)", "n=int(input())\nz=[]\nfor i in range (0,n):\n    x=int(input())\n    n=360/(180-x)\n    z.append(n)\n\nfor j in range (0,len(z)):\n    if (int(z[j])==z[j]):\n        print(\"YES\")\n    if (int(z[j]) !=z[j]):\n        print (\"NO\")\n\n", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n    def size_query(self, x):\n        return self.size[self.find(x)]\n\nn, q = list(map(int, input().split()))\ntree = Union_Find(n)\n\nfor _ in range(q):\n    a = tuple(map(int, sys.stdin.readline().split()))\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nprint(\" \".join(map(str, [tree.size_query(tree.find(i+1)) for i in range(n)])))\n", "def Count_Segment(a,n):\n\tans=0\n\tupto=[False]*(n+1)\n\tfor i in range(1,n-1):\n\t\tif a[i]>a[i-1] and a[i]>a[i+1]:\n\t\t\tcurr=a[i]\n\t\t\tj=i-1\n\t\t\twhile j>=0 and a[j]<curr:\n\t\t\t\tupto[a[j]]=curr\n\t\t\t\tj-=1\n\n\t\t\tj=i+1\n\t\t\twhile j<n and a[j]<curr:\n\t\t\t\tif upto[curr-a[j]]==curr:\n\t\t\t\t\tans+=1\n\t\t\t\tj+=1\n\n\treturn ans\n\nn=int(input())\na=list(map(int,input().split( )))\nprint(Count_Segment(a,n))\n", "for _ in range(int(input())):\n    n, x = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    m = sum(arr) % x\n    if m != 0:\n        print(n)\n        continue\n    ls = 0\n    li = -1\n    for i in range(n):\n        ls += arr[i]\n        li = i+1\n        if ls % x != 0:\n            break\n    rs = 0\n    ri = -1\n    for i in range(n-1, -1, -1):\n        rs += arr[i]\n        ri = i\n        if rs % x != 0:\n            break\n\n    if n-min(n-ri, li) == 0:\n        print(-1)\n    else:\n        print(n-min(n-ri, li))\n", "t = int(input())\nfor _ in range(t):\n    n, m = list(map(int, input().split()))\n    print((n * m + 1) // 2)\n", "n, k, m, t = map(int, input().split())\nfor j in range(t):\n    a, i = map(int, input().split())\n    if a:\n        n += 1\n        if i <= k:\n            k += 1\n    else:\n        if i >= k:\n            n = i\n        else:\n            n -= i\n            k -= i\n    print(n, k)", "import sys\nimport itertools\nimport math\nimport collections\nfrom collections import Counter\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = prime[1] = False\n    r = [p for p in range(n + 1) if prime[p]]\n    return r\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().split()))\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\n\n\nt = ii()\nfor _ in range(t):\n    n = ii()\n    d = sorted(li(), reverse = True)\n    res = 0\n    for i in range(n):\n        if d[i] >= i + 1:\n            res = i + 1\n        else:\n            break\n    print(res)\n", "from collections import deque\n \nn, m = list(map(int, input().split()))\nadj = [[] for i in range(n)]\nfor i in range(m):\n    u, v, c = input().split()\n    u, v = int(u)-1, int(v)-1\n    adj[u].append((v, c))\n    adj[v].append((u, c))\n \nvisited = S = T = None\n \ndef bfs(i, k):\n    q = deque([(i, 0)])\n    while q:\n        u, p = q.pop()\n \n        if visited[u] >= 0:\n            if visited[u] == p: continue\n            else: return False\n \n        visited[u] = p\n        if p: S.append(u)\n        else: T.append(u)\n \n        for v, c in adj[u]:\n            nxt = p if c == k else p^1\n            q.appendleft((v, nxt))\n \n    return True\n \ndef solve(k):\n    nonlocal visited, S, T\n    visited = [-1]*n\n    res = []\n    for i in range(n):\n        if visited[i] < 0:\n            S, T = [], []\n            if not bfs(i, k):\n                return [0]*(n+1)\n            else:\n                res.extend(S if len(S) < len(T) else T)\n    return res\n \nres1 = solve(\"R\")\nres2 = solve(\"B\")\n \nif min(len(res1), len(res2)) > n:\n    print(-1)\nelse:\n    print(min(len(res1), len(res2)))\n    print(\" \".join([str(x+1) for x in res1 if len(res1) < len(res2) else res2]))\n", "import sys\nfrom math import gcd\n\ninput=sys.stdin.readline\n\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    A=[a[i] for i in range(n)]\n    A.sort()\n    m=min(a)\n    check=all(a[i]==A[i] or a[i]%m==0 for i in range(n))\n    print(\"YES\" if check else \"NO\")\n", "import sys\ninput=sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    t = sorted(map(int,input().split()))\n    cur = [0]*(2*n)\n    for i in range(n):\n        low = high = t[i]\n        while low and cur[low]:\n            low -= 1\n        while cur[high]:\n            high += 1\n        if low > 0 and i:\n            lowsum = ind = j = 0\n            cur[low] = 1\n            while ind <= i:\n                if cur[j]:\n                    lowsum += abs(t[ind] - j)\n                    ind += 1\n                j += 1\n            cur[low] = 0\n            highsum = ind = j = 0\n            cur[high] = 1\n            while ind <= i:\n                if cur[j]:\n                    highsum += abs(t[ind] - j)\n                    ind += 1\n                j += 1\n            cur[high] = 0\n            if lowsum < highsum:\n                cur[low] = 1\n            else:\n                cur[high] = 1\n        else:\n            cur[high] = 1\n    ans = ind = j = 0\n    while ind < n:\n        if cur[j]:\n            ans += abs(t[ind] - j)\n            ind += 1\n        j += 1\n    print(ans)", "from math import sqrt, log2\nfrom sys import stdin\nfrom bisect import bisect\nimport time\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n+1):\n        prime = True\n        for j in range(2, min(int(sqrt(i))+2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime: res.append(i)\n    return res\n\n\ndef count_pow_nums(n, p):  #don't count 1\n    top = int(pow(n, 1.0/p))\n    if pow(top+2, p) <= n:\n        return top+1\n    elif pow(top+1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top-1\n    else:\n        return top-2\nprimes = all_primes(64)\nnum_set=set()\nmax_n = 1000000000000000000\nfor pi in range(3, len(primes)):\n    p = primes[pi]\n    cnt = count_pow_nums(max_n, p)\n    for n in range(2, cnt+5):\n        sq2 = round(sqrt(n))\n        sq3 = round(pow(n, 1/3))\n        if sq2**2 != n and sq3**3 != n:\n            num = pow(n, p)\n            if num <= max_n:\n                num_set.add(num)\nnums = sorted(num_set)\nt = int(stdin.readline())\nfor i in range(t):\n    n = int(stdin.readline())\n    ans = n-1-count_pow_nums(n, 2)-count_pow_nums(n, 3)+count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    print(ans)\n", "n = int(input())\nfor i in range(int(n)):\n    a = int(input())\n    \n    for j in range(35):\n        if a <= 2**j - 1:\n            print(j-1)\n            break\n    l = [2**x for x in range(j)]\n    #print(l)\n    \n    total = sum(l)\n    c = 1\n    while total != a:\n        try:\n            l[-c] -= min(l[-c-1], total - a)\n            total = sum(l)\n            c += 1\n            #print(c)\n        except:\n            pass\n    ans = []\n    for j in range(len(l) - 1):\n        ans.append(l[j+1] - l[j])\n    ans = [str(x) for x in ans]\n    print(' '.join(ans))", "class Solution:\n     def generateMatrix(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         \n         left = 0\n         top = 0\n         right = n - 1\n         bottom = n - 1\n         \n         res = [[0 for _ in range(n)] for _ in range(n)]\n         \n         num = 1\n         \n         while left < right and top < bottom:\n             for i in range(left, right):\n                 res[top][i] = num\n                 num += 1\n             for i in range(top, bottom):\n                 res[i][right] = num\n                 num += 1\n             for i in range(right, left, -1):\n                 res[bottom][i] = num\n                 num += 1\n             for i in range(bottom, top, -1):\n                 res[i][left] = num\n                 num += 1\n             left += 1\n             right -= 1\n             top += 1\n             bottom -= 1\n         if left == right and top == bottom:\n             res[left][top] = num\n             \n         return res\n", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         V = numCourses\n         \n         # Store outgoing edges\n         edges = []\n         \n         for _ in range(V):\n             edges.append(set())\n         \n         for p in prerequisites:\n             # Edge goes from v1 to v2\n             v2, v1 = p\n             edges[v1].add(v2)\n         \n         checked = set()\n         \n         def detect_cycle(x, visited):\n             visited.add(x)\n             checked.add(x)\n             \n             for v in edges[x]:\n                 if v in visited:\n                     return True\n                 if detect_cycle(v, visited):\n                     return True\n             visited.remove(x)\n             return False\n         \n         for v in range(V):\n             if v in checked:\n                 continue\n             if detect_cycle(v, set()):\n                 return False\n         \n         return True\n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n", "class Solution:\n     def subsets(self, nums):\n         if len(nums) == 0:\n             return [[]]\n         ret = []\n         for i, n in enumerate(nums):\n             if i > 0 and n == nums[i - 1]:\n                 continue\n             for s in self.subsets(nums[i + 1:]):\n                 ret.append([n] + s)\n         return [[]] + ret\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         nums.sort()\n         return self.subsets(nums)", "def main():\n  import numpy as np\n  k, q = map(int, input().split())\n  d = np.array(list(map(int, input().split())))\n  for i in range(q):\n    n, x, m = map(int, input().split())\n    x %= m\n    d_mod = d % m\n    zero_d = k - np.count_nonzero(d_mod)\n    d_mod_sum = np.sum(d_mod) + m * zero_d\n    rep = (n-1) // k\n    rem = (n-1) % k\n    zero_rem = len(d_mod[:rem]) - np.count_nonzero(d_mod[:rem])\n    rem_sum = np.sum(d_mod[:rem]) + m * zero_rem\n    ans = n - 1 - (x + d_mod_sum * rep + rem_sum) // m\n    print(ans)\ndef __starting_point():\n  main()\n__starting_point()", "n=int(input())\na=[]\nj=k=0\ndef s(a):\n    return a[0]+a[1]\ndef ss(a):\n    return a[0]-a[1]\nfor i in range(n):\n    f=list(map(int,input().split()))\n    a.append(f)\naa=min(map(s,a))\nb=max(map(s,a))\nc=min(map(ss,a))\nd=max(map(ss,a))\nprint(max(abs(d-c),abs(b-aa)))", "n,m = map(int,input().split())\nx = list(map(int,input().split()))\ny = list(map(int,input().split()))\nMOD = 10**9 + 7\nans = 0\ntemp1 = 0\ntemp2 = 0\nfor i in range(n):\n    temp1 += i*x[i] -(n-(i+1))*x[i]\n    temp1 %= MOD\n\nfor i in range(m):\n    temp2 += i*y[i] -(m-(i+1))*y[i]\n    temp2 %= MOD\n\nans = temp1*temp2\nans %= MOD\nprint(ans)", "# -*- coding:utf-8 -*-\n\ndef solve():\n    N = int(input())\n    Ls, Rs = [], []\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        Ls.append(a), Rs.append(b)\n    Ls.sort(), Rs.sort()\n\n    ans = 0\n    if N%2 == 1:\n        # N\u304c\u5947\u6570\u306a\u3089\n        l = Ls[N//2]\n        r = Rs[N//2]\n        ans = r-l+1\n    else:\n        # N\u304c\u5076\u6570\u306a\u3089\n        l2 = Ls[N//2-1]+Ls[N//2]\n        r2 = Rs[N//2-1]+Rs[N//2]\n        ans = r2-l2+1\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "# cook your dish here\nsize = int(input())\nstarting_times = list(map(int, input().split()))\nending_times = list(map(int, input().split()))\n\ntasks_indices_set = set()\n\nlast_timing = 0\n\nfor i in range(size):\n    # print(\"Index:\", i, \"& last_timing:\", last_timing)\n    # if i==0: tasks_indices_set.add(i)\n    if starting_times[i]>=last_timing:\n        tasks_indices_set.add(i)\n        last_timing = ending_times[i]\n        for j in range(i+1, size):\n            if ending_times[i]<=starting_times[j]:\n                tasks_indices_set.add(j)\n                last_timing = ending_times[j]\n                break\n\nprint(*sorted(tasks_indices_set))", "from collections import defaultdict as dd\n\ndef find(a, b):\n n = len(a)\n m = len(b)\n\n dp = [[0]*(m+1) for i in range(n+1)]\n\n for i in range(n-1,-1, -1):\n  for j in range(m-1, -1, -1):\n   if a[i] == b[j]:\n    dp[i][j] = dp[i+1][j+1] + 1\n\n mx = dd(int)\n ans = 0\n for i in range(n-1, -1, -1):\n  for j in range(m-1, -1, -1):\n   a = mx[(i+1, j)]\n   b = mx[(i, j+1)]\n   mx[(i, j)] = max([dp[i][j], a, b])\n\n for i in range(n):\n  for j in range(m):\n   c = dp[i][j]\n   nxt = mx[(i+c, j+c)]\n   cur = c + nxt\n   ans = max(ans, cur)\n   \n return 2*ans\nfor case in range(int(input())):\n a, b = input().split()\n b = b[-1::-1]\n\n ans = find(a, b)\n print(ans)\n", "# your code goes here\nn=int(input())\ns=0\nfor i in range(1,4):\n s+=pow(n,i)\nprint(s%1000000007)", "from collections import defaultdict\n\ndef solve():\n\n a = input().strip()\n n = len(a)\n #print(n)\n g = defaultdict(list)\n for i in range(n):\n  g[a[i]].append(i)\n vis = {}\n vis[0] = 0\n q = [0]\n # print(g)\n while len(q)!=0:\n  tmp = q.pop(0)\n  if tmp==n-1:\n   break\n  val = a[tmp]\n  x = len(g[val])\n  for i in range(x):\n   if g[val][i] not in vis:\n    q.append(g[val][i])\n    vis[g[val][i]] = vis[tmp]+1\n  g[val] = []\n  if tmp+1<=n-1 and tmp+1 not in vis:\n   q.append(tmp+1)\n   vis[tmp+1] = vis[tmp]+1\n  if tmp-1>=0 and tmp-1 not in vis:\n   q.append(tmp-1)\n   vis[tmp-1] = vis[tmp]+1\n print(vis[n-1])\n\n\ndef __starting_point():\n solve()\n__starting_point()", "a=int(input())\r\nb=a//100\r\nc=a//10\r\nc=c%10\r\nd=a\r\nd=d%10\r\nif((b^c)^d):\r\n    print(\"Inclusive\")\r\nelse: \r\n    print(\"Exclusive\")\r\n", "def subString(s, n):\n lst = []\n for i in range(n):\n  for len in range(i+1,n+1):\n   lst.append(s[i: len])\n return lst\n\nlst = []\nfor _ in range(int(input())):\n n = (input())\n lst.append(n)\nm = int(input())\nb = input()\nsubs = subString(b, m)\nuniques = []\ncount = 0\nfor i in subs:\n if i not in uniques:\n  uniques.append(i)\nfor i in uniques:\n if i in lst:\n  count += 1\nprint(count)\n\n", "s = input()\nL = []\n\nfor i in s:\n L.append(i)\n\nvowels = ['A', 'E', 'I', 'O', 'U']\n\nflag = 0\nfor i in range(len(L)-2):\n if (L[i] in vowels) and (L[i+1] in vowels) and (L[i+2] in vowels):\n  flag = 1\n  break\nif flag == 1:\n while 'A' in L:\n  L.remove('A')\n\n while 'E' in L:\n  L.remove('E')\n\n while 'I' in L:\n  L.remove('I')\n\n while 'O' in L:\n  L.remove('O')\n\n while 'U' in L:\n  L.remove('U')\n\n newL = []\n\n for i in L:\n  if i not in newL:\n   newL.append(i)\n\n if len(newL) >= 5:\n  print(\"GOOD\")\n else:\n  print(-1)\nelse:\n print(-1)", "a=int(input())\nb=int(input())\nc=input()\nif c=='+':\n print(a+b)\nelif c=='-':\n print(a-b)\nelif c=='*':\n print(a*b)\nelif c=='/':\n print(a/b)\n", "from itertools import combinations\nN = int(input())\nst = input()\nmx = \"\"\nans = False\na = [st[x:y] for x, y in combinations(range(len(st) + 1), r = 2)] \nfor i in a:\n    for j in range(len(i)//2):\n        if i[j]==i[-1-j]:\n            ans = True\n        else:\n            ans = False\n            break\n    if ans == True:\n        if len(mx) < len(i):\n            mx = i\nprint(len(mx))\nprint(mx)", "try:\n    def isPrime(n): \n      \n    # Corner case \n        if n <= 1 : \n            return False\n  \n    # check from 2 to n-1 \n        for i in range(2, n): \n            if n % i == 0: \n                return False\n  \n        return True\n  \n# Function to print primes \n    def printPrime(n): \n        l1=[]\n        for i in range(2, n + 1): \n            if isPrime(i): \n                l1.append(i) \n    \n        print(len(l1))\n  \n# Driver code \n    def __starting_point(): \n        n = int(input())\n    # function calling \n        printPrime(n)\nexcept:\n    pass\n__starting_point()", "# cook your dish here\n\ndef query(ar, k, a, b):\n return \"Yes\" if k <= a and k >= b else \"No\"\n \ndef __starting_point():\n n, t = map(int, input().split())\n ar = list(map(int, input().split()))\n large, small = max(ar), min(ar)\n for i in range(t):\n  k = int(input())\n  print(query(ar, k, large, small))\n__starting_point()", "a,b=[int(a) for a in input().split()]\r\nfor i in range(1,b+1):\r\n    if a%10!=0:\r\n        a=a-1\r\n    else:\r\n        a=a//10\r\nprint(a)", "\n \n class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         \n         if len(nums) == 0:\n             return [-1, -1]\n \n         nums = [target - 1] + nums + [target + 1]\n \n         lbound = -1\n \n         l, r = 1, len(nums) - 2\n \n         while l <= r:\n \n             m = (l + r)//2\n \n             if nums[m] == target and nums[m - 1] < target:\n                 lbound = m\n                 break\n \n             if nums[m] < target:\n                 l = m + 1\n             else: # nums[m] >= target:\n                 r = m - 1\n \n         if lbound == -1:\n             return [-1, -1]\n \n         rbound = -1\n         l, r = 1, len(nums) - 2\n \n         while l <= r:\n \n             m = (l + r)//2\n \n             if nums[m] == target and nums[m + 1] > target:\n                 rbound = m\n                 break\n \n             if nums[m] <= target:\n                 l = m + 1\n             else: # target < nums[m]\n                 r = m - 1\n \n         return [lbound - 1, rbound - 1]\n \n", "from functools import reduce\n \n class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         \n         d = {}\n         d[\"1\"] = \"\"\n         d[\"2\"] = \"abc\"\n         d[\"3\"] = \"def\"\n         d[\"4\"] = \"ghi\"\n         d[\"5\"] = \"jkl\"\n         d[\"6\"] = \"mno\"\n         d[\"7\"] = \"pqrs\"\n         d[\"8\"] = \"tuv\"\n         d[\"9\"] = \"wxyz\"\n         d[\"0\"] = \" \"\n         \n         digs = list(map(lambda x: list(d[x]), digits))\n         \n         return reduce(alg_mul, digs, [])\n                 \n \n def alg_mul(xs, ys):\n     if xs == []:\n         return ys\n     \n     ws = []\n     for x in xs:\n         for y in ys:\n             ws.append(x + y)\n     \n     return ws", "h, w = list(map(int, input().split()))\nn = int(input())\na = list(map(int, input().split()))\ncolor = [[0]*w for i in range(h)]\nloch = 0\nlocw = 0\nfor i in range(n):\n  for j in range(a[i]):\n    color[loch][locw]=str(i+1)\n    if loch % 2 == 0:\n      if locw != w-1:\n        locw+=1\n      else:\n        loch+=1\n    else: \n      if locw != 0:\n        locw-=1\n      else:\n        loch+=1\n\nfor i in range(h):\n  print((\" \".join(color[i])))\n", "class Node(object):\n     def __init__(self,val,root,n,p):\n         self.val=val\n         self.n=n\n         self.p=p\n         if root:\n             self.root=root\n         else:\n             self.root=self\n         self.left=self.leftchild(n,p)\n         self.right=self.rightchild(n,p)\n            \n     def leftchild(self,n,p):\n         if n==0:\n             if p==0:                 \n                 temp=''.join(self.val);\n                 self.root.val.append(temp)\n             return None\n \n         if n>0:\n             return Node(self.val+['('],self.root,n-1,p+1)\n \n     def rightchild(self,n,p):\n         if p==0:\n               return None\n         else:\n               return Node(self.val+[')'],self.root,n,p-1)\n             \n \n class Solution:\n     def generateParenthesis(self, s):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: void Do not return anything, modify nums in-place instead.\n         \"\"\"\n         D=Node([],None,s,0)\n         return D.val\n \n         \n                ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         si = sorted(intervals, key=lambda x: (x.start, x.end))\n         cur = 1  # index of current tuple\n         while cur < len(si):\n             # check intersection of current and previous tuple\n             # if end of previous is less than begin of current\n             # there are the intersection, we should merge them\n             # into the bigger interval\n             if si[cur - 1].end >= si[cur].start:\n                 # change end of the interval(tuple)\n                 si[cur - 1] = Interval(si[cur - 1].start, max(si[cur - 1].end, si[cur].end))\n                 # delete unnecessary interval(tuple)\n                 del si[cur]\n             # there are no intersection, go to the next tuple\n             else:\n                 cur += 1\n         return si\n         ", "x0, y0, A, C, B, D = list(map(int, input().split()))\n\npts = [[x0, y0]]\nfor i in range(100):\n\tnx, ny = [pts[-1][0] * A + B, pts[-1][1] * C + D]\n\tpts.append([nx, ny])\n\tif max(nx, ny) > 10000000000000000 * 10000000000000000: break\n\n\nx, y, t = list(map(int, input().split()))\n# print (pts[0])\n# print (pts[1])\n# print (pts[2])\n# print (pts[3])\n_max = 0\nfor i in range(len(pts)):\n\tfor j in range(len(pts)):\n\t\tif abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]) + abs(x - pts[i][0]) + abs(y - pts[i][1]) <= t:\n\t\t\t_max = max(_max, abs(i - j) + 1)\nprint(_max)\n", "def main():\n    def center(xx):\n        return sum(xx[::2]) * .25, sum(xx[1::2]) * .25\n\n    aa = list(map(float, input().split()))\n    bb = list(map(float, input().split()))\n    x, y = center(aa)\n    for i in range(0, 8, 2):\n        aa[i] -= x\n        bb[i] -= x\n        aa[i + 1] -= y\n        bb[i + 1] -= y\n    x, y = center(bb)\n    if x < 0.:\n        for i in range(0, 8, 2):\n            bb[i] *= -1.\n    if y < 0.:\n        for i in range(1, 8, 2):\n            bb[i] *= -1.\n    x, y = max(aa[i:i + 2] for i in range(0, 8, 2))\n    for i in range(0, 8, 2):\n        bb[i] -= x\n        bb[i + 1] -= y\n    [x1, y1], [x2, y2] = sorted(bb[i:i + 2] for i in range(0, 8, 2))[:2]\n    print(('NO', 'YES')[x1 <= 0 and x1 + y1 <= 0. and y2 <= 0. and x2 + y2 <= 0.])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def Numb(a,k):\n    if a == 0:\n        return 0\n    m = len(bin(a))-3\n    if m + 1 < k:\n        return 0\n    if k == 1:\n        return m+1\n    if m + 1 == k:\n        return Numb(a & ((1<<m)-1), k-1)\n    return C[m][k]+Numb(a & ((1<<m)-1), k-1)\n\ns = input()\nnDec = int(s,2)\nn = len(s)\nk = int(input())\n\nC = [[1],[1,1]]\nfor i in range(n):\n    tmp = [1]\n    for j in range(1,i+2):\n        tmp.append(C[-1][j-1]+C[-1][j])\n    tmp.append(1)\n    C.append(tmp)\n\nif k == 0:\n    print(1)\nelse:\n    NumOfOp = [0 for i in range(n+1)]\n    for i in range(2,n+1):\n        NumOfOp[i] = NumOfOp[bin(i).count('1')] + 1\n    res = 0\n    for i in range(1,n+1):\n        if NumOfOp[i] == k-1:\n            res += Numb(nDec,i)\n    if k == 1:\n        res -= 1\n    print(res%(10**9+7))", "n,x,y =map(int,input().split())\nss = input().strip()\nL = len(ss)\ni = 0\nlast = -1\ncnt = 0\nwhile i<L :\n    if ss[i] == '1' :\n        if last == 0 : cnt += 1\n        last = 1\n    else :\n        last = 0\n    i += 1\n\nif ss[L-1] == '0' : cnt += 1    \n\nans = 0\n\nif x<y : ans = ( cnt - 1 ) * x + y\nelse : ans = cnt * y\n\nif cnt == 0 : ans = 0\n\nprint(int(ans))", "n,a,d=map(int,input().split())\nprint(368131125*a%10**9*12*10**9+1,368131125*d%10**9*12*10**9)", "n,k=map(int, input().split())\nvis = [0] * 17\nfor _ in range(n):\n\ta = list(map(int, input().split()))\n\tvis[sum(a[i]*(1<<i) for i in range(k))] = 1\nflag=0\nfor i in range(16):\n\tfor j in range(16):\n\t\tif i&j==0 and vis[i] and vis[j]: flag=1\nprint(\"YES\" if flag else \"NO\")", "input()\na = input()\ns = []\nfor c in a:\n if not s or s[-1][0] != c:\n  s.append([c, 1])\n else:\n  s[-1][1] += 1\ns2 = sorted(s, key=lambda x: x[1])\ndelta = 0\nif s2[-1][1] >= 3 or len(s2) > 1 and s2[-2][1] >= 2:\n delta = 2\nelif s2[-1][1] >= 2:\n delta = 1\nprint(len(s) + delta)", "from collections import Counter\nMV = 400020\na = [0] * MV\nfor i in range(MV):\n    a[i] = set()\n\nn ,m = list(map(int , input().split()))\n\nfirst = list(map(int , input().split()))\nsecond = list(map(int , input().split()))\n\nfor fid, f in enumerate(first):\n    for sid, s in enumerate(second):\n        a[f+s].add(fid + MV)\n        a[f+s].add(sid)\n\na.sort(key = lambda x: -len(x))\n\nb = [len(k) for k in a]\n\n# for k in range(MV):\n#     if b[k]>0:\n#         print(k, b[k], a[k])\n\nbest_res = b[0]\nfor pos in range(MV):\n    for pos2 in range(MV):\n        if b[pos] + b [pos2] <= best_res:\n            break\n        cur = len(a[pos].union(a[pos2]))\n        if cur > best_res :\n            best_res = cur\nprint(best_res)\n", "n, m = [int(x) for x in input().split()]\nL = [[int(x) for x in input().split()] for i in range(n)]\ndef solve(L):\n    D = {i:set() for i in range(n)}\n    for i in range(n):\n        for j in range(m):\n            if L[i][j] != j+1:\n                D[i].add((min(j+1, L[i][j]), max(j+1, L[i][j])))\n                if len(D[i]) > 3 or len(D[i]) == 3 and L[i][L[i][j]-1] == j+1:\n                    return False\n    if all((len(D[i]) < 2) for i in range(n)):\n        return True\n    for x in range(m):\n        for y in range(x,m):\n            for i in range(n):\n                if not ((x+1,y+1) in D[i] or len(D[i]) == 0):\n                    break\n            else:\n                return True\n    return False\n\nprint('YES') if solve(L) else print('NO')\n", "def main():\n    n, l, res, a = int(input()), [], [], 0\n    aa = list(map(int, input().split()))\n    for i, b in enumerate(aa):\n        if a >= b:\n            l.append(i)\n        a = b\n    if not l:\n        print(n)\n        return \n    l.append(n)\n    rapp, a = res.append, 0\n    for b in l:\n        rapp(b - a)\n        a = b\n    a = b = 0\n    for c in l:\n        if a + 1 < b < c - 1 and (aa[b] - aa[b - 2] > 1 or aa[b + 1] - aa[b - 1] > 1):\n            rapp(c - a - 1)\n        a, b = b, c\n    print(max(res) + 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\n\na = [int(x) for x in input().split(' ')]\n\nm = min(a)\nM = max(a)\n\nres = n\nres -= len([x for x in a if x == m or x == M])\n    \nprint(res)\n", "import math\nk,d,t=map(int,input().split())\nl=(math.ceil(k/d)*d)-k\nm=(2*t)//(2*k+l)\nif (t-m*(k+(l/2)))<=k:\n    print(m*(k+l)+t-m*(k+(l/2)))\nelse:\n    print(m*(l+k)+k+2*(t-m*(k+(l/2))-k))", "#EFIM AND STRANGES GRADE 718A\nimport sys\nimport decimal\na,b = map(int,input().split())\nc = input()\nclock = c.find(\".\")\n\nfor x in range(clock+1,a):\n\tif c[x] > '4': break\nelse:\n\tprint(c)\n\treturn\n\n\nwhile b:\n\tx -=1\n\tb -=1\n\tif c[x] != '4': break\n\t\n\t\t\t\t\nif x > clock:\n\tprint(c[:x],chr(ord(c[x])+1),sep=\"\")\nelse:\n\tc = list(c[:x])\n\tx -= 1\n\twhile x>=0:\n\t\tif c[x] == '9':\n\t\t\tc[x] = '0'\n\t\t\tx-=1\n\t\telse:\n\t\t\tc[x] = chr(ord(c[x])+1)\n\t\t\tbreak\n\telse:\n\t\tc.insert(0,'1')\n\tprint(\"\".join(c) )\n\t\t\n", "\"\"\"\nCodeforces Round 253 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s=\"\\n\"):\n    if isinstance(s, list): s = \" \".join(map(str,s))\n    s = str(s)\n    print(s, end=\"\")\n\n################################################### SOLUTION\nimport itertools\ncovers = itertools.product([0,1], repeat=10)\n\nn, = read()\ns = read(1)\na = [0] * 25\ncolors = \"RGBYW\"\nfor i in s:\n    a[colors.index(i[0]) * 5 + int(i[1])-1] |= 1\n\ndef check(cover):\n    nonlocal a\n    unknowns = [0] * 11\n    for i in range(25):\n        if not a[i]: continue\n        id = -1\n        if not cover[i%5]: id = 5+i//5\n        if not cover[5+i//5]:\n            if id == -1:\n                id = i%5\n            else:\n                id = 10\n        if id > -1:\n            if unknowns[id]: return False\n            unknowns[id] = 1\n    return True\n\nmn = 99\nfor i in covers:\n    if check(i):\n        mn = min(mn, sum(i))\n\nprint(mn)", "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\n\n\ndef f(ai, ki):\n    if ai < ki: return 0\n    elif ai % ki == 0 :return ai // ki\n    d = ai // ki + 1\n    if ai % ki % d:\n        return f(ai - (ai % ki // d + 1) * d, ki)\n    return f(ai - ai % k, k)\n\n\nn = I()\nret = 0\nfor i in range(n):\n    a, k = LI()\n    ret ^= f(a, k)\n\nprint((\"Takahashi\" if ret else \"Aoki\"))\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ncan0 = set()\ncan1 = [set() for i in range(n)]\ncan2 = [set() for i in range(m)]\n\nfor i in range(n):\n    for j in range(m):\n        x1 = a[i * 2]\n        x2 = a[i * 2 + 1]\n        y1 = b[j * 2]\n        y2 = b[j * 2 + 1]\n        if x1 > x2: x1, x2 = x2, x1\n        if y1 > y2: y1, y2 = y2, y1\n        if x1 == y1 and x2 == y2: continue\n        if x1 == y1:\n            can1[i].add(y1)\n            can2[j].add(y1)\n            can0.add(y1)\n        if x2 == y1:\n            can1[i].add(y1)\n            can2[j].add(y1)\n            can0.add(y1)\n        if x1 == y2:\n            can1[i].add(y2)\n            can2[j].add(y2)\n            can0.add(y2)\n        if x2 == y2:\n            can1[i].add(y2)\n            can2[j].add(y2)\n            can0.add(y2)\nif len(can0) == 1:\n    print(min(can0))\nelse:\n    ok = True\n    for i in can1:\n        if len(i) > 1:\n            ok = False\n    for i in can2:\n        if len(i) > 1:\n            ok = False\n    if ok: print(0)\n    else: print(-1)\n", "n, k = map(int, input().split())\nm = int(1e9+7)\nr = 0\np = pow(2, n, m)\na = [1] + [0] * k\nfor i in range(k):\n    for j in range(i, -1, -1):\n        a[j+1] += a[j]\n        a[j] = a[j]*j % m\nfor i in range(k + 1):\n    r += p*a[i]\n    p = p*500000004*(n - i) % m\nprint(r % m)", "n=int(input())\nd=int(input())\ne=int(input())*5\n\nans=10**8+1\nfor i in range(d):\n    k=n-e*i\n    if k<0:\n        break\n    ans=min(ans, k%d)\n\nprint(ans)", "import math\n\nN = int(input())\nS = int(input())\n\ndef f(B, N):\n    X, res = N, 0\n    while 0 < X:\n        res += X % B\n        X //= B\n    return res\n\n\nif N == S:\n    print(N + 1)\n    return\n\ni = 2\nwhile i * i <= N:\n    if f(i, N) == S:\n        print(i)\n        return\n    i += 1\n\nsqrtN = math.floor(math.sqrt(N))\ni = 1\nans = -1\nwhile i * i < N:\n    if (N - S) % i != 0:\n        i += 1\n        continue\n    b = (N - S) // i + 1\n    if sqrtN < b and f(b, N) == S:\n        ans = b\n    i += 1\n\nprint(-1 if ans == -1 else ans)", "from math import *\n\ndef dist(a,b,p):\n\txu = b[0]-a[0]\n\tyu = b[1]-a[1]\n\txv = p[0]-a[0]\n\tyv = p[1]-a[1]\n\tc1 = xu*xv + yu*yv\n\tc2 = xu*xu + yu*yu\n\tx,y = 0,0\n\tif c1<=0:\n\t\tx = a[0]-p[0]\n\t\ty = a[1]-p[1]\n\telif c2<=c1:\n\t\tx = b[0]-p[0]\n\t\ty = b[1]-p[1]\n\telse:\n\t\tx = a[0] + xu*(c1/c2)-p[0]\n\t\ty = a[1] + yu*(c1/c2)-p[1]\n\treturn x*x + y*y\n\n\nn,cx,cy = map(int,input().split())\npts =  [ list(map(int,input().split())) for _ in range(n) ]\nmini,maxi = float('inf'),0\nfor i in range(n):\n\tpx,py = pts[i]\n\tmaxi = max((px-cx)**2+(py-cy)**2,maxi)\n\tmini = min(dist(pts[i-1],pts[i],[cx,cy]),mini)\nprint((maxi-mini)*pi)", "import sys\ninput = sys.stdin.readline\n \ndef getInt(): return int(input())\ndef getVars(): return list(map(int, input().split()))\ndef getList(): return list(map(int, input().split()))\ndef getStr(): return input().strip()\n## -------------------------------\n\ndef addDictList(d, key, val):\n    if key not in d: d[key] = []\n    d[key].append(val)\n\ndef addDictInt(d, key, val):\n    if key not in d: d[key] = 0\n    d[key] = val\n    \ndef addDictCount(d, key):\n    if key not in d: d[key] = 0\n    d[key] += 1\n\ndef addDictSum(d, key, val):\n    if key not in d: d[key] = 0\n    d[key] += val\n\n## -------------------------------\n\nn = getInt()\ns = getStr()\nif n %2 == 1:\n    r = 'No'\nelse:\n    r = 'Yes'\n    num = 0\n    for i in range(n):\n        if s[i] == '(':\n            num+=1\n        else:\n            num-=1\n            if num <-1:\n                r = 'No'\n                break\n    if num != 0:\n        r = 'No'\nprint(r)\n", "from math import gcd, sqrt\nn = int(input())\n\n\ndef divsor(a):\n    for i in range(2, int(sqrt(a)) + 1):\n        if not a % i:\n            return i\n    return a\n\n\na, b = map(int, input().split())\nif n == 1:\n    print(a)\n    return\nfor i in range(n - 1):\n    c, d = map(int, input().split())\n    a = gcd(c*d, a); b = gcd(c*d, b)\n\nif a > 1:\n    print(divsor(a))\nelif b > 1:\n    print(divsor(b))\nelse:\n    print(-1)", "import math\ndef binpow(a,b,m):\n    a %= m\n    res = int(1)\n    while b > 0 :\n        if b & 1:\n            res = (res * a) % m\n        a = (a * a) % m\n        b >>= 1\n    return res\n\ndef inv(a,m:int=1000000009):\n    return binpow(a,m-2,m)\n\nm=int(1000000009)\n\nn,a,b,k=input().split()\nn=int(n);a=int(a);b=int(b);k=int(k)\nst=input()\nres=int(1)\np=int((b*inv(a,m))%m)\nitr=(n+1)//k\nmul1=0\nfor i in range (len(st)):\n    if st[i]=='+':\n        mul1=(mul1+binpow(p,i,m))%m\n    else:\n        mul1=(mul1-binpow(p,i,m))%m\nif binpow(p,k,m)==1:\n    mul2=itr%m\nelse:\n    mul2=((binpow(p,k*itr,m)-1)*inv((binpow(p,k,m)-1)%m))%m\nres=(mul1*mul2)%m\nleft=n-k*itr+1\nmul1=binpow(p,k*itr,m)\nmul2=0\nfor i in range (left):\n    if st[i]=='+':\n        mul2=(mul2+binpow(p,i,m))%m\n    else:\n        mul2=(mul2-binpow(p,i,m))%m\nres=(res+mul1*mul2)%m\nres=(res*binpow(a,n,m))%m\nprint(res)\n\n\n", "m, n = map(int, input().split());\n\nsum = 0.0;\n\nfor i in range(1, m + 1):\n\tsum += i * ((1.0 * i / m) ** n - ((i - 1.0) / m) ** n);\n\nprint (\"%.10lf\" % sum);", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    a = s.count('>')\n    b = s.count('<')\n    if a == 0 or b == 0:\n        print(n)\n    else:\n        s = s[-1] + s\n        ans = 0\n        for i in range(1, n + 1):\n            if s[i] == '-' or s[i - 1] == '-':\n                ans += 1\n        print(ans)", "from functools import *\n\nread_line = lambda: [int(i) for i in input().split()]\n\nn, m, k = read_line()\na = [read_line() for i in range(n)]\nif n < m:\n    n, m, a = m, n, list(zip(*a))\n\nxs = [reduce(lambda x, b: 2 * x + b, y) for y in a]\nminm = lambda a: min(a, m - a)\nwork = lambda y: sum(minm(bin(x ^ y).count('1')) for x in xs)\nans = min(list(map(work, xs if m > k else list(range(1<<m)))))\n\nprint(ans if ans <= k else -1)\n\n\n\n\n# Made By Mostafa_Khaled\n", "from math import sqrt\nn = int(input())\nm = {}\nfor i in range(n):\n    line = input()\n    mi = [int(x) for x in line.strip().split()]\n    for j in range(n):\n        if i not in m:\n            m[i] = {}\n        m[i][j] = mi[j]\n\nres = []\nfor i in range(n):\n    x = m[i][(i+1)%n]\n    y = m[i][(i+2)%n]\n    z = m[(i+1)%n][(i+2)%n]\n    res.append(str(int(sqrt(int(x*y/z)))))\n\nprint(' '.join(res))", "n=int(input())\na=[];b=[];c=[];d=[]\nfor i in range(n):\n    opt,num=[int(x) for x in input().split()]\n    if opt==0:\n        a.append(num)\n    if opt==10:\n        b.append(num)\n    if opt==1:\n        c.append(num)\n    if opt==11:\n        d.append(num)\nans=0\nans+=sum(d)\nb.sort(reverse=True)\nc.sort(reverse=True)\nif len(b)<len(c):\n    ans+=sum(b)+sum(c[0:len(b)])\n    a.extend(c[len(b):])\nelse:\n    ans+=sum(c)+sum(b[0:len(c)])\n    a.extend(b[len(c):])\na.sort(reverse=True)\nans+=sum(a[0:len(d)])\nprint(ans)", "from itertools import *\nfrom math import *\nn, m = map(int, input().split())\nx, y = (max(1, ceil(log(k, 7))) for k in [n, m])\np = [''.join(t) for t in permutations('0123456', x + y)]\nprint(0 if x + y > 7 else sum(int(t[:x], 7) < n and int(t[x:], 7) < m for t in p))", "[n, m] = list(map(int, input().split()));\na = [0] + list(map(int, input().split()));\nb = [0] + list(map(int, input().split()));\nx = int(input());\n\nfor i in range(1, n+1):\n    a[i] += a[i-1];\n    \nfor i in range(1, m+1):\n    b[i] += b[i-1];\n    \nINF = 4 * 10**9 + 1;\nA = [INF] * (n+1);\nB = [INF] * (m+1);\n\nfor i in range(1, n+1):\n    for j in range(1, i+1):\n        A[i - j + 1] = min(A[i - j + 1], a[i] - a[j - 1]);\nfor i in range(1, m+1):\n    for j in range(1, i+1):\n        B[i - j + 1] = min(B[i - j + 1], b[i] - b[j - 1]);\n\nansw = 0;\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if (A[i] * B[j] <= x):\n            answ = max(answ, i*j);\nprint(answ);\n", "import sys\n\ndef sum_range(l, r):\n    if r < l: return 0\n    if l == 0: return sum[r]\n    return sum[r] - sum[l - 1]\n\nn, k = map(int, input().split())\n\ncards = input()\n\nsum = [0] * n\nsum[0] = 1 if cards[0] == '1' else 0\nfor i in range(1, n):\n    sum[i] += sum[i - 1]\n    if cards[i] == '1':\n        sum[i] += 1\n\nmin0 = min1 = n\nmax0 = max1 = -1\nfor i in range(0, n):\n    if cards[i] == '1':\n        min1 = min(min1, i)\n        max1 = i\n    else:\n        min0 = min(min0, i)\n        max0 = i\n        \ntoki = False\nqual = True\nfor i in range(0, n - k + 1):\n    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + k == n:\n        toki = True\n    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + 0 == 0:\n        toki = True\n        \n    prefix = sum_range(0, i - 1) == 0\n    suffix = sum_range(i + k, n - 1) == 0\n    if i > 0 and i + k < n and (prefix ^ suffix) == 0:\n        qual = False\n    if i - min0 > k or i - min1 > k or max0 - (i + k - 1) > k or max1 - (i + k - 1) > k:\n        qual = False\n\nif toki == True:\n    print('tokitsukaze')\nelif qual == True:\n    print('quailty')\nelse:\n    print('once again')", "from math import ceil, log2\n\nprint(ceil(log2(int(input()) + 1)))", "\na = int(input())\nb = int(input())\nn = int(input())\nm = max(0, n - b)\n\nM = min(a, n)\nprint(M - m + 1)\n", "mo = 998244353\n\nn = int(input())\n\nif n == 1:\n    print(pow(2, mo - 2, mo))\n    return\n\ndef calc(n, s):\n    nonlocal bans, qa\n    return (bans + qa(2, min(n - 2, 2 * n - 1 - 2 * s, 2 * s - 2))) % mo\n\na = [0] * n\n\nfor k in range(3, n - 1, 2):\n    a[k] = k * pow(2, k - 2, mo) % mo\n\nfor k in range(1, n):\n    a[k] += a[k - 1]\n\ndef qa(l, r):\n    if l > r:\n        return 0\n    return a[r] - a[l - 1]\n\nbans = 0\nbans = (bans + pow(2, n - 2, mo) * n) % mo\nfor i in range(1, n):\n    bans = (bans + 2 * i) % mo\ntmp = 0\nfor k in range(2, n - 1):\n    tmp = (tmp + pow(2, n - k - 2, mo) * (k - 1)) % mo\nbans = (bans + tmp * n) % mo\n\ndom = pow(2, -n + mo - 1, mo)\n\nfor s in range(1, n + 1):\n    print(calc(n, s) * dom % mo)", "from math import sin,cos,tan,pi\n[w,h,a] =[int(i) for i in input().split()]\nif h > w:\n    h,w = w,h\nif a > 90:\n    a = 180 - a\nif a==0:\n    print(w*h)\nelse:\n    b = (a*pi)/180\n    w = w/2.0\n    h = h/2.0\n    if tan(b/2) >= h/w:\n        print(4*h*h/sin(b))\n    else:\n        ans = 4*w*h\n        m = -1 / tan(b)\n        c = w*sin(b) + w*cos(b) / tan(b)\n        ans = ans - (h - m*w - c)*(w - (h - c)/m)\n        m = tan(b)\n        c = h*cos(b) + h*sin(b)*tan(b)\n        ans = ans - (h + m*w - c)*((h - c)/m + w)\n        print (ans)\n", "n=int(input())\np=lambda a,b:print(a+1,b+1)\nb=[0,1]\ndef g(n):\n\tprint(\"YES\")\n\tfor i in range(n%4,n,4):\n\t\tfor x in b:\n\t\t\ta=2*x\n\t\t\tfor j in range(i):p(j,i+a)\n\t\t\tp(i+a,i+a+1)\n\t\t\tfor j in range(i,0,-1):p(j-1,i+a+1)\n\t\t[p(i+y,i+(y^(3-x))) for x in b for y in b]\n\treturn\"\"\nprint(\"NO\"*(n%4>1)or g(n))\n", "n, l, r = list(map(int, input().split()))\nln = 0\nans = 0\ncurr = 1\nwhile curr <= n :\n    curr *= 2\n    ln += 1\nln -= 1\nfor i in range(l, r + 1):\n    if curr > i:\n        res = 1\n        res2 = 0\n        while (res & i) == 0:\n            res *= 2\n            res2 += 1\n        if res2 <= ln:\n            msk = n & (1 << (ln - res2))\n            ans += (msk != 0)\nprint(ans)\n", "n = int(input())\na = list(map(int,input().split()))\nx = list(map(abs,a))\nsm = sum(x)\n# print(sm)\nif n&1==0 and len([0 for i in a if i<0])&1==1:\n    sm-=2*min(x)\nprint(sm)", "f0 = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\nf1 = \"What are you doing while sending \\\"{0}\\\"? Are you busy? Will you send \\\"{0}\\\"?\"\na = list(f1.split(\"{0}\"))\nb = list(map(len, a))\nq = int(input())\nf = lambda n: 143 * 2**min(n, 54) - 68\n\t\nfor _ in range(q):\n\tn, k = map(int, input().split())\n\tans = \"\"\n\twhile n > 0 and b[0] < k < b[0] + f(n-1):\n\t\tk -= b[0]\n\t\tn -= 1\n\twhile not ans:\n\t\tw = f(n-1)\n\t\tif k > f(n):\n\t\t\tans = \".\"\n\t\telif n == 0:\n\t\t\tans = f0[k-1]\n\t\telif k <= b[0]:\n\t\t\tans = a[0][k-1]\n\t\telif k <= b[0] + w:\n\t\t\tk -= b[0]\n\t\t\tn -= 1\n\t\telif k <= b[0] + w + b[1]:\n\t\t\tk -= b[0] + w\n\t\t\tans = a[1][k-1]\n\t\telif k <= b[0] + w + b[1] + w:\n\t\t\tk -= b[0] + w + b[1]\n\t\t\tn -= 1\n\t\telse:\n\t\t\tk -= b[0] + w + b[1] + w\n\t\t\tans = a[2][k-1]\n\tprint(ans, end=\"\")", "import sys\n\ninput = sys.stdin.readline\n\nmex = [[1, 2, 1], [2, 0, 0], [1, 0, 0]]\n\nN = int(input())\na = [list(map(int, input().split()))]\nfor i in range(1, N):\n    a.append([int(input())])\n    # \u6700\u521d\u306e4\u884c / 4\u5217\u306e\u307f\u3092\u611a\u76f4\u306b\u8a08\u7b97\u3059\u308b\n    if i < 4:\n        stop = N\n    else:\n        stop = min(4, N)\n    for j in range(1, stop):\n        a[i].append(mex[a[i - 1][j]][a[i][j - 1]])\n\ncount = [0, 0, 0]\nfor i, ai in enumerate(a):\n    for j, aij in enumerate(ai):\n        if i >= 3 and j >= 3:\n            count[aij] += N - max(i, j)\n        else:\n            count[aij] += 1\nprint(*count)", "from collections import Counter\n\nn = int(input())\nc = Counter(input())\n\nflag = False\nfor char in c:\n    if c[char] >= 2: flag = True\n\nif n==1 or flag:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "n, k = int(input()), 3\nwhile n % k == 0: k *= 3\nprint(n // k + 1)", "n = int(input())\np = []\nwhile n != 0:\n    while len(p) >= 2 and p[-2] == p[-1]:\n        p[-2] += 1\n        p.pop()\n    p.append(1)\n    n -= 1\nwhile len(p) >= 2 and p[-2] == p[-1]:\n        p[-2] += 1\n        p.pop()\nprint(*p)\n        \n", "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,M = map(int,input().split())\nS = np.array(list(input().rstrip()),dtype='U1')\nLR = [[int(x) for x in input().split()] for _ in range(M)]\n\ncnt_0 = (S=='0').cumsum()\ncnt_1 = (S=='1').cumsum()\ncanuse_0 = cnt_0\ncanuse_1 = cnt_1\nfor L,R in LR:\n    canuse_0[L-1] = max(canuse_0[L-1],cnt_0[R-1])\n    canuse_1[L-1] = max(canuse_1[L-1],cnt_1[R-1])\nnp.maximum.accumulate(canuse_0,out=canuse_0)\nnp.maximum.accumulate(canuse_1,out=canuse_1)\n\n# 1\u3092\u4f7f\u3063\u305f\u500b\u6570\u3067\ndp = np.zeros(N+1,dtype=np.int64)\ndp[0] = 1\nfor i in range(N):\n    prev = dp\n    dp = np.zeros(N+1,dtype=np.int64)\n    # i\u756a\u76ee\u3092\u7f6e\u3044\u305f\u5f8c\u3067\u30011\u306e\u500b\u6570\u306e\u7bc4\u56f2\n    left = max(0,(i+1)-canuse_0[i])\n    right = canuse_1[i]\n    # 0\u3092\u4f7f\u3046\n    dp[left:right+1] += prev[left:right+1]\n    # 1\u3092\u4f7f\u3046\n    left = max(1,left)\n    dp[left:right+1] += prev[left-1:right]\n    dp %= MOD\n\nanswer = dp.sum()\nprint(answer)", "N, A, B = map(int, input().split())\n\nfor i in range(N//A+1):\n    if (N-i*A)%B==0:\n        ans = []\n        \n        for j in range(i):\n            l = []\n            \n            for k in range(1, A+1):\n                l.append(j*A+k)\n                \n            ans += l[1:]+[l[0]]\n        \n        for j in range((N-i*A)//B):\n            l = []\n            \n            for k in range(1, B+1):\n                l.append(i*A+j*B+k)\n            \n            ans += l[1:]+[l[0]]\n        \n        print(*ans)\n        break\nelse:\n    print(-1)", "n,k =list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\nbag=a[0]//k\nremain=a[0]%k\nfor i in range(1,n):\n    tk=a[i]+remain\n    remain=tk%k\n    if remain>a[i]:\n        bag+=1\n        remain=0\n    else:\n        bag+=tk//k\n    \nif remain==0:\n    print(bag)\n   \n        \nelse:  \n        \n    print(bag+1)        \n", "from collections import deque\nn, m = list(map(int, input().split()))\nsx, sy = list(map(int, input().split()))\nx, y = list(map(int, input().split()))\nsmap = [input() for i in range(n)]\n\n\nmp = [[-1] * m for i in range(n)]\n\n\nsx, sy = sx - 1, sy - 1\nmp[sx][sy] = 0\nans = 0\n\nq = deque()\n\nq.append((sx, sy))\n\n\ndef move(px, py, s, left):\n  if (px >= 0 and px < n and py >= 0 and py < m):\n    if (smap[px][py] == '.' and mp[px][py] == -1):\n      mp[px][py] = s\n      if left:\n        q.appendleft((px, py))\n      else:\n        q.append((px, py))\n\n\n\nwhile q:\n  px, py = q.popleft()\n  s = mp[px][py]\n  #print(s)\n  #print(s + py - r)\n  #print(s - py + r)\n  #print(s + py - r <= y * 2)\n  #print(s - py + r <= x * 2)\n  #print(x, y)\n  #return\n  ans += s + py - sy <= y * 2 and s - py + sy <= x * 2\n  \n  move(px + 1, py, s, left=True)\n  move(px - 1, py, s, left=True)\n  move(px, py + 1, s + 1, left=False)\n  move(px, py - 1, s + 1, left=False)\n  \nprint(ans)\n", "N,K=map(int,input().split())\nG=[1]+[0]*N\nfor i in range(K):\n for j in range(i,N):G[j+1]+=G[j]\nprint((G[-2]<<N-K-(K<N))%(10**9+7))", "n, a, b, k, f = list(map(int, input().split()))\ntotalCost = {}\nlastStop = ''\ntotal = 0\nfor i in range(n):\n    s1, s2 = input().split()\n    cost = a if lastStop != s1 else b\n    key = (min(s1, s2), max(s1, s2))\n    if key not in totalCost:\n        totalCost[key] = cost\n    else:\n        totalCost[key] += cost\n    total += cost\n    lastStop = s2\n\nsortedTotalCost = [(totalCost[key], key[0], key[1]) for key in totalCost]\nsortedTotalCost.sort(reverse=True)\n\ni = 0\nwhile i < len(sortedTotalCost) and k > 0 and sortedTotalCost[i][0] > f:\n    total -= sortedTotalCost[i][0]\n    total += f\n    k -= 1\n    i += 1\nprint(total)\n", "a=int(input())\nb=list(map(int,input().split()))\nn=0\nx=0\nif b[0]>b[1]:\n\tx=b[0]-b[1]\n\tfor i in range(len(b)-1):\n\t\tif b[i]-b[i+1]!=x:\n\t\t\tn=1\n\tif n==0:\n\t\tprint(b[-1]-x)\n\telse:\n\t\tprint(b[-1])\nelse:\n\tx=b[1]-b[0]\n\tfor i in range(len(b)-1):\n\t\tif b[i+1]-b[i]!=x:\n\t\t\tn=1\n\tif n==0:\n\t\tprint(b[-1]+x)\n\telse:\n\t\tprint(b[-1])\n", "n = int(input())\nl = list(map(int, input().split()))\ntemp = []\nfor i in l:\n    temp.append(len(bin(i & -i)[2:]))\nf = [0] * (61)\nfor i in temp:\n    f[i] += 1\ncmp = f.index(max(f))\nans = []\nfor i in range(n):\n    if temp[i] != cmp: ans.append(l[i])\nprint(len(ans))\nprint(*ans)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nT = int(input())\nfor _ in range(T):\n    N, K = list(map(int, input().split()))\n    A = [int(a) for a in input().split()]\n    if K not in A:\n        print(\"no\")\n        continue\n    \n    if N == 1 or (A[0] >= K and A[1] >= K):\n        print(\"yes\")\n        continue\n    \n    for i in range(2, N):\n        if A[i] >= K and (A[i-1] >= K or A[i-2] >= K):\n            print(\"yes\")\n            break\n    else:\n        print(\"no\")\n        continue\n", "s = input()\nlast = s.rfind('#')\ndif = s.count('(')-s.count(')')-s.count('#')\ntry:\n    assert dif >= 0\n    lev = 0\n    out = []\n    for i in range(len(s)):\n        c = s[i]\n        if c == '(': lev += 1\n        elif c == ')':\n            lev -= 1\n            assert lev >= 0\n        elif c == '#':\n            lev -= 1\n            if i == last:\n                out.append(dif+1)\n                lev -= dif\n            else:\n                out.append(1)\n            assert lev >= 0\n    assert lev == 0\n    for x in out: print(x)\nexcept AssertionError:\n    print(-1)\n    \n", "from collections import Counter\nfrom fractions import gcd\ninput()\ng, v = Counter(list(map(int, input().split()))), []\nwhile g:\n    x = max(g)\n    g[x] -= 1\n    for y in v:\n        g[gcd(x, y)] -= 2\n    v.append(x)\n    g += Counter()\nprint(' '.join(map(str, v)))\n", "n = int(input())\ns = [''] * n\nfor i in range(n):\n    s[i] = input()\nrow, col = 0, 0\nfor i in range(n):\n    for j in range(n):\n        if s[i][j] == '.':\n            break\n    else:\n        row = 1\n        break\nfor i in range(n):\n    for j in range(n):\n        if s[j][i] == '.':\n            break\n    else:\n        col = 1\n        break\nif row == col == 1:\n    print(-1)\n    return\nif row == 0:\n    for i in range(n):\n        for j in range(n):\n            if s[i][j] == '.':\n                print(i+1, j+1)\n                break\nelse:\n    for i in range(n):\n        for j in range(n):\n            if s[j][i] == '.':\n                print(j+1, i+1)\n                break\n", "n,k,x = list(map(int,input().split()))\nlis = list(map(int,input().split()))\npre=[0]*(n+2)\npos=[0]*(n+2)\nans=0\nm=x**k\nfor i in range(1,n):\n    pre[i]=pre[i-1]|lis[i-1]\nfor i in range(n,0,-1):\n    pos[i]=pos[i+1]|lis[i-1]\nfor i in range(1,n+1):\n    ans=max(ans,pre[i-1]|lis[i-1]*m|pos[i+1])\nprint(ans)    \n\n\n", "from collections import Counter\nn, m = list(map(int, input().split()))\nx = [[] for i in range(m)]\nfor i in range(n):\n    a = list(map(int, input().split()))\n    k = a[0]\n    for j in a[1:]:\n        x[j - 1].append(i)\n\n\nans = 1\nMOD = 10 ** 9 + 7\nfor e in list(Counter(list(map(str, x))).values()):\n    for i in range(2, e + 1):\n        ans = ans * i % MOD\n\nprint(ans)\n", "from sys import stdin\n\n__author__ = 'artyom'\n\n\ndef read_next_line():\n  return list(map(int, stdin.readline().strip().split()))\n\n\nn, k = read_next_line()\na = read_next_line()\nres = set(a)\n\nif k > 1:\n  excl = set()\n  for x in reversed(sorted(a)):\n    if x % k > 0 or x in excl:\n      continue\n    p = x / k\n    if p in res:\n      res.remove(p)\n      excl.add(p)\n\nprint(len(res))", "import sys\n\nk = [0] * 100001\nn = int(sys.stdin.readline())\nst = [int(x) for x in (sys.stdin.readline()).split()]\n\nfor i in st:\n    k[i] += 1\n    \nx = 0\ny = 0\n\nj = 100000\nwhile(j > 0):\n    if(j % 2 != 0):\n        x = max(x + k[j] * j, y)\n    else:\n        y = max(y + k[j] * j, x)\n    j -= 1\n        \nprint(max(x, y))", "import sys\ninput = sys.stdin.readline\n\nclass BIT:\n    def __init__(self, size):\n        self.bit = [0] * (size + 1)\n        self.size = size\n\n    def sum(self, i):\n        i += 1\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.bit[i] += x\n            i += i & -i\n\nn, m = list(map(int, input().split()))\na = list([int(x) - 1 for x in input().split()])\n\nbit0 = BIT(m)\nbit1 = BIT(m)\nfor i in range(n-1):\n    x, y = a[i], a[i+1]\n    bit1.add(0, (y - x) % m)\n    if (y - x) % m < 2:\n        continue\n    x = (x + 2) % m\n    if x <= y:\n        bit0.add(x, -1)\n        bit1.add(x, x - 1)\n        bit0.add(y + 1, 1)\n        bit1.add(y + 1, -(x - 1))\n    else:\n        bit0.add(x, -1)\n        bit1.add(x, x - 1)\n\n        b = (0 - (x - 1)) % m\n        bit0.add(0, -1)\n        bit1.add(0, -b)\n        bit0.add(y + 1, 1)\n        bit1.add(y + 1, b)\n\nans = min(bit0.sum(i) * i + bit1.sum(i) for i in range(m))\nprint(ans)\n", "S = input()\n\nans = 0\np, n = 0, 0\nfor i in range( len( S ) ):\n  if S[ i ] == '+':\n    p += 1\n    n -= 1\n  else:\n    n += 1\n    p -= 1\n  n = max( 0, n )\n  p = max( 0, p )\n  ans = max( ans, max( n, p ) )\n\nprint( ans )\n", "import sys\nn=int(input())\nf={\n 'AND':(lambda a:a[0]&a[1]),\n 'OR':(lambda a:a[0]|a[1]),\n 'XOR':(lambda a:a[0]^a[1]),\n 'NOT':(lambda a:a[0]^1),\n}\ng={'0':(lambda a:0), '1':(lambda a:1)}\nd=[(g[v[0]],[]) if o=='IN' else (f[o],[int(a)-1 for a in v]) for o,*v in map(str.split,sys.stdin.read().strip().split('\\n'))]\nt=[0]\nfor i in t:\n t.extend(d[i][1])\nv=[0 for _ in range(n)]\nfor i in t[::-1]:\n o,a=d[i]\n v[i]=o([v[x] for x in a])\nf=[0 for _ in range(n)]\nf[0]=1\nfor i in t:\n if f[i]<1: continue\n o,a=d[i]\n b=[v[x]for x in a]\n assert o(b)==v[i]\n for j,k in enumerate(a):\n  b[j]^=1\n  f[k]=(o(b)!=v[i])\n  b[j]^=1\nprint(''.join(str(f[i]^v[0]) for i in range(n) if not d[i][1]))", "s = n = int(input()) + 1\nt, r = [], list(range(n))[::-1]\nk = 2 ** 20\n\nwhile s:\n    while k >= 2 * s: k //= 2\n    t = r[n - s: n + s - k] + t\n    s = k - s\n\nprint(n*(n-1))\nprint(*t)", "n,k=map(int,input().split())\nif n<k:\n    print(-1)\n    return\nif n==k:\n    ans=[chr(i+97) for i in range(k)]\n    print(''.join(ans))\n    return\nif k==1:\n    print(-1)\n    return\nif k==2:\n    ans=\"ab\"*(n//2)+\"ab\"[:n%2]\n    print(ans)\n    return\nrem=k-2\nans=\"ab\"*(n//2)+\"ab\"[:n%2]\nans=list(ans)\nc=99\nfor i in range(n-rem,n):\n    ans[i]=chr(c)\n    c+=1 \nprint(''.join(ans))", "n = int(input())\narr = sorted(list(map(int, input().split())))\nres = 0\nmod = 1000000007\nacc = 0\narr = [arr[i+1] - arr[i] for i in range(n-1)]\nn -= 1\ns = sum(arr)\nfor i in range((n+1)//2):\n    acc += s\n    res += acc * pow(2, n-i-1, mod) % mod\n    if not i*2+1 == n:\n        res += acc * pow(2, i, mod) % mod\n    res %= mod\n    s -= arr[i] + arr[n-i-1]\nprint(res)", "\nN = int(input())\n\na = list(map(int,input().split()))\n\nend = [False] * N\ngive = []\n\nfor i in range(N):\n\n    if a[i] != 0:\n        end[a[i] - 1] = True\n\n    else:\n        give.append(i)\n\nwant = []\n\nfor i in range(N):\n    if not end[i]:\n        want.append(i)\n\n#print (give)\n#print (want)\n\nfor i in range(len(give) - 1):\n\n    if give[i] == want[i]:\n        t = want[i+1]\n        want[i+1] = want[i]\n        want[i] = t\n\nif give[-1] == want[-1]:\n    t = want[-1]\n    want[-1] = want[-2]\n    want[-2] = t\n\nfor i in range(len(give)):\n\n    a[give[i]] = want[i] + 1\n\nprint(\" \".join(map(str,a)))\n", "#\t!/usr/bin/env python3\n#\tencoding: UTF-8\n#\tModified: <26/Apr/2019 08:18:47 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\n\ndef input(): return sys.stdin.readline().strip()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    n = int(input())\n    a = list(input())\n    f = get_array()\n    flag = False\n    for i in range(n):\n        x = int(a[i])\n        if (x < f[x - 1]):\n            flag = True\n            a[i] = f[x - 1]\n        else:\n            if flag == True and x > f[x - 1]:\n                break\n    print(*a, sep='')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nf = [[] for i in range(20021)]\n\nfor i in range(1,20021):\n\tfor j in range(1,i+1):\n\t\tif j * j > i:\n\t\t\tbreak\n\t\tif i % j == 0:\n\t\t\t\tf[i].append(j)\n\t\t\t\tif j*j != i:\n\t\t\t\t\tf[i].append(i//j)\n\ndef solve():\n\ta,b,c = mints()\n\tans = (int(1e9),0,0,0)\n\tfor C in range(1,2*c+10):\n\t\tdc = abs(C-c)\n\t\t#print(C, f[C])\n\t\tfor B in f[C]:\n\t\t\tdb = abs(B-b)\n\t\t\tfor A in f[B]:\n\t\t\t\tans = min(ans, (dc+db+abs(A-a),A,B,C))\n\tprint(ans[0])\n\tprint(*ans[1:])\n\nfor i in range(mint()):\n\tsolve()\n", "# your code goes here\nn,k=map(int,input().split())\ns=input()\nc=0\nq=[s]\nd=set()\nls=0\nwhile q:\n\tp=q.pop(0)\n\tif p not in d:\n\t\tls+=1\n\t\tc+=(n-len(p))\n\t\tif ls==k:\n\t\t\tbreak\n\t\td.add(p)\n\t\tfor i in range(len(p)):\n\t\t\ttemp=p[:i]+p[i+1:]\n\t\t\tif temp not in d:\n\t\t\t\tq.append(temp)\n\t\t\t\nif ls==k:\n\tprint(c)\nelse:\n\tprint(-1)", "\nalp = \"abcdefghijklmnopqrstuvwxyz\"\n\ndic = {}\nfor i,s in enumerate(alp):\n    dic[s] = i\n\nlis = [0] * 27\n\nn = int(input())\nS = input()\nans = []\n\nfor i,s in enumerate(S):\n\n    ind = dic[s]\n\n    ans.append(max(lis[ind+1:]) + 1)\n\n    lis[ind] = ans[-1]\n\nprint(max(ans))\nprint(\" \".join(map(str,ans)))\n", "n=int(input())\nL=[input() for i in range(n)]\nL.sort(key=len)\nflag=True\nfor i in range(1,n):\n    if L[i-1] not in L[i]:\n        flag=False\n        break\nif flag:\n    print(\"YES\")\n    for i in L:\n        print(i)\nelse:\n    print(\"NO\")\n", "import math\na,b = [int(x) for x in input().split()]\n\narea = a+b\nt = int(math.sqrt(area))\nsa = int(math.sqrt(a))\nsb = int(math.sqrt(b))\n\nD = []\nDA = []\nDB = []\nfor i in range(1,t+1):\n    if area % i == 0:\n        if i*i != area:\n            D.append(i)\n            D.append(area//i)\n        else:\n            D.append(i)\n\nfor i in range(1,sa+1):\n    if a % i == 0:\n        if i*i != a:\n            DA.append(i)\n            DA.append(a//i)\n        else:\n            DA.append(i)\n            \nfor i in range(1,sb+1):\n    if b % i == 0:\n        if i*i != b:\n            DB.append(i)\n            DB.append(b//i)\n        else:\n            DB.append(i)\nDA.sort()\nDB.sort()\nD.sort()\n\nstart = ((len(D)+1)//2)-1\ndiv = len(D)\n\ndef closestdiv(t,D):\n    low = 0\n    high = len(D)-1\n    while high - low > 1:\n        guess = (high+low)//2\n        if D[guess] > t:\n            high = guess\n        else:\n            low = guess\n    if D[high] <= t:\n        return high\n    else:\n        return low\n    \nwhile start > -1:\n    t = D[start]\n    s = D[-start-1]\n    if DA[-closestdiv(t,DA)-1] <= s:\n        print(2*t+2*s)\n        break\n    elif DB[-closestdiv(t,DB)-1] <= s:\n        print(2*t+2*s)\n        break\n    start -= 1", "n = int(input())\ns = input()\nnajm = [0] * n\nnajm[n-1] = s[n-1]\nfor i in range(n-1):\n    j = n - i - 2\n    najm[j] = min(najm[j+1], s[j+1])\ncan_sort = True\nfor i in range(n):\n    for j in range(i+1, n-1):\n        if s[i] > s[j] and s[j] > najm[j]:\n            can_sort = False\n            break\nif not can_sort:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    kol = [-1] * n\n    kol[0] = 0\n    ind = 0\n    while ind < n:\n        if kol[ind] == -1:\n            kol[ind] = 0\n        for i in range(ind+1,n):\n            if s[i] < s[ind]:\n                kol[i] = (kol[ind]+1)%2\n        ind += 1\n    print(\"\".join(map(str,kol)))", "def subseq(a, b):\n    j = 0\n    for i in range(len(a)):\n        if j < len(b) and a[i] == b[j]:\n            j = j + 1\n    if j == len(b):\n        return True\n    else:\n        return False\n\n\ns = input()\nt = input()\nans = 0\n\nfor i in range(len(s)):\n    for j in range(i, len(s)):\n        cur = s[:i] + s[j+1:len(s)]\n        if subseq(cur, t) and j - i + 1 > ans:\n            ans = j - i + 1\nprint (ans)\n", "\nimport sys\nn,d,k=list(map(int,input().split()))\nif(n<=d):\n    print('NO')\n    return\nif(k==1 and n>2):\n    print('NO')\n    return\n\nedgestot=[]\nedges=[[] for i in range(n)]\ntovisit=[]\nfor i in range(d):\n    edgestot.append([i,i+1])\n    tovisit.append([i+1,min(i+1,d-i-1)])\n    edges[i].append(i+1)\n    edges[i+1].append(i)\ncur=d+1\nwhile(cur<n and len(tovisit)>0):\n    x=tovisit.pop()\n    if(x[1]==0):\n        continue\n    while(len(edges[x[0]])<k and cur<n):\n        tovisit.append([cur,x[1]-1])\n        edgestot.append([cur,x[0]])\n        edges[x[0]].append(cur)\n        edges[cur].append(x[0])\n        cur+=1\n\n#print(edgestot)\nif(len(edgestot)==n-1):\n    print('YES')\n    for i in range(n-1):\n        print(edgestot[i][0]+1,edgestot[i][1]+1)\n    \nelse:\n    print('NO')\n", "n=int(input())\na1,a3,a2=map(int,input().split())\nb1,b3,b2=map(int,input().split())\nmaxx=min(a1,b3)+min(a2,b1)+min(a3,b2)\nminn=max(0,a1-b1-b2)+max(0,a2-b2-b3)+max(0,a3-b3-b1)\nprint(minn,maxx)", "n = int(input())\nf = 0\na = list(map(int , input().split()))\nfor i in range(n - 1):\n    if(abs(a[i] - a[i + 1]) > 1):\n        f = 1\nprint([\"YES\" , \"NO\" ][f])\n", "def go():\n    from collections import Counter\n    n = int(input())\n    a = [i for i in input()]\n    b = [i for i in input()]\n    if Counter(a) != Counter(b):\n        return -1\n    i = 0\n    o = []\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n        else:\n            j = i + 1\n            while j < n and a[j] != b[i]:\n                j += 1\n            for k in range(j, i, -1):\n                a[k], a[k - 1] = a[k - 1], a[k]\n                o.append(k)\n    print(len(o))\n    return ' '.join(str(i) for i in o)\n\nprint(go())\n", "def main():\n    n = int(input())\n    ain = [input() for _ in range(2*n - 2)]\n    a = sorted(ain, key=lambda x: len(x), reverse=True)\n\n    s1 = a[0] + a[1][-1]\n    d = { k: [] for k in a }\n\n    next = False\n    for i in range(1, n):\n        try:\n            d[s1[:i]].append('P')\n            d[s1[-i:]].append('S')\n        except KeyError:\n            next = True\n\n    if not next:\n        result = []\n        for e in ain:\n            if not d[e]:\n                break\n            result.append(d[e][0])\n            d[e].pop(0)\n        else:\n            print(''.join(result))\n            return\n\n    s1 = a[1] + a[0][-1]\n    d = { k: [] for k in a }\n\n    for i in range(1, n):\n        d[s1[:i]].append('P')\n        d[s1[-i:]].append('S')\n\n    result = []\n    for e in ain:\n        if not d[e]:\n            break\n        result.append(d[e][0])\n        d[e].pop(0)\n    else:\n        print(''.join(result))\n        return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "b =[1,1,2,7,4]\na =list(map(int,input().split()))\nans = 100\nfor i in range(5):\n    ans = min(a[i]//b[i],ans)\nprint(ans)\n\n", "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(1, n-1):\n    if(a[i] == 0 and a[i-1]==1 and a[i+1]==1):\n        ans+=1\n        a[i+1] = 0\nprint(ans)", "a,b,c,d = [int(s) for s in input().split()]\nprint(max([a * c, a * d, b * c, b * d]))", "n,m=list(map(int,input().split()))\na=[int(input()) for i in range(m)]\na=set(a)\nmod=10**9+7\ndp=[0]*(n+7)\ndp[0]=1\nfor i in range(n+1):\n    if i+2 not in a: #2\u6bb5\u5148\u304c\u58ca\u308c\u3066\u3044\u306a\u3044\n        dp[i+2]+=dp[i]\n    if i+1 not in a: #1\u6bb5\u5148\u304c\u58ca\u308c\u3066\u3044\u306a\u3044\n        dp[i+1]+=dp[i]\n    dp[i+2]%=mod\n    dp[i+1]%=mod\nprint((dp[n]%mod))\n", "ls = [0, 4, 22, 27, 58, 85, 94, 121, 166, 202, 265, 274, 319, 346, 355, 378, 382, 391, 438, 454, 483, 517, 526, 535, 562, 576, 588, 627, 634, 636, 645, 648, 654, 663, 666, 690, 706, 728, 729, 762, 778, 825, ]\nprint(ls[int(input())])", "n=int(input())\nif n%2==0:\n    print(0)\nelse:\n    print(1)", "for _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    ar = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            ar.append(i)\n            ar.append(n // i)\n        i += 1\n    ar.sort()\n    i = len(ar) - 1\n    ans = n\n    while i >= 0:\n        if ar[i] <= k:\n            ans = n // ar[i]\n            break\n        i -= 1\n    print(ans)", "from itertools import combinations\nn, m = map(int, input().split())\nksm = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nonoff = [0]*n\ntotal = 0\ndef dfs(i, onoff):\n    nonlocal total\n    if i == n:\n        flag = True\n        for idx, j in enumerate(ksm):\n            count = 0\n            for k in j[1:]:\n                count += onoff[k-1]\n            if count%2 != p[idx]:\n                flag = False\n        if flag:\n            total += 1\n        return\n    dfs(i+1, onoff[:])\n    dfs(i+1, onoff[:i]+[1]+onoff[i+1:])\n\ndfs(0, onoff)\nprint(total)", "class BinaryIndexedTree:\n  def __init__(self, n):\n    self.bit = [0] * n\n\n  def add(self, i, x):\n    i += 1\n    while i <= len(self.bit):\n      self.bit[i-1] += x\n      i += i & -i\n\n  def sum_sub(self, i):\n    a = 0\n    i += 1\n    while i:\n      a += self.bit[i-1]\n      i -= i & -i\n    return a\n\n  def sum(self, i, j):\n    a = 0\n    if j != 0:\n      a += self.sum_sub(j-1)\n    if i != 0:\n      a -= self.sum_sub(i-1)\n    return a\n\ndef f(m):\n  ans=0\n  bit=BinaryIndexedTree(2*n+7)\n  f=0\n  for i in range(n):\n    bit.add(n+f,1)\n    if a[i]>m:f-=1\n    else:f+=1\n    ans+=bit.sum_sub(n+f)\n  return ans\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nprint(f(m)-f(m-1))", "n = int(input())\nu = list(map(int, input().split()))\ni1 = 0; i2 = n - 1\nans = []\nm = 0\np = []\nwhile 1 == 1:\n    m1 = min(u[i1], u[i2])\n    m2 = max(u[i1], u[i2])\n    if m > m2:\n        break\n    #print(m, m1, m2)\n    if m > m1:\n        p.append(m2)\n        m = m2\n        if u[i1] > u[i2]:\n            i1 += 1\n            ans.append('L')\n        else:\n            i2 -= 1\n            ans.append('R')\n    else:\n        p.append(m1)\n        m = m1\n        if u[i1] < u[i2]:\n            i1 += 1\n            ans.append('L')\n        else:\n            i2 -= 1\n            ans.append('R')\n    if i1 > i2:\n        break\n    #print(p)\nprint(len(ans))\nprint(''.join(ans))\n", "def f(n):\n    a=0\n    while(n>0):\n        a+=n%10\n        n//=10\n    return a\nn=int(input())\nwhile f(n)%4!=0:\n    n+=1\nprint(n)\n", "n = int(input())\nl = []\nwhile n:\n    n -= 1\n    l.insert(0,chr(97 + (n % 26)))\n    n //= 26\nprint((''.join(l)))\n", "t=int(input())\nfor _ in range(t):\n    n, m = list(map(int, input().split()))\n    if n==1:\n        print(0)\n    elif n==2:\n        print(m)\n    else:\n        print(2*m)\n", "s = input()\n\nops = []\n\nfor i in range(0,len(s)):\n    ch = s[i]\n    if ch == '+' or ch == '-':\n        ops.append(i)\nops.append(len(s))\n\n\nfor i in range(0,len(ops)-1):\n    ch = s[ops[i]]\n    if ch == '-':\n        s += '+3'\n    if ch == '+':\n        s += '-5'\n    for j in range(ops[i], ops[i + 1] - 1):\n        s += '0'\n\n#print(s)\nprint(eval(s))", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, K, X = MAP()\nA = [0] + LIST()\n\ndp = list2d(X+1, N+1, -1)\ndp[0][0] = 0\nfor i in range(X):\n    for j in range(i, N):\n        if dp[i][j] == -1:\n            continue\n        for k in range(j+1, min(j+K+1, N+1)):\n            dp[i+1][k] = max(dp[i+1][k], dp[i][j] + A[k])\nans = max(dp[X][-K:])\nprint(ans)\n", "s = input()\ncount = 0\nfor i in range(len(s)//2):\n    if s[i] != s[-(i + 1)]:\n        count+= 1\nprint(count)", "i = int(input())\ns = input().split()\n\nl = []\nfor j in s:\n    if not l or  int(j)%2 != l[-1]:\n        l.append(int(j)%2)\n    else:\n        l.pop()\n\nif len(l) < 2:\n    print('YES')\nelse:\n    print('NO')\n", "n = int(input())\ns = input()\na = [[0] * 26 for _ in range(26)]\nfor i in range(n -1):\n    a[ord(s[i]) - ord('A')][ord(s[i + 1]) - ord('A')] += 1\n\nmx = -1\n\nfor i in range(26):\n    for j in range(26):\n        if a[i][j] > mx:\n            mx = a[i][j]\n            ans = chr(i + ord('A')) + chr(j + ord('A'))\n\nprint(ans)\n", "import math\nn=int(input())\na=[*map(int,input().split())]\nans=0\nfor i in a:\n    ans=math.gcd(ans,i)\nprint(ans)", "S = input()\n\nprint((\"Yes\", \"No\")[\"L\" in S[::2] or \"R\" in S[1::2]])", "##C - Ubiquity\nN = int(input())\nans = 10**N - 2*(9**N) +8**N\nprint(ans%(10**9+7))", "from collections import *\nn = int(input())\nv = list(map(int,input().split()))\nif len(set(v))==1:\n    print(len(v)//2)\n    return\nn_even = v[0::2]\nn_odd = v[1::2]\na = Counter(n_even).most_common()+[(0,0)]\nb = Counter(n_odd).most_common()+[(0,0)]\n#print(a)\n#print(b)\nif a[0][0] == b[0][0]:\n    ans = min(n-a[0][1]-b[1][1],n-a[1][1]-b[0][1])\nelse:\n    ans = n - a[0][1] - b[0][1]\nprint(ans)", "from collections import defaultdict\nmaxn = 2000000000\n\nmk = []\nbs = 1\n\nwhile bs <= maxn:\n    mk.append(bs)\n    bs *= 2\n\nn = int(input())\nls = [int(i) for i in input().split()]\n\ndic = defaultdict(int)\nfor i in ls:\n    dic[i] += 1\n\ncnt = 0\nfor i in ls:\n    dic[i] -= 1\n    flag = False\n    for j in mk:\n        if dic[j - i] > 0:\n            flag = True\n            break\n\n    if not flag:\n        cnt += 1\n    dic[i] += 1\n\nprint(cnt)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 11 01:27:46 2020\n\n@author: liang\n\"\"\"\n\nN, M = map(int,input().split())\nL = list()\nR = list()\nfor i in range(M):\n    l, r = map(int,input().split())\n    L.append(l)\n    R.append(r)\n\nans = min(R) - max(L) + 1\nif ans < 0:\n    ans = 0\nprint(ans)", "a, b, k = map(int,input().split())\n\na_ans = max(0, a-k)\nb_ans = max(0, b-max(0, k-a))\n\nprint(a_ans,b_ans)", "X = int(input())\n\nans = 0\ndeposit = 100\n\nwhile deposit < X:\n    deposit = deposit + (deposit // 100)\n    ans += 1\n\nprint(ans)", "#ABC162\nK=int(input())\nans=0\nimport math\nfor i in range(1,K+1):\n    for j in range(1,K+1):\n        a = math.gcd(i,j)\n        for k in range(1,K+1):\n            l=math.gcd(a,k)\n            ans+=l\nprint(ans)", "n = int(input())\n\ndoubles = 0\njail = False\n\nfor i in range(n):\n    dice = input().split()\n    if dice[0] == dice[1]:\n        doubles += 1\n    else:\n        doubles = 0\n    if doubles == 3:\n        jail = True\n        print('Yes')\n\nif not jail:\n    print('No')", "n = int(input())\nprint(n ** 2)", "N = int(input())\nL = list(map(int, input().split()))\nsortL = sorted(L)\nprint('Yes' if sortL[-1] < sum(sortL[:-1]) else 'No')", "#n\u306f\u6841\u6570\u3000 (1,0)\u304c\u542b\u307e\u308c\u3066\u308b\u6642\u3068\u3001(2,4),(2,7)\u307f\u305f\u3044\u306a\u5165\u529b\u306e\u6642\u306f\u3060\u3081\nn,m = list(map(int,input().split()))\ns = [0]*m\nc = [0]*m\nd = dict()\nans = 0\n\nfor x in range(m):\n    s[x],c[x] = list(map(int,input().split()))\n    if s[x] not in d:\n        d[s[x]] = c[x]\n    elif d[s[x]] != c[x]:\n        ans = -1\n        break\n\nelse:\n    ans = \"\"\n    for x in range(1,n+1):\n        if x in d :\n            if x != 1:\n                ans += str(d[x])\n            elif x == 1 and d[x] != 0:\n                ans += str(d[x])\n            elif n == 1 and d[x] == 0:\n                ans += \"0\"\n            else:\n                ans = -1\n                break\n        else:\n            if m != 0:\n                if x == 1:\n                    ans += str(1)\n                else:\n                    ans += str(0)\n            else:\n                if n == 1:\n                    ans = str(0)\n                else:\n                    ans = \"1\" + (\"0\"*(n-1))\n\nprint(ans)\n", "n, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\nvalue_lists = [[] for _ in range(2 * (10**5) + 1)]\nfor val in arr:\n    turn = 0\n    while val != 1:\n        value_lists[val].append(turn)\n        val //= 2\n        turn += 1\n    value_lists[val].append(turn)\nmindist = 999999999\nfor turns_val in value_lists:\n    if len(turns_val) < k:\n        continue\n    turns_val.sort()\n    mindist = min(mindist, sum(turns_val[:k]))\nprint(mindist)\n", "\n\nfor _ in range(int(input())):\n\tn,a,b=list(map(int,input().rstrip().split(\" \")))\n\tif(a+a>b):\n\t\tif(n%2!=0):\n\t\t\tprint(((n//2)*b)+a)\n\t\telse:\n\t\t\tprint((n//2)*b)\n\telse:\n\t\tprint(n*a)\n", "print(\"x\"*len(input()))", "n = int(input())\na = list(map(int,input().split()))\nmax_num = a[0]\nif n==1:\n  print('Yes')\n  \nelse:\n  flag = True\n  for i in range(1,n):\n    max_num = max(max_num,a[i])\n    if max_num-a[i]>=2:\n      print('No')\n      flag = False\n      break\n    else:\n      pass\n  if flag == True:\n    print('Yes')", "n = int(input())\nw = list(map(int,input().split()))\ns = sum(w)\nans = int(100000000)\nm = int(0)\nfor i in range(n):\n    m += w[i]\n    ans = min(ans,abs(2*m-s))\nprint(ans)", "def solve():\n    n = int(input())\n    A = [int(k) for k in input().split()]\n    \n    A.sort()\n    \n    ans = 0\n    \n    for i in range(0,n,2):\n        ans += (A[i+1] - A[i])\n        \n    print (ans)\n    \nsolve()", "D,N = map(int,input().split())\nif N == 100:\n    N += 1\nprint(N*100**D)", "from math import gcd\n\n\nN, *A = list(map(int, open(0).read().split()))\n\nacc_l = [0] * (N + 1)\nacc_r = [0] * (N + 1)\nfor i in range(1, N + 1):\n    acc_l[i] = gcd(acc_l[i - 1], A[i - 1])\n    acc_r[i] = gcd(acc_r[i - 1], A[-i])\nans = 0\nfor i in range(N + 1):\n    ans = max(ans, gcd(acc_l[i], acc_r[N - i - 1]))\nprint(ans)\n", "from itertools import product\n\nh, w, k = map(int, input().split())\nCC = [input() for _ in range(h)]\n\ntotal = 0\nfor x in product((0, 1), repeat=w):\n  for y in product((0, 1), repeat=h):\n    count = 0\n    for i in range(h):\n      if y[i]:\n        continue\n      for j in range(w):\n        if x[j]:\n          continue\n        if CC[i][j] == '#':\n          count += 1\n    if count == k:\n      total += 1\nprint(total)", "l, r = list(map(int, input().split()))\n\nif (r-l)//2019 >= 1:\n    print((0))\nelse:\n    ans = float('inf')\n    for i in range(l, r+1):\n        for j in range(l, r+1):\n            if i != j:\n                ans = min(ans, (i*j)%2019)\n\n    print(ans)\n", "import math\n\nn=int(input())\nx=[*map(int,input().split())]\ny=[*map(int,input().split())]\ncnt=dict()\nfixcnt=0\nzeroToCnt=0\n\nfor i in range(n):\n    if x[i]==0:\n        if y[i]==0: fixcnt+=1\n        continue\n    if y[i]==0:\n        zeroToCnt+=1\n        continue\n    gc=math.gcd(x[i],y[i])\n    tx,ty=x[i]//gc,y[i]//gc\n    if tx*ty>=0: si=True\n    else: si=False\n    cnt[(abs(tx),abs(ty),si)]=cnt.get((abs(tx),abs(ty),si),0)+1\n\ncntRes=max(zeroToCnt,max(cnt.values() if cnt else [0]))\nprint(cntRes+fixcnt)", "n=int(input())\nb=list(map(int,input().split()))\nans=0\nfor i in range(n-2):\n  ans+=min(b[i],b[i+1])\nans+=b[0]\nans+=b[n-2]\nprint(ans)", "n = int(input())\na = list(map(int,input().split()))\na.sort()\nprint(a[len(a) - 1] - a[0])", "N = int(input())\nlocs = []\nS = 0\n\nfor _ in range(N):\n  locs.append(list(map(int,input().split())))\n  \nfor i in range(N):\n  for j in range(i+1,N):\n    dis = ((locs[i][0]-locs[j][0])**2 + (locs[i][1]-locs[j][1])**2)**(1/2)\n    S += dis\n\nprint(2*S/N)", "a,b=map(int,input().split())\nif a-2*b>=0:\n    print(a-2*b)\nelse:\n    print(\"0\")", "import math\nn=int(input())\nans=100\nfor a in range(1,int(math.sqrt(n))+1):\n    if n%a==0:\n        m=max(len(str(a)),len(str(n//a)))\n        ans=min(ans,m)\nprint(ans)", "import sys\nfrom io import StringIO\nimport unittest\nimport itertools\n\ndef yn(b):\n    print(\"Yes\" if b==1 else \"No\")\n    return\n\ndef resolve():\n    readline=sys.stdin.readline\n    n=int(readline())\n    dat = [[-1 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        m=int(readline())\n        for j in range(m):\n            x,y=map(int, readline().rstrip().split())\n            x-=1\n            dat[i][x] = y\n    \n    ans=0\n    for ptn in itertools.product([False,True], repeat=n):\n        ok=True\n        for i in range(n):\n            if ptn[i]==False:\n                continue\n            for j in range(n):\n                if dat[i][j] == -1:\n                    continue\n                if dat[i][j] == 1 and ptn[j]==False:\n                    ok=False\n                    break\n                if dat[i][j] == 0 and ptn[j]==True:\n                    ok=False\n                    break\n            if ok==False:\n                break\n        if ok==True:\n            ans=max(ans,ptn.count(True))\n    print(ans)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    return", "k,s=int(input()),input();print([s[:k]+'...',s][len(s)<=k])", "#-*-coding:utf-8-*-\nimport sys\ninput=sys.stdin.readline\nimport numpy as np\n\ndef main():\n    n = int(input())\n    numbers=list(map(int,input().split()))\n    numbers=np.array(numbers)\n    count=0\n    \n    if np.all(numbers%2==1):\n        print(0)\n        return\n    while True:\n        if np.all(numbers%2==1)==True:\n            break\n        else:\n            idx=np.where(numbers%2==0)\n            count+=np.count_nonzero(numbers%2==0)\n            numbers[idx]=numbers[idx]//2\n    print(count)\n\ndef __starting_point():\n    main()\n__starting_point()", "x, y = list(map(int, input().split()))\n\nans = 'No'\n\nfor i in range(x + 1):\n    j = x - i\n    if 2 * i + 4 * j == y:\n        ans = 'Yes'\n        break\n\nprint(ans)\n", "n, k = [int(x) for x in input().split()]\ns = [int(x) for x in input().split()]\nd = {}\nfor i in range(n):\n    if s[i] not in d:\n        d[s[i]] = 1\n    else:\n        d[s[i]] += 1\nq = []\nfor i in d:\n    q.append((i, d[i]))\nq.sort()\n# print(q)\nl = 0\nif k == 0:\n    if q[0][0] == 1:\n        print(-1)\n        return\n    else:\n        print(q[0][0] - 1)\n        return\n    \nfor i in range(len(d)):\n    l += q[i][1]\n    if l == k:\n        print(q[i][0])\n        return\nprint(-1)\n\n", "n, m = [int(i) for i in input().split()]\nf = [True] * (m + 1)\nf[0] = False  \nfor i in range(n):\n    p, q = [int(j) for j in input().split()]\n    for j in range(p, q + 1):\n        f[j] = False\nprint(sum(f))\nfor i in range(1, m + 1):\n    if f[i]:\n        print(i, end = \" \")\nprint()\n\n", "n = int(input())\n\nif n % 9 == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "def main():\n    s = input()\n    t = input()\n    ans = 'No'\n    s2 = s * 2\n    for i in range(len(s2)):\n        if t == s2[i:i + len(s)]:\n            ans = 'Yes'\n            break\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    S = input()\n    T = input()\n    size = len(T)\n    count = 10000\n    for i in range(len(S)-size+1):\n        x = 0\n        for j in range(size):\n            if S[i+j] != T[j]:\n                x+=1\n        count = min(count,x)\n    print(count)              \n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "a,b,k = list(map(int,input().split()))\n\ncnt = 0\nans = 0\nl = []\nfor i in range(1,101):\n    if(a%i==0 and b%i==0):\n        l.append(i)\n\nans = l[-1*k]    \nprint(ans)\n    \n\n", "a,b=list(map(int,input().split()))\nprint((b-2)//(a-1)+1)", "n = int(input())\nab = 0\nfor i in range(n):\n    x, y = map(float, input().split())\n    ab += y\nprint(5 + ab / n)", "import math\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split())) + [-1]\na.sort(reverse=True)\ns = sum(a)\n\nif m > s + 1:\n    print(-1)\n    return\n\nleft, r = 0, n\nwhile r - left > 1:\n    mid = (left + r) // 2\n\n    minus = 0\n    i = 0\n    ans = 0\n    while a[i] > minus:\n        cur = i\n        while cur - i < mid:\n            if a[cur] <= minus:\n                minus = 999999999\n                break\n            ans += a[cur] - minus\n            cur += 1\n        i = cur\n        minus += 1\n    if ans >= m:\n        r = mid\n    else:\n        left = mid\nprint(r)\n", "from operator import itemgetter\n#int(input())\n#map(int,input().split())\n#[list(map(int,input().split())) for i in range(q)]\n#print(\"YES\" * ans + \"NO\" * (1-ans))\nn,k =  map(int,input().split())\nsi = list(map(int,input().split()))\nnum = 10**5 * 2 + 1\nai = [0] * num\nfor i in range(n):\n    ai[si[i]] += 1\nnum3 = num\nnum = max(ai) + 1\nai2 = [[] for i in range(num)]\nfor i in range(num3):\n    if ai[i] != 0:\n        ai2[ai[i]] += [[i,1,ai[i]]]\ni = num-1\nwhile k > 0:\n    for j in ai2[i]:\n        if k == 0:\n            break\n        num2 =  j[2] // (j[1]+1)\n        ai2[num2] += [[j[0],j[1]+1,j[2]]]\n        print(j[0],end=\" \")\n        k -= 1\n    i -= 1\n    \n", "n = int(input())\nfile_name = input()\n\nto_remove = 0\ncurrent_streak = 0\n\nfor i in range(n):\n\tif file_name[i] != 'x':\n\t\tcurrent_streak = 0\n\t\tcontinue\n\telse:\n\t\tcurrent_streak += 1\n\t\tif current_streak > 2:\n\t\t\tto_remove += 1\n\n\nprint(to_remove)", "AB,BC,CA= map(int, input().split())\n\nprint(int(AB*BC/2))", "a, b, c = map(int, input().split())\nprint(b//a if b//a < c else c)", "a, b = map(int, input().split())\nprint(a*b)", "a,b,c=map(int,input().split())\nprint(max(0,c-(a-b)))", "import itertools\nN = int(input())\nP = tuple(map(int,input().split()))\nQ = tuple(map(int,input().split()))\np = list(itertools.permutations(range(1,N+1)))\nprint(abs(p.index(P)-p.index(Q)))    ", "S = input()\ncnt = 0\nres = 0\nfor s in S:\n    if s in \"AGCT\":\n       cnt += 1\n       res = max(res,cnt)\n    else:\n        cnt = 0\nprint(res)\n", "N, M = map(int, input().split())\nprint('Yes' if N == M else 'No')", "l = [0]\n\ndef count(size):\n    nums = (10**size - 10**(size - 1))\n    small =  l[size-1] + size\n    large = l[size-1] + nums * size\n    if len(l) <= size:\n        l.append(large)\n    return (nums * (small + large))//2\n\ndef test(minSize, size, val):\n    out = minSize * val + size * ((val + 1) * val)//2\n    return out\n\nq = int(input())\nfor _ in range(q):\n    want = int(input())\n\n    size = 1\n    while want > count(size):\n        want -= count(size)\n        size += 1\n\n    minSize = l[size - 1]\n\n    lo = 0 #Impossible\n    hi = (10**size - 10**(size - 1)) #Possible\n\n    while hi - lo > 1:\n        testV = (lo + hi) // 2\n        out = test(minSize, size, testV)\n\n        if out < want:\n            lo = testV\n        else:\n            hi = testV\n\n    want -= test(minSize, size, lo)\n\n    newS = 1\n    while 9 * (10**(newS - 1)) * newS < want:\n        want -= 9 * (10**(newS - 1)) * newS\n        newS += 1\n\n    want -= 1\n\n    more = want//newS\n    dig = want % newS\n    value = 10**(newS - 1) + more\n    print(str(value)[dig])\n\n    \n", "n = input()\nn = int(n)\na = input()\na = [int(i) for i in a.split()]\na.sort()\n\n_min = 0\n_max = 0\n_dict = {}\nfor i in a:\n    if _min < i-5:\n        _max = max(_max, sum(_dict.values()))\n        _dict = {key:value for key, value in _dict.items() if key >= i-5}\n    _dict[i] = _dict[i] + 1 if i in _dict else 1\n_max = max(_max, sum(_dict.values()))\nprint(_max)", "for i in range(int(input())):\n    k, n, a, b = list(map(int, input().split()))\n    if k <= n * b:\n        print(-1)\n        continue\n    if (k - n * b) % (a - b) == 0:\n        print(min((k - n * b) // (a - b) - 1, n))\n    else:\n        print(min(int((k - n * b) / (a - b)), n))\n", "import sys\nfrom io import StringIO\n\n\ndef main():\n    def find_set(v):\n        tmp = []\n        while v != parent[v]:\n            tmp.append(v)\n            v = parent[v]\n        for i in tmp:\n            parent[i] = v\n\n        return v\n\n\n    sys.stdin = StringIO(sys.stdin.read())\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n    n, m = list(map(int, input().split(' ')))\n    a = list(map(int, input().split(' ')))\n\n\n    edges = []\n    for _ in range(m):\n        x, y, w = list(map(int, input().split(' ')))\n        edges.append((x - 1, y - 1, w))\n\n\n    min_val = min(a)\n    min_ind = a.index(min_val)\n\n    for i in range(n):\n        edges.append((min_ind, i, min_val + a[i]))\n\n\n    parent, rank = list(range(n)), [0] * n\n    cost = 0\n\n    for edge in sorted(edges, key=lambda edge: edge[2]):\n        find_u, find_v = find_set(edge[0]), find_set(edge[1])\n\n        if find_u != find_v:\n            cost += edge[2]\n\n            if rank[find_u] < rank[find_v]:\n                find_v, find_u = find_u, find_v\n            elif rank[find_u] == rank[find_v]:\n                rank[find_u] += 1\n\n            parent[find_v] = find_u\n\n    print(cost)\n\nmain()\n", "N = int (input ())\nT,A = map (int, input ().split ())\nS = 1000000\nl = [int (x) for x in input().split()]\nfor i in range (len(l)):\n  s = abs((T-l[i]*0.006)-A)\n  if s < S:\n    S = s\n    ans = i\nprint (ans+1)", "p, q, r = list(map(int, input().split()))\nprint((p + q + r - max(p, q, r)))\n", "X,A=list(map(int,input().split()))\nif X<A:\n    print((0))\nelse:\n    print((10))\n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    A, B = list(map(int, readline().split()))\n\n    if A > B:\n        print((A + (A - 1)))\n    elif A < B:\n        print((B + (B - 1)))\n    else:\n        print((A + B))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n\ndef primefac(n):\n    s = []\n    x = int(math.sqrt(n))+1\n    for i in range(2,x+1):\n        if n%i == 0:\n            cnt= 0\n            while n%i == 0:\n                n //=i\n                cnt += 1\n            s.append([i,cnt])\n    if n != 1:\n        s.append([n,1])\n    return(s)\n  \nn = int(input())\nans = 0\nfor i in range(1,n+1):\n    x = 1\n    s = primefac(i)\n    for t in s:\n        x *= t[1]+1\n    if x == 8 and i%2 == 1:\n        ans += 1\nprint(ans)\n    \n", "\ndef main():\n    x, y = list(map(int, input().split()))\n    if x % y != 0:\n        print((abs((x // y + 1) - (x // y))))\n    else:\n        print((abs((x // y) - (x // y))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\ndiv_n = -(-n // 111)\nprint(111 * div_n)", "import math\nR = int(input())\nprint(2*math.pi*R)", "a,b=list(map(int, input().split()))\n\nprint((max(a+b,a-b,a*b)))\n", "inp=input()\nn=int(inp.split()[0])\nx=int(inp.split()[1])\nt=int(inp.split()[2])\nimport math\nif n%x!=0:\n  value=int(n/x)+1\nelse:\n  value=n/x\nprint(int(value*t))", "a= list(map(int,input().split()))\nif (a[0]+a[1]) % 2 == 0:\n  print((a[0]+a[1])//2)\nelse:\n  print(\"IMPOSSIBLE\")", "print(\"Yes\") if \"7\" in list(input()) else print(\"No\")", "N = input()\nprint((\"Yes\" if int(N) % sum(map(int, N)) == 0 else \"No\"))\n", "n=int(input())\ns=list(input())\nif n%2==0:\n    bef=s[:n//2]\n    aft=s[n//2:]\n    if bef==aft:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")", "w,h,x,y=map(int,input().split())\nche=0\ncenter=(w/2,h/2)\nif (x,y)==center:\n  che=1\nprint(w*h/2,che)", "n,x,y=map(int,input().split())\narr=list(map(int,input().split()))\nif x<=y:\n\tc=0\n\tarr=sorted(arr)\n\tfor i in range(0,len(arr),2):\n\t\tif arr[i]<=x:\n\t\t\tc+=1\n\tprint(c)\n\treturn\n# if x==y:\n# \tc=0\n# \tfor i in range(0,len(arr)):\n# \t\tif arr[i]<=x:\n# \t\t\tc+=1\n# \tprint(c//2)\n# \treturn\nif x>y:\n\tc=0\n\tprint(n)", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nnow = []\nfor i in range(n):\n    now.append([a[i] - b[i], a[i], b[i]])\nnow.sort()\nans = 0\ni = 0\nj = n - 1\nwhile i < j:\n    if now[i][0] + now[j][0] > 0:\n        ans += j - i\n        j -= 1\n    else:\n        i += 1\nprint(ans)\n", "#!/usr/bin/env python3\n\n[n, m] = list(map(int, input().strip().split()))\nbis = [tuple(map(int, input().strip().split())) for _ in range(m)]\n\ntos = [[] for _ in range(n)]\nfor u, v in bis:\n\ttos[u - 1].append(v - 1)\n\ttos[v - 1].append(u - 1)\n\ncands = set(i for i in range(n) if len(tos[i]) == 2)\nres = 0\nwhile cands:\n\tv = cands.pop()\n\tR, L = tos[v]\n\twhile L in cands:\n\t\tcands.remove(L)\n\t\tV1, V2 = tos[L]\n\t\tif V1 in cands:\n\t\t\tL = V1\n\t\telif V2 in cands:\n\t\t\tL = V2\n\t\telse:\n\t\t\tbreak\n\t\tif L == R:\n\t\t\tres += 1\n\nprint (res)\n", "import sys\ninput=sys.stdin.readline\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\nfor i in range(n-1):\n    v1, v2 = list(map(int,input().split()))\n    mx[v1-1].append(v2-1)\n    mx[v2-1].append(v1-1)\ncount = [[0, 0] for _ in range(n)]\ntotal = [a.count(1), a.count(2)]\nanswer = 0\nOBSERVE = 0\nCHECK = 1\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n    #print(stack,count)\n    state, vertex, parent = stack.pop()\n    if state == OBSERVE:\n        stack.append((CHECK, vertex, parent))\n        for child in mx[vertex]:\n            #print(nv,v,from_)\n            if child != parent:\n                stack.append((OBSERVE, child, vertex))\n    else:\n        for child in mx[vertex]:\n            if child != parent:\n                #print(child,parent,count)\n                if count[child][0] == total[0] and count[child][1] == 0 or count[child][1] == total[1] and count[child][0] == 0:\n                    answer += 1\n                count[vertex][0] += count[child][0]\n                count[vertex][1] += count[child][1]\n \n        if a[vertex] != 0:\n            #print(count)\n            count[vertex][a[vertex]-1] += 1\n            #print(count)\n \nprint(answer)\n", "n = int(input())\nfor q in range(n):\n    L, v, l, r = list(map(int, input().split()))\n    ac = L // v\n    lc = l // v + (0 if l % v == 0 else 1)\n    rc = r // v\n    print(ac - (rc - lc + 1))\n", "# A - One Card Poker\n\n# \u4e00\u679a\u30dd\u30fc\u30ab\u30fc\u306e\u52dd\u6557\u3092\u5224\u5b9a\u3057\u51fa\u529b\u3059\u308b\n\n\ncard_A, card_B = list(map(int, input().split()))\n\nif card_A == 1:\n    card_A = 14\n\nif card_B == 1:\n    card_B = 14\n\nif card_A > card_B:\n    print('Alice')\nelif card_A < card_B:\n    print('Bob')\nelif card_A == card_B:\n    print('Draw')\n", "lst = input().split()\nN = int(lst[0])\nM = int(lst[1])\n\nA = []\nB = []\n\nfor i in range(N):\n   A.append(input())\n\nfor i in range(M):\n   B.append(input())\n\nif A == B:\n   print('Yes')\n   return\n\nfor x in range(N-M):\n   for y in range(N-M):\n      count = 1\n      for i in range(M):\n         if A[y+i][x:x+M] != B[i]:\n            count = 0\n      if count == 1:\n         print('Yes')\n         return\n\nprint('No')", "a = list(map(int,input().split()))\na = sorted(a,reverse=True)\nprint((10*a[0]+a[1]+a[2]))\n\n\n", "a = [int(input()) for _ in range(5)]\nz,ans = 123,0\nfor i in a:\n    if i%10!=0:z = min(z,i%10)\n    ans += 10*((i+10-1)//10)\nprint(ans+z-10 if (z!=123) or (z==0) else ans)", "N = int(input())\nA = list(map(int, input().split()))\n\nlst = []\nfor i in A:\n    lst.append(1/i)\nans = 1 / (sum(lst))\nprint(ans)", "A,B = list(map(int, input().split()))\nif A+B < 24:\n    print((A+B))\nelif A+B >= 24:\n    print((A+B-24))\n", "n = int(input())\n\nprint(n//2 + n%2)", "a,b = map(int,input().split())\nif a <= 8 and b <= 8:\n    print(\"Yay!\")\nelse:\n    print(\":(\")", "s = input()\nans = 10**8\nfor i in range(len(s)-2):\n  ans = min(ans, abs(753-int(s[i:i+3])))\nprint(ans)", "import sys\n\n\ndef dfs(v, d, prev, i):\n    nonlocal mid\n    nonlocal M\n    M[v] = False\n    way[d] = v\n    if way[d + 1] == 0:\n        mid[i] = way[d // 2]\n    mx = (d, v)\n    for x in E[v]:\n        if x != prev:\n            mx = max(mx, dfs(x, d + 1, v, i))\n\n    return mx\n\n\nsys.setrecursionlimit(2000)\nn, m = list(map(int, input().split()))\n\nE = [[] for i in range(n + 1)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    E[a].append(b)\n    E[b].append(a)\n\nmid = [0] * (n + 2)\nc = 0\nk = 0\nway = [0] * (n + 2)\n\nM = [True] * (n + 1)\nM[0] = False\ni = -1\nwhile True in M:\n    i += 1\n    idx = M.index(True)\n    p1 = dfs(idx, 0, 0, i)[1]\n    way = [0] * (n + 2)\n    s, p2 = dfs(p1, 0, 0, i)\n    if s > c:\n        c = s\n        k = i\nr = []\nfor j in range(0, i + 1):\n    if j == k:\n        continue\n    r.append((mid[k], mid[j]))\n    E[mid[k]].append(mid[j])\n    E[mid[j]].append(mid[k])\np1 = dfs(1, 0, 0, n + 1)[1]\ns, p2 = dfs(p1, 0, 0, n + 1)\nprint(s)\nfor item in r:\n    print(item[0], item[1])\n", "T = input().split(' ')\nn = int(T[0])\nm = int(T[1])\nP = input().split(' ')\nfor i in range(len(P)):\n    P[i] = int(P[i])\nfor i in range(1, len(P)):\n    P[i] += P[i-1]\nQ = input().split(' ')\nfor i in range(len(Q)):\n    Q[i] = int(Q[i])\na = 0\nb = 0\nc = 0\nd = 0\nwhile c < len(Q):\n    b = Q[c]\n    if b > P[a]:\n        d = P[a]\n        a+=1\n    else:\n        print(a+1, end=' ')\n        print(b - d)\n        c+=1\n", "def main():\n    a, b, c, d = sorted(map(int, input().split()))\n    print(d - a, d - b, d - c)\n    return 0\nmain()", "A,B=list(map(int,input().split()))\nif A*B%2==0:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n", "x = int(input())\nif x in [7,5,3]:\n    print('YES')\nelse:\n    print('NO')", "a = int(input())\ns= input()\nprint(s if a>=3200 else 'red')", "R=int(input())\nprint(\"ABC\" if R<1200\n      else \"ARC\" if R<2800\n      else \"AGC\")", "n = input()\n\nfor i in range(len(n)):\n    if n[i] == '1':\n        n = n[:i] + '9' + n[i+1:]\n    else:\n        n = n[:i] + '1' + n[i+1:]\n\nprint(int(n))", "\"\"\"\nAuthor: Q.E.D\nTime: 2020-06-16 09:36:16\n\"\"\"\nT = int(input())\nfor _ in range(T):\n    b = input()\n    a = b[0] + b[1:-1:2] + b[-1]\n    print(a)", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\n\nWCHANGE=[]\nfor i in range(1,m):\n    if EDGE[i-1][2]!=EDGE[i][2]:\n        WCHANGE.append(i)\n\nWCHANGE.append(m)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\nNOW=0\nnoneed=[0]*m\nANS=0\nfor wc in WCHANGE:\n    for j in range(NOW,wc):\n\n        if find(EDGE[j][0])==find(EDGE[j][1]):\n            noneed[j]=1\n\n    for j in range(NOW,wc):\n        if noneed[j]==1:\n            continue      \n        x,y,w=EDGE[j]\n        if find(x)!=find(y):\n            Union(x,y)\n        else:\n            ANS+=1\n\n    NOW=wc\n\nprint(ANS)\n        \n", "import itertools\nn = int(input())\ns = input()\nbest_pattern = None\nbest_count = None\nfor pattern in itertools.permutations(\"RGB\", 3):\n    count = 0\n    for i, ch in enumerate(s):\n        if ch != pattern[i % 3]:\n            count += 1\n    if best_count is None or best_count > count:\n        best_count, best_pattern = count, pattern\n\nprint(best_count)\nfull, tail = divmod(n, 3)\nprint(\"\".join(best_pattern * full + best_pattern[:tail]))\n", "N = int(input())\nans = 0\nfor i in range(N):\n  x, u = map(str, input().split())\n  if u == 'JPY':\n    ans += int(x)\n  else:\n    ans += float(x) * 380000\nprint(ans)", "S=input()\nS_list=list(S)\nif S[0]!=S[1] and S[1] != S[2]:\n    print(1)\nelse:\n    print(S_list.count(\"R\"))", "s=[int(i) for i in input().split(\"/\")]\n#print(s)\n\nans=\"TBD\"\n\nif s[0]<=2018:\n    ans=\"Heisei\"\n    \nelif s[0]==2019 and s[1]<=4:\n    ans=\"Heisei\"\n    \nprint(ans)", "n = int(input())\na = [int(x) for x in input().split()]\ndtt = dict()\nfor t in a:\n    if t in dtt:\n        dtt[t] += 1\n    else:\n        dtt[t] = 1\nlts = [dtt[x] for x in dtt]\nlts.sort(reverse=True)\nmt = [lts[0]]\npl = lts[0]\nfor d in range(1, len(lts)):\n    cl = min(pl // 2, lts[d])\n    if cl == 0:\n        break\n    cs = cl * (2**(d+1) - 1)\n    mt.append(cs)\n    pl = cl\nprint(max(mt))\n", "from sys import stdin, stdout, setrecursionlimit\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    s = input()\n    s = '1' + '0' * k + s + '0' * k + '1'\n    cou = 0\n    a = []\n    for i in range(len(s)):\n        if s[i] == '1':\n            a.append(i)\n    # print(a)\n    for i in range(1, len(a)):\n        cou += (a[i] - a[i - 1] - 1 - k) // (k + 1)\n    print(cou)\n", "# -*- coding: utf-8 -*-\n\nimport sys\nimport bisect\nimport heapq\n\nline_count = 0\nsegments = [None]\nnum_points = 200000\nfor line in sys.stdin.readlines():\n    inputs = line.split()\n    if line_count == 0:\n        n = int(inputs[0])\n        k = int(inputs[1])\n        opening = {}\n        closing = {}\n        removed_right = {}\n        segment_index = 0\n        for i in range(1, num_points + 1):\n            opening[i] = []\n            closing[i] = []\n            removed_right[i] = 0\n    else:\n        l = int(inputs[0])\n        r = int(inputs[1])\n        segment_index += 1\n        segments.append((l, r))\n        opening[l].append(segment_index)\n        closing[r].append(segment_index)\n    if line_count == n:\n        break\n    line_count += 1\n\nworking = []\nworking_count = 0\nremoved = []\nfor i in range(1, num_points + 1):\n    for segment_index in opening[i]:\n        _, r = segments[segment_index]\n        heapq.heappush(working, (- r, segment_index))\n        working_count += 1\n#        bisect.insort_right(working, (r, segment_index))\n    while working_count > k:\n        r, segment_index = heapq.heappop(working)\n#        r, segment_index = working.pop()\n        working_count -= 1\n        removed.append(segment_index)\n        removed_right[- r] += 1\n    squeezed_out = len(closing[i]) - removed_right[i]\n    working_count -= squeezed_out\n#    working = working[squeezed_out: ]\n\nprint(len(removed))\nfor j in removed:\n    print(j, end = \" \")", "\nn,k=list(map(int,input().split(\" \")))\ndb=[]\na=[]\nb=[]\nfor i in range(n):\n    t,A,B= list(map(int, input().split(\" \")))\n    if A==B==1:\n        db.append(t)\n    elif A==1:\n        a.append(t)\n    elif B==1:\n        b.append(t)\na.sort()\nb.sort()\nfor i in range(min(len(a),len(b))):\n    db.append((a[i]+b[i]))\nif len(db)<k:\n    print(-1)\nelse:\n    db.sort()\n    print(sum(db[:k]))\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    def intersection(a, b, c, d):\n        return max(a, c), min(b, d)\n    \n    def solve():\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        \n        a, b = 0, 10**18\n        for x in arr:\n            a, b = intersection(a, b, x - k, x + k)\n        \n        if a > b:\n            print(-1)\n        else:\n            print(b)\n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()", "#Bhargey Mehta (Senior)\n#DA-IICT, Gandhinagar\nimport sys, math\nmod = 10**9 + 7\n\ndef solve(test_index):\n    a, b = list(map(int, input().split()))\n    ans = math.ceil(abs(a-b) / 10)\n    print(ans)\n    return\n\nif 'PyPy' not in sys.version:\n    sys.stdin = open('input.txt', 'r')\n\nsys.setrecursionlimit(100000)\nnum_tests = 1\nnum_tests = int(input())\nfor test in range(1, num_tests+1):\n    #print(\"Case #{}: \".format(test), end=\"\")\n    solve(test)\n", "n, k = map(int, input().split())\ns = set()\nst = input()\ninp = input().split()\nfor x in inp:\n    s.add(x)\ncurrent, ans = 0, 0\nfor x in st:\n    if x in s:\n        current += 1\n    else:\n        ans += (current * (current + 1)) // 2\n        current = 0\nans += (current * (current + 1)) // 2\nprint(ans)", "from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\n\ndef solve():\n    n = ri()\n    answer = 0\n    half = (n + 1) // 2\n    for i in range(1, half):\n        ring = (2 * i + 1)**2 - (2 * i - 1)**2\n        answer += i * ring\n    print (answer)\n\n\n\n\n\nmode = 'T'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n", "s,t=input().split()\nprint(t+s)", "import sys\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\nEDGE=EDGE[:k]\n\nCOST_vertex=[[] for i in range(n+1)]\nVERLIST=[]\n\nfor a,b,c in EDGE:\n    COST_vertex[a].append((b,c))\n    COST_vertex[b].append((a,c))\n    VERLIST.append(a)\n    VERLIST.append(b)\n\nVERLIST=list(set(VERLIST))\n\nimport heapq\n\nANS=[-1<<50]*k\n\n\nfor start in VERLIST:\n    MINCOST=[1<<50]*(n+1)\n\n    checking=[(0,start)]\n    MINCOST[start]=0\n\n    j=0\n    while j<k:\n        if not(checking):\n            break\n        \n        cost,checktown=heapq.heappop(checking)\n        if cost>=-ANS[0]:\n            break\n\n        if MINCOST[checktown]<cost:\n            continue\n        \n        if cost!=0 and checktown>start:\n            heapq.heappop(ANS)\n            heapq.heappush(ANS,-cost)\n            j+=1\n            \n        for to,co in COST_vertex[checktown]:\n\n            if MINCOST[to]>cost+co:\n                MINCOST[to]=cost+co\n\n                heapq.heappush(checking,(cost+co,to))\n\nprint(-ANS[0])\n    \n    \n", "'''input\n5\n5009\n7\n9876\n10000\n10\n'''\ndef solve():\n\ts = input()\n\tln = len(s)\n\tans = []\n\tfor i in s:\n\t\tnum = int(i+(ln-1)*'0')\n\t\tif num!=0:\n\t\t\tans.append(num)\n\t\tln-=1\n\tprint(len(ans))\n\tfor i in ans:\n\t\tprint(i,end=\" \")\n\tprint()\n\treturn \nt = 1\nt = int(input())\nwhile t>0:\n\tt-=1\n\tsolve()", "N = []\nAA = []\nt = int(input())\nfor i in range(t):\n    N.append(int(input()))\n    a = list(map(int,input().split()))\n    for j in range(len(a)):\n        a[j] -= 1\n    AA.append(a)\n\nfor i in range(t):\n    n = N[i]\n    A = AA[i]\n    ans = [0] * n\n    for j in range(n):\n        c = 1\n        b = A[j]\n        while b != j:\n            b = A[b]\n            c += 1\n        ans[j] = c\n    print(\" \".join([str(i) for i in ans]))", "'''input\n6\n5 4 5 4 4 5\n'''\nfrom sys import stdin\n\n\ndef check_valid(string):\n\tstack = []\n\tfor i in string:\n\t\tif i in ['(',  '[']:\n\t\t\tstack.append(i)\n\t\telif i == ')':\n\t\t\tif len(stack) > 0:\n\t\t\t\tif stack[-1] == '(':\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tcontinue\n\t\t\treturn False\n\t\telif i == ']':\n\t\t\tif len(stack) > 0:\n\t\t\t\tif stack[-1] == '[':\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tcontinue\n\t\t\treturn False\n\n\treturn len(stack) == 0\n\ndef merge(index):\n\taux = []\n\tif len(index) > 0:\n\t\taux = [index[0]]\n\t\tfor i in range(1, len(index)):\n\t\t\tif index[i][0] == aux[-1][1] + 1:\n\t\t\t\taux[-1][1] = index[i][1]\n\t\t\telse:\n\t\t\t\tif check_valid(string[aux[-1][1] + 1: index[i][0]]):\n\t\t\t\t\taux[-1][1] = index[i][1]\n\t\t\t\telse:\n\t\t\t\t\taux.append(index[i])\n\treturn aux\n\n\n# main starts\nn = int(stdin.readline().strip())\narr = []\narr = list(map(int, stdin.readline().split()))\nfor i in range(n):\n\tarr[i] = [i, arr[i]]\n\narr.sort(key = lambda x: x[1], reverse  = True)\ncount = 0 \nans = []\ntotal = 0\nfor i in range(n):\n\tindex, a = arr[i]\n\tans.append(index + 1)\n\ttotal += count * a + 1\n\n\tcount += 1\n\nprint(total)\nprint(*ans)\n", "x1, x2, x3, x4, x5 = map(int, input().split())\nl = [x1, x2, x3, x4, x5]\nprint(l.index(0) + 1)", "from fractions import gcd\nA, B, C = map(int, input().split())\nif C % gcd(A, B) == 0:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")", "N = int(input())\nRed = sorted([tuple(map(int, input().split())) for _ in range(N)])\nBlue = sorted([tuple(map(int, input().split())) for _ in range(N)])\n\nans = 0\nfor bx,by in Blue:\n    C = [(y,x) for x,y in Red if x<bx and y<by] #\u5019\u88dc\n    if len(C) == 0:\n        continue\n    ans += 1\n    C.sort(reverse=True)\n    Red.remove((C[0][1],C[0][0]))\nprint(ans)", "# @author \n\nimport sys\n\n\nclass ADivideIt:\n    def solve(self):\n        for _ in range(int(input())):\n            n = int(input())\n            cnt = 0\n            while n != 1:\n                if n % 2 == 0:\n                    n //= 2\n                elif n % 3 == 0:\n                    n //= 3\n                    n *= 2\n                elif n % 5 == 0:\n                    n *= 4\n                    n //= 5\n                else:\n                    print(-1)\n                    break\n                cnt += 1\n            else:\n                print(cnt)\n\n\n\n\nsolver = ADivideIt()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "N = int(input())\nS = [input() for _ in range(N)]\ndict_s = dict()\nfor s in S:\n    if s in dict_s:\n        dict_s[s] += 1\n    else:\n        dict_s[s] = 1\n\nsorted_s = sorted(dict_s.items(), key=lambda x: x[1], reverse=True)\nmax_s = []\nmax_count = -1\nfor s in sorted_s:\n    if s[1] >= max_count:\n        max_s.append(s[0])\n        max_count = s[1]\n\nfor s in sorted(max_s):\n    print(s)", "d=int(input())\nprint(\"Christmas\"+\" Eve\"*(25-d))", "print((2**(len(bin(int(input()))[2:])-1)))\n", "a,b,c = input().split()\nprint(str.upper(a[0]+b[0]+c[0]))", "S = input()\nif \"a\" in S and \"b\" in S and \"c\" in S:\n    print( \"Yes\" )\nelse:\n    print( \"No\" )", "from collections import deque\nn, k = list(map(int, input().split()))\ns = set()\nd = deque()\nfor i in map(int, input().split()):\n    if i in s:\n        continue\n    if len(d) == k:\n        s.discard(d.pop())\n    d.appendleft(i)\n    s.add(i)\nprint(len(d))\nprint(*d)\n", "n,m=map(int,input().split())\nx=[int(x1) for x1 in input().split()]\n\npre1=[0]*(n+2)\npre2=[0]*(n+1)\npre3=[0]*(n+1)\n\nfor i in range(0,len(x)-1):\n    a=min(x[i],x[i+1])\n    b=max(x[i],x[i+1])\n\n    if(b-a>1):\n\n        pre1[a+1]+=1\n        pre1[b]+=-1\n\n    if(a!=b):\n        pre2[a]+=(b-1)-(b-a)\n        pre3[b]+=a-(b-a)\n\n\nt=0\nfor i in range(0,len(pre1)):\n    pre1[i]=t+pre1[i]\n    t=pre1[i]\n\n\nans=0\nfor i in range(0,m-1):\n    ans+=abs(x[i]-x[i+1])\n\n\n\nprint(ans,end=\" \")\nfor i in range(2,n+1):\n    temp=ans+pre2[i]+pre3[i]+-pre1[i]\n    print(temp,end=\" \")\n\nprint(\" \")\n    \n", "\nimport math\nimport bisect\n\nclass Fenwick:\n    def __init__(self, n):\n        self.data = [[0,0] for i in range(n)] \n    \n    def update(self, pos, dist):\n        while pos<len(self.data):\n            self.data[pos][0] += 1\n            self.data[pos][1] += dist\n            pos = pos | (pos+1)\n    \n    def query(self, pos):\n        ans = [0,0]\n        while pos > 0:\n            ans[0] += self.data[pos-1][0]\n            ans[1] += self.data[pos-1][1]\n            pos = pos & (pos-1)\n        return ans\n\n\ndef rints():\n    return list(map(int,input().split()))\n\n\nn = int(input())\n\nx = rints()\nv = rints()\n\nascDist = list(range(n))\nascDist.sort(key=lambda i: x[i])\n\nuniqueSpeeds = sorted(list(set(v)))\n\ntree = Fenwick(len(uniqueSpeeds))\n\n\nans = 0\nfor i in ascDist:\n    speedId = bisect.bisect_left(uniqueSpeeds, v[i])\n    count, dsum = tree.query(speedId+1)\n    ans += count*x[i] - dsum\n    tree.update(speedId, x[i])\n\nprint(ans)\n\n", "n,m=map(int,input().split())\nta=input()\ntb=input()\ncount=0\nans=0\nr=n-m\nfor i in range(m):\n    if tb[i]=='1':\n        count+=1\n    if i+r>=0:\n        if ta[i+r]=='1':\n            ans=(ans+pow(2,m-i-1,998244353)*count)%998244353\nprint(ans)", "from collections import deque\nfor _ in range(int(input())):\n    n=int(input());val=set([0,2*10**5+1]);seg=[(0,2*10**5+1)]\n    for i in range(n):l,r=map(int,input().split());val.add(l);val.add(r);seg.append((l,r))\n    val=sorted(list(val));comp={i:e+1 for e,i in enumerate(val)};deg=[0]*(n+1);out=[[] for i in range(n+1)]\n    for i in range(n+1):l,r=seg[i];seg[i]=(comp[l],comp[r])    \n    for i in range(n+1):\n        for j in range(i+1,n+1):\n            l,r=seg[i];L,R=seg[j]\n            if L<=l and r<=R:out[j].append(i);deg[i]+=1\n            elif l<=L and R<=r:out[i].append(j);deg[j]+=1\n    ans=[0];deq=deque(ans);dp=[0]*(n+1)\n    while deq:\n        v=deq.popleft()\n        for nv in out[v]:\n            deg[nv]-=1\n            if deg[nv]==0:deq.append(nv);ans.append(nv)    \n    def solve(v):\n        query=[[] for i in range(2*n+3)];subdp=[0]*(2*n+3)\n        for nv in out[v]:l,r=seg[nv];query[r].append((l,dp[nv]))        \n        for i in range(1,2*n+3):\n            res=subdp[i-1]\n            for l,val in query[i]:test=subdp[l-1]+val;res=max(test,res)\n            subdp[i]=res\n        dp[v]=subdp[-1]+1\n    for v in ans[::-1]:solve(v)\n    print(dp[0]-1)", "from sys import stdin,stdout\nn=int(stdin.readline().strip())\nfor t in range(n):\n    h,c=list(map(int,stdin.readline().strip().split()))\n    ans=0\n    if c!=0:\n        ans+=60-c\n        h+=1\n    ans+=(24-h)*60\n    print(ans)\n        \n\n", "n=input()\nf=0\nfor i in range(len(n)):\n  f+=int(n[i])\nif int(n)%f==0:\n  print(\"Yes\")\nelse:\n  print(\"No\")", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nS = input()\nans = 0\nfor i in range(len(S)-1):\n    if S[i+1] != S[i]:\n        ans += 1\nprint(ans)\n", "#!/usr/bin/env python3\ncnt=[0]*100002\ninput()\nfor x in map(int,input().split()):\n    cnt[x]+=1\n    cnt[x+1]+=1\n    cnt[x+2]+=1\nprint(max(cnt))", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 18 10:13:51 2020\n\n@author: liang\n\"\"\"\nH, W = map(int, input().split())\nflag = True\nfield = [input() for i in range(H)]\n\nfor i in range(H):\n    for j in range(W):\n        if field[i][j] == \"#\":\n            tmp = False\n            if i-1>= 0 and field[i-1][j] == \"#\":\n                tmp = True\n            if i+1 < H and field[i+1][j] == \"#\":\n                tmp = True\n            if j-1>= 0 and field[i][j-1] == \"#\":\n                tmp = True\n            if j+1 < W and field[i][j+1] == \"#\":\n                tmp = True\n            if tmp == False:\n                flag = False\n\nif flag :\n    print(\"Yes\")\nelse:\n    print(\"No\")", "a,b = list(map(int,input().split()))\ns =input()\nfor i in range(a+b+1):\n    if i == a:\n        if s[i] !='-':\n            print('No')\n            break\n    else:\n        if s[i]=='-':\n            print(\"No\")\n            break\n            \n        else:\n            if int(s[i])<0 or 9<int(s[i]):\n                print(\"No\")\n                break\nelse:\n    print('Yes')", "a, b, k = map(int,input().split())\nif a+k+1 <= b:\n    for i in range(a, k+a):\n        print(i)\n    if a+k+1 <= b+1-k:\n        for i in range(b+1-k, b+1):\n            print(i)\n    else:\n        for i in range(a+k, b+1):\n            print(i)\nelse:\n    for i in range(a, b+1):\n        print(i)", "a, b, x = map(int, input().split())\nif a > x:\n  print('NO')\nelif a+b >= x:\n  print('YES')\nelse:\n  print('NO')", "class Combination:\n    def __init__(self, n, mod):\n        self.n = n\n        self.mod = mod\n        self.fac = [1 for i in range(self.n + 1)]\n        self.finv = [1 for i in range(self.n + 1)]\n        for i in range(2, self.n+1):\n            self.fac[i] = (self.fac[i - 1] * i) % self.mod\n            self.finv[i] = (self.finv[i-1] * pow(i, -1, self.mod)) % self.mod\n\n    def comb(self, n, m):\n        return self.fac[n] * (self.finv[n-m] * self.finv[m] % self.mod) % self.mod\ndef iparse():\n    return list(map(int, input().split()))\n\n\ndef __starting_point():\n    n = int(input())\n    ml = 1\n    last = [0,0]\n    for i in range(n):\n        x = iparse()\n        # print(len(x))\n        l = (last[0] + x[0] - 1) // x[0]\n        r = (last[1] + x[1] - 1) // x[1]\n        m = max(l, r)\n        if m == 0:\n            m = 1\n        x[0] *= m\n        x[1] *= m\n        \n        last = x\n    print((sum(last)))\n    \n        \n    \n\n__starting_point()", "import math\nimport sys\nimport os\nfrom operator import mul\nimport numpy as np\n\nsys.setrecursionlimit(10**7)\n\ndef _S(): return sys.stdin.readline().rstrip()\ndef I(): return int(_S())\ndef LS(): return list(_S().split())\ndef LI(): return list(map(int,LS()))\n\nif os.getenv(\"LOCAL\"):\n    inputFile = basename_without_ext = os.path.splitext(os.path.basename(__file__))[0]+'.txt'\n    sys.stdin = open(inputFile, \"r\")\nINF = float(\"inf\")\n\n\nN = I()\nS = list(_S())\nans = N\n\nSn = np.array(S)\nS_cum = np.zeros(N+1,dtype='int')\nS_cum[1:] = np.cumsum(Sn=='W')\n\nSnr=np.flip(Sn, 0)\nS_cumr = np.zeros(N+1,dtype='int')\nS_cumr[1:] = np.cumsum(Snr=='E')\n\n# print(S_cum)\n# print(S_cumr)\n\nfor i in range(N):\n    attention = S_cum[i] + S_cumr[N-(i+1)]\n    # print(attention)\n    ans = min(ans, attention)\n\nprint(ans)", "def main():\n    n = int(input())\n    s = input()\n    ans = 0\n\n    for i in range(1, n):\n        cnt = 0\n        x, y = set(s[:i]), set(s[i:])\n        for j in x:\n            if j in y:\n                cnt += 1\n        ans = max(ans, cnt)\n\n    print(ans)\n\n\nmain()", "s=input()\nwea=[\"Sunny\",\"Cloudy\",\"Rainy\"]\nprint(wea[(wea.index(s)+1)%3])", "A = int(input())\nB = int(input())\nC = int(input())\nX = int(input())\n\ncnt = 0\nfor i in range(A+1):\n    for j in range(B+1):\n        for k in range(C+1):\n            ans =500*i + 100*j + 50*k\n            if ans == X:\n                cnt += 1\n\nprint(cnt)", "# ABC 164 C\nN = int(input())\ndic = {}\nfor i in range(N):\n    s = str(input())\n    if s not in dic:\n        dic[s] = 'o'\nprint(len(dic))", "import math\n\nN = int(input())\nA = [math.floor(a/400) if a < 3200 else 3200 for a in list(map(int, input().split()))]\n\nset_A = set([a for a in A if a != 3200])\nprint(*[max(1, len(set_A)), len(set_A) + A.count(3200)], sep=\" \")", "n=input()\n\nfor i in range(2 ** 3):\n    \n\n    co=[\"-\",\"-\",\"-\"]\n\n    for j in range(3):\n        if ((i>>j)&1):\n            co[2-j]=\"+\"\n\n    eq=n[0]+co[0]+n[1]+co[1]+n[2]+co[2]+n[3]\n\n\n    if eval(eq)==7:\n            ans=eq\n\nprint(ans,end=\"\")\nprint(\"=7\")\n", "import sys\n\nX, Y = sys.stdin.readline().strip().split()\nif X == Y:\n    print(\"=\")\nelif X < Y:\n    print(\"<\")\nelse:\n    print(\">\")", "def solve():\n    H, W = list(map(int, input().split()))\n    S = [input() for i in range(H)]\n\n    for i in range(H):\n        S[i] = list(S[i])\n\n    for i in range(H):\n        for k in range(W):\n\n            if S[i][k]!=\"#\":\n\n                c = 0; #counter\n\n                if i>0 and k>0 and S[i-1][k-1]==\"#\": # upper left\n                    c += 1\n\n                if i>0  and S[i-1][k]==\"#\": # right above\n                    c += 1\n\n                if i>0 and k<W-1 and S[i-1][k+1]==\"#\": # upper right\n                    c+= 1\n\n                if k>0 and S[i][k-1]==\"#\": # left\n                    c += 1\n           \n                if k<W-1 and S[i][k+1]==\"#\": # right\n                    c += 1\n\n                if i<H-1 and k>0 and S[i+1][k-1]==\"#\": # lower left\n                    c += 1\n\n                if i<H-1 and S[i+1][k]==\"#\": # right under\n                    c += 1\n\n                if i<H-1 and k<W-1 and S[i+1][k+1]==\"#\": # lower right\n                    c += 1\n\n                S[i][k] = str(c)\n\n    for i in range(H):\n        print((\"\".join(S[i])))\n\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "N, M, K = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nSA =[0]\nSB =[0]\nfor i in range(len(A)):\n  SA.append(SA[i] + A[i])\nfor j in range(len(B)):\n  SB.append(SB[j] + B[j])\n\nl = M\nans = 0\nfor k in range(N+1):\n  if SA[k] > K:\n    break\n  while SA[k] + SB[l] > K:\n    l -= 1\n  ans = max(ans, k + l)\nprint(ans)", "#-*-coding:utf-8-*-\nimport sys\ninput=sys.stdin.readline\n\ndef main():\n    a,b,c,x,y = map(int,input().split())\n    ans1=99999999999999999999999999\n    if a+b>2*c:\n        if x > y:\n            ans1=2*c*y+a*(x-y)\n        elif y > x:\n            ans1=2*c*x+b*(y-x)\n    ans2=c*2*max(x,y)\n    ans3=a*x+b*y\n    print(min(ans1,ans2,ans3))\n\ndef __starting_point():\n    main()\n__starting_point()", "from sys import stdin\nn = int(stdin.readline().rstrip())\na = [0]*n\nfor x in range(n):\n   a[x] = int(stdin.readline().rstrip())\n\na.sort(reverse = True)\n\nsum = 1\n\nfor x in range(n-1):\n   if a[x] > a[x+1]:\n      sum += 1\nprint(sum)", "N = int(input())\nA = list(map(int, input().split()))\ncount = 0\nwhile all(a % 2 == 0 for a in A):\n  A = [a /2 for a in A]\n  count += 1\nprint(count)\n  \n", "import math\nn = int(input())\nprint(math.factorial(n) % (10 ** 9 + 7))", "n = int(input())\na = list(map(int, input().split()))\nalice = 0\nbob = 0\na.sort(reverse = True)\nfor i in range(0, n, 2):\n    alice += a[i]\nfor i in range(1, n, 2):\n    bob += a[i]\nprint(alice - bob)", "N, M = map(int, input().split(' '))\nac_set = set()\nwa_cnt_ls, wa_cnt = [ 0 for i in range(N) ], 0\nfor i in range(M):\n    p, s = input().split(' ')\n    idx = int(p) - 1\n    if not idx in ac_set:\n        if s == 'AC':\n            ac_set.add(idx)\n            wa_cnt += wa_cnt_ls[idx]\n        else:\n            wa_cnt_ls[idx] += 1\nprint(len(ac_set), wa_cnt)", "A = int(input())\nB = int(input())\nC = int(input())\nD = int(input())\n\nbus = [A, B]\ntrain = [C, D]\n\nprint(min(bus) + min(train))", "n = input()\nprint((\"ABC\" + n))\n", "x,y,z=map(int,input().split())\nprint(z if x == y else y if x == z else x)", "S = str(input())\n\ns_between_len = len(S) - 2\n\na = S[:1] + str(s_between_len) + S[-1]\nprint(a)", "from collections import defaultdict\nimport string\ns = input()\nK = int(input())\nlocation = defaultdict(list)\nfor i, s_i in enumerate(s):\n    location[s_i].append(i)\ncount = 0\ns_list = []\nfor c in string.ascii_lowercase[:26]:\n    if location[c] == []:\n        continue\n    for idx in location[c]:\n        for i in range(K):\n            if idx + i + 1 > len(s):\n                break\n            if s[idx:idx+i+1] in s_list:\n                continue\n            s_list.append(s[idx:idx+i+1])\n    count += 1\n    if count == K:\n        break\ns_list.sort()\nprint(s_list[K-1])", "w, h, n = list(map(int, input().split()))\n\ns_w = [0, w]\ns_h = [0, h]\nfor _ in range(n):\n    x, y, a = list(map(int, input().split()))\n    if a == 1 and x > s_w[0]:\n        s_w[0] = x\n    elif a == 2 and x < s_w[1]:\n        s_w[1] = x\n    elif a == 3 and y > s_h[0]:\n        s_h[0] = y\n    elif a == 4 and y < s_h[1]:\n        s_h[1] = y\n\nans_w = s_w[1] - s_w[0]\nans_h = s_h[1] - s_h[0]\nprint((ans_w * (ans_w > 0)) * (ans_h * (ans_h > 0)))", "for eps in range(int(input())):\n    n, m = map(int, input().split())\n    s = input()\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = [0] * 26\n    j = 0\n    for i in range(n):\n        while j < m and i >= a[j]:\n            j += 1\n        ans[ord(s[i]) - ord(\"a\")] += m - j + 1\n    for elem in ans:\n        print(elem, end=\" \")\n    print()", "t=int(input())\nfor nt in range(t):\n\ta,b,c=map(int,input().split())\n\tprint (max(0,abs(a-b)+abs(b-c)+abs(a-c)-4))", "n, m = list(map(int, input().split()))\ntrees = set(list(map(int, input().split())))\nvis = set(trees)\nres = []\ndist = 0\nfor d in range(1, m+1):\n    done = False\n    removal = set()\n    for t in trees:\n        if t-d in vis and t+d in vis:\n            removal.add(t)\n        if not t-d in vis:\n            vis.add(t-d)\n            res.append(t-d)\n            dist += d\n        if len(res) == m:\n            done = True\n            break\n        if not t+d in vis:\n            vis.add(t+d)\n            res.append(t+d)\n            dist += d\n        if len(res) == m:\n            done = True\n            break\n    if done:\n        break\n    for t in removal:\n        trees.remove(t)\nprint(dist)\nprint(' '.join(map(str, sorted(res))))\n    \n        \n", "def ssum(s):\n    return sum(map(int, list(s)))\nfor _ in range(int(input())):\n    n, s = list(map(int, input().split()))\n    ns = str(n)\n    if ssum(ns) <= s:\n        print(0)\n        continue\n\n    ans = float(\"inf\")\n    for i in range(0, len(ns)):\n        x = 1\n        if i > 0:\n            x = int(ns[:i])+1\n        acc = 0\n        while x > 0:\n            acc += x % 10\n            x //= 10\n        if acc > s:\n            continue\n        y = 10**(len(ns)-i) - int(ns[i:])\n        ans = min(ans, y)\n    print(ans)\n", "for _ in range(int(input())):\n    n, x, y = list(map(int, input().split()))\n    i = 1\n    ad = []\n    bd = []\n    while i*i <= y-x:\n        if (y-x)%i == 0:\n            ad.append(i)\n            if i*i != y-x:\n                bd.append((y-x)//i)\n        i += 1\n    ds = ad + bd[::-1]\n    best = (float(\"inf\"), 0)\n    for d in ds:\n        l = (y-x)//d+1\n        if l > n:\n            continue\n        p = n-l\n        while x-p*d <= 0:\n            p -= 1\n        best = min(best, (y+(n-l-p)*d, x-p*d))\n    d = (best[0]-best[1])//(n-1)\n    print(*list(range(best[1], best[0]+1, d)))\n", "for _ in range(int(input())):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tif sum(arr)%2 == 1:\n\t\tprint('YES')\n\telif all(ele%2 == 0 for ele in arr):\n\t\tprint('NO')\n\telif all(ele%2 == 1 for ele in arr) and len(arr)%2 == 0:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')", "from sys import stdin,stdout\ninput=stdin.readline\nfor _ in range(int(input())):\n    x=10**5\n    n,k=list(map(int,input().split()))\n    s=input()\n    ans=10**9\n    for i in range(n-k+1):\n        x=s[i:i+k]\n        m=0\n        curr=['R','G','B']\n        for l in range(3):\n            m=0\n            z=l\n            for j in x:\n                if j!=curr[z]:\n                    m+=1\n                z+=1\n                z%=3\n            ans=min(ans,m)\n    print(ans)\n", "def main():\n    for i in range(int(input())):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n        thr = 0\n        tw = 0\n        on = 0\n        for val in a:\n            if val % 3 == 0:\n                thr += 1\n            elif val % 3 == 2:\n                tw += 1\n            else:\n                on += 1\n        if tw == on:\n            print(thr + tw)\n        elif tw > on:\n            print(thr + on + (tw - on) // 3)\n        else:\n            print(thr + tw + (on - tw) // 3)\n\n\nmain()\n", "t = int(input())\nfor i in range(t):\n\tn, k = list(map(int, input().split()))\n\tz = n // k\n\tn -= z * k\n\tprint(z * k + min(n, k // 2))\n", "n = int(input())\nfor _ in range(n):\n\tl = list(map(int, input().split()))\n\ts = sum(l)\n\tprint(s // 2)", "def gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a%b)\n\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    s = input()\n    if s[0] * n == s:\n        print(n)\n        continue\n    cnt = {}\n    for c in s:\n        if c not in cnt:\n            cnt[c] = 0\n        cnt[c] += 1\n    cnt = [cnt[c] for c in cnt]\n    ans = 1\n    for x in range(2,n+1):\n        tempK = k % x\n        if tempK == 0:\n            ans = max(ans, x)\n            continue\n        mod = x % tempK\n        if mod != 0:\n            mod = -(mod - tempK)\n        times = tempK // gcd(tempK, mod)\n        needed = x*times // tempK\n        usedBeads = 0\n        for num in cnt:\n            usedBeads += num - num % needed\n        if usedBeads >= x:\n            ans = max(ans, x)\n    print(ans)\n", "class Solution:\n     def generate(self, numRows):\n         \"\"\"\n         :type numRows: int\n         :rtype: List[List[int]]\n         \"\"\"\n         A=[[1],[1,1]]\n         if numRows == 0:\n             return[]\n         elif numRows<3:\n             return A[0:numRows]\n         else:\n             i=3\n             while i<=numRows:\n                 temp=A[i-2][:]\n                 temp.append(0)\n                 temp2=temp[::-1]\n                 temp3=[X+Y for X,Y in zip(temp,temp2)]\n                 A.append(temp3) \n                 i+=1          \n         print(A)\n         return A", "# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef sqr(a):\n    return a*a*a\nn=int(input())\nif(n==0):\n    print(\"[]\")\nelif(n==1):\n    print(\"[0]\")\nelse:\n    ar=[0]*n\n    ar[0]=0\n    ar[1]=1\n    for i in range(2,n):\n        ar[i]=ar[i-1]+ar[i-2]\n\n    ar=list(map(sqr,ar))\n    print(ar)\n", "# Enter your code here. Read input from STDIN. Print output to STDOUT\nxml_str=\"\"\nn=int(input())\nfor i in range(0,n):\n    tmp_str=input()\n    xml_str=xml_str+tmp_str\n    \nimport xml.etree.ElementTree as etree\ntree = etree.ElementTree(etree.fromstring(xml_str))\nroot=tree.getroot()\nar=[]\ndef cnt_node(node):\n    return max( [0] + [cnt_node(child)+1 for child in node])\ncnt=cnt_node(root)\nprint(cnt)\n", "#!/usr/bin/env python3\n\nfrom collections import namedtuple\n\ndef __starting_point():\n    s_num = int(input().strip())\n    tuple_fields = input().strip().split()\n    \n    student = namedtuple('student', tuple_fields)\n    library = []\n    res = 0\n    \n    for _ in range(s_num):\n        st_info = input().strip().split()\n        library.append(student(st_info[0], st_info[1], st_info[2], st_info[3]))\n        \n    for el in library:\n        res += int(el.MARKS)\n    \n    print(res/s_num)\n__starting_point()", "class Points(object):\n    def __init__(self, x, y, z):\n        self.x, self.y, self.z = x, y, z\n\n    def __sub__(self, no):\n        return Points(self.x - no.x,\n                      self.y - no.y,\n                      self.z - no.z)\n\n    def dot(self, no):\n        return self.x*no.x + self.y*no.y + self.z*no.z\n\n    def cross(self, no):\n        return Points(self.y*no.z - self.z*no.y,\n                      self.z*no.x - self.x*no.z,\n                      self.y*no.x - self.x*no.y)\n        \n    def absolute(self):\n        return pow((self.x ** 2 + self.y ** 2 + self.z ** 2), 0.5)", "# Enter your code here. Read input from STDIN. Print output to \n\n\nimport math\n\nclass ComplexNumber(object): \n    def __init__(self, real, compl): \n        self.real = real \n        self.compl = compl\n        pass\n    def __str__(self):\n        if (self.compl >= 0):\n            return '{0:.2f}'.format(self.real) +'+'+ '{0:.2f}'.format(self.compl) +'i' \n        return '{0:.2f}'.format(self.real) +'-'+ '{0:.2f}'.format(abs(self.compl)) +'i' \n    def __add__(x, y):\n        return ComplexNumber(x.real+y.real, x.compl+y.compl)\n    def __sub__(x, y):\n        return ComplexNumber(x.real-y.real, x.compl-y.compl)\n    def __mul__(x, y):\n        return ComplexNumber(x.real*y.real - x.compl*y.compl, x.compl*y.real + x.real*y.compl)\n    def __truediv__(x, y):\n        return ComplexNumber((x.real*y.real + x.compl*y.compl) / (y.real*y.real + y.compl*y.compl), \n                             (x.compl*y.real - x.real*y.compl) / (y.real*y.real + y.compl*y.compl))\n    def mod(self):\n        return ComplexNumber(math.sqrt(self.real*self.real + self.compl*self.compl), 0)\n    \nhelp = list(map(float, input().split(' ')))   \nx = ComplexNumber(help[0], help[1])    \nhelp = list(map(float, input().split(' ')))   \ny = ComplexNumber(help[0], help[1])    \n\nprint(x+y)\nprint(x-y)\nprint(x*y)\nprint(x/y)\nprint(x.mod())\nprint(y.mod())", "n = int(input())\nl = [2, 1]\nfor _ in range(n - 1):\n    l.append(l[-2] + l[-1])\nprint(l[-1])", "a,b,c = map(int,input().split())\nk = int(input())\nprint(max(a,b,c)*(2**k-1)+a+b+c)", "N, K  = [int(x) for x in input().split()]\nans = (K-1)**(N-1)*K\nprint(ans)", "K, N = map(int, input().split())\nA = list(map(int, input().split()))\n\nsub = [0] * (N - 1)\n\nfor i in range(N - 1):\n\tsub[i] = A[i + 1] - A[i]\nsub.append(A[0] + (K - A[-1]))\n\nprint(sum(sub) - max(sub))", "a, b, c, d = (int(n) for n in input().split())\nprint(max(a * b, c * d))", "import sys\n\n\ninputs = []\nfor input in sys.stdin:\n    inputs.append(input.replace(\"\\n\", \"\"))\n\nAC = 0\nWA = 0\nTLE = 0\nRE = 0\n\nfor index, input in enumerate(inputs, 1):\n    if input == \"AC\":\n        AC += 1\n    if input == \"WA\":\n        WA += 1\n    if input == \"TLE\":\n        TLE += 1\n    if input == \"RE\":\n        RE += 1\n\nprint((\"AC x \" + str(AC) + \"\\nWA x \" + str(WA) + \"\\nTLE x \" + str(TLE) + \"\\nRE x \" + str(RE)))\n", "M=int(input())\nprint(48-M)", "a, b = map(int, input().split())\nprint(a+b if a+b<10 else 'error')", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\n\na, b = list(map(int, input().split()))\n\nif a*b % 2 == 0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n", "N=int(input())\nT=list(map(int,input().split()))\nM=int(input())\ndrink=[]\nfor i in range(M):\n    P,X=map(int,input().split())\n    drink.append([P,X])\n    \nfor j in range(len(drink)):\n    P,X=drink[j]\n    time=X+sum(T)-T[P-1]\n    print(time)", "N = int(input())\nK = int(input())\n\nans = 1\n\ndef A(n):\n   return 2 * n\n\ndef B(n):\n   return n + K\n\nfor i in range(N):\n   if A(ans) <= B(ans):\n      ans = A(ans)\n   else:\n      ans = B(ans)\n\nprint(ans)", "N = int(input())\n\nx = N * 800\ny = N // 15 * 200\n\nanswer = x - y\n# print(x, y)\nprint(answer)", "print((input().count('1')))\n", "A,op,B=input().split()\nA,B=int(A),int(B)\nif op==\"+\":\n  print(A+B)\nelse:\n  print(A-B)", "a = list(map(int,input().split()))\nprint(sum(a)-max(a))", "a = list(input().split())\nprint(len(set(a)))", "alf=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\nn=int(input())\nli=[]\nans=[]\nSTR=\"\"\nfor h in range(n):\n    li.append([0]*26)\n\nfor i in range(n):\n    S=input()\n    for j in range(len(S)):\n        li[i][alf.index(S[j])]+=1\n\n\nfor k in range(26):\n    temp=1000000000000000000000000000000000000000000\n    for l in range(n):\n        if temp>li[l][k]:\n            temp=li[l][k]\n        \n    if temp!=1000000000000000000000000000000000000000000:\n        ans.append(temp)\n\nfor m in range(26):\n    STR=STR+alf[m]*ans[m]\nprint(STR)\n", "s = input()\nt = input()\nlt = len(t)\nans = []\nfor i in range(len(s)-lt+1):\n    cnt = 0\n    n = 0\n    while n < lt:\n        if s[i+n] == '?':\n            cnt += 1\n        else:\n            if s[i+n] == t[n]:\n                cnt += 1\n        n += 1\n    if cnt == lt:\n        ans.append(list(s[:i] + t + s[i+lt:]))\n        # print(ans)\n        # break\n\nif len(ans) != 0:\n    for a in ans:\n        # print(a)\n        for i in range(len(a)):\n            if a[i] == '?':\n                a[i] = 'a'\n    ans.sort()\n    print(*ans[0], sep='')\n\nelse:\n    print('UNRESTORABLE')", "R = int(input())  # \u73fe\u5728\u306e\u30ec\u30fc\u30c6\u30a3\u30f3\u30b0\nG = int(input())  # \u6b21\u306e\u30b3\u30f3\u30c6\u30b9\u30c8\u3067\u3068\u308a\u305f\u3044\u3068\u601d\u3063\u3066\u308b\u30ec\u30fc\u30c6\u30a3\u30f3\u30b0\n\n# \u9ad8\u6a4b\u541b\u304c\u53d6\u308b\u3079\u304d\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u51fa\u529b\nprint(G*2 - R)"], "train": ["t=int(input())\nfor i in range(t):\n    n=int(input())\n    i0,i1=[],[]\n    l0,l1=[],[]\n    h0,h1=False,False\n    for i in range(n):\n        t=input()\n        if t[0]=='0' and t[-1]=='1':\n            i0.append(i)\n            l0.append(t)\n        elif t[0]=='1' and t[-1]=='0':\n            i1.append(i)\n            l1.append(t)\n        elif t[0]==t[-1]=='1':\n            h1=True\n        elif t[0]==t[-1]=='0':\n            h0=True\n    c0,c1=len(l0),len(l1)\n    req,sl=0,[]\n    s0=set(l0)\n    s1=set(l1)\n    if c0>0 or c1>0:\n        if c0-c1>1:\n            req=(c0-c1)//2\n            sel=0\n            sl=[]\n            for tt in range(len(l0)):\n                t=l0[tt]\n                if not t[::-1] in s1:\n                    req-=1\n                    sl.append(i0[tt]+1)\n                if req==0:\n                    break\n        elif c1-c0>1:\n            req=(c1-c0)//2\n            sel=0\n            sl=[]\n            for tt in range(len(l1)):\n                t=l1[tt]\n                if not t[::-1] in s0:\n                    req-=1\n                    sl.append(i1[tt]+1)\n                if req==0:\n                    break\n        if req>0:\n            print(-1)\n        else:\n            print(len(sl))\n            print(*sl)\n    else:\n        if h0 and h1:\n            print(-1)\n        else:\n            print(0)\n            print(*[])\n", "q = int(input())\n\nfor i in range(q):\n    (x, y, k) = list(map(int, input().split()))\n\n    if max(x, y) > k:\n        print(-1)\n    elif x == y and k == x + 1:\n        print(k - 2)\n        continue\n    elif x % 2 == 1 and y % 2 == 1 and k % 2 == 0:\n        print(k - 2)\n        continue\n    elif x % 2 == 0 and y % 2 == 0 and k % 2 == 1:\n        print(k - 2)\n        continue\n    elif (x + y) % 2 == 0:\n        print(k)\n    else:\n        print(k - 1)\n", "gans = []\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    ans = [a[0]]\n    for i in range(1, n - 1):\n        if a[i] != ans[i - 1]:\n            ans.append(a[i])\n        else:\n            ans.append(b[i])\n    if a[-1] != ans[-1] and a[-1] != ans[0]:\n        ans.append(a[-1])\n    elif b[-1] != ans[-1] and b[-1] != ans[0]:\n        ans.append(b[-1])\n    else:\n        ans.append(c[-1])\n    gans.append(' '.join(map(str, ans)))\nprint('\\n'.join(gans))\n", "def main():\n    N, K = list(map(int, input().split()))\n    *A, = list(map(int, input().split()))\n    \n    A.sort()\n    print(A[-1] + sum(A[-K-1:-1]))\n\ndef __starting_point():\n    for __ in [0]*int(input()):\n        main()\n\n__starting_point()", "from sys import stdin\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n\nk, = rl()\nfor _ in range(k):\n    n, = rl()\n    p = rl()\n\n    q = [0] * n\n    for i, x in enumerate(p):\n        q[x-1] = i\n\n    l = r = q[0]\n    m = []\n    for k, i in enumerate(q):\n        if i < l:\n            l = i\n        elif i > r:\n            r = i\n        m.append('1' if r - l == k else '0')\n    print(''.join(m))\n", "import sys\ninput=sys.stdin.readline\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    aa=list(map(int,input().split()))\n    ss=set()\n    \n    st=0\n    ind=1\n    pre=[0 for i in range(n)]\n    for i in range(n):\n        if aa[i] in ss:\n            break\n        ss.add(aa[i])\n        while ind<=len(ss):\n            if ind in ss:\n                ind+=1\n            else:\n                break\n        if len(ss)!=ind-1:\n            pre[i]=0\n        else:\n            pre[i]=ind\n    ind=1\n   # print(pre)\n    ss=set()\n    suff=[0 for i in range(n)]\n    for i in range(n-1,-1,-1):\n        if aa[i] in ss:\n            break\n        ss.add(aa[i])\n        while ind<=len(ss):\n            if ind in ss:\n                ind+=1\n            else:\n                break\n        if len(ss)!=ind-1:\n            suff[i]=0\n        else:\n            suff[i]=ind\n    tot=0\n    ans=[]\n    for i in range(n-1):\n        if pre[i]>0 and suff[i+1]>0:\n            tot+=1\n            ans.append([i+1,n-i-1])\n    print(tot)\n    for i in ans:\n        print(i[0],i[1])\n        \n\n", "import sys\n\nT = int(sys.stdin.readline().strip())\nfor t in range (0, T):\n    n, m = list(map(int, sys.stdin.readline().strip().split()))\n    P = [[] for i in range (0, n)]\n    G = [0] * n\n    for i in range (0, m):\n        x, y = list(map(int, sys.stdin.readline().strip().split()))\n        x, y = x-1, y-1\n        P[y].append(x)\n    ans = []\n    for i in range (0, n):\n        for j in P[i]:\n            for k in P[j]:\n                if G[j] == 0 and G[k] == 0:\n                    if G[i] == 0:\n                        ans.append(str(i+1))\n                        G[i] = 1\n                    \n    print(len(ans))\n    print(\" \".join(ans))\n", "import sys\ninput = sys.stdin.readline\nimport heapq as hq\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  vt = [list(map(int,input().split())) for i in range(n)]\n  vt.sort(reverse=True)\n  q = []\n  hq.heapify(q)\n  ans = 0\n  cnt = 0\n  for i in range(n):\n    hq.heappush(q,vt[i][1])\n    if vt[i][0] >= n-i+cnt:\n      ans += hq.heappop(q)\n      cnt += 1\n  print(ans)", "for _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    inp = input().lower()\n    k = min(k, inp.count('l'))\n    ans = inp.count('w') + tuple(zip(inp, 'l' + inp)).count('ww') + k * 2\n    if 'w' in inp:\n        inp2 = []\n        cur = -1\n        for c in inp:\n            if cur != -1:\n                if c == 'l':\n                    cur += 1\n                else:\n                    inp2.append(cur)\n            if c == 'w':\n                cur = 0\n        inp2.sort()\n        for inp2i in inp2:\n            if inp2i > k:\n                break\n            k -= inp2i\n            ans += 1\n    else:\n        ans = max(ans - 1, 0)\n    print(ans)\n", "for _ in range(int(input())):\n    s = input()\n\n    ones = []\n    cnt = 0\n    for i in s:\n        if i == '1':\n            cnt += 1\n        else:\n            if cnt != 0:\n                ones.append(cnt)\n                cnt = 0\n    if cnt != 0:\n        ones.append(cnt)\n\n    ones.sort(reverse=True)\n    print(sum(ones[::2]))\n", "import sys\n\ndef ii():\n    return sys.stdin.readline().strip()\n\ndef idata():\n    return [int(x) for x in ii().split()]\n\ndef solve_of_problem():\n    n = int(ii())\n    data = idata()\n    ans = [data[0]]\n    for i in range(1, n - 1):\n        if data[i - 1] < data[i] > data[i + 1] or data[i - 1] > data[i] < data[i + 1]:\n            ans += [data[i]]\n    print(len(ans) + 1)\n    print(*ans, data[-1])\n    return\n\nfor ______ in range(int(ii())):\n    solve_of_problem()", "t = int(input())\nfor _ in range(t):\n    ss = input()\n    minx=0\n    fminxpos = -1\n    lminxpos = -1\n    maxx=0\n    fmaxxpos = -1\n    lmaxxpos = -1\n    miny=0\n    fminypos = -1\n    lminypos = -1\n    maxy=0\n    fmaxypos = -1\n    lmaxypos = -1\n    x = 0\n    y = 0\n    for i,s in enumerate(ss):\n        if s == 'W':\n            y +=1\n            if y > maxy:\n                maxy=y\n                fmaxypos=i\n            if y == maxy:\n                lmaxypos=i\n        elif s == 'S':\n            y -= 1\n            if y < miny:\n                miny = y\n                fminypos = i\n            if y == miny:\n                lminypos = i\n        elif s == 'D':\n            lastd = i\n            x += 1\n            if x > maxx:\n                maxx = x\n                fmaxxpos = i\n            if x == maxx:\n                lmaxxpos = i\n        elif s == 'A':\n            lasta = i\n            x -= 1\n            if x < minx:\n                minx = x\n                fminxpos = i\n            if x == minx:\n                lminxpos = i\n    xsize = maxx - minx + 1\n    ysize = maxy - miny + 1\n    if xsize > 2 and (fmaxxpos > lminxpos or fminxpos > lmaxxpos):\n        xmin = xsize - 1\n    else:\n        xmin = xsize\n    if ysize > 2 and (fmaxypos > lminypos or fminypos > lmaxypos):\n        ymin = ysize - 1\n    else:\n        ymin = ysize\n    print(min(xmin*ysize, xsize*ymin))", "import math\nfrom collections import defaultdict\nml=lambda:map(int,input().split())\nll=lambda:list(map(int,input().split()))\nii=lambda:int(input())\nip=lambda:input()\n\n\"\"\"========main code===============\"\"\"\n\nt=ii()\nfor _ in range(t):\n    x=ii()\n    a=ll()\n    b=ll()\n    one=-1\n    minus=-1\n    f=0\n    for i in range(x):\n        if(b[i]>a[i]):\n            if(one==-1):\n                f=1\n                break\n        elif (b[i]<a[i]):\n            if(minus==-1):\n                f=1\n                break\n        if(a[i]==1):\n            one=1\n        elif(a[i]==-1):\n            minus=1\n    if(f):\n        print(\"NO\")\n    else:\n        print(\"YES\")", "for _ in range(int(input())):\n\tn,g,b = map(int,input().split())\n\torign = n\n\tn = (n+1)//2\n\tcom = ((n-1)//g)\n\tans = com*(g+b)\n\tn -= com*g\n\tans += n\n\tprint(max(ans,orign))", "t=int(input())\nfor i in range(t):\n    a,b=list(map(int,input().split()))\n    c,d=list(map(int,input().split()))\n    if max(a,b)==max(c,d):\n        if min(a,b)+min(c,d)==max(a,b):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n", "from math import *\nfrom collections import *\nt = int(input())\nfor y in range(t):\n\ta,b,x,y = map(int,input().split())\n\tl = max(x,a-x-1)\n\tw = max(y,b-y-1)\n\tprint(max(l*b,a*w))", "from math import sqrt\nclass pro(object):\n    def __init__(self,dif,sc):\n        self.dif=dif\n        self.sc=sc\n\n    def __lt__(self,other):\n        return self.dif>other.dif\n\nT=int(input())\nmul=[1]\nfor i in range(100):\n    mul.append(mul[i]*10/9)\ninf=1000000007\nfor t in range(T):\n    n=int(input())\n    effi,tim=list(map(float,input().split()))\n    prob=[]\n    for i in range(n):\n        x,y=list(map(int,input().split()))\n        prob.append(pro(x,y))\n    prob.sort()\n    f=[[inf for i in range(n+1)] for j in range(1001)]\n    f[0][0]=0\n    totsc=0\n    for i in range(n):\n        totsc+=prob[i].sc\n        for j in range(totsc,prob[i].sc-1,-1):\n            for k in range(1,i+2):\n                f[j][k]=min(f[j][k],f[j-prob[i].sc][k-1]+prob[i].dif*mul[k])\n    for i in range(totsc,-1,-1):\n        flag=False\n        for j in range(n+1):\n            if sqrt(effi*f[i][j])>=1:\n                res=2*sqrt(f[i][j]/effi)-1/effi+10*j\n            else:\n                res=f[i][j]+10*j\n            if res<=tim:\n                print(i)\n                flag=True\n                break\n        if flag==True:\n            break\n", "\nfrom sys import stdin\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n = int(stdin.readline())\n    a = list(map(int,stdin.readline().split()))\n\n    l = [0] * (n+1)\n    ans = 0\n\n    for j in range(n):\n        r = [0] * (n+1)\n        for k in range(n-1,j,-1):\n            ans += l[a[k]] * r[a[j]]\n            r[a[k]] += 1\n        l[a[j]] += 1\n\n    print (ans)\n            \n    \n", "import math\nimport sys\ninput = sys.stdin.readline\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    theta = 2 * n\n    print(1 / math.tan(math.radians(360 / 4 / n)))", "from collections import deque\n\nt=int(input())\nfor i in range(t):\n    n,k,dp=[int(x) for x in input().split()]\n    d={}\n    i=0\n    p=deque()\n    cur=0\n    min=k\n    for el in input().split():\n        i+=1\n        if i<=dp:\n            p.append(el)\n            if el in list(d.keys()):\n                d[el]+=1\n            else:\n                d[el]=1\n                cur+=1\n        else:\n            if cur<min:\n                min=cur\n            ##deleting\n            exc=p.popleft()\n            if d[exc]==1:\n                d.pop(exc)\n                cur-=1\n            else:\n                d[exc]-=1\n            ##adding\n            p.append(el)\n            if el in list(d.keys()):\n                d[el]+=1\n            else:\n                d[el]=1\n                cur+=1\n        ##print(d,p)\n    if min>cur:\n        min=cur\n    print(min)\n", "for _ in range(int(input())):\n\tn,m=map(int,input().split())\n\tlm=hm=m\n\tpt=0\n\tans=\"YES\"\n\tfor i in range(n):\n\t\tt,l,h=map(int,input().split())\n\t\tlm-=(t-pt)\n\t\thm+=(t-pt)\n\t\tpt=t\n\t\thm=min(h,hm)\n\t\tlm=max(l,lm)\n\t\tif hm<lm:\n\t\t\tans=\"NO\"\n\tprint(ans)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n  N = int(input())\n  a = list(map(int, input().split()))\n  a.sort()\n  for x in range(1, 1024):\n    b = [0] * N\n    for i in range(N): b[i] = a[i] ^ x\n    b.sort()\n    if a == b:\n      print(x)\n      break\n  else: print(-1)", "t=int(input())\nfor i in range(t):\n    a1,k=map(int,input().split())\n    an=a1\n    for j in range(1,k):\n        astr=str(an)\n        min=9\n        max=0\n        for r in range(len(astr)):\n            if int(astr[r])<min:\n                min=int(astr[r])\n            if int(astr[r])>max:\n                max=int(astr[r])\n        an+=min*max\n        if min==0:\n            break\n    print(an)", "import sys\nimport heapq\n \n \ndef solve(pr, mm):\n    omm = []\n    n = len(mm)\n    for i in range(n + 1):\n        omm.append([])\n    \n    for i in range(n):\n        omm[mm[i]].append(pr[i])\n    \n    for i in range(n + 1):\n        omm[i] = sorted(omm[i])\n    \n    heap = []\n    c = 0\n    t = n\n    p = 0\n    for i in range(n, -1, -1):\n        for h in omm[i]:\n            heapq.heappush(heap, h)\n            \n        t -= len(omm[i])\n        mn = max(i - c - t, 0)\n        c += mn\n        for j in range(mn):\n            p += heapq.heappop(heap)\n        \n    return p\n    \n \ndef __starting_point():\n    t = int(input().strip())\n    for i in range(t):\n        n = int(input().strip())\n        ms = []\n        ps = []\n        for j in range(n):\n            arr = [int(v) for v in input().strip().split(' ')]\n            ms.append(arr[0])\n            ps.append(arr[1])\n            \n        print(solve(ps, ms))\n\n__starting_point()", "for _ in range(int(input())):\n    d=int(input())\n    anws=False\n    if d**2>=4*d:\n        root=(d**2-4*d)**0.5\n        a=(d+root)/2\n        b=(d-root)/2\n        anws=True\n    if anws:\n        print(\"Y {:.9f} {:.9f}\".format(a,b))\n    else:\n        print(\"N\")", "q = int(input())\n\nfor _ in range(q):\n    n, m = list(map(int, input().split()))\n    if n == 2 and m == 2 or n == 1 or m == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    dell = []\n    for i in range(n):\n        new = 0\n        while A[i] % 2 != 1:\n            A[i] //= 2\n            new += 1\n        dell.append([A[i], new])\n    dicter = {}\n    for el in dell:\n        if el[1] > dicter.get(el[0], -1):\n            dicter[el[0]] = el[1]\n    ans = 0\n    for el in dicter:\n        ans += dicter[el]\n    print(ans)", "def f(s):\n  t=\"abacaba\"\n  for i in range(7):\n    if s[i]!=\"?\" and t[i]!=s[i]:return False\n  return True\ndef g(s):\n  c=0\n  for i in range(7,len(s)+1):\n    if s[i-7:i]==\"abacaba\":c+=1\n  return c\n\nfor _ in range(int(input())):\n  n=int(input())\n  s=input()\n  if g(s)>1:\n    print(\"No\")\n    continue\n  if \"abacaba\" in s:\n    print(\"Yes\")\n    print(s.replace(\"?\",\"z\"))\n    continue\n  flag=False\n  for i in range(7,len(s)+1):\n    if f(s[i-7:i]):\n      t=(s[:i-7]+\"abacaba\"+s[i:]).replace(\"?\",\"z\")\n      if g(t)>1:continue\n      print(\"Yes\")\n      print(t)\n      flag=True\n      break\n  if not(flag):print(\"No\")", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] + list(map(int, input().split()))\n\n    period = [0 for i in range(n+1)]\n    first = [-1 for i in range(n+1)]\n    last = [-1 for i in range(n+1)]\n    for i in range(1, len(a)):\n        b = a[i]\n        if first[b] == -1:\n            first[b] = i\n            last[b] = i\n        else:\n            period[b] = max(period[b], i - last[b])\n            last[b] = i\n    \n    for i in range(1, len(period)):\n        period[i] = max(period[i], n-last[i]+1)\n    \n    period = period[1:]\n    l = sorted(list(e if e[0] > first[e[1]] else (first[e[1]], e[1]) for e in zip(period, list(range(1, n+1))) if e[0] > 0))\n\n    ans = []\n    AA = n+5\n    ind = 0\n    for i in range(1, n+1):\n        if ind < len(l) and l[ind][0] == i:\n            AA = min(AA, l[ind][1])\n        ans.append(-1 if AA == n+5 else AA)\n        while ind < len(l) and l[ind][0] == i:\n            ind += 1\n            \n    print(*ans)\n        \n        \n", "import collections\nimport math\nfrom itertools import permutations as p\n\nfor t in range(int(input())):\n    n=int(input())\n    s=input()\n    stack=[]\n    for i in s:\n        if i=='1':\n            if stack and stack[-1]=='0':\n                stack.pop()\n        else:\n            if stack and stack[-1]=='1':\n                stack.pop()\n        stack.append(i)\n    print(len(stack)//2)", "from math import *\n\nfor zz in range(int(input())):\n    used = set()\n    ans = 0\n    pos = [0, 0]\n    a = 0\n    for i in range(35000):\n        a += 1\n    a = ans - 1\n    for x in input():\n        ppos = pos[:]\n        ppos = tuple(ppos)\n        if x == 'N':\n            pos[0] += 1\n        elif x == 'S':\n            pos[0] -= 1\n        elif x == 'W':\n            pos[1] -= 1\n        else:\n            pos[1] += 1\n        if ((ppos, tuple(pos)) in used) or ((tuple(pos), ppos) in used):\n            ans += 1\n        else:\n            used.add((ppos, tuple(pos)))\n            ans += 5\n    print(ans)\n\n#aaa\n", "from sys import stdin, stdout\nfrom collections import defaultdict\ninput = stdin.readline\nfor _ in range(int(input())):\n\tn = int(input())\n\tchanek = 0\n\tflag = 1\n\twhile n>0:\n\t\tif n%4==0 and n!=4:\n\t\t\tif flag:\n\t\t\t\tchanek += 1\n\t\t\t\tn-=1\n\t\t\t\tflag = 0\n\t\t\telse:\n\t\t\t\tn-=1\n\t\t\t\tflag = 1\n\t\telif n%2:\n\t\t\tif flag:\n\t\t\t\tchanek += 1\n\t\t\t\tn-=1\n\t\t\t\tflag = 0\n\t\t\telse:\n\t\t\t\tn-=1\n\t\t\t\tflag = 1\n\t\telse:\n\t\t\tif flag:\n\t\t\t\tchanek += n//2\n\t\t\t\tn//=2\n\t\t\t\tflag = 0\n\t\t\telse:\n\t\t\t\tn//=2\n\t\t\t\tflag = 1\n\tprint(chanek)", "for _ in range (int(input())):\n    n=int(input())\n    hold=n\n    res=[]\n    for i in range (n-1,0,-1):\n        res.append((hold,i))\n        hold=(hold+i+1)//2\n    print(hold)\n    for i in res:\n        print(*i)", "t =  int(input())\n\nfor _ in range(t):\n    n = int(input())\n    if (n%2==0):\n        print('1'*(n//2))\n    else:\n        print('7'+'1'*((n-3)//2))", "from sys import stdin\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    ans = 0\n    arr = sorted(list(map(int,stdin.readline().split())))\n    peo = 0\n    for i in range(n):\n        peo += 1\n        if peo == arr[i]:\n            ans += 1\n            peo = 0\n    print(ans)\n", "from sys import stdin\nfrom bisect import bisect_left\n\nstdin.readline()\nx, l = 0, []\nfor y in map(int, stdin.readline().split()):\n    x += y\n    l.append(x)\nstdin.readline()\n\nfor y in map(int, stdin.readline().split()):\n    print(bisect_left(l, y) + 1)\n", "from sys import stdin\ninput = stdin.readline\n\n\ndef main():\n    anses = []\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        f = [0]*(n+1)\n        d = sorted(list(set(a)))\n        for q in range(1, len(d)+1):\n            f[d[q-1]] = q\n        for q in range(len(a)):\n            a[q] = f[a[q]]\n        n = len(d)\n        starts, ends = [-1]*(n+1), [n+1]*(n+1)\n        for q in range(len(a)):\n            if starts[a[q]] == -1:\n                starts[a[q]] = q\n            ends[a[q]] = q\n        s = [0]*(n+1)\n        max1 = -float('inf')\n        for q in range(1, n+1):\n            s[q] = s[q-1]*(ends[q-1] < starts[q])+1\n            max1 = max(max1, s[q])\n        anses.append(str(len(d)-max1))\n    print('\\n'.join(anses))\n\n\nmain()\n", "t = int(input())\n\nfor i in range(t):\n    n, k = map(int, input().split())\n    *s, = input()\n    operations = []\n    best = (['('] + [')']) * (k - 1) + (['('] * (n // 2 - k + 1) + [')'] * (n // 2 - k + 1))\n\n    for startx_pos in range((k - 1) * 2):\n        try:\n            if s[startx_pos - 1] == ')' or startx_pos == 0:\n                end_pos = s.index('(', startx_pos)\n            else:\n                end_pos = s.index(')', startx_pos)\n        except ValueError:\n            continue\n        if startx_pos == end_pos:\n            continue\n        if startx_pos == 0:\n            s = s[:startx_pos] + s[end_pos::-1] + s[end_pos + 1:]\n        else:\n            s = s[:startx_pos] + s[end_pos:startx_pos - 1:-1] + s[end_pos + 1:]\n        operations.append(f'{startx_pos + 1} {end_pos + 1}')\n\n    for startx_pos in range((k - 1) * 2, (k - 1) * 2 + (n // 2 - k + 1)):\n        try:\n            end_pos = s.index('(', startx_pos)\n        except ValueError:\n            continue\n        if startx_pos == end_pos:\n            continue\n        if startx_pos == 0:\n            s = s[:startx_pos] + s[end_pos::-1] + s[end_pos + 1:]\n        else:\n            s = s[:startx_pos] + s[end_pos:startx_pos - 1:-1] + s[end_pos + 1:]\n        operations.append(f'{startx_pos + 1} {end_pos + 1}')\n\n    print(len(operations))\n    if len(operations):\n        print(*operations, sep='\\n')\n", "def run(a, ind, l):\n    newSt = ''\n    ans = 0\n    for i in range(ind, len(a)):\n        newSt += a[i]\n        if int(newSt, 2) == (i - l + 1):\n            ans += 1\n        if int(newSt, 2) > (i - l + 1):\n            return ans\n    return ans\n\n\nn = int(input())\nfor kkk in range(n):\n    st = input()\n    uk = [0] * len(st)\n    for i in range(len(uk)):\n        uk[i] = i\n\n    for j in range(len(uk)):\n        if st[j] == '1':\n            uk[0] = j\n            break\n    for i in range(1, len(uk)):\n        if i < uk[i - 1]:\n            uk[i] = uk[i - 1]\n        else:\n            for j in range(i, len(uk)):\n                if st[j] == '1':\n                    uk[i] = j\n                    break\n\n    s = 0\n    for i in range(len(uk)):\n         if ((uk[i] != i) or st[i] == '1'):\n             s += run(st, uk[i], i)\n    print(s)", "import sys\ninput=sys.stdin.readline\ndef f(x):\n    ans=0\n    for i in range(n):\n        if(a[i]<=x):\n            continue\n        ans+=b[i]\n    if(ans<=x):\n        return 1\n    return 0\ndef bsearch(l,r):\n    m=(l+r)//2\n    if(f(m)):\n        if(f(m-1)==0):\n            return m\n        return bsearch(l,m-1)\n    return bsearch(m+1,r)\nt=int(input())\nfor you in range(t):\n    n=int(input())\n    l=input().split()\n    a=[int(i) for i in l]\n    l=input().split()\n    b=[int(i) for i in l]\n    print(bsearch(0,10**9+5))\n", "for _ in range (int(input())):\n    n=int(input())\n    for i in range (4*n,4*n-2*n,-2):\n        print(i,end=' ')\n    print()", "y=lambda:int(input())\nfor _ in range(y()):\n n=y();c=0\n while 2**(2*c+1)-2**c<=n:n-=2**(2*c+1)-2**c;c+=1\n print(c)", "import sys\nimport math\nimport collections\nimport heapq\n\ndef set_debug(debug_mode=False):\n    if debug_mode:\n        fin = open('input.txt', 'r')\n        sys.stdin = fin\n\n\ndef int_input():\n    return list(map(int, input().split()))\n\n\ndef __starting_point():\n    # set_debug(True)\n\n    t = int(input())\n    # t = 1\n\n    for ti in range(1, t + 1):\n        # n = int(input())\n        s = input()\n\n        c = collections.Counter(s)\n        m = max(c['R'], c['S'], c['P'])\n\n        if m == c['R']:\n            print('P' * len(s))\n        elif m == c['S']:\n            print('R' * len(s))\n        else:\n            print('S' * len(s))\n\n__starting_point()", "for i in range(int(input())):\n\tn, q = list(map(int, input().split()))\n\ta = list(map(int, input().split()))\n\ttot = 0\n\tsmall = 400000\n\tbig = 0\n\tgoingUp = True\n\tfor i, val in enumerate(a):\n\t\tif goingUp:\n\t\t\tif val > big:\n\t\t\t\tbig = val\n\t\t\telse:\n\t\t\t\ttot += big\n\t\t\t\tgoingUp = False\n\t\t\t\tsmall = val\n\t\telse:\n\t\t\tif val < small:\n\t\t\t\tsmall = val\n\t\t\telse:\n\t\t\t\ttot -= small\n\t\t\t\tgoingUp = True\n\t\t\t\tbig = val\n\tif goingUp:\n\t\ttot += big\n\tprint(tot)", "q = int(input())\nfor t in range(q):\n    x, y, k = list(map(int, input().split()))\n    a = ((y + 1) * k - 1 + x - 1 - 1) // (x - 1)\n    b = k\n    print(a + b)\n", "import math\ndef combi(L,n):\n    return math.factorial(L)//math.factorial(n)//math.factorial(L-n)\n\n\nT=int(input())\nLR=[list(map(int,input().split())) for i in range(T)]\n\ndef classy(less,nonzero,now):\n    L=len(str(now))\n\n    if less==0:\n        if 3-nonzero>=L:\n            return 10**L\n        else:\n            ANS=1\n            for i in range(1,3-nonzero+1):\n                ANS+=combi(L,i)*(9**i)\n\n            return ANS\n\n    else:\n        if nonzero<=2:\n            if now<=9:\n                return now+1\n            \n            else:\n                if int(str(now)[0])==1:\n                    return classy(1,nonzero+1,int(str(now)[1:]))\\\n                           +classy(0,nonzero,int(\"9\"*(L-1)))\\\n\n                else:\n                    return classy(1,nonzero+1,int(str(now)[1:]))\\\n                           +(int(str(now)[0])-1)*classy(0,nonzero+1,int(\"9\"*(L-1)))\\\n                           +classy(0,nonzero,int(\"9\"*(L-1)))\n\n        else:\n            return 1\n\nfor l,r in LR:\n    print(classy(1,0,r)-classy(1,0,l-1))\n\n            \n        \n                          \n        \n    \n    \n", "import sys\nreadline = sys.stdin.readline\nT = int(readline())\nAns = [None]*T\ninf = 10**9+7\nfor qu in range(T):\n    N = int(readline())\n    A = list(map(int, readline().split()))\n    bj = A.count(1)\n    sj = 2*N-bj\n    x = sj-bj\n    A1 = [3-2*a for a in A[:N][::-1]]\n    A2 = [3-2*a for a in A[N:]]          \n    for i in range(1, N):\n        A1[i] += A1[i-1]\n        A2[i] += A2[i-1]\n    geta = -min(0, min(A2))+1\n    mA = max(0, max(A2))\n    idx = [inf]*(mA+geta+1)\n    idx[geta+0] = 0\n    for i in range(N):\n        a2 = A2[i]\n        idx[geta+a2] = min(idx[geta+a2], i+1)\n    \n    ans = inf\n    A1 = [0]+A1\n    for i in range(N+1):\n        a1 = A1[i]\n        if -geta <= -a1-x <= mA:\n            ans = min(ans, i+idx[geta-a1-x])\n    Ans[qu] = ans\nprint('\\n'.join(map(str, Ans)))", "q = int(input())\n\nwhile q > 0:\n    n, k, d1, d2 = list(map(int, input().split()))\n    if d1 > d2:\n        d1, d2 = d2, d1\n    if k - 2 * d1 - d2 >= 0 and (k - 2 * d1 - d2) % 3 == 0 and \\\n            (n - k) - d1 - 2 * d2 >= 0 and ((n - k) - d1 - 2 * d2) % 3 == 0:\n        print('yes')\n    elif k - 2 * d2 - d1 >= 0 and (k - 2 * d2 - d1) % 3 == 0 and \\\n            (n - k) - d2 - 2 * d1 >= 0 and ((n - k) - d2 - 2 * d1) % 3 == 0:\n        print('yes')\n    elif k - 2 * d2 + d1 >= 0 and (k - 2 * d2 + d1) % 3 == 0 and \\\n            (n - k) - d2 - d1 >= 0 and ((n - k) - d2 - d1) % 3 == 0:\n        print('yes')\n    elif k - d1 - d2 >= 0 and (k - d1 - d2) % 3 == 0 and \\\n            (n - k) - 2 * d2 + d1 >= 0 and ((n - k) - 2 * d2 + d1) % 3 == 0:\n        print('yes')\n    else:\n        print('no')\n    q -= 1\n", "n = int(input())\na=[]\nfor i in range(n):\n    a += [int(input())]\na.sort()\nans = 0\nfor i in range(n):\n    ans += a[i] * a[n-i-1]\nprint(ans % 10007)", "def makeRepeat(s):\n    repeat = [[s[0], 0]]\n    for ch in s:\n        if ch == repeat[-1][0]:\n            repeat[-1][1] += 1\n        else:\n            repeat.append([ch, 1])\n    return repeat\n\n\ndef solve(N, S):\n    assert len(S) == N - 1\n    curr = 0\n    repeat = makeRepeat(S)\n    longest = list(range(1, N + 1))\n    shortest = list(reversed(list(range(1, N + 1))))\n    for ch, count in repeat:\n        if ch == \">\":\n            longest[curr : curr + count + 1] = reversed(\n                longest[curr : curr + count + 1]\n            )\n        else:\n            assert ch == \"<\"\n            shortest[curr : curr + count + 1] = reversed(\n                shortest[curr : curr + count + 1]\n            )\n        curr += count\n\n    # print(\" \" + \" \".join(S))\n    return \" \".join(map(str, shortest)) + \"\\n\" + \" \".join(map(str, longest))\n\n\ndef __starting_point():\n    T, = list(map(int, input().split()))\n    for t in range(T):\n        N, S = input().split()\n        N = int(N)\n        ans = solve(N, S)\n        print(ans)\n\n__starting_point()", "tgt = (2048).bit_length() - 1\nfor _ in range(int(input())):\n    n = int(input())\n    c = [0] * 31\n    for x in input().split():\n        c[int(x).bit_length() - 1] += 1\n    for i in range(tgt):\n        c[i + 1] += c[i] // 2\n    print('YES' if c[tgt] else 'NO')", "import sys\nimport math\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n\treturn map(int, sys.stdin.readline().split())\n\ndef SI():\n\treturn sys.stdin.readline().strip()\nt = II()\nfor q in range(t):\n\tn = II()\n\tprint(math.ceil(n/2))", "import sys\ninput = sys.stdin.readline\ninputr = lambda: sys.stdin.readline().rstrip('\\n')\n\nfor _ in range(int(input())):\n\tn, k = list(map(int, input().split()))\n\n\te = k // n\n\tT = [[0] * n for _ in range(n)]\n\n\tfor i in range((k+n-1)//n):\n\t\tfor j in range(min(n, k - i * n)):\n\t\t\tT[j][(i + j)%n] = 1\n\n\trows = [sum(R) for R in T]\n\tcols = [sum(C) for C in zip(*T)]\n\tassert sum(rows) == k\n\tassert sum(cols) == k\n\tprint((max(rows) - min(rows)) ** 2 + (max(cols) - min(cols)) ** 2)\n\tfor R in T:\n\t\tprint(''.join(map(str, R)))\n", "\nT = int(input())\n\nfor i in range(T):\n  n = int(input())\n  #n,m = map(int, input().split())\n  #a,b = map(int, input().split())\n  a = [int(i) for i in input().split()]\n  #a = list(input())\n  \n  if a[-1]>a[0]:\n    print('YES')\n  else:\n    print('NO')\n\n\n", "import sys\ninput = sys.stdin.readline\n\nd={}\ntestnumber = int(input())\n\ndef calc(n, m, k):\n    if k <= 0 or k == m*n:\n        return 0\n    if k > n*m:\n        return 1000_000_000\n\n    nonlocal d\n    if n < m:\n        n, m = m, n\n    \n    if k > (m*n - m):\n        return m*m + 1\n    if k < m:\n        return m*m + 1\n    if k % m == 0:\n        return m*m\n\n    if (n, m, k) in d:\n        return d[ (n, m, k)]\n\n    d[ (n, m, k) ] = min( calc2(n, m, k), calc2(m, n, k) )\n\n    return d[ (n, m, k) ]\n\ndef calc2(n, m, k):\n    m2 = m*m\n    ans = m2*2 + 1\n    for i in range(1, n):\n        if i*m >= k:\n            ans = min(ans, m2 + calc(m, i, k) )\n        else:\n            ans = min(ans, m2 + calc(m, n-i, k - i*m))\n    \n    return ans\n\nfor ntest in range(testnumber):\n    n, m, k = map( int, input().split() )\n    if k == n*m:\n        print(0)\n        continue\n\n    print( calc(n, m, k) )", "from math import *\n\nzzz = int(input())\nfor zz in range(zzz):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = set()\n    for i in range(n):\n        if a[i] == -1:\n            if i > 0:\n                if a[i-1] >= 0:\n                    b.add(a[i-1])\n            if i < n - 1:\n                if a[i+1] >= 0:\n                    b.add(a[i+1])\n    b = list(b)\n    if len(b) == 0:\n        print(0, 0)\n    else:\n        k = (min(b) + max(b)) // 2\n        m = 0\n        for i in range(n):\n            if a[i] == -1:\n                a[i] = k\n        for i in range(1, n):\n            m = max(m, abs(a[i-1]- a[i]))\n        print(m, k)\n", "read = lambda: map(int, input().split())\nt = int(input())\nfor i in range(t):\n    a, b = read()\n    print(a^b)", "for _ in range(int(input())):\n    N=int(input())\n    A=list(map(int,input().split()))\n    temp=0\n    for i in range(1,N-1):\n        if(A[i]>A[i-1] and A[i]>A[i+1]):\n            temp=1\n            print(\"YES\")\n            print(i,i+1,i+2)\n            break\n    if(temp==0):\n        print(\"NO\")", "T = int(input())\n\n\n\ndef solve(S):\n    res = [S[0]]\n    pos = 0 # think...\n    for s in S[1:]:\n        # can we change?\n        if 0 <= pos-1 < len(res) and res[pos-1] == s:\n            pos = pos-1\n        elif 0 <= pos+1 < len(res) and res[pos+1] == s:\n            pos = pos+1\n        elif pos == 0 and s not in res:\n            res.insert(0, s) # pos is still 0\n        elif pos == len(res)-1 and s not in res:\n            res.append(s)\n            pos += 1\n        else: return None\n    #print(''.join(res))\n    for x in range(ord('a'), ord('z')+1):\n        x = chr(x)\n        if x not in res:\n            res.append(x)\n    return ''.join(res)\n\nfor _ in range(T):\n    res = solve(input())\n    if res is None:\n        print('NO')\n    else:\n        print('YES')\n        print(res)\n", "t=int(input())\nfor i in range(t):\n    n,k=map(int,input().split())\n    a=list(map(int,input().split()))\n    w=list(map(int,input().split()))\n    a.sort()\n    a.reverse()\n    w.sort()\n    ans=0\n    for i in range(k):\n        ans+=a[i]\n    pointer=k-1\n    for i in range(k):\n        if w[i]==1:\n            ans+=a[i]\n            continue\n        pointer+=w[i]-1\n        ans+=a[pointer]\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\nfrom bisect import bisect_right\n\nfor _ in range(int(input())):\n\tn, l = list(map(int, input().split()))\n\tA = list(map(int, input().split()))\n\n\tc1 = []\n\tspeed = 1\n\tx = 0\n\tt = 0.\n\tfor a in A:\n\t\tt += (a-x)/speed\n\t\tc1.append(t)\n\t\tspeed += 1\n\t\tx = a\n\n\tc2 = []\n\tspeed = 1\n\tx = l\n\tt = 0.\n\tfor a in reversed(A):\n\t\tt += (x-a)/speed\n\t\tc2.append(t)\n\t\tspeed += 1\n\t\tx = a\n\n\tlo = 0.\n\thi = float(l)\n\n\twhile hi - lo > 1e-7:\n\t\tm = (lo + hi) / 2\n\n\t\ti1 = bisect_right(c1, m)-1\n\t\tif i1 == -1:\n\t\t\tx1 = m\n\t\telse:\n\t\t\ttpass = c1[i1]\n\t\t\ttextra = m - tpass\n\t\t\tx1 = A[i1] + textra * (i1+2)\n\n\t\ti2 = bisect_right(c2, m)-1\n\t\tif i2 == -1:\n\t\t\tx2 = l-m\n\t\telse:\n\t\t\ttpass = c2[i2]\n\t\t\ttextra = m - tpass\n\t\t\tx2 = A[-1-i2] - textra * (i2+2)\n\n\t\tif x1 < x2: lo = m\n\t\telse: hi = m\n\n\tprint((lo+hi)/2)\n", "INF = 10**6\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    out = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        best = INF\n        if i >= 2:\n            best = min(best, a[i-2] + out[i-2])\n        if i >= 3:\n            best = min(best, a[i-3] + out[i-3])\n        if i >= 4:\n            best = min(best, a[i-4] + a[i-3] + out[i-4])\n        out[i] = best\n\n    fin = out[n]\n    for i in range(1,4):\n        if i <= n:\n            fin = min(fin, out[n-i] + a[n-i])\n    print(fin)\n", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    t = input()\n\n    d = {}\n    for i in range(ord('a'), ord('z') + 1):\n        d[chr(i)] = 0\n\n    for cs in s:\n        d[cs] += 1\n    for ct in t:\n        d[ct] += 1\n\n    ok = True\n    for e in d:\n        if d[e] % 2 == 1:\n            ok = False\n\n    if not ok:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\n        changes = []\n\n        s, t = list(s), list(t)\n        for i in range(n-1):\n            if s[i] != t[i]:\n                r = (0, -1)\n                for j in range(i+1, n):\n                    if s[j] == t[i]:\n                        r = (j, 0)\n\n                for j in range(i+1, n):\n                    if t[j] == t[i]:\n                        r = (j, 1)\n\n                if r[1] == 0:\n                    changes += [(r[0], i+1), (i, i+1)]\n                    s[r[0]], t[i+1] = t[i+1], s[r[0]]\n                    s[i], t[i+1] = t[i+1], s[i]\n                elif r[1] == 1:\n                    changes += [(i, r[0])]\n                    s[i], t[r[0]] = t[r[0]], s[i]\n\n        print(len(changes))\n        for change in changes:\n            x, y = change\n            print(x+1, y+1)", "t = int(input())\n\nfor case in range(t):\n    n = int(input())\n    s = input()\n    #print(\"Input read in OK\", n, s)\n\n    groups = [s[0]]\n    for x in s[1:]:\n        if x == groups[-1][-1]:\n            groups[-1] += x\n        else:\n            groups.append(x)\n\n    groups = [len(x) for x in groups]\n    to_use = 0\n    #print(\"groups are\", groups)\n\n    ops = 0\n    for i, x in enumerate(groups):\n        while to_use < len(groups):\n            if to_use < i:\n                to_use += 1\n                continue\n            if groups[to_use] <= 1:\n                to_use += 1\n                continue\n            break\n        else:\n            break\n\n        #print(\"using\", to_use)\n        groups[to_use] -= 1\n        groups[i] = 0\n        ops += 1\n    else:\n        print(ops)\n        continue\n\n    # We now have a situation where the grid is of the form 10101010.\n    # What do we do? Well,\n    # 1010 (even length = n/2)\n    # 10101 (odd length = (n + 1)/2)\n    # so (n+1)/2 it is\n    #print(\"ops before was\", ops)\n    size = len(groups) - i\n    #print(\"size is\", size)\n    ops += (size + 1) // 2\n    print(ops)\n        \n        \n", "for _ in range (int(input())):\n    a,b=map(int,input().split())\n    s=input()\n    n=len(s)\n    j=0\n    while j<n and s[j]=='0':\n        j+=1\n    c=0\n    r=a\n    if j==n:\n        r=0\n    damp=0\n    for i in range(j,n):\n        if s[i]=='1':\n            if damp>0:\n                r+=min(a,damp*b)\n            damp=0\n        else:\n            damp+=1\n        #print(damp,r)\n    print(r)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\ndef calc(n, k, A):\n    X = [[0] * 26 for _ in range((k+1)//2)]\n    for i, a in enumerate(A):\n        j = i % k\n        j = min(j, k-1-j)\n        X[j][a] += 1\n    return sum([sum(x) - max(x) for x in X])\n\nT = int(input())\nfor _ in range(T):\n    N, K = list(map(int, input().split()))\n    S = [ord(a) - 97 for a in input()]\n    print(calc(N, K, S))\n\n", "import sys\nimport math\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef SI():\n\treturn sys.stdin.readline().strip()\nt = II()\nfor q in range(t):\n\tn = II()\n\ta = LI()\n\td = [0]*n\n\ts = 0\n\tfor i in range(n):\n\t\ts+=a[i]\n\t\td[i] = s\n\tans = min(d)\n\tif ans>0:\n\t\tans = 0\n\tprint(-ans)\n", "for _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    if len(set(arr)) > k:\n        print(-1)\n    else:\n        result = []\n        temp = list(set(arr))\n        for i in range(1, n + 1):\n            if len(temp) == k:\n                break\n            if i not in temp:\n                temp.append(i)\n                \n        for i in range(len(arr)):\n            result.extend(temp)\n        print(len(result))\n        print(*result)\n        \n", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [0] * (n + 1)\n    def inc():\n        for i in range(n - 1):\n            if a[i] > a[i + 1]:\n                return False\n        return True\n    def calc():\n        for i in range(n + 1):\n            c[i] = 0\n        for i in a:\n            c[i] += 1\n        for i in range(n + 1):\n            if not c[i]:\n                return i\n        return n + 1\n    ans = []\n    while not inc():\n        x = calc()\n        if x >= n:\n            y = 0\n            while y < n and a[y] == y:\n                y += 1\n            a[y] = x\n            ans.append(y)\n        else:\n            a[x] = x\n            ans.append(x)\n    print(len(ans))\n    print(*map(lambda x: x + 1, ans))\n\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\n\nreadline = sys.stdin.readline\nread = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    n, k = nm()\n    mini = [tuple(nl() + [i+1]) for i in range(n)]\n    mini.sort(key = lambda x: x[1])\n    # print(mini)\n    dp = [-1]*(k+1)\n    dp[0] = 0\n    f = [[0]*(k+1) for _ in range(n)]\n    for i in range(n):\n        if dp[k] > 0:\n            dp[k] += (k - 1) * mini[i][1]\n        for j in range(k-1, -1, -1):\n            if dp[j] >= 0:\n                if dp[j+1] < dp[j] + mini[i][0] + j * mini[i][1]:\n                    dp[j+1] = dp[j] + mini[i][0] + j * mini[i][1]\n                    f[i][j+1] = 1\n                dp[j] += (k - 1) * mini[i][1]\n    \n    cx = k\n    a = list()\n    b = list()\n    for i in range(n-1, -1, -1):\n        if f[i][cx]:\n            a.append(mini[i][2])\n            cx -= 1\n        else:\n            b.append(mini[i][2])\n    com = list()\n    for x in a[:0:-1]:\n        com.append(x)\n    for x in b:\n        com.append(x)\n        com.append(-x)\n    com.append(a[0])\n    print(len(com))\n    print(*com)\n    return\n\nT = ni()\nfor _ in range(T):\n    solve()", "import math\n\nt=int(input())\n\nwhile(t):\n\tt-=1\n\tn=int(input())\n\n\tang= math.pi/(2*n)\n\n\tans= 1/math.sin(ang)\n\tprint(ans*math.cos(ang/2))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n % 4 == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "import sys\ninput = sys.stdin.readline\n\nQ = int(input())\nfor _ in range(Q):\n    N = int(input())\n    X = []\n    ne = [0] * 3\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        X.append((a, b))\n        if i == 0:\n            ne = [0, b, b*2]\n            continue\n        Y = ne\n        ne = [1<<100] * 3\n        if X[i][0] != X[i-1][0]: ne[0] = min(ne[0], Y[0])\n        if X[i][0] != X[i-1][0]+1: ne[0] = min(ne[0], Y[1])\n        if X[i][0] != X[i-1][0]+2: ne[0] = min(ne[0], Y[2])\n        if X[i][0]+1 != X[i-1][0]: ne[1] = min(ne[1], Y[0] + b)\n        if X[i][0]+1 != X[i-1][0]+1: ne[1] = min(ne[1], Y[1] + b)\n        if X[i][0]+1 != X[i-1][0]+2: ne[1] = min(ne[1], Y[2] + b)\n        if X[i][0]+2 != X[i-1][0]: ne[2] = min(ne[2], Y[0] + b * 2)\n        if X[i][0]+2 != X[i-1][0]+1: ne[2] = min(ne[2], Y[1] + b * 2)\n        if X[i][0]+2 != X[i-1][0]+2: ne[2] = min(ne[2], Y[2] + b * 2)\n        \n    print(min(ne))\n", "import sys\ninput = sys.stdin.readline\n\nQ=int(input())\nfor testcases in range(Q):\n    n,m=list(map(int,input().split()))\n\n    MAP=[list(input().strip()) for i in range(n)]\n\n    R=[MAP[i].count(\"*\") for i in range(n)]\n    C=[]\n    \n    for j in range(m):\n        M=[MAP[i][j] for i in range(n)]\n        C.append(M.count(\"*\"))\n\n    ANS=float(\"inf\")\n\n    for i in range(n):\n        for j in range(m):\n            if MAP[i][j]==\"*\":\n                ANS=min(ANS,n+m-R[i]-C[j])\n            else:\n                ANS=min(ANS,n+m-R[i]-C[j]-1)\n\n    print(ANS)\n                \n    \n", "from sys import stdin, stdout\nimport math\nimport bisect\n\ndef gcd(a,b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\ndef solve(n):\n    dv = [n]\n    x = 2\n    while x*x <= n:\n        if n%x == 0:\n            dv.append(x)\n            if x != n//x:\n                dv.append(n//x)\n        x += 1\n    dv = sorted(dv)\n    ans = [0]*len(dv) \n\n    ans[0], ans[-1] = dv[0], dv[-1]\n    seen = {dv[0], dv[-1]}\n    cur_prime = dv[0]\n    min_prime = dv[0]\n    while len(seen) < len(dv):\n        for x in dv:\n            if x in seen: continue\n            if min_prime == -1:\n                min_prime = x\n\n            if cur_prime == -1:\n                if ans[len(seen)-2]%x == 0:\n                    cur_prime = x\n                    ans[len(seen)-1] = x\n                    seen.add(x)\n            else:\n                if x%cur_prime == 0:\n                    ans[len(seen)-1] = x\n                    seen.add(x)\n        if cur_prime == -1:\n            cur_prime = min_prime\n        else:\n            cur_prime = -1\n        min_prime = -1\n    cnt = 0\n    for i in range(1, len(ans)):\n        if gcd(ans[i], ans[i-1]) == 1:\n            cnt += 1\n    print(\" \".join(map(str, ans)))\n    print(cnt)\n\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    solve(n)\n\n#for i in range(2, 50):\n#    solve(i)\n", "def g( a , b ):\n    cur = 1\n    res = 0\n    ze = 0\n    while cur <= b:\n        if b & cur:\n            b ^= cur\n            if a & b == 0:\n                res += ( 1 << ze )\n        if a & cur == 0:\n            ze = ze + 1\n        cur <<= 1\n    return res\n\ndef f( a , b ):\n    res = 0\n    if a == b:\n        return 0\n    if a == 0:\n        return 2 * b - 1 + f( 1 , b )\n    if a & 1:\n        res = res + 2 * ( g( a , b ) - g( a , a ) )\n        a = a + 1\n    if b & 1:\n        res = res + 2 * ( g( b - 1 , b ) - g( b - 1 , a ) )\n    return 3 * f( a >> 1 , b >> 1 ) + res\n\nt = int(input())\n\nwhile t > 0:\n    t = t - 1\n    l , r = map(int , input().split())\n    print( f( l , r + 1 ) )", "q = int(input())\nfor rwere in range(q):\n\ta = input()\n\tb = input()\n\tc = input()\n\tn = len(a)\n\tdasie = True\n\tfor i in range(n):\n\t\tif c[i] == a[i] or c[i] == b[i]:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdasie = False\n\tif dasie:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")", "t=int(input())\nfor t in range(t):\n\tn=int(input())\n\ta=[int(x) for x in input().split(' ')]\n\ta.reverse()\n\tprint(*a)", "def one():\n    return int(input())\n\n\ndef two():\n    return list(map(int, input().split()))\n\n\ndef lis():\n    return list(map(int, input().split()))\n\n\ndef st():\n    return input()\n\n\nfor _ in range(one()):\n    x, y, a, b = list(map(int, input().split()))\n    d = y - x\n    if d%(a+b)==0:\n        print(d//(a+b))\n    else:\n        print(-1)\n", "def solve():\n    s = list(map(int, input()))\n    n = len(s)\n    x = int(input())\n    w = [0] * n\n    d = [False] * n\n    for i in range(n):\n        if s[i] == 0:\n            if i - x >= 0:\n                w[i - x] = 0\n                d[i - x] = True\n            if i + x < n:\n                w[i + x] = 0\n                d[i + x] = True\n    for i in range(n):\n        if not d[i]:\n            w[i] = 1\n            d[i] = True\n    t = [0] * n\n    for i in range(n):\n        if i - x >= 0 and w[i - x] == 1:\n            t[i] = 1\n        if i + x < n and w[i + x] == 1:\n            t[i] = 1\n    if s != t:\n        print('-1')\n        return\n    print(''.join(map(str, w)))\nt = int(input())\nfor _ in range(t):\n    solve()", "from math import log2, ceil\n\ndef readGenerator():\n    while True:\n        tokens = input().split(' ')\n        for t in tokens:\n            yield t\n\nreader = readGenerator()\n\ndef readWord():\n    return next(reader)\n\ndef readInt():\n    return int(next(reader))\n\ndef readFloat():\n    return float(next(reader))\n\ndef readLine():\n    return input()\n\ndef solve(a):\n    v0, v1 = 0, 0\n    for i in a:\n        if i == 0:\n            v0 += 1\n        else:\n            v1 += 1\n\n    if v1 > v0:\n        if v1 % 2 != 0:\n            v1 -= 1\n        print(v1)\n        return '1 ' * v1\n    print(v0)\n    return '0 ' * v0\n\n\ntests = readInt()\n\nfor i in range(tests):\n    n = readInt()\n    a = [readInt() for _ in range(n)]\n    print(solve(a))", "from  math import gcd\n\nfor _ in range(int(input())):\n    m,d,w=list(map(int,input().split()))\n    M=min(m,d)\n    W=w//gcd(w,d-1)\n    Q=M//W\n    R=M%W\n    ans=(W-R)*(Q*(Q-1)//2)+R*(Q*(Q+1)//2)\n    print(ans)\n", "n = int(input())\narr = list(map(int, input().split()))\nfor x in arr:\n    if x < 15:\n        print('NO')\n        continue\n    if x % 14 >= 7 or x % 14 == 0:\n        print('NO')\n        continue\n    else:\n        print('YES')\n\n", "for _ in range(int(input())):\n  N = int(input())\n  A = [int(x) for x in input().split()]\n  last = i = j = 1\n  ans = nxt = cur = 0\n  while j < N:\n    while j < N-1 and A[j+1] > A[j]:\n      j += 1\n    if cur == 0:\n      ans += 1\n    nxt += j - i + 1\n    j += 1\n    i = j\n    cur += 1\n    if cur == last:\n      last = nxt\n      nxt = cur = 0\n\n  print(ans)\n", "for t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    lock = list(map(int, input().split()))\n    b = []\n    for i in range(n):\n        if lock[i] == 0:\n            b.append(a[i])\n    b.sort()\n    b=b[::-1]\n    ind = 0\n    for i in range(n):\n        if lock[i] == 0:\n            a[i]=b[ind]\n            ind+=1\n    a=[str(i) for i in a]\n    print(\" \".join(a))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [0] * (n + 2)\n    c = 1\n    d = a[0]\n    ans = [a[0]]\n    b[a[0]] = 1\n    for i in range(1, len(a)):\n        if a[i] == a[i - 1]:\n            while b[c] != 0:\n                c += 1\n            if c > a[i]:\n                ans = -1\n                break\n            else:\n                b[c] = 1\n                ans.append(c)\n        else:\n            ans.append(a[i])\n            b[a[i]] = 1\n    if ans == -1:\n        print(ans)\n    else:\n        print(*ans)\n    \n    \n", "a = int(input())\nfor i in range(a):\n    b = input()\n    c = input()\n    y = 0\n    for i in b:\n        if i in c:\n            y = 1\n        else:\n            pass\n    if  y == 1:\n        print('YES')\n    else:\n        print(\"NO\")", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    memo = {}\n    for i in range(n):\n        memo[a[i]] = i\n    \n    max_num = -1\n    cnt = 0\n    ans = 0\n    for i in range(m):\n        if max_num < memo[b[i]]:\n            ans += 2 * (memo[b[i]] - cnt) + 1\n            max_num = memo[b[i]]\n            cnt += 1\n        else:\n            ans += 1\n            cnt += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n, u = map(int, input().split())\n    a = list(map(int, input().split()))\n    k=u//2\n    p = [-1 for i in range(n)]\n    if u%2!=0:\n        for i in range(n):\n            if a[i]<=k:\n                p[i]=0\n            else:\n                p[i]=1\n    else:\n        x=0\n        for i in range(n):\n            if a[i]<k:\n                p[i]=0\n            elif a[i]>k:\n                p[i]=1\n            elif a[i]==k:\n                if x==0:\n                    p[i]=0\n                    x=1\n                else:\n                    p[i]=1\n                    x=0\n    print(*p)", "#JMD\n#Nagendra Jha-4096\n\n \nimport sys\nimport math\n\n#import fractions\n#import numpy\n \n###File Operations###\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\n###Defines...###\nmod=1000000007\n \n###FUF's...###\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n \n \n \n##### Main ####\nt=int(input())\nfor tt in range(t):\n    n=int(input())\n\n    if n==1:\n        print(-1)\n    else:\n        s=\"2\"\n        for i in range(n-1):\n            s+='3'\n        print(s)\n    #n,k,s= map(int, sys.stdin.readline().split(' '))\n    #a=list(map(int,sys.stdin.readline().split(' ')))\n    \n    \n#####File Operations#####\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()", "from string import ascii_uppercase\n\na = ascii_uppercase\nN = int(input())\n\nfor i in range(N):\n    me, comp = input().split(' ')\n    # Want to maximize the lexicographic swap\n    best = ''.join(sorted(me))\n    # print(best)\n\n    mismatch = -1\n    for index, pair in enumerate(zip(best, me)):\n        i, j = pair\n        if i != j:\n            mismatch = index\n            break\n    \n    if mismatch != -1:\n        # Want to swap mismatch (index) with last occurence after mismatch\n        swaploc = len(me) - me[mismatch+1:][::-1].find(best[mismatch]) - 1\n        swap1 = me[:mismatch] + me[swaploc] + me[mismatch+1:swaploc] + me[mismatch] + me[swaploc+1:]\n    else:\n        swap1 = me\n    if swap1 < comp:\n        print(swap1)\n    else:\n        print('---')", "n=int(input())\nwhile n:\n    n-=1\n    l=list(map(int,input().split()))\n    if sum(l)//3 < min(l[0],l[1]):\n        print(sum(l)//3)\n    else:\n        print(min(l[0],l[1]))", "from itertools import groupby as gb\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    if s.count('10') == 0:\n        print(s)\n        continue\n    res = \"\"\n    suf = \"\"\n    l = [(k, len(list(v))) for k, v in gb(s)]\n    if len(l) > 0 and l[0][0] == '0':\n        res += l[0][0] * l[0][1]\n        l = l[1:]\n    if len(l) > 0 and l[-1][0] == '1':\n        suf = l[-1][0] * l[-1][1]\n        l = l[:-1]\n    print(res + '0' + suf)\n", "t=int(input())\nfor _ in range(t):\n    a,b,c=list(map(int,input().split()))\n    a,b,c=sorted([a,b,c])\n    aa=a\n    bb=b\n    cc=c\n    d=c-b\n    c-=min(d,a)\n    a-=min(a,d)\n    b-=min(a//2,0)\n    a-=min(a//2,0)\n    c-=min(a,0)\n    a-=min(a,0)\n    b,c=sorted([b,c])\n    c-=b\n    b=0\n    print((aa+bb+cc-c)//2)\n", "import os\nfrom io import BytesIO\n\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfor i in range(int(input())):\n    a, b, c, r = list(map(int, input().split()))\n    a, b = min(a, b), max(a, b)\n    left = max(c - r, a)\n    right = min(c + r, b)\n    if right >= a and left <= right:\n        print(b - a - (right - left))\n    else:\n        print(b - a)\n", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = str(n)\n    ans = (len(s) - 1) * 9\n    for j in range(1, 10):\n        if int(str(j) * len(s)) <= n:\n            ans += 1\n        else:\n            break\n    print(ans)", "t=int(input())\nfor q in range(t):\n\tn,m=[int(i) for i in input().split()]\n\ta=[[int(j) for j in input().split()] for i in range(n)]\n\trow=[False for i in range(n)]\n\tcol=[False for i in range(m)]\n\tnr,nc=0,0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif a[i][j]==1:\n\t\t\t\tif not row[i]:\n\t\t\t\t\trow[i]=True\n\t\t\t\t\tnr+=1\n\t\t\t\tif not col[j]:\n\t\t\t\t\tcol[j]=True\n\t\t\t\t\tnc+=1\n\tt=min(n-nr,m-nc)\n\tres=\"Vivek\" if t%2==0 else \"Ashish\"\n\tprint(res)\n", "import sys\n\n\n\ndef bestval(pp, cc):\n    # print(\"BESTVAL:\")\n    # print(pp)\n    # print(cc)\n    k = len(pp)\n    k_2 = k//2+1\n    for f in range(1, k_2):\n        if k % f == 0:\n            for offs in range(f):\n                \n                good = True\n                num = cc[offs]\n                # print(f\"{f}, {offs}, {num}: \")\n                upp = (k//f)//2+1\n                for j in range(1, upp):\n                    v1 = f*j \n                    v2 = k - v1 + offs\n                    v1 += offs\n                    # print(pp[v1], pp[v2])\n                    if cc[v1] != num or cc[v2] != num:\n                        good = False\n                        break\n                if good:\n                    return f\n    return k\n\n\n\nfor q in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    p = [int(j)-1 for j  in sys.stdin.readline().split()]\n    c = [int(j)-1 for j  in sys.stdin.readline().split()]\n    fnd = [0]*n\n    ans = n+1\n    for i in range(n):\n        if not fnd[i]:\n            ppp = [i]\n            ccc = [c[i]]\n            fnd[i] = 1\n            j = p[i]\n            while j != i:\n                fnd[j] = 1\n                ppp.append(j)\n                ccc.append(c[j])\n                j = p[j]\n            # bb = \n            # print(bb)\n            ans = min(ans, bestval(ppp, ccc))\n    sys.stdout.write(str(ans) + '\\n')", "def solve(n,k):\n    s=list(map(int,input().split()))\n    s.sort()\n    ans=0\n    p=s[0]\n    for i in range(1,n):\n        ans+=((k-s[i])//p)\n    print(ans)\n\n\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    solve(n,k)", "T = int(input())\nfor i in range(T):\n    n = int(input())\n    inp=[]\n    temp = []\n    for j in range(n):\n        a,b = [int(u) for u in input().split()]\n        inp.append([a,b])\n        temp.append([a,b])\n    inp.sort()\n    check=0\n    begin = inp[0][0]\n    end = inp[0][1]\n    for j in range(n):\n        if(inp[j][0]>end):\n            check=1\n            break\n        if(inp[j][1]>end):\n            end = inp[j][1]\n    ans = []\n    if(check==0):\n        print(-1)\n    else:\n        for j in range(n):\n            if(temp[j][0]>=begin and temp[j][1]<=end):\n                ans.append(\"1\")\n            else:\n                ans.append(\"2\")\n        print(\" \".join(ans))\n", "t = int(input())\nfor _ in range(t):\n    a, b, c, d = list(map(int, input().split()))\n    possible = ['Ya', 'Ya', 'Ya', 'Ya']\n    if (a+b)%2 == 0:\n        possible[0] = 'Tidak'\n        possible[1] = 'Tidak'\n    else:\n        possible[2] = 'Tidak'\n        possible[3] = 'Tidak'\n    if (a+d) == 0:\n        possible[0] = 'Tidak'\n        possible[3] = 'Tidak'\n    if (b+c) == 0:\n        possible[1] = 'Tidak'\n        possible[2] = 'Tidak'\n\n    print(' '.join(possible))\n", "for nt in range(int(input())):\n\tn=int(input())\n\tl=list(map(int,input().split()))\n\tpoint = -1\n\tfor i in range(n):\n\t\tif l[i]<i:\n\t\t\tpoint = i-1\n\t\t\tbreak\n\tif point == -1:\n\t\tprint (\"Yes\")\n\telse:\n\t\tflag=0\n\t\tfor i in range(n-1,point-1,-1):\n\t\t\tif l[i]<(n-1-i):\n\t\t\t\tflag=1\n\t\t\t\tprint (\"No\")\n\t\t\t\tbreak\n\t\tif flag==0:\n\t\t\tprint (\"Yes\")", "import math\nt = int(input())\nM2 = [1]\nfor i in range(35):\n    M2.append(M2[-1]*2)\nfor i in range(t):\n    n, m = map(int,input().split())\n    A = list(map(int,input().split()))\n    if sum(A) < n:\n        print(-1)\n    else:\n        B = [0] * 33\n        for i in range(m):\n            B[int(math.log2(A[i]))] += 1\n        # print(B[:10])\n        C = [0] * 33\n        nn = n\n        for i in range(33):\n            C[i] = nn%2\n            nn//=2\n            if nn==0:\n                break\n        # print(C)\n        b = 0\n        c = 0\n        i = 0\n        ans = 0\n        ok = 0\n        while i < len(B):\n            while i < len(B) and b >= c:\n                b += B[i] * M2[i]\n                c += C[i] * M2[i]\n                B[i]=0\n                i += 1\n            if i == len(B) and b >= c:\n                print(ans)\n                ok = 1\n                break\n            else:\n                i-=1\n                while B[i] == 0:\n                    i += 1\n                    ans += 1\n                    # print(\"ansplus\",i)\n                B[i] -= 1\n                b=0\n                c=0\n            if ok==1:\n                break", "#!/usr/bin/env python\n# coding:utf-8\n# Copyright (C) dirlt\n\nfrom sys import stdin\n\n\ndef run(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n    # print(acc)\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                # print(x, y, k, zero, k * k - zero)\n                res += min(zero, k * k - zero)\n        # print(k, res)\n        ans = min(ans, res)\n    print(ans)\n\n\ndef main():\n    n, m = [int(x) for x in stdin.readline().split()]\n    pixels = []\n    for i in range(n):\n        pixels.append(stdin.readline().strip())\n    run(n, m, pixels)\n\n\ndef __starting_point():\n    import os\n\n    if os.path.exists('tmp.in'):\n        stdin = open('tmp.in')\n    main()\n\n__starting_point()", "for _ in range(int(input())):\n    a, b = list(map(int, input().split()))\n    a = abs( a - b )\n    c = a // 5\n    a -= c * 5\n    print( c + a // 2 + a % 2 )\n", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nANS = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    m = int(input())\n    ps = [list(map(int, input().split())) for _ in range(m)]\n    p = [0] * (n+1)\n    for i in range(m):\n        p[ps[i][1]] = max(p[ps[i][1]], ps[i][0])\n    for i in range(n)[::-1]:\n        p[i] = max(p[i], p[i + 1])\n    if p[1] < max(a):\n        ANS.append(-1)\n        continue\n    ans = 0\n    mx = 0\n    cnt = 0\n    i = 0\n    for x in a:\n        cnt += 1\n        mx = max(mx, x)\n        if p[cnt] < mx:\n            ans += 1\n            mx = x\n            cnt = 1\n    if cnt:\n        ans += 1\n    ANS.append(ans)\n\nprint('\\n'.join(map(str, ANS)))\n", "for nt in range(int(input())):\n\tn=int(input())\n\tl=list(map(int,input().split()))\n\ts=sum(l)\n\te=l[0]\n\tfor i in range(1,n):\n\t\te=e^l[i]\n\tif s==2*e:\n\t\tprint(0)\n\t\tprint ()\n\telse:\n\t\tprint(2)\n\t\tprint(e,s+e)\n", "import sys as _sys\n\n\ndef main():\n    t = int(input())\n    for i_t in range(t):\n        \n        rows_n, columns_n = _read_ints()\n        rows = [tuple(_read_ints()) for i_row in range(rows_n)]\n        columns = [tuple(_read_ints()) for i_column in range(columns_n)]\n        \n        any_first_column_element = rows[0][0]\n        \n        i_first_column = 0\n        while any_first_column_element not in columns[i_first_column]:\n            i_first_column += 1\n        first_column = columns[i_first_column]\n        \n        # Can be written in O(N*log(N)) but it is not necessary for N <= 500\n        rows = sorted(rows, key=lambda row: first_column.index(row[0]))\n        \n        for row in rows:\n            print(*row)\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split()))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "t=int(input())\nfor _ in range(t):\n  n,x=map(int,input().split())\n  a=list(map(int,input().split()))\n  a.sort()\n  a.reverse()\n  count=0\n  ans=0\n  for i in range(n):\n    count+=1\n    if count*a[i]>=x:\n      ans+=1\n      count=0\n  print(ans)", "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  ab = [list(map(int,input().split())) for i in range(n-1)]\n  graph = [[] for i in range(n+1)]\n  deg = [0]*(n+1)\n  for a,b in ab:\n    graph[a].append(b)\n    graph[b].append(a)\n    deg[a] += 1\n    deg[b] += 1\n  pnt = [max(deg[i]-1,1) for i in range(n+1)]\n  root = 1\n  stack = [root]\n  dist = [0]*(n+1)\n  dist[root] = pnt[root]\n  while stack:\n    x = stack.pop()\n    for y in graph[x]:\n      if dist[y] == 0:\n        dist[y] = dist[x]+pnt[y]\n        stack.append(y)\n  far = dist.index(max(dist))\n  root = far\n  stack = [root]\n  dist = [0]*(n+1)\n  dist[root] = pnt[root]\n  while stack:\n    x = stack.pop()\n    for y in graph[x]:\n      if dist[y] == 0:\n        dist[y] = dist[x]+pnt[y]\n        stack.append(y)\n  print(max(dist))", "def main():\n    from sys import stdin, stdout\n    for _ in range(int(stdin.readline())):\n        n, m = list(map(int, stdin.readline().split()))\n        n += 1\n        m += 1\n        div, mod = divmod(n, m)\n        stdout.write(f'{(n ** 2 - div ** 2 * (m - mod) - (div + 1) ** 2 * mod) // 2}\\n')\n\n\nmain()\n", "for nt in range(int(input())):\n\tn=int(input())\n\tl=list(map(int,input().split()))\n\tif n==1:\n\t\tprint (abs(l[0]-l[1]))\n\t\tcontinue\n\tl.sort()\n\tprint (abs(l[n]-l[n-1]))", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        min = 0\n        window = 0\n        all = 0\n        for i in range(n):\n            window += cardPoints[i]\n            all += cardPoints[i]\n        min = window\n        # print(all)\n\n        for x in range(k):\n            # print(x)\n            y = x+n\n            all += cardPoints[y]\n            window -= cardPoints[x]\n            window += cardPoints[y]\n            if window < min:\n                min = window\n        return all - min\n        # print(all)\n        # print(all-min)\n", "from functools import lru_cache\nclass Solution:\n    def numMusicPlaylists(self, N, L, K):\n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            ans = dp(i-1, j-1) * (N-j+1)\n            ans += dp(i-1, j) * (j-min(K, i-1))\n            return ans % (10**9+7)\n\n        return dp(L, N)\n            \n            \n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: bool\n         \"\"\"\n         if not nums:\n             return False\n         l, r = 0, len(nums)-1\n         while l < r:\n             mid = (l + r) // 2\n             if nums[mid] == target:\n                 return True\n             if nums[mid] < nums[r]:\n                 if nums[mid] < target <= nums[r]:\n                     l = mid + 1\n                 else:\n                     r = mid - 1\n             elif nums[mid] > nums[r]:\n                 if nums[l] <= target < nums[mid]:\n                     r = mid - 1\n                 else:\n                     l = mid + 1\n             else:\n                 r -= 1\n         return nums[l] == target", "class Solution:\n     def superPow(self, a, b):\n         \"\"\"\n         :type a: int\n         :type b: List[int]\n         :rtype: int\n         \"\"\"\n         # return pow(a, int(''.join(map(str, b))), 1337)\n         from functools import reduce\n         k=reduce(lambda x,y:x*10+y, b)\n         # print(k)\n         # return pow(a,k)%1337\n         return pow(a, k, 1337)", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        start = 0\n        end = minSize\n        counts = {}\n        res = 0\n        \n        while start <= len(s)-minSize:\n            item = s[start:end]\n            counts[item] = counts.get(item, 0) + 1\n            \n            start += 1\n            end += 1\n            \n        for i in counts:\n            if self.countUnique(i) <= maxLetters:\n                res = max(res, counts[i])\n                  \n        return res\n        \n    def countUnique(self, s):\n        return len(set(s))", "class Solution:\n    def profitableSchemes(self, G: int, P: int, groups: List[int], profits: List[int]) -> int:\n        dp = [[0] * (P+1) for i in range(0,G+1)]\n        for i in range(0, G+1):\n            dp[i][0] = 1\n        N = len(groups)\n        l = []\n        for i in range(0, N):\n            l.append((groups[i], profits[i]))\n        l.sort()\n        \n        for i in range(0, N):\n            group, profit = l[i]\n            if group > G:\n                break\n            for j in range(G, group - 1, -1):\n                gremain = j - group\n                for k in range(P, -1, -1):\n                    dp[j][k] += dp[gremain][max(k - profit, 0)]\n                    dp[j][k] %= (10**9 + 7)\n                \n        return dp[G][P]", "class Solution:\n     def calculate(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         total, tmp, sign = 0, 0, 1\n         numStack = []\n         signStack = []\n         for c in s:\n             if c == '+':\n                 total, tmp, sign = total + tmp*sign, 0, 1\n             elif c == '-':\n                 total, tmp, sign = total + tmp*sign, 0, -1\n             elif c == '(':\n                 numStack.append(total)\n                 signStack.append(sign)\n                 total, tmp, sign = 0, 0, 1\n             elif c == ')':\n                 total += tmp * sign\n                 total, tmp, sign = total * signStack.pop() + numStack.pop(), 0, 1\n             elif '0' <= c <= '9':\n                 tmp = tmp * 10 + ord(c) - ord('0')\n             else:\n                 continue\n         return total + tmp * sign", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        curmaxsight = A[0] - 1\n        curmaxpair = 0\n        for sight in A[1:]:\n            if sight + curmaxsight > curmaxpair:\n                curmaxpair = sight + curmaxsight\n            if sight > curmaxsight:\n                curmaxsight = sight\n            curmaxsight -= 1\n        return curmaxpair\n            \n", "MOD = int(1e9 + 7)\n\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        dp = [-1 for _ in s]\n        n = len(s)\n        \n        def recurse(i: int) -> int:\n            if i == n:\n                return 1\n            \n            if dp[i] != -1:\n                return dp[i]\n            \n            result = 0\n            val = 0\n            for j in range(i, n):\n                val = 10 * val + (ord(s[j]) - ord('0'))\n                if val > k:\n                    break\n                elif j == n - 1 or s[j + 1] != '0':\n                    result = (result + recurse(j + 1)) % MOD\n            dp[i] = result\n            return result\n        \n        return recurse(0)\n                \n    \n\n", "from sys import maxsize\nfrom collections import Counter\nclass Solution:\n    def balancedString(self, s):\n        n = len(s)\n        right = 0\n        chars = Counter(s)\n        res = maxsize\n        for left in range(n):\n            while right <= n - 1 and any(chars[c] > n // 4 for c in 'QWER'):\n                chars[s[right]] -= 1\n                right += 1\n            if all(chars[c] <= n // 4 for c in 'QWER'):\n                res = min(res, right - left)\n            chars[s[left]] += 1\n        return res      ", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        N = str(N)\n        \n        @lru_cache(None)\n        def dfs(i, r, m):\n            if i == len(N):\n                return 1\n            \n            ans = 0\n            limit = int(N[i]) if r else 9\n            for k in range(0,limit+1):\n                if m & (1 << k) == 0:\n                    mask =  m | (1 << k) if m or k > 0 else 0\n                    if k < limit or not r:\n                        ans += dfs(i+1, False, mask)\n                    else:\n                        ans += dfs(i+1, True, mask)\n            return ans\n        \n        return int(N) - dfs(0, True, 0) + 1", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        push = []\n        i = 0\n        while popped:\n            if i < len(pushed):\n                push += [pushed[i]]\n            while push and push[-1] == popped[0]:\n                popped.pop(0)\n                push.pop()\n            # print(push)\n            # print(popped)\n            if i < len(pushed):\n                i += 1\n            else:\n                return False\n        return True", "class Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        # Pad with inf to make implementation easier\n        INF = -10_000\n        n = len(grid)\n\n        total = 0\n        max_rows = [max(row, default=INF) for row in grid]\n        # Transpose the grid to make max less cumbersome\n        max_cols = [max(col, default=INF) for col in zip(*grid)]\n\n        for i, best_row in enumerate(max_rows):\n            for j, best_col in enumerate(max_cols):\n                new_height = min(best_row, best_col)\n                total += new_height - grid[i][j]\n\n        return total\n", "class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        tot = 0\n        \n        b = bin(n)[2:]\n        if b[1] == '0':\n            tot += 2**(len(b)-2)\n            \n        lastChanged = b[1] == '0'\n        for i in range(2,len(b)):\n            if (lastChanged and b[i] == '0') or (not lastChanged and b[i] == '1'):\n                tot += 2**(len(b)-1-i)\n                lastChanged = True\n            else:\n                lastChanged = False\n        \n        return tot + 1 + self.minimumOneBitOperations(int('1' + '0'*(len(b)-2),2))\n", "class Solution:\n    def getMaxLen(self, nums):\n        n = len(nums)\n        pos, neg = 0, 0\n        res = 0\n        for i in range(n):\n            if nums[i] > 0:\n                pos, neg = 1 + pos, 1 + neg if neg else 0\n            elif nums[i] < 0:\n                pos, neg = 1 + neg if neg else 0, 1 + pos\n            else:\n                pos, neg = 0, 0\n            res = max(res, pos)\n        return res  ", "class Solution:\n    def minDeletionSize(self, A):\n        m, n = len(A), len(A[0])\n        first = [-1] * m\n        res = 0\n        for j in range(n):\n            for i in range(1, m):\n                if first[i] == -1 and A[i][j] < A[i - 1][j]:\n                    res += 1\n                    break\n            else:\n                for i in range(1, m):\n                    if A[i][j] > A[i - 1][j] and first[i] == -1:\n                        first[i] = j\n        return res        ", "class Solution:\n     def findMaximumXOR(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         ans = 0\n         for bit in range(31, -1, -1) :\n             ans = (ans << 1) + 1\n             pre = set()\n             for n in nums :\n                 p = (n >> bit) & ans\n                 if p in pre :\n                     break\n                 pre.add(ans - p)\n             else :\n                 ans -= 1\n         return ans", "class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        l = len(people)\n        if (l <= 1):\n            return(1)\n#        people = self.sortPeople(people)\n        people.sort()\n        i = 0; j = l-1; c = 0\n        while i < j:\n            print((i,j,c))\n            if people[i] + people[j] <= limit:\n                c +=1\n                i +=1\n                j -=1\n            else:\n                j -=1\n                c +=1\n        if i == j:\n            c +=1\n        return(c)\n        \n        \n        \n        \n    def sortPeople(self, arr):\n   #     print(arr)\n        l = len(arr)\n        if l <= 1:\n            return(arr)\n        pivot = arr[l-1]\n        larr = [];rarr = []\n        \n        for i in range(l-1):\n            if arr[i] >= pivot:\n                rarr.append(arr[i])\n            else:\n                larr.append(arr[i])\n       # print(larr + [pivot] + rarr)\n        return(self.sortPeople(larr) + [pivot] + self.sortPeople(rarr))\n        \n", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def isSub(s1, s2):\n             it = iter(s2)\n             return all(i in it for i in s1)\n         keep, max1, N = False, -1, len(strs)\n         mask = [True]*N\n         for i in range(N):\n             for j in range(N):\n                 # need to update the condition to see whether it is substring of it.\n                 # because \"abc\" is a subsequence of \"aabbcc\", so it is different with substring...okay, make sense now\n                 if i != j and isSub(strs[i],strs[j]):\n                     mask[i] = False\n                     break\n         for i in range(N):\n             if mask[i]:\n                 max1 = max(max1,len(strs[i]))\n         return max1\n", "class Solution:\n    def totalFruit(self, s: List[int]) -> int:\n        m=0\n        arr={}\n        i=0\n        k=2\n        for j in range(len(s)):\n            if s[j] not in arr:\n                arr[s[j]]=0\n            arr[s[j]]+=1\n            while len(arr)>k:\n                x=s[i]\n                arr[x]-=1\n                if arr[x]==0:\n                    arr.pop(x)\n                i+=1\n            m=max(m,j-i+1)\n        return m", "class Solution:\n     def minSteps(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         def factors(n):\n             d = 2\n             while d * d <= n:\n                 while n % d == 0:\n                     n /= d\n                     yield d\n                 d += 1\n             if n > 1:\n                 yield n\n \n         return int(sum(factors(n)))\n             \n             \n     \n", "class Solution:\n     def judgePoint24(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         bad = '\u5bf9\u6492\u5258\u52a5\u571e\u525c\u528f\u54f1\u63b6\u687a\u6cdb\u63cb\u63b5\u5f93\u525f\u5263\u5f6b\u5be3\u6c61\u60ab\u58db\u6884\u750f\u548d\u54f2\u6c6d\u5264\u5827\u70b9\u534b\u5b1e\u52c6\u53db\u6c6c\u6cd0\u5875\u680b\u529a\u56ae\u5483\u5ba0\u5416\u5257\u6957\u56e7\u529b\u687b\u650b\u58ef\u52af\u55cf\u6879\u5299\u5262\u525a\u7127\u556b\u6815\u70b8\u682b\u6816\u56b2\u5f73\u525b\u6491\u70c3\u6d3f\u5b8b\u6c77\u5f72\u5259\u63c1\u59b7\u57fb\u64a7\u6c62\u5429\u58d9\u5287\u526d\u57fc\u5415\u525d\u6c63\u656f\u6187\u52c7\u5265\u548e\u56fb\u5313'\n         return chr(int(''.join(map(str, sorted(nums)))) + 19968) not in bad", "class Solution:\n     def decodeString(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n         if len(s) == 0:\n             return \"\"\n         idx = 0\n         while s[idx].isdigit():\n             idx += 1\n         if idx > 0:\n             k = int(s[:idx])\n             idx += 1\n             idx_from = idx\n             bracket_count = 1\n             while bracket_count > 0:\n                 if s[idx] == \"[\":\n                     bracket_count += 1\n                 elif s[idx] == \"]\":\n                     bracket_count -= 1\n                 idx += 1\n             return self.decodeString(s[idx_from:idx-1]) * k + self.decodeString(s[idx:])\n         return s[0] + self.decodeString(s[1:])", "from heapq import *\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        ids = [i for i in range(n)]\n        ids = sorted(ids, key=lambda x: -efficiency[x])\n        max_perf, heap = 0, []\n        sum = 0\n        for i in ids:\n            if len(heap) == k:\n                sum -= heappop(heap)\n            heappush(heap, speed[i])\n            sum += speed[i]\n            max_perf = max(max_perf, sum * efficiency[i])\n        \n        return max_perf % (10 ** 9 + 7)", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        job = sorted(zip(difficulty, profit))\n\n        best = 0 \n        i = 0 \n        profit = 0\n\n        for work in sorted(worker):\n            while (i < len(difficulty) and job[i][0] <= work):\n                best = max(best, job[i][1])\n                i += 1\n            profit += best\n\n        return profit", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        \n        ret = list(s) \n        \n        while True: \n            s = ret\n            ret = []\n            ac = 1\n            for c in s: \n                if not ret or ret[-1] != c: \n                    ac = 1\n                    ret.append(c)\n                else: \n                    if ac + 1 == k: \n                        while ac: \n                            ret.pop()\n                            ac -= 1\n                    else: \n                        ret.append(c)\n                        ac += 1\n                # print(ret, ac)\n            if len(ret) == len(s): \n                break\n                        \n        return ''.join(ret)\n                    \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        a = [A[0]]\n        b = [0 for i in range(len(A))]\n        for i in range(1, len(A)):\n            a.append(max(a[i - 1], A[i]))\n        \n        b[-1] = A[-1]\n        for i in range(len(A) - 2, -1, -1):\n            b[i] = min(b[i + 1], A[i])\n            \n        for i in range(len(A) - 1):\n            if a[i] <= b[i + 1]:\n                return i + 1\n        return -1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # Binary search solution.\n        # https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/794070/Python-Binary-search-solution-with-explanation-and-similar-questions\n        \n        position.sort()\n        \n        def num_balls_placed(tested_distance):\n            num_placed, current = 1, position[0]\n            \n            for i in range(1, len(position)):\n                if position[i] - current >= tested_distance:\n                    current = position[i]\n                    num_placed += 1\n            \n            return num_placed\n        \n        low, high = 0, position[-1] - position[0]\n        best = -1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if num_balls_placed(mid) < m:\n                high = mid - 1\n            else:\n                best = mid\n                low = mid + 1\n                \n        return best", "class Solution:\n     def makesquare(self, nums):\n         s = sum(nums)\n         if not s % 4 == 0:\n             return False\n         l = s // 4\n         from collections import Counter\n         self.c = Counter(nums)\n         for _ in range(4):\n             n = self.f(0, sorted(self.c.elements(),reverse=True), l, ())\n             if not n:\n                 return False\n             self.c.subtract(n)\n         return True\n \n     def f(self, index, keys, sum, nums):\n         if sum == 0:\n             return nums\n         if sum < 0 or index >= len(keys):\n             return None\n         return self.f(index + 1, keys, sum - keys[index], (*nums, keys[index])) \\\n                or self.f(index + 1, keys, sum, nums)", "class Solution:\n    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        mx= max(verticalCuts[0], w - verticalCuts[-1])\n        my = max(horizontalCuts[0], h - horizontalCuts[-1])\n        for i in range(1,len(verticalCuts)):\n            mx=max(mx,verticalCuts[i] - verticalCuts[i - 1])\n        for i in range(1,len(horizontalCuts)):\n            my = max(my, horizontalCuts[i] - horizontalCuts[i - 1])              \n        return mx*my%(10**9+7)", "class Solution: # top-down dp\n    # Time complexity O(ND)\n    # Space complexity O(N) for dp\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * (n+1)\n        stack = []\n        \n        for i, a in enumerate(arr + [float('inf')]):\n            while stack and arr[stack[-1]] < a:\n                L = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[L[0]]:\n                    L.append(stack.pop())\n                for j in L:\n                    if i - j<=d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    if stack and j - stack[-1] <=d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])    ", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        size1, size2 = len(str1), len(str2)\n        Inf = str1 + str2\n        dp = [None] * (size2 + 1)\n        dp[0] = ''\n        for i in range(1, size2 + 1):\n            dp[i] = dp[i-1] + str2[i-1]\n        for i1 in range(1, size1 + 1):\n            newDP = [None] * (size2 + 1)\n            newDP[0] = dp[0] + str1[i1-1]\n            for i2 in range(1, size2 + 1):\n                newDP[i2] = Inf\n                if str1[i1-1] == str2[i2-1]:\n                    newDP[i2] = dp[i2-1] + str1[i1-1]\n                newDP[i2] = min(\n                    newDP[i2],\n                    dp[i2] + str1[i1-1],\n                    newDP[i2-1] + str2[i2-1],\n                    key=len)\n            dp = newDP\n        return dp[-1]", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         m = len(s)\n         n = len(p)\n         starj = -1\n         last_match = -1\n         i = j = 0\n         while i<m:\n             if j<n and (s[i]==p[j] or p[j]=='?'):\n                 i+=1\n                 j+=1\n             elif j<n and p[j]=='*':\n                 starj = j\n                 j += 1\n                 last_match = i\n             elif starj!=-1:\n                 j = starj+1\n                 last_match +=1\n                 i = last_match\n             else:\n                 return False\n         \n         while j<n and p[j]=='*':\n             j+=1\n         return j==n\n                 \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        lsta, lstb = [], []\n        for i in range(len(A)):\n            if A[i] != B[i]:\n                lsta.append(A[i])\n                lstb.append(B[i])\n        A, B = ''.join(lsta), ''.join(lstb)\n        q = deque([(0, A, B)])\n        while q:\n            cost, curr, goal = q.popleft()\n            if not curr:\n                return cost\n            need = goal[0]\n            work = None\n            for i in range(len(curr)):\n                # need to find one where curr[i] == goal[0] and goal[i] == curr[0]\n                if curr[i] == goal[0] and goal[i] == curr[0]:\n                    work = i\n                    break\n            if work:\n                # only swap this one\n                q.append((cost+1, curr[1:work]+curr[work+1:], goal[1:work]+goal[work+1:]))\n            else:\n                for i in range(1, len(curr)):\n                    if curr[i] == need:\n                        q.append((cost+1, curr[1:i]+curr[0]+curr[i+1:], goal[1:]))", "from sortedcontainers import SortedList\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        B = [nums[i] for i in range(len(nums))]\n        store = SortedList()\n        \n        for i in range(len(nums)-1,-1,-1): \n            if len(store) > 0:\n                if store[-1] > 0:\n                    B[i] += store[-1]\n            \n            \n            store.add(B[i])\n            if len(store) > k:\n                store.remove(B[i+k])\n\n        return max(B)", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        prefix = list(itertools.accumulate(piles))\n        \n        @lru_cache(maxsize=None)\n        def getScore(i, j):\n            if i > j:\n                return 0\n            \n            stones = float('-inf')\n            prev = prefix[i - 1] if i - 1 >= 0 else 0\n            stones = max(stones, prefix[j] - prev - getScore(i + 1, j))\n            stones = max(stones, prefix[j] - prev - getScore(i, j - 1))\n            return stones\n            \n        alex_score = getScore(0, len(piles) - 1)\n        if alex_score > prefix[-1] - alex_score:\n            return True\n        return False", "class Solution:\n     def isValidSerialization(self, preorder):\n         \"\"\"\n         :type preorder: str\n         :rtype: bool\n         \"\"\"\n         arr = preorder.split(',')\n         k = len(arr)\n         for _ in range(k):\n             print(arr)\n             if arr==['#']:\n                 return True\n             newArr = []\n             i = 0\n             while i < len(arr):\n                 if i < len(arr)-2 and arr[i].isdigit() and arr[i+1:i+3] == ['#','#']:\n                     newArr += ['#']\n                     i += 3\n                 else:\n                     newArr += [arr[i]]\n                     i += 1\n             arr = newArr\n         return False\n", "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        cache = {}\n        def lcs(i, j):\n            if i == len(text1) or j == len(text2): return 0\n            if (i, j) in cache: return cache[(i, j)]\n            if text1[i] == text2[j]: \n                cache[(i, j)] = 1+lcs(i+1, j+1)\n                return cache[(i, j)]\n            cache[(i, j)] = max(lcs(i+1, j), lcs(i, j+1))\n            return cache[(i, j)]\n        return lcs(0,0)\n            \n", "class Solution:\n     def isSubsequence(self, s, t):\n         if s == \"\":\n             return True\n         s_num = 0\n         temp = s[s_num]\n         for i in t:\n             if i == temp:\n                 s_num = s_num + 1\n                 if s_num >= len(s):\n                     return True\n                 temp = s[s_num]\n         return False\n", "class Solution:\n    def minInteger(self, num: str, k: int) -> str:\n        if k <= 0:\n            return num\n        for i in range(10):\n            ind = num.find(str(i))\n            if 0 <= ind <= k:\n                return str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k - ind)\n        return num", "class Solution:\n     def findLongestWord(self, s, d):\n         \"\"\"\n         :type s: str\n         :type d: List[str]\n         :rtype: str\n         \"\"\"\n         word_dict = collections.defaultdict(list)\n         for i, word in enumerate(d):\n             word_dict[word[0]].append((i, word))\n         \n         res = \"\"\n         for c in s:\n             words_startswithc = word_dict[c]\n             word_dict[c] = []\n             for i, word in words_startswithc:\n                 if len(word)==1: \n                     if len(d[i])==len(res):\n                         res = min(res, d[i])\n                     else: res = d[i] if len(d[i])>len(res) else res\n                 else:\n                     word_dict[word[1]].append((i, word[1:]))\n         return res", "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        stra = '{0:b}'.format(a)\n        strb = '{0:b}'.format(b)\n        strc = '{0:b}'.format(c)\n        n = max(len(stra),len(strb),len(strc))\n        stra = '0' * (n-len(stra)) + stra\n        strb = '0' * (n-len(strb)) + strb\n        strc = '0' * (n-len(strc)) + strc\n        boolA = [s=='1' for s in stra]\n        boolB = [s=='1' for s in strb]\n        boolC = [s=='1' for s in strc]\n        x = 0\n        for i in range(n):\n            A, B, C = boolA[i], boolB[i], boolC[i]\n            if not ((A or B) == C):\n                if A and B:\n                    x += 2\n                else:\n                    x += 1\n        return x\n", "class Solution:\n    # def superEggDrop(self, K: int, N: int) -> int:\n    #     drops = 0\n    #     floors = [0] * (K + 1)\n    #     while floors[K] < N:\n    #         for eggs in range(K, 0, -1):\n    #             floors[eggs] += 1 + floors[eggs - 1]\n    #         drops += 1\n    #     return drops\n\n    def superEggDrop(self, K: int, N: int) -> int:\n            # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n            M = N # big enough number\n            dp = [[0 for j in range(K+1)] for i in range(M+1)]\n            # Initialization 1 --> no move no floor --> dp[0][*] = 0\n            # Initialization 2 --> no egg no floor --> dp[*][0] = 0\n            # General case --> we want to find dp[m][k] --> we pick one egg and drop (1 move)\n            #              --> now we have k or k-1 eggs, depending on whether the previous egg is broken\n            #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n            for i in range(1, M+1):\n                for j in range(1, K+1):\n                    dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n                    if dp[i][j] >= N:\n                        return i", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        odd = 0\n        counts = defaultdict(lambda: 0)\n        \n        for c in s:\n            counts[c] += 1\n            if (counts[c]%2): odd += 1\n            else: odd -= 1\n        \n        if (odd > k or k>len(s)): return False\n        \n        return True", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         https://leetcode.com/problems/integer-break/discuss/80689/A-simple-explanation-of-the-math-part-and-a-O(n)-solution\n         use 3 as many as possible\n         \"\"\"\n         if n < 4:\n             return n - 1\n         ans = 1\n         while n > 4:\n             ans *= 3\n             n -= 3\n         ans *= n\n         return ans\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        peak=0\n        while peak<len(arr)-1 and  arr[peak]<=arr[peak+1]:\n            peak+=1\n        if peak==len(arr)-1:\n            return 0\n        valley=len(arr)-1\n        while valley>0 and  arr[valley]>=arr[valley-1]:\n            valley=valley-1\n        ans=min(valley,len(arr)-peak-1)\n        i=0\n        j=valley\n        while i<=peak and j<len(arr):\n            if arr[j]>=arr[i]:\n                ans=min(ans,j-i-1)\n                i+=1\n            else:\n                j+=1\n        return ans\n        \n            \n                \n                \n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(nums)\n         dp = [[nums[0], nums[0]]] * n\n         ans = nums[0]\n         for i in range(1, n):\n             temp = [dp[i-1][0] * nums[i], dp[i-1][1] * nums[i], nums[i]]\n             dp[i][0], dp[i][1] = max(temp), min(temp)\n             if dp[i][0] > ans:\n                 ans = dp[i][0]\n         return ans", "class Solution:\n    def maxDiff(self, num: int) -> int:\n        if num < 10: return 8\n        a = b = str(num)\n        i = 0\n        while i < len(a):\n            if a[i] == '9':\n                i += 1\n            else:\n                a = a.replace(a[i], '9')\n                break\n\n        if b[0] != '1':\n            b = b.replace(b[0], '1')\n        else:\n            i = 1\n            while i < len(b):\n                if b[i] == '1' or b[i] == '0':\n                    i += 1\n                else:\n                    b = b.replace(b[i], '0')\n                    break\n        #print(a,b)\n        return int(a) - int(b)", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        counter = Counter([num%k for num in arr])\n        return all([counter[i] == counter[k-i] for i in range(1,k//2+1)]) and counter[0] % 2 == 0", "class Solution:\n     def lengthLongestPath(self, input):\n         maxlen = 0\n         pathlen = {0: 0}\n         for line in input.splitlines():\n             name = line.lstrip('\\t')\n             depth = len(line) - len(name)\n             if '.' in name:\n                 maxlen = max(maxlen, pathlen[depth] + len(name))\n             else:\n                 pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n         return maxlen\n", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         if num<3:\n             return num+1\n         if num==3:\n             return num\n         import math\n         bits = int(math.log(num,2))\n         f = [0]*(bits+1)\n         f[0],f[1],f[2] =2,3,4\n         for i in range(3,bits+1):\n             f[i] = f[i-1]+f[i-2]-1\n \n         res = 0\n         pre = 0\n         flag = False\n         for i in range(bits+1):\n             if num&(1<<i):\n                 \n                 if pre:\n                     res = f[i]+f[i-1]-2\n \n                 elif flag:\n                     res = f[i]+res-1\n                 else:\n                     res = f[i]+res\n                     flag = True\n             pre = num&(1<<i)\n             #print(pre)\n         return res\n", "class Solution:\n     def isScramble(self, s1, s2):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :rtype: bool\n         \"\"\"\n         if len(s1) != len(s2):\n             return False\n         if s1 == s2:\n             return True\n         if sorted(s1) != sorted(s2): # prunning\n             return False\n         for i in range(1, len(s1)):\n             if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n             (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\n                 return True\n         return False", "class Solution:\n     def minWindow(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         left=-1\n         right = 0\n         result = \"\"\n         totalMatch = 0\n         d = {}\n         for c in t:\n             d[c] = d.get(c, 0) + 1\n \n         for right in range(len(s)):\n             c = s[right]\n             d[c] = d.get(c, 0) - 1\n \n             # good match\n             if d[c] >=0:\n                 totalMatch +=1\n \n                 #over match \u53ef\u4ee5\u4e0d\u79fb\u52a8left\n                 #total match, need to advance left\n                 if totalMatch == len(t):\n                     totalMatch -= 1\n \n                     left +=1\n                     while d[s[left]]<0:\n                         d[s[left]] += 1\n                         left += 1\n \n                     # we dec the count here so that next round right need to match one more s[left], \n                     d[s[left]] += 1\n \n                     if result == \"\" or len(result) > right - left:\n                         result = s[left: right+1]\n \n         return result", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         import bisect\n         \n         d = [0] * len(nums)\n         \n         maxLen = 0\n         \n         for n in nums:\n           i = bisect.bisect_left(d, n, 0, maxLen)\n           if i == maxLen:\n             maxLen += 1\n           d[i] = n\n         return maxLen", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:    \n        \n        def get_code_len(x):\n            return 1 + len(str(x)) if x > 1 else x\n        \n        n = len(s)\n        dp = [[ n ] * (k + 1) for i in range(n + 1)]\n        dp[0] = [0] * (k + 1)\n        for i in range(n):\n            for j in range(k + 1):\n                if j > 0:\n                    dp[i + 1][j - 1] = min(dp[i+1][j-1], dp[i][j])\n                    \n                deletions = 0\n                for p in reversed(range(i+1)): \n                    if s[p] != s[i]:\n                        deletions += 1\n                    if deletions > j:\n                        break\n                    dp[i+1][j - deletions] = min(dp[i + 1][j - deletions],\n                                          dp[p][j] + get_code_len(i - p - deletions + 1))\n                    \n        return min(dp[n])", "class Solution:\n     def maxProfit(self, prices):\n         if not prices:\n             return 0\n         max_buy = [0]*len(prices)\n         max_sell = [0]*len(prices)\n         max_rest = [0]*len(prices)\n \n         max_buy[0] = -prices[0]\n         max_sell[0] = 0\n         max_rest[0] = 0\n \n         for i in range(1, len(prices)):\n             max_buy[i] = max(max_rest[i-1] - prices[i], max_buy[i-1])\n             max_sell[i] = max(max_buy[i-1] + prices[i], max_sell[i-1])\n             max_rest[i] = max(max_sell[i-1], max_rest[i-1])\n                 \n         return max(max_buy[-1], max_sell[-1], max_rest[-1])\n", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         leftmaxes = []\n         rightmaxes = []\n         \n         maximum = 0\n         for i in range(len(height)):\n             maximum = max(maximum, height[i])\n             leftmaxes.append(maximum)\n             \n             \n         maximum = 0\n         for i in range(len(height)):\n             maximum = max(maximum, height[len(height) - i - 1])\n             rightmaxes.append(maximum)\n         \n         water = 0\n         \n         print(leftmaxes)\n         print(rightmaxes)\n         \n         for i in range(len(height)):\n             trappable = min(leftmaxes[i], rightmaxes[-i-1])\n             if(trappable > height[i]):\n                 water += trappable - height[i]\n         \n         return water\n", "class Solution:\n    def maxDotProduct(self, a: List[int], b: List[int]) -> int:\n        nums1 = [0] + a\n        nums2 = [0] + b\n        m, n = len(nums1), len(nums2)\n        dp = [[float('-inf')] * m for _ in range(n)]\n\n        for i in range(1, n):\n            for j in range(1, m):\n                # if nums1[j] * nums2[i] > 0:\n                dp[i][j] = max(dp[i-1][j-1] + nums1[j] * nums2[i], dp[i][j-1], dp[i-1][j], nums1[j] * nums2[i])\n                # else:\n                    # dp[i][j] = max(dp[i][j-1], dp[i-1][j], nums1[j] * nums2[i])\n        return dp[-1][-1]", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        # Group letters by occurence\n        # Ex: \\\"aaabaaa\\\" -> [['a', 3], ['b', 1], ['a', 3]]\n        groups = []\n        for key, group in itertools.groupby(text):\n            groups.append([key,len(list(group))])\n            \n        # We need a counter to check if we can extend by one letter\n        # Ex: \\\"aaa\\\" in \\\"aaabba\\\" can be extended to \\\"aaaa\\\" because we have another \\\"a\\\" at the end.\n        count = collections.Counter(text)\n        \n        for index in range(len(groups)):\n            # Check if we can merge two groups.\n            # Ex \\\"aaa\\\" and \\\"aa\\\" in aaabaa\\\" can be merged to \\\"aaaaa\\\"\n            if index <= len(groups) - 3: # Make sure to dont go out of bounds\n                # The next groups's length must be 1 to be able to merge\n                if groups[index+1][1] == 1 and groups[index+2][0] == groups[index][0]:\n                    groups[index][1] += groups[index+2][1]\n                    \n            # Length will be extend by 1 if there are more letters in available, as explained above.\n            if count[groups[index][0]] > groups[index][1]:\n                groups[index][1] += 1\n                \n        # Return the maximum length that exists\n        maxlength = 0\n        for group in groups:\n            if group[1] > maxlength:\n                maxlength = group[1]\n        return maxlength", "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        if k >= len(s):\n            return False\n        d = set()\n        num = 0\n        for i in range(k):\n            m = ord(s[i]) - ord('0')\n            num = num * 2 + m\n        d.add(num)\n        #print(num)\n        mask = (1 << (k-1))  - 1\n        #print(mask)\n        for i in range(k, len(s)):\n            num &= mask\n            m = ord(s[i]) - ord('0')\n            num = num * 2 + m\n            d.add(num)\n        #print(len(d))\n        return len(d) >= (1<<k)\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        return self.helper(cost, target, {})\n        \n    def helper(self, cost, target, visited):\n        if target == 0:\n            return ''\n        if target in visited:\n            return visited[target]\n        ans = '0'\n        for i in range(1, 10):\n            if target >= cost[i - 1]:\n                prev = self.helper(cost, target - cost[i - 1], visited)\n                if prev != '0':\n                    curr = str(i) + prev\n                    if len(curr) >= len(ans) and int(curr) > int(ans):\n                        ans = curr\n        visited[target] = ans\n        return ans", "class Solution:\n     def getEnglishThousand(self, n):\n         if 1 <= n <= 9:\n             return ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'][n-1]\n         elif 10 <= n <= 19:\n             return ['Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'][n-10]\n         elif 20 <= n <= 99:\n             eng = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'][(n//10)-2]\n             if n % 10 > 0:\n                 return eng + ' ' + self.getEnglishThousand(n % 10)\n             else:\n                 return eng\n         else:\n             hundred = self.getEnglishThousand(n // 100) + ' Hundred'\n             if n % 100 > 0:\n                 return hundred + ' ' + self.getEnglishThousand(n % 100)\n             else:\n                 return hundred\n \n     def numberToWords(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: str\n         \"\"\"\n         if num == 0:\n             return 'Zero'\n         stack = ['Billion', 'Million', 'Thousand', None]\n         english = []\n         while num:\n             quantifier = stack.pop()\n             if num % 1000 > 0:\n                 english.append(self.getEnglishThousand(num % 1000) + (' ' + quantifier if quantifier else ''))\n             num //= 1000\n         return ' '.join(reversed(english))", "class Solution:\n     def findLength(self, A, B):\n         def check(length):\n             seen = {A[i:i+length]\n                     for i in range(len(A) - length + 1)}\n             return any(B[j:j+length] in seen\n                        for j in range(len(B) - length + 1))\n \n         A = ''.join(map(chr, A))\n         B = ''.join(map(chr, B))\n         lo, hi = 0, min(len(A), len(B)) + 1\n         while lo < hi:\n             mi = int((lo + hi) / 2)\n             if check(mi):\n                 lo = mi + 1\n             else:\n                 hi = mi\n         return lo - 1\n                         \n", "class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        def less(digits, d):\n            return len([i for i in digits if i < d ])\n        \n        cnt = 0\n        ld, ln = len(digits), len(str(n))\n        N = str(n)\n        for i in range(ln-1):\n            cnt += ld ** (i+1)\n        for i in range(ln):\n            cnt += less(digits, N[i]) * (ld ** (ln - i -1) )\n            if N[i] not in digits:\n                return cnt\n        return cnt + 1\n\n\n\n        \n        \n\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        rounds = len(piles) // 3\n        count = 0\n        piles.sort(reverse=True)\n        for i in range(0, 2*rounds, 2):\n            count += piles[i+1]\n        return count\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        d = {}\n        n = len(arr)\n        \n        for a in arr:\n            d[a] = d.get(a,0) + 1\n        \n        val  = sorted(list(d.items()), key = lambda x :x[1])[::-1]\n        \n        count =0\n        \n        for i,(_,val_i) in enumerate(val):\n            count += val_i\n            \n            if count>=n//2:\n                return i +1\n        \n", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         \n         if not nums:\n             return True\n         \n         if sum(nums) % k != 0:\n             return False\n         \n         target = sum(nums) / k\n         \n         nums.sort()\n         \n         if nums[-1] > target:\n             return False\n         \n         while nums and nums[-1] == target:\n             nums.pop()\n             k -= 1\n         \n         def partition(nums, subsets, target):\n             if not nums:\n                 return True\n             selected = nums.pop()\n             for i in range(len(subsets)):\n                 if subsets[i] + selected <= target:\n                     subsets[i] += selected\n                     if partition(nums, subsets, target):\n                         return True\n                     subsets[i] -= selected\n                 if subsets[i] == 0:\n                     # this line is important, otherwise TLE.\n                     # if subsets[i] is 0 then later subsets are all zeros. No need to try them all.\n                     break\n             nums.append(selected)\n             return False\n         \n         return partition(nums, subsets=[0]*k, target=target)", "class Solution:\n    def countTriplets(self, A: List[int]) -> int:\n        \n        tot = 1<<16\n        cnt = [0 for _ in range(tot)]\n        for a in A:\n            for b in A:\n                cnt[a&b]+=1\n        \n        ans = 0\n        for e in A:\n            s = 0\n            while s<tot:\n                if s&e==0:\n                    ans += cnt[s]\n                    s += 1\n                else:\n                    s += (e&s)\n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A):\n        total = sum(A)\n        max_sum = [0 for i in range(len(A))]\n        min_sum = [0 for i in range(len(A))]\n\n        max_sum[0] = A[0]\n        min_sum[0] = A[0]\n\n        best_non_loop = max_sum[0]\n        best_inverse_loop = min_sum[0]\n\n        for i in range(1, len(A)):\n            max_sum[i] = A[i] + max(max_sum[i - 1], 0)\n            min_sum[i] = A[i] + min(min_sum[i - 1], 0)\n            \n            best_non_loop = max(best_non_loop, max_sum[i])\n            best_inverse_loop = min(best_inverse_loop, min_sum[i])\n\n        ret = max(best_non_loop, total - best_inverse_loop)\n        if ret == 0:\n            return max(A)\n        return ret", "class Solution:\n    def isValid(self, s: str) -> bool:\n        rtn =''\n        for i,char in enumerate(s):\n            if char == 'a':\n                rtn = rtn[:i] + 'abc' + rtn[i:]\n        return rtn == s\n                    \n#             aabcbc,...abcabcababcc\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \n        arr = [abs(ord(sc) - ord(tc)) for sc, tc in zip(s, t)]\n        max_len = 0\n        left, right = 0, 0\n        curr_sum = 0\n        max_len = 0\n        while(right < len(arr)):\n            curr_sum += arr[right]\n            while(left < len(arr) and curr_sum > maxCost):\n                curr_sum -= arr[left]\n                left += 1\n            max_len = max(max_len, right - left + 1)\n            right += 1\n        return max_len", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         # init dict, set default to 0\n         length_dict = {key: 0 for key in nums}\n         longest = 0\n         \n         for i in nums:\n             #print(\"i = \"+str(i))\n             if length_dict[i]:\n                 #print(\"skip \"+str(i)) # already done\n                 continue\n             \n             length = 1\n             length_dict[i] = 1\n             #print(length_dict)\n             \n             j = i + 1\n             while j in length_dict:\n                 #print(\"+:\"+str(j))\n                 length_dict[j] = 1\n                 length += 1\n                 j += 1\n             \n             j = i - 1\n             while j in length_dict:\n                 #print(\"-:\"+str(j))\n                 length_dict[j] = 1\n                 length += 1\n                 j -= 1\n             \n             longest = max(longest, length)\n         \n         return longest\n", "class Solution:\n    def findMinFibonacciNumbers(self, k: int) -> int:\n        a = b = 1\n        fibo = [a,b]\n      \n        res = 0\n        while a + b <= k:\n            fibo.append(a + b)\n            a, b = b, a+b\n        for i in fibo[::-1]:\n            if k >= i:\n                k -= i\n                res +=1\n        return res\n            \n            \n        \n", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n<1:\n             return 1\n             \n         tree_nums = [0]*(n+1)\n         tree_nums[0] = 1\n         tree_nums[1] = 1    # index start with 1\n         \n         for t in range(2, n+1):\n             for root in range(1,t+1):\n                 lt_num = root-1 # nodes num which smaller than root\n                 rt_num = t-root # nodes num which larger than root\n                 \n                 tree_nums[t] += tree_nums[lt_num]*tree_nums[rt_num]\n         \n         return tree_nums[n]\n", "class Solution(object):\n    def longestMountain(self, A):\n        N = len(A)\n        ans = base = 0\n\n        while base < N:\n            end = base\n            if end + 1 < N and A[end] < A[end + 1]: #if base is a left-boundary\n                #set end to the peak of this potential mountain\n                while end+1 < N and A[end] < A[end+1]:\n                    end += 1\n\n                if end + 1 < N and A[end] > A[end + 1]: #if end is really a peak..\n                    #set 'end' to right-boundary of mountain\n                    while end+1 < N and A[end] > A[end+1]:\n                        end += 1\n                    #record candidate answer\n                    ans = max(ans, end - base + 1)\n\n            base = max(end, base + 1)\n\n        return ans", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         a = m - 1\n         b = n - 1\n         ret = 1\n         for i in range(b):\n             ret = ret * (a+b-i) / (b-i)\n         return round(ret)", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         # if target in nums:\n         #     return nums.index(target)\n         # else:\n         #     return -1\n \n         low, high = 0, len(nums)-1\n         while low < high:\n             mid = (low+high)//2\n             if nums[mid] > nums[high]:\n                 low = mid+1\n             else:\n                 high = mid\n         start = low\n         low, high = 0, len(nums)-1\n         while low <= high:\n             mid = (low+high)//2\n             realMid = (mid+start) % (len(nums))\n             if nums[realMid] == target:\n                 return realMid\n             if target > nums[realMid]:\n                 low = mid+1\n             else:\n                 high = mid-1\n         return -1\n         \n                 \n", "class Solution:\n     def findMaxForm(self, strs, m, n):\n         \"\"\"\n         :type strs: List[str]\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         def getMax(arr, m, n):\n             res = 0\n \n             for e in arr:\n                 if m >= e[0] and n >= e[1]:\n                     res += 1\n                     m -= e[0]\n                     n -= e[1]\n \n             return res\n \n         arr = [(s.count('0'), s.count('1')) for s in strs]\n         arr1 = sorted(arr, key=lambda s: -min(m - s[0], n - s[1]))\n         arr2 = sorted(arr, key=lambda s: min(s[0], s[1]))\n         res = max(getMax(arr1, m, n), getMax(arr2, m, n))\n \n         return res", "class Solution:\n     def PredictTheWinner(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         _cache = {}\n         return Solution.Moves(self,nums, 0,len(nums)-1, 1, _cache ) >= 0\n         \n     \n     def Moves(self, nums, ini ,fin, pl, _cache = {}):\n         \n         memo = str((ini,fin,pl))\n         \n         if memo in list(_cache.keys()):\n             return _cache[memo]\n           \n         if ini == fin :\n             if pl == 1:\n                 _cache[memo] = nums[ini]\n                 return _cache[memo]\n             else:\n                 _cache[memo] = - nums[ini]\n                 return _cache[memo]\n         else:\n             if pl == 1:             \n                 _cache[memo]= max(Solution.Moves(self, nums, ini+1, fin, 2,_cache) + nums[ini] , Solution.Moves(self, nums, ini, fin-1, 2,_cache) + nums[fin])\n                 return _cache[memo]\n             \n             if pl == 2:\n                 _cache[memo] = min(Solution.Moves(self, nums, ini+1, fin, 1,_cache) - nums[ini] , Solution.Moves(self, nums, ini, fin-1, 1,_cache) - nums[fin])\n                 return _cache[memo]\n", "class Solution:\n     def largestNumber(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: str\n         \"\"\"\n         s=self.sort(nums)\n         if s.startswith(\"0\"):\n             return \"0\"\n         else:return s\n     def sort(self,nums):\n         if not nums:return \"\"\n         else:\n             pivot=nums[0]\n             left=[]\n             right=[]\n             for i in range(1,len(nums)):\n                 if self.compare(nums[i],pivot):\n                     left.append(nums[i])\n                 else:\n                     right.append(nums[i])\n             return self.sort(left)+str(pivot)+self.sort(right)\n             \n     def compare(self,num1,num2):\n         num1,num2=str(num1),str(num2)\n         return int(num1+num2)>int(num2+num1)", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        # Time Complexity: O(N^3 K)\n        # Space Complexity: O(N^2 K)\n        \n        self.dp = {}\n        self.prefix = [0] + list(itertools.accumulate(stones))\n        \n        ret = self.merge(stones, 0, len(stones) - 1, 1, K)\n        \n        return ret\n        \n    def merge(self, stones, start: int, end: int, num_parts: int, K: int):\n        if (start, end, num_parts) in self.dp:\n            return self.dp[(start, end, num_parts)]\n        \n        if end - start + 1 < num_parts:\n            return -1\n        \n        if end - start + 1 == num_parts:\n            return 0\n        \n        window_sum = self.prefix[end + 1] - self.prefix[start] \n        \n        if num_parts == 1:\n            split = self.merge(stones, start, end, K, K)\n            \n            if split == -1:\n                ret = -1\n            else:\n                ret = window_sum + split\n        else:\n            candidates = []\n            \n            for i in range(start, end):\n                left = self.merge(stones, start, i, 1, K)\n                right = self.merge(stones, i + 1, end, num_parts - 1, K)\n                \n                \n                if left >= 0 and right >= 0:\n                    candidates.append(left + right)\n            \n            if candidates:\n                ret = min(candidates)\n            else:\n                ret = -1\n                \n        self.dp[(start, end, num_parts)] = ret\n        return ret\n\n", "class Solution:\n     def containsNearbyAlmostDuplicate(self, nums, k, t):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :type t: int\n         :rtype: bool\n         \"\"\"\n         \n         if t<0:\n             return False\n         \n         w = t+1\n         d = {}\n         \n         for i in range(0, len(nums)):\n             m = nums[i]//w\n             #print(m,d)\n             if m in d:\n                 return True\n             if m-1 in d and abs(nums[i]-d[m-1])<=t:\n                 return True\n             if m+1 in d and abs(nums[i]-d[m+1])<=t:\n                 return True\n             d[m] = nums[i]\n             if i>=k:\n                 del d[nums[i-k]//w]\n                 \n         return False\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        dp = [[] for i in range(len(s))]\n        dp[0].append([s[0]])\n        \n        for i in range(1, len(s)):\n            for j in range(len(dp[i-1])):\n                comb = dp[i-1][j]\n                \n                dp[i].append(comb[:-1]+[comb[-1]+s[i]])\n                dp[i].append(comb+[s[i]])\n        _max = 0\n        \n        for i in range(len(s)):\n            for j in range(len(dp[i])):\n                length = len(set(dp[i][j]))\n                if length >_max:\n                    _max = length\n                \n        return _max\n            \n", "import functools as ft\nimport typing as t\n\n\nclass Solution:\n    \n    BASE = 10 ** 9 + 7\n    \n    def divisor_pairs(self, idx: int) -> List[t.Tuple[int, int]]:\n        num = self.A[idx]\n        left_idx = 0\n        ans = []\n        while self.A[left_idx] ** 2 <= num:\n            left = self.A[left_idx]\n            if num % left == 0:\n                right = num // left\n                if right in self.A_idx:\n                    ans.append((left_idx, self.A_idx[right]))\n            left_idx += 1\n        return ans\n    \n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        self.A = sorted(A)\n        self.A_idx = {a: idx for idx, a in enumerate(self.A)}\n        return sum(self.count_binary_trees(idx) for idx in range(len(A))) % self.BASE\n    \n    @ft.lru_cache(None)\n    def count_binary_trees(self, idx: int) -> int:\n        num = self.A[idx]\n        ans = 1  # root only\n        for left_idx, right_idx in self.divisor_pairs(idx):\n            left_cnt = self.count_binary_trees(left_idx)\n            right_cnt = self.count_binary_trees(right_idx)\n            if left_idx == right_idx:\n                total_cnt = left_cnt * right_cnt\n            else:\n                total_cnt = 2 * left_cnt * right_cnt\n            ans += total_cnt\n        return ans", "class Solution:\n     def myPow(self, x, n):\n         \"\"\"\n         :type x: float\n         :type n: int\n         :rtype: float\n         \"\"\"\n         if n == 0:\n             return 1\n         if abs(n) == 1:\n             if n == 1:\n                 return x\n             else:\n                 return 1/x\n         if n > 0:\n             a, b = int(n//2), n%2\n         else:\n             a, b = -int(-n//2), -(n%2)\n         y = self.myPow(x, a)\n         z = self.myPow(x, b)\n         return y*y*z", "class Solution:\n    def movesToMakeZigzag(self, A: List[int]) -> int:\n        res1=0\n        n=len(A)\n        B=A.copy()\n        for i in range(1,n,2):\n            if A[i-1]<=A[i]:\n                t=A[i]-A[i-1]+1\n                res1+=t\n                A[i]=A[i-1]-1\n            if i+1<n and A[i+1]<=A[i]:\n                t=A[i]-A[i+1]+1\n                res1+=t\n                A[i]=A[i+1]-1\n        res2=0\n        for i in range(0,n,2):\n            if i-1>=0 and B[i]>=B[i-1]:\n                t=B[i]-B[i-1]+1\n                res2+=t\n                B[i]=B[i-1]-1\n            if i+1<n and B[i+1]<=B[i]:\n                t=B[i]-B[i+1]+1\n                res2+=t\n                B[i]=B[i+1]-1\n        # print(A)\n        # print(B)\n        # print(res1,res2)\n        return min(res1,res2)", "class Solution:\n    \n    def gcd(self, a:int, b:int) -> int:\n        a,b = max(a,b),min(a,b)\n        while b>0:\n            a,b = b,a%b\n        return a\n    \n    def isGoodArray(self, nums: List[int]) -> bool:\n        lowest = nums[0]\n        for i in nums[1:]:\n            lowest = self.gcd(lowest,i)\n        return lowest==1", "class Solution:\n    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n        croaks = {'c':[], 'r':[], 'o':[], 'a':[]}\n        nfrogs = 0\n        icroak = 0\n        curfrogs = 0\n        for sound in croakOfFrogs:\n            if sound == 'c':\n                icroak += 1\n                croaks['c'].append(icroak)\n                curfrogs += 1\n                nfrogs = max(curfrogs, nfrogs)\n            elif sound == 'r':\n                if croaks['c']:\n                    croaks['r'].append(croaks['c'].pop())\n                else:\n                    return -1\n            elif sound == 'o':\n                if croaks['r']:\n                    croaks['o'].append(croaks['r'].pop())\n                else:\n                    return -1\n            elif sound == 'a':\n                if croaks['o']:\n                    croaks['a'].append(croaks['o'].pop())\n                else:\n                    return -1\n            elif sound == 'k':\n                if croaks['a']:\n                    croaks['a'].pop()\n                    curfrogs -= 1\n                else:\n                    return -1\n            else:\n                return -1\n        \n        for sound in croaks:\n            if croaks[sound] != []:\n                return -1\n        \n        return nfrogs\n                \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        dp = []\n        for i in range(len(A)):\n            if i == 0:\n                dp.append(set([A[i]]))\n            else:\n                inner = set([A[i]])\n                for d in dp[-1]:\n                    inner.add(d | A[i])\n                dp.append(inner)\n        total = set()\n        for d in dp:\n            total.update(d)\n        return len(total)", "class Solution:\n    def orderlyQueue(self, S: str, K: int) -> str:\n        if K==1:\n            tmp = S\n            for i in range(len(S)):\n                S = S[1:] + str(S[0])\n                if S<tmp:\n                    tmp = S\n            return tmp\n        else:\n            return ''.join(sorted(S))", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        ret = 0\n        overall = 0\n\n        totals = {}\n        for i, h in enumerate(hours):\n            if h > 8:\n                overall += 1 \n            else:\n                overall -= 1\n            \n            if overall > 0:\n                ret = i + 1\n            else:\n                if overall-1 in totals:\n                    length = i - totals[overall-1]\n                    ret = max(ret, length)\n                if overall not in totals:\n                    totals[overall] = i\n    \n        return ret", "class Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\n        to_ret = sum([c for c, g in zip(customers, grumpy) if g == 0])\n        \n        mt = mf = sum([c for c, g in zip(customers[:X], grumpy[:X]) if g == 1])\n        for t in range(X, len(customers)) :\n            if grumpy[t] == 1 :\n                mt += customers[t]\n            if grumpy[t-X] == 1 :\n                mt -= customers[t-X]\n            mf = max(mf, mt)\n        return to_ret + mf", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        chars = [ord(c) - 97 for c in S]\n        BASE = 26\n        MOD = (1 << 63) - 1\n        POWS = [1] * n\n        for i in range(1, n):\n            POWS[i] = (POWS[i - 1] * BASE) % MOD\n        def search(k):\n            seen = set()\n            h = 0\n            for i in range(k):\n                h = (h * BASE + chars[i]) % MOD\n            seen.add(h)\n            for i in range(k, n):\n                h = ((h - chars[i - k] * POWS[k - 1]) * BASE + chars[i]) % MOD\n                if h in seen:\n                    return i\n                seen.add(h)\n            return -1\n        \n        l, r = 0, n - 1\n        k = 0\n        while l < r:\n            m = (l + r + 1) // 2\n            i = search(m)\n            if i >= 0:\n                k = i\n                l = m\n            else:\n                r = m - 1\n        return S[k - l + 1:k + 1]", "class Solution:\n    def lenLongestFibSubseq1(self, A: List[int]) -> int:\n        mp = {}\n        \n        for v in A:\n            mp[v] = set()\n        \n        result = 0\n        for i in range(len(A)):\n            for j in range(i + 1, len(A)):\n                a = A[i]\n                b = A[j]\n                l = 2\n                while True:\n                    if b in mp[a]:\n                        break\n                    if l != 2:\n                        mp[a].add(b) \n                    c = a + b\n                    if c not in mp:\n                        break\n                    a, b = b, c\n                    l += 1\n                if l >= 3:\n                    result = max(result, l)\n        return result\n\n    def lenLongestFibSubseq(self, A):\n        index = {x: i for i, x in enumerate(A)}\n        longest = collections.defaultdict(lambda: 2)\n\n        ans = 0\n        for k, z in enumerate(A):\n            for j in range(k):\n                i = index.get(z - A[j], None)\n                if i is not None and i < j:\n                    cand = longest[j, k] = longest[i, j] + 1\n                    ans = max(ans, cand)\n\n        return ans if ans >= 3 else 0", "class Solution:\n     def hIndex(self, citations):\n         \"\"\"\n         :type citations: List[int]\n         :rtype: int\n         \"\"\"\n         citations.sort(reverse=True)\n         for idx in range(len(citations)):\n             if idx + 1> citations[idx]:\n                 return idx\n         return len(citations)\n", "class Solution:\n     def numDistinct(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: int\n         \"\"\"\n         row = len(s) + 1\n         col = len(t) + 1\n         dp = [0]*col\n         dp[0] = 1\n         for i in range(1, row):\n             pre = dp[:]\n             # print(pre)\n             for j in range(1, col):\n                 if s[i-1] == t[j-1]:\n                     dp[j] += pre[j-1]\n             # print(dp)\n         return dp[-1]\n                     \n", "class Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        n = len(dominoes)\n        \n        d = [0] * n\n        \n        force = 0\n        \n        for i in range(n):\n            c = dominoes[i]\n            \n            if c == 'R':\n                force = n\n            elif c == 'L':\n                force = 0\n            else:\n                force = max(force - 1, 0)\n                \n            d[i] += force\n            \n        force = 0\n        \n        for i in range(n-1, -1, -1):\n            c = dominoes[i]\n            \n            if c == 'R':\n                force = 0\n            elif c == 'L':\n                force = n\n            else:\n                force = max(force - 1, 0)\n                \n            d[i] -= force\n            \n        def inner():\n            for f in d:\n                if f == 0:\n                    yield '.'\n                elif f > 0:\n                    yield 'R'\n                else:\n                    yield 'L'\n                    \n        return ''.join(inner())", "from copy import copy\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        \n        d = dict()\n        count = dict()\n        lim = len(A)\n        blank = dict()\n        for i in range(0,lim-1):  \n            try:\n                count[A[i]]+=1\n            except:\n                blank[A[i]]=0\n                count[A[i]]=1\n            for j in range(i+1,lim):\n                if ((A[i]+A[j])**.5).is_integer():\n                    try:\n                        d[A[i]].add(A[j])\n                    except:\n                        d[A[i]] = set()\n                        d[A[i]].add(A[j])\n                    try:\n                        d[A[j]].add(A[i])\n                    except:\n                        d[A[j]] = set()\n                        d[A[j]].add(A[i])\n        try:\n            count[A[-1]]+=1\n        except:\n            count[A[-1]]=1\n            blank[A[-1]]=0\n            \n        check = sorted(A)\n        if d==dict():return 0\n        f = set()\n        c = 0\n        def r(val,ld,l,lth):\n            if lth==lim:\n                f.add(tuple(l))\n            else:\n                if val in d:\n                    for x in d[val]:\n                        s = copy(ld)\n                        if s[x]<=count[x]:\n                            s[x]+=1\n                            r(x,s,l+[x],lth+1)\n        \n        for x in set(A):\n            r(x,blank,[x],1)\n        for x in f:\n            if sorted(list(x))==check:c+=1\n        return c\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        onecount = 0 \n        start = 0\n        ans = 0\n        \n        for end in range(len(A)):\n            if A[end] == 1: \n                onecount += 1\n \n            if end - start + 1 - onecount > K:\n                if A[start] == 1: onecount -= 1\n                start += 1\n   \n            ans = max(ans , end - start +1)\n            \n        return ans", "class Solution:\n    def maxVowels(self,S,K):\n        N=len(S)\n        L=[0]*(N+1)\n        for i in range(N):\n            if S[i] in ['a','e','i','o','u']:\n                L[i+1]=1\n        for i in range(1,N+1):\n            L[i]+=L[i-1]\n        i=0\n        j=K\n        ans=0\n        while(i<=N and j<=N):\n            ans=max(ans,L[j]-L[i])\n            i+=1\n            j+=1\n        return ans     \n            \n                \n        \n", "import numpy as np\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        statdict = {}\n        flag = True\n#        print(A)\n        for i in A:\n#            print(statdict)\n            if i in statdict:\n                statdict[i] = statdict[i] + 1\n            elif i < 0:\n                if i*2 in statdict:\n                    statdict[i*2] = statdict[i*2] - 1\n                    if statdict[i*2] == 0:\n                        statdict.pop(i*2)\n                else:\n                    statdict[i] = 1\n            else:\n                if (i%2 == 0) and i/2 in statdict:\n                    statdict[int(i/2)] = statdict[int(i/2)] - 1\n                    if statdict[int(i/2)] == 0:\n                        statdict.pop(int(i/2))\n                else:\n                    statdict[i] = 1\n        return (len(statdict) == 0) or (len(statdict) == 1 and 0 in statdict and statdict[0] % 2 == 0)", "class Solution(object):\n     def removeKdigits(self, num, k):\n         \"\"\"\n         :type num: str\n         :type k: int\n         :rtype: str\n         \"\"\"\n         if k == len(num):\n             return \"0\"\n         stack = []\n         cnt = 0\n         for i, ch in enumerate(num):\n             if cnt == k:\n                 for j in range(i, len(num)):\n                     stack.append(num[j])\n                 break\n             if not stack or ch >= stack[-1]:\n                 stack.append(ch)\n             else:\n                 while stack and ch < stack[-1] and cnt < k:\n                     stack.pop()\n                     cnt += 1\n                 stack.append(ch)\n         while cnt < k:\n             stack.pop()\n             cnt += 1\n         i = 0\n         while i < len(stack) and stack[i] == '0':\n             i += 1\n         if i == len(stack):\n             return \"0\"\n         return ''.join(stack[i:])", "class Solution:\n     def firstMissingPositive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 1\n         for index in range(len(nums)):\n             while nums[index] != index + 1:\n                 tmp = nums[index]\n                 if tmp <= 0 or tmp > len(nums) or tmp == nums[tmp - 1]:\n                     break\n                 nums[index] = nums[tmp - 1]\n                 nums[tmp - 1] = tmp\n         for index in range(len(nums)):\n             if nums[index] != index + 1:\n                 return index + 1\n         return len(nums) + 1\n", "class Solution:\n     def findPoisonedDuration(self, timeSeries, duration):\n         \"\"\"\n         :type timeSeries: List[int]\n         :type duration: int\n         :rtype: int\n         \"\"\"\n         if not timeSeries:\n             return 0\n         \n         previous_time = timeSeries[0]\n         total_time = duration\n         for time in timeSeries[1:]:\n             if time - previous_time < duration:\n                 total_time += time - previous_time\n                 previous_time =time\n             else:\n                 total_time += duration\n                 previous_time =time\n \n         return total_time", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        print(m, n)\n        mat = [[0] * (4*n) for _ in range(4*m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '/':\n                    mat[4*i][4*j+3] = 1\n                    mat[4*i+1][4*j+2] = 1\n                    mat[4*i+2][4*j+1] = 1\n                    mat[4*i+3][4*j] = 1\n                elif grid[i][j] == '\\\\\\\\':\n                    mat[4*i][4*j] = 1\n                    mat[4*i+1][4*j+1] = 1\n                    mat[4*i+2][4*j+2] = 1\n                    mat[4*i+3][4*j+3] = 1\n        # print(mat)\n        dirs = [[-1,0],[1,0],[0,1],[0,-1]]\n        def dfs(i, j):\n            visit[i][j] = 1\n            for d in dirs:\n                x, y = i+d[0], j+d[1]\n                if 0<=x<(4*m) and 0<=y<(4*n) and not mat[x][y]:\n                    mat[x][y] = 1\n                    if not visit[x][y]:\n                        dfs(x, y)\n            \n        visit = [[0]*(4*n) for _ in range(4*m)]\n        res = 0\n        for i in range(4*m):\n            for j in range(4*n):\n                if not mat[i][j]:\n                    res += 1\n                    dfs(i, j)\n        return res", "class Solution:\n    def minAddToMakeValid(self, S: str) -> int:\n        if not S:\n            return 0\n        N = len(S)\n        open_brackets = [0]*N\n        close_brackets = [0]*N\n        \n        ans = 0\n        for i, c in enumerate(S):\n            if i>0:\n                open_brackets[i] = open_brackets[i-1]\n                close_brackets[i] = close_brackets[i-1]\n            if c == '(':\n                open_brackets[i] += 1\n            elif c == ')':\n                close_brackets[i] += 1\n            \n            if close_brackets[i] > open_brackets[i]:\n                diff = close_brackets[i]-open_brackets[i]\n                ans += diff\n                open_brackets[i] += diff\n                \n        return ans+open_brackets[-1]-close_brackets[-1]\n", "class Solution:\n     def numberOfArithmeticSlices(self, A):\n         \"\"\"\n         :type A: List[int]\n         :rtype: int\n         \"\"\"\n         dp = [0 for _ in range(len(A))]\n         for i in range(2, len(A)):\n             if A[i] - A[i-1] == A[i-1] - A[i-2]:\n                 dp[i] = dp[i-1] + 1\n             else:\n                 dp[i] = 0\n                 \n         return sum(dp)", "class Solution:\n    def minFlipsMonoIncr(self, S: str) -> int:\n        at0 = 0\n        at1 = 0\n        \n        num0 = 0\n        for a in S:\n            if a=='0':\n                at1 = min(at1,at0) + 1\n            else:\n                at1 = min(at1,at0)\n                at0 += 1\n                \n            #print(at0,at1)\n        return min(at1,at0)", "from collections import Counter\n\n'''\nlet P[i] = sum(A[:i])\nfor each j\n    count # of i's \n        where P[j] - P[i] = S where i < j\n'''\n\nclass Solution:\n    def numSubarraysWithSum(self, A, k):\n        count = Counter({0:1})\n        ans = psum = 0\n        \n        for v in A:\n            psum += v\n            ans += count[psum - k]\n            count[psum] += 1\n            \n        return ans", "class Solution:\n     def maxProfit(self, prices, k = 2):\n         \"\"\"\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         if not prices:\n             return 0\n         \n         s1 = s2 = 0\n         b1 = b2 = -1000000000\n         \n         for p in prices:\n             b1 = max(b1, -p)\n             s1 = max(s1, b1 + p)\n             b2 = max(b2, s1 - p)\n             s2 = max(s2, b2 + p)\n         \n         return s2\n", "from queue import PriorityQueue\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        pq = PriorityQueue()\n        for i in range(len(values)):\n            pq.put((-values[i],labels[i]))\n        \n        subset_sum = 0\n        ecount = 0\n        label_usage_count_map = {}\n        \n        while (pq.qsize()>0):\n            popped_element = pq.get()\n            v = -popped_element[0]\n            l = popped_element[1]\n            \n            if (v<0):\n                break\n            \n            if (ecount>=num_wanted):\n                break\n            \n            lusage = label_usage_count_map.get(l,0)\n            if (lusage>=use_limit):\n                continue\n            \n            ecount += 1\n            subset_sum += v\n            label_usage_count_map[l] = label_usage_count_map.get(l,0) + 1\n        \n        return subset_sum\n", "class Solution:\n     def frequencySort(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n         charToFreq = {}\n         freqToChar = {}\n         for c in s:\n             if c not in charToFreq:\n                 charToFreq[c] = 0\n             charToFreq[c] += 1\n         for key, value in list(charToFreq.items()):\n             if value not in freqToChar:\n                 freqToChar[value] = []\n             freqToChar[value].append(key)\n         result = []\n         for key in range(len(s), -1, -1):\n             if key in freqToChar:\n                 for char in freqToChar[key]:\n                     result += [char] * key\n         return \"\".join(result)\n", "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        x, y, dx, dy = 0, 0, 0, 1\n        for i in instructions:\n            if i == 'R': dx, dy = dy, -dx\n            if i == 'L': dx, dy = -dy, dx\n            if i == 'G': x, y = x + dx, y + dy\n        return (x, y) == (0, 0) or (dx, dy) != (0,1)\n", "from collections import Counter \n    \n\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        n = len(nums)\n        res = n\n        if n <= 2:\n            return n\n        \n        c = set(cnt.values())\n        min_c = min(cnt.values())\n        max_c = max(cnt.values())\n        if (len(c) == 2 and ((sum([1 for k in cnt if cnt[k] == max_c]) == 1 and max_c == min_c + 1) or (sum([1 for k in cnt if cnt[k] == min_c]) == 1 and min_c == 1))) or (len(c) == 1 and min_c == 1) or (len(cnt) == 1):\n            return res\n        # print(cnt, min_c, max_c)\n        \n        for i in reversed(nums[2:]):\n            res -= 1\n            cnt[i] -= 1\n            if cnt[i] == 0:\n                del cnt[i]\n            \n            if not cnt:\n                return res\n            c = set(cnt.values())\n            min_c = min(cnt.values())\n            max_c = max(cnt.values())\n            if (len(c) == 2 and ((sum([1 for k in cnt if cnt[k] == max_c]) == 1 and max_c == min_c + 1) or (sum([1 for k in cnt if cnt[k] == min_c]) == 1 and min_c == 1))) or (len(c) == 1 and min_c == 1) or (len(cnt) == 1):\n                return res\n        \n        return 2\n", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        res_map = {}\n        for idx in range(len(fronts)) :\n            if fronts[idx] == backs[idx] :\n                res_map.setdefault(fronts[idx], False)\n                res_map[fronts[idx]] = False\n            else :\n                res_map.setdefault(fronts[idx], True)\n                res_map.setdefault(backs[idx], True)\n        for num in sorted(res_map.keys()) :\n            if res_map[num] : return num\n        return 0", "class Solution:\n    def numSteps(self, s: str) -> int:\n        i, mid_zero = 0 , 0 \n        for j in range(1, len(s)):\n            if s[j] == '1':\n                mid_zero += j -i - 1\n                i = j\n        if i == 0:\n            return len(s)-1\n        return mid_zero + 1 + len(s)\n", "class Solution:\n     def optimalDivision(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: str\n         \"\"\"\n         A = list(map(str, nums))\n         if len(A) <= 2:\n             return '/'.join(A)\n         return A[0] + '/(' + '/'.join(A[1:]) + ')'", "class Solution:\n     def replaceWords(self, dict, sentence):\n         \"\"\"\n         :type dict: List[str]\n         :type sentence: str\n         :rtype: str\n         \"\"\"\n         sentence = sentence + ' '\n         dic = {}\n         for i in dict:\n             if i[0] not in list(dic.keys()):\n                 dic[i[0]] = [i]\n             else:\n                 dic[i[0]].append(i)\n         res = ''\n         while len(sentence) > 0:\n             word = sentence[:sentence.index(' ')]\n             tmp = ''\n             if word[0] in list(dic.keys()):\n                 for refer in dic[word[0]]:\n                     if len(refer) < len(word):\n                         if word[:len(refer)] == refer:\n                             if tmp == '':\n                                 tmp = refer\n                             else:\n                                 if len(tmp) > len(refer):\n                                     tmp = refer\n             if tmp != '':\n                 res += tmp+' '\n             else:\n                 res += word+' '                     \n             sentence = sentence[sentence.index(' ')+1:]\n         res = res[:-1]\n         return res\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        minlen = [float('inf')] * len(arr)\n        res = float('inf')\n        l, r, windsum = 0, 0, 0\n        for r in range(len(arr)):\n            windsum += arr[r]\n            while windsum > target:\n                windsum -= arr[l]\n                l += 1\n            if windsum == target:\n                if minlen[l-1] != float('inf'):\n                    temp = minlen[l-1] + r - l + 1\n                    res = min(res, temp)\n                minlen[r] = min(minlen[r-1], r - l + 1)\n            else:\n                minlen[r] = minlen[r-1]\n        return res if res < float('inf') else -1\n", "class DSU:\n    def __init__(self,m,n):\n        self.par = {(i,j):(i,j) for i in range(m) for j in range(n)}\n    \n    def find(self,x):\n        if self.par[x]!=x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self,x,y):\n        xp,yp = self.find(x),self.find(y)\n        if xp == yp:\n            return False\n        self.par[xp] = yp\n        return True\n\ndirs = [(0,1),(1,0)]\nclass Solution:\n    def containsCycle(self, grid):\n        R,C = len(grid),len(grid[0])\n        dsu = DSU(R,C)        \n        for r in range(R):\n            for c in range(C):\n                for x,y in dirs:\n                    nr,nc = r+x,c+y\n                    if 0<=nr<R and 0<=nc<C and grid[r][c] == grid[nr][nc]:\n                        if dsu.union((r,c),(nr,nc)) == False:\n                            return True\n        return False\n                \n                \n                        \n", "class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        # slide window and call isMagicSquare\n        if len(grid) < 3 or len(grid[0]) < 3:\n            return 0\n        rows = len(grid)\n        cols = len(grid[0])\n        magic_squares = 0\n        for i in range(rows - 2):\n            for j in range(cols - 2):\n                window = [tmp[j:j + 3] for tmp in grid[i: i + 3]]\n                if self.isMagicSquare(window):\n                    magic_squares += 1\n        \n        return magic_squares\n    \n    def isMagicSquare(self, square: List[List[int]]) -> bool:\n        target = square[0][0] + square[0][1] + square[0][2]\n        seen = {}\n        print(square)\n        # check rows\n        for row in square:\n            tmp = 0\n            for i in row:\n                tmp += i\n                if i in seen or i > 9 or i < 1:\n                    return False\n                else:\n                    seen[i] = 1\n            if tmp != target:\n                return False\n        \n        # check cols\n        for i in range(3):\n            tmp = 0\n            for row in square:\n                tmp += row[i]\n            \n            if tmp != target:\n                return False\n        \n        \n        # check left to right diag\n        tmp = 0\n        for i in range(3):\n            tmp += square[i][i]\n        if tmp != target:\n            return False\n        \n        # check right to left diag\n        tmp = 0\n        for i in range(3):\n            tmp += square[i][2 - i]\n        if tmp != target:\n            return False\n        \n        return True", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n        \n        print(workers)\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "class Solution:\n    def clumsy(self, N: int) -> int:\n        res = None\n        while N > 0:\n            val = N\n            N -= 1\n            print(N, val, res)\n            if N > 0:\n                val = val * N\n                N -= 1\n            print(N, val, res)\n            if N > 0:\n                val = val // N\n                N -= 1\n            print(N, val, res)\n            if res is None:\n                if N > 0:\n                    val = val + N\n                    N -= 1\n                print(N, val, res)\n                res = val\n            else:\n                if N > 0:\n                    val = val - N\n                    N -= 1\n                print(N, val, res)\n                res -= val\n            print(N, val, res)\n        return res", "class Solution:\n    def minTaps(self, n: int, ranges) -> int:\n\n        def process_input(ranges):\n            spans = []\n            for i in range(len(ranges)):\n                spans.append([max(i - ranges[i], 0), i + ranges[i]])\n\n            return spans\n\n        spans = process_input(ranges)\n\n        spans.sort(key=lambda time: (time[0], -time[1]))\n\n        sol = []\n        step = .5\n        for i in range(len(spans)):\n\n            if step > n:\n                continue\n\n            if spans[i][0] < step and spans[i][1] > step:\n                try:\n                    if spans[i][0] <= sol[-2][1]:\n                        sol.pop()\n                except:\n                    pass\n                sol.append(spans[i])\n                step = spans[i][1] + .5\n\n\n\n        if step < n:\n            return -1\n        return len(sol)", "class Solution:\n     def __init__(self):\n         pass\n         \n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         \n         N = len(machines)\n         if N == 0:\n             return 0\n         \n         val_sum = sum(machines)\n         if val_sum%N != 0:\n             return -1\n         \n         val_each = val_sum//N\n         \n         go_left, go_right, net_change, max_step = 0, 0, 0, 0\n         for i in range(N):\n             go_left = -go_right\n             go_right = go_right + machines[i] - val_each\n             net_change = go_left + go_right\n             step = max(abs(go_left), abs(go_right), net_change)\n             max_step = max(max_step, step)\n             \n         return max_step", "class Solution:\n     def countNumbersWithUniqueDigits(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         answer = 10 ** n\n         for i in range(1, n + 1):\n             all_count = 9 * 10 ** (i - 1)\n             invalid = 9\n             for j in range(1, i):\n                 invalid *= (10 - j)\n             answer -= (all_count - invalid)\n         \n         return answer", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums: return 0\n         if len(nums) == 1: return 0\n         step, far, maxV = 0, 0, 0\n         \n         for i in range(len(nums)):\n             if i + nums[i] > maxV and i + nums[i] >= len(nums) - 1: return step + 1\n             maxV = max(maxV, i + nums[i])\n             if i == far:\n                 step += 1\n                 far = maxV\n         return step", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # if len(piles) == 1:return -(piles[0] // -H)\n        self.piles = piles\n        l, r = 1, max(piles)\n        \n        while l <= r:\n            K = (l + r)//2\n            if self.eat_time(K) <= H:\n                r = K - 1\n            else:\n                l = K + 1\n        return l\n            \n    def eat_time(self, K):\n        cnt = 0\n        for banana in self.piles:\n            q, mod = divmod(banana, K)\n            cnt += q\n            if mod != 0: cnt += 1\n            # cnt += banana / K\n            # if banana%K != 0: cnt += 1\n        return cnt", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        def method1():\n            graph=collections.defaultdict(set)\n            for i,pair in enumerate(edges):\n                u,v=pair\n                graph[u].add((v,succProb[i]))\n                graph[v].add((u,succProb[i]))\n                \n            seen={0:0}\n            queue=[(start,-1)]\n            ans=float('-inf')\n            while queue:\n                node,p=heapq.heappop(queue)\n                p=-p\n                if node==end:\n                    ans=max(ans,p)\n                for nei,dw in graph[node]:\n                    if (nei not in seen or seen[nei]<p*dw) and p*dw>ans:\n                        seen[nei]=p*dw\n                        heapq.heappush(queue,(nei,-p*dw))\n                        \n            return ans if ans!=float('-inf') else 0\n        \n        #return method1()\n    \n        def method2():\n            AdjList = [set() for _ in range(n)]\n            \n            for (u, v), p in zip(edges, succProb):\n                AdjList[u].add((v, log2(1/p)))\n                AdjList[v].add((u, log2(1/p)))\n            \n            dist = [float('inf') for _ in range(n)]\n            dist[start] = 0\n            h = [(0, start)]\n            while h:\n                d, u = heappop(h)\n                if d == dist[u]:\n                    for (v, p) in AdjList[u]:\n                        if dist[u] + p < dist[v]:\n                            dist[v] = dist[u] + p\n                            heappush(h, (dist[v], v))\n            return 1 / (2 ** dist[end])\n        return method2()", "class Solution:\n     def originalDigits(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n         d=collections.defaultdict(int)\n         for i in s:\n             d[i]+=1\n         zero='0'*d['z']\n         d['e']-=d['z']\n         d['r']-=d['z']\n         d['o']-=d['z']\n         two='2'*d['w']\n         d['t']-=d['w']\n         d['o']-=d['w']\n         four='4'*d['u']\n         d['f']-=d['u']\n         d['o']-=d['u']\n         d['r']-=d['u']\n         five='5'*d['f']\n         d['i']-=d['f']\n         d['v']-=d['f']\n         d['e']-=d['f']\n         six='6'*d['x']\n         d['s']-=d['x']\n         d['i']-=d['x']\n         seven='7'*d['v']\n         d['s']-=d['v']\n         d['e']-=d['v']*2\n         d['n']-=d['v']\n         eight='8'*d['g']\n         d['e']-=d['g']\n         d['i']-=d['g']\n         d['h']-=d['g']\n         d['t']-=d['g']\n         nine='9'*d['i']\n         d['n']-=d['i']*2\n         d['e']-=d['i']\n         one='1'*d['o']\n         three='3'*d['r']\n         return zero+one+two+three+four+five+six+seven+eight+nine\n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def isDiv(mid):\n            s=0\n            for i in nums:\n                s+=math.ceil(i/mid)\n            # print(\\\"Sum\\\",s,mid)\n            return s<=threshold\n            \n    \n        def binsearch():\n            low=1\n            high=sum(nums)\n            while low<high:\n                mid=low+(high-low)//2\n                if isDiv(mid):\n                    high=mid\n                else:\n                    low=mid+1\n            return low\n        return binsearch()", "class Solution:\n     def wiggleMaxLength(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0:\n             return 0\n         if len(nums) == 1:\n             return 1\n         N = len(nums)\n         sol = [0 for _ in nums]\n         sol[0] = [1,1] #starting with -, starting with +\n         for i in range(1,N):\n             new = [0,0]\n             if nums[i] > nums[i-1]:\n                 new[0] = sol[i-1][1]+1\n             else:\n                 new[0] = sol[i-1][0]\n             if nums[i] < nums[i-1]:\n                 new[1] = sol[i-1][0]+1\n             else:\n                 new[1] = sol[i-1][1]\n             sol[i] = new\n         return max(sol[-1])\n             \n                 \n", "class Solution:\n     def findKthLargest(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         \n         def partition(nums, ind, i, j):\n             \n             big, scan = i, i\n             \n             nums[ind], nums[j] = nums[j], nums[ind]\n             \n             while scan < j:\n                 if nums[scan] > nums[j]:\n                     nums[big], nums[scan] = nums[scan], nums[big]\n                     big += 1\n                     \n                 scan += 1\n                     \n             nums[j], nums[big] = nums[big], nums[j]\n             # print(nums)\n             # print(big)\n             return big\n             \n         \n         # 12 53 - 1 09\n         \n         \n         i, j = 0, len(nums)-1\n         while i <= j:\n             ind = random.randint(i, j)\n             new_ind = partition(nums, ind, i, j)\n             if new_ind == k-1: \n                 return nums[new_ind]\n             elif new_ind < k-1: \n                 i = new_ind + 1\n             else:\n                 j = new_ind - 1\n                 \n         return -1 \n         \n         \n             \n", "\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        start = set()\n        for word in words + [result]:\n            if len(word) > 1:\n                start.add(word[0])\n\n\n        n = max(map(len, words + [result]))\n        if len(result) < n:\n            return False\n\n        def dfs(idx, i, carry, visited, mp):\n            if idx == n:\n                return carry == 0\n            if i == len(words) + 1:\n                sums = sum(mp[word[-idx - 1]] if idx < len(word) else 0 for word in words) + carry\n                if sums % 10 == mp[result[-idx - 1]]:\n                    carry = sums // 10\n                    return dfs(idx + 1, 0, carry, visited, mp)\n                return False\n\n            if (i < len(words) and idx >= len(words[i])):\n                return dfs(idx, i + 1, carry, visited, mp)\n            tmp = words + [result]\n            ch = tmp[i][-idx-1]\n            if ch in mp:\n                return dfs(idx, i + 1, carry, visited, mp)\n            begin = 0\n            if ch in start:\n                begin = 1\n            for x in range(begin, 10):\n                if x not in visited:\n                    visited.add(x)\n                    mp[ch] = x\n                    if dfs(idx, i + 1, carry, visited, mp.copy()):\n                        return True\n                    visited.remove(x)\n            return False\n\n        return dfs(0, 0, 0, set(), {})", "class Solution:\n        \n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD\n", "class Solution:\n    \n    def is_unique(self, s):\n        return len(set(s)) == len(s)\n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        dct= {}\n        maxVal = 0\n        \n        for i in range(0, len(arr)):\n            if self.is_unique(arr[i]):\n                maxVal = max(maxVal, len(arr[i]))\n                \n            for j in range(i+1, len(arr)):\n                t = arr[i] + arr[j]\n                \n                if self.is_unique(t):\n                    arr.append(t)\n                    maxVal = max(maxVal, len(t))\n        # print(dct)\n        return maxVal", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        if not nums: return 0\n        \n        seen = set([0])\n        \n        out = 0\n        \n        curr = 0\n        \n        for i in nums:\n            curr += i\n            if curr - target in seen:\n                out += 1\n                seen = set([0])\n                curr = 0\n            else:\n                seen.add(curr)\n        \n        return out", "class Solution:\n    def numSplits(self, s: str) -> int:\n        left = {s[0]:1}\n        right = {}\n        for i in range(1, len(s)):\n            right[s[i]] = right.get(s[i], 0) + 1\n            \n        #check if the left set has as many items as the right set\n        #then we incremenet the middle pointer\n        #remove the item from right\n        #add it to left\n        middle_i = 1\n        count = 0\n        while middle_i < len(s):\n            if len(left) == len(right):\n                count += 1\n                \n            middle = s[middle_i]\n            right[middle] -= 1\n            if right[middle] == 0:\n                right.pop(middle)\n            \n            left[middle] = left.get(middle, 0) + 1\n            \n            middle_i += 1\n        \n        return count\n", "class Solution:\n   def evalRPN(self, tokens):\n     \"\"\"\n     :type tokens: List[str]\n     :rtype: int\n     \"\"\"\n     s = []\n     for token in tokens:\n       if token == \"+\":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(a+b)\n       elif token == \"/\":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(b/a)\n       elif token == \"*\":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(a*b)\n       elif token == \"-\":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(b-a)\n       else:\n         s.append(token)\n     if len(s) is not 1:\n       return False\n     else:\n       return int(s.pop())", "class Solution:\n    def baseNeg2(self, N):\n        res = []\n        while N != 0:\n            m = N %(-2)\n            if m == -1:\n                m = 1\n            N = (N-m) // (-2)\n            res.append(str(m))\n            \n        return ''.join(res[::-1]) or '0'", "class Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n        dis = k\n        for n in nums:\n            if n:\n                if dis<k:\n                    return False\n                else:\n                    dis=0\n            else:\n                dis+=1\n        return True        ", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        k = k -1\n        \n        def dfs(path, new):\n            \n            if len(path) == n:\n                res.append(path)\n                return\n            \n            \n            if len(path) == 0:\n                for ind, x in enumerate(new):\n                    dfs(path+x, new[:ind] + new[ind+1:])\n            \n            \n            else:\n                last = path[-1]\n                l = []\n                for i in letters:\n                    if i != last:\n                        l.append(i)\n                \n                for ind, x in enumerate(l):\n                    dfs(path+x, l[:ind] + l[ind+1:])\n        \n        \n        \n        \n        \n        letters = ['a', 'b', 'c']\n        res =[]\n        dfs('', letters)\n        \n        if k >= len(res):\n            return ''\n        else:\n            return res[k]", "class Solution:\n     def canJump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         n = len(nums)\n         maxReachable = 0\n         for i, num in enumerate(nums):\n             if num >= n-i-1:\n                 return True\n             flag = False\n             if i+num >= maxReachable:\n                 for j in range(i+1, num+i+1):\n                     if nums[j]>0:\n                         flag = True\n                         break\n                 if flag == False:\n                     # print(i, num)\n                     return False\n             maxReachable = max(maxReachable, i+num)\n         return True", "from collections import deque\nclass Solution:\n    # def racecar(self, target: int) -> int:\n    #     # position, speed\n    #     queue = deque([(0,1)])\n    #     nsteps = -1\n    #     while queue:\n    #         levelSize = len(queue)\n    #         nsteps += 1\n    #         for _ in range(levelSize):\n    #             pos, speed = queue.popleft()\n    #             if pos == target:\n    #                 return nsteps\n    #             # Always consider moving the car in the direction it is already going\n    #             queue.append( (pos+speed, speed*2) )\n    #             # Only consider changing the direction of the car if one of the following conditions is true\n    #             if (pos>target and speed>0) or \\\\\n    #                (pos<target and speed<0) or \\\\\n    #                (pos+speed>target and speed>0) or \\\\\n    #                (pos+speed<target and speed<0):\n    #                 queue.append( (pos, -1 if speed>0 else 1) )\n    #     return nsteps\n    def __init__(self):\n        self.dp = {0: 0}\n    def racecar(self, t: int) -> int:\n        if t in self.dp:\n            return self.dp[t]\n\n        n = t.bit_length()\n        if 2**n - 1 == t:\n            self.dp[t] = n\n        else:\n            # go pass the target, stop and turn back\n            self.dp[t] = self.racecar(2**n-1-t) + n + 1\n            # Go as far as possible before pass target, stop and turn back\n            for m in range(n-1):\n                self.dp[t] = min(self.dp[t], self.racecar(t - 2**(n-1) + 1 + 2**m - 1) + (n - 1) + m + 2)\n        return self.dp[t]\n", "from collections import deque\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        minq, maxq = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while minq and nums[r] <= nums[minq[-1]]:\n                minq.pop()\n            while maxq and nums[r] >= nums[maxq[-1]]:\n                maxq.pop()\n                \n            minq.append(r)\n            maxq.append(r)\n            \n            while nums[maxq[0]] - nums[minq[0]] > limit:\n                l += 1\n                if l > minq[0]:\n                    minq.popleft()\n                if l > maxq[0]:\n                    maxq.popleft()\n            ans = max(ans, r - l + 1)\n            r += 1\n        return ans", "class Solution:\n     def checkValidString(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         cmin = cmax = 0\n         for i in s:\n             if i == '(':\n                 cmax += 1\n                 cmin += 1\n             if i == ')':\n                 cmax -= 1\n                 cmin = max(cmin - 1, 0)\n             if i == '*':\n                 cmax += 1\n                 cmin = max(cmin - 1, 0)\n             if cmax < 0:\n                 return False\n         return cmin == 0\n", "class Solution:\n     def findMinStep(self, board, hand):\n         \"\"\"\n         :type board: str\n         :type hand: str\n         :rtype: int\n         \"\"\"\n         return self.use_dfs(board, hand)\n     \n     def use_dfs(self, board, hand):\n         counts = collections.Counter(hand)\n         return self.dfs(board, counts)\n     \n     def dfs(self, board, hand):\n         if not board:\n             return 0\n         result = float('inf')\n         i, j = 0, 0\n         n = len(board)\n         while i < n:\n             j = i\n             while j < n and board[i] == board[j]:\n                 j += 1\n             color = board[i]\n             remove = 3 - (j - i)\n             if color in hand and hand[color] >= remove:\n                 new_board = self.shrink(board[:i] + board[j:])\n                 hand[color] -= remove\n                 dist = self.dfs(new_board, hand)\n                 if dist >= 0:\n                     result = min(result, dist + remove)\n                 hand[color] += remove\n             i = j\n         return result if float('inf') != result else -1\n     \n     def shrink(self, board):\n         i, j = 0, 0\n         while i < len(board):\n             j = i\n             while j < len(board) and board[i] == board[j]:\n                 j += 1\n             if j - i >= 3:\n                 board = board[:i] + board[j:]\n                 i = 0\n             else:\n                 i = j\n         return board\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        light = [i-1 for i in light]\n        bulbs = [0 for _ in range(len(light))]\n        on,blue = set(),set()\n        res = 0\n        #print(bulbs)\n        #print(light)\n        n = len(light)\n        total = 0\n        for moment in light:\n            #print(bulbs,moment)\n            if moment == 0:\n                bulbs[0] = 2\n                blue.add(0)\n            elif bulbs[moment-1] == 2:\n                bulbs[moment] = 2\n                blue.add(moment)\n            else:\n                bulbs[moment] = 1\n                on.add(moment)\n            if bulbs[moment] == 2:\n                #print('turning things blue',bulbs[moment+1] if moment+1 < n else -1)\n                i = moment+1\n                while i < n and bulbs[i] == 1:\n                    bulbs[i] = 2\n                    blue.add(on.remove(i))\n                    i += 1\n            res += 1 if blue and not on else 0\n        return res", "class Solution:\n    def largestMultipleOfThree(self, a: List[int]) -> str:\n        n, dp = len(a), [''] * 3\n        a.sort(reverse=True)\n        for i in range(n):\n            d, dp1 = a[i] % 3, [''] * 3\n            for j in range(3): \n                k = (j-d) % 3\n                dp1[j] = max([dp[k] + str(a[i]) if dp[k] or k==0 else '', dp[j]], key=lambda x: (len(x), x))\n                if len(dp1[j]) >= 2 and dp1[j][0] == '0': dp1[j] = dp1[j][1:]\n            dp = dp1            \n        return dp[0]\n            \n", "class Solution:\n     def factorial(self, n):\n         if n <= 1:\n             return 1\n         return self.factorial(n-1) * n\n     \n     def getPermutation(self, n, k):\n         \"\"\"\n         :type n: int\n         :type k: int\n         :rtype: str\n         \"\"\"\n         r = ''\n         nums = [i+1 for i in range(n)]\n         m = n \n         while m:\n             np = self.factorial(m-1)\n             i = (k-1)//np\n             k -= i*np\n             r += str(nums[i])\n             del nums[i]\n             m = len(nums)\n         return r\n         \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = dict()\n        cost_memo = dict()\n        def find_cost(l, r):\n            a, b = l, r\n            if (l, r) not in memo:\n                cost = 0\n                while l < r:\n                    cost += s[l] != s[r]\n                    l += 1\n                    r -= 1\n                cost_memo[(a, b)] = cost\n            return cost_memo[(a, b)]\n                \n        def top_down(i, k):\n            if n-i == 1:\n                return 0\n            if k == 1:\n                return find_cost(i, n-1)\n            if (i, k) not in memo:\n                res = float('inf')\n                for j in range(i+1, n-k+2):\n                    res = min(res, find_cost(i, j-1)+top_down(j, k-1))\n                memo[(i, k)] = res\n            return memo[(i, k)]\n        return top_down(0, k)", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        from collections import defaultdict\n        if len(s) != len(t): return False\n        i = 0\n        j = defaultdict(int)\n        print((len(s)))\n        while i < len(s):\n            mr = (ord(t[i]) - ord(s[i]))%26\n            if mr == 0:\n                pass\n            else:\n                if mr + j.get(mr,0) * 26 > k:\n                    return False\n                j[mr] += 1\n            i += 1\n        return True\n        \n        \n", "class Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        dp = [[0 for _ in range(len(mat[0]) + 1)]for r in range(len(mat) + 1)]\n        \n        for r in range(1, len(mat) + 1):\n            for c in range(1, len(mat[r-1]) + 1):\n                dp[r][c] += mat[r-1][c-1]\n                if not r and not c:\n                    continue\n                elif not r:\n                    dp[r][c] += dp[r][c-1]\n                    continue\n                elif not c:\n                    dp[r][c] += dp[r-1][c]\n                    continue\n                dp[r][c] += dp[r][c-1] + dp[r-1][c] - dp[r-1][c-1]\n         \n        # print(dp)\n        highest = -1\n        for r in range(1, len(dp)):\n            r0= r1 = r\n            c0= c1 = 1\n            while r1 < len(dp) and c1 < len(dp[0]):\n              \n                result = dp[r1][c1] + dp[r0-1][c0-1] - dp[r1][c0-1] - dp[r0-1][c1]\n  \n                # print(f'r0:{r0} r1:{r1} c0:{c0} c1:{c1} result:{result}')\n                if result <= threshold:\n                    highest = max(r1-r0, highest)\n                    r1 += 1\n                    c1 +=1\n                else:\n                    r1 -=1\n                    c0 +=1\n                r1 = max(r0+1,r1)\n                c1 = max(c0+1,c1)\n\n        return highest + 1", "class Solution(object):\n     def smallestDistancePair(self, nums, k):\n         def possible(guess):\n             #Is there k or more pairs with distance <= guess?\n             count = left = 0\n             for right, x in enumerate(nums):\n                 while x - nums[left] > guess:\n                     left += 1\n                 count += right - left\n             return count >= k\n \n         nums.sort()\n         lo = 0\n         hi = nums[-1] - nums[0]\n         while lo < hi:\n             mi = (lo + hi) // 2\n             if possible(mi):\n                 hi = mi\n             else:\n                 lo = mi + 1\n \n         return lo", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens.sort()\n        if(not tokens or P < tokens[0]):\n            return 0\n        l, r = 0, len(tokens)-1\n        points = 0\n        \n        while(l <= r):\n            if(P >= tokens[l]):\n                points += 1\n                P -= tokens[l]\n                l += 1\n            else:\n                if(r-l > 1):\n                    points -= 1\n                    P += tokens[r]\n                    r -= 1\n                else:\n                    break\n        return points", "class Solution:\n    def smallestRangeII(self, A: List[int], K: int) -> int:\n        A.sort()\n        res = A[-1] - A[0]\n        for i in range(len(A)-1):\n            res = min(res, max(A[i]+K, A[-1] - K) - min(A[0] + K, A[i+1] - K))\n        return res", "class Solution:\n     def countArrangement(self, N):\n         \"\"\"\n         :type N: int\n         :rtype: int\n         \"\"\"\n         cache = {}\n         def helper(i, X):\n             if i == 1:\n                 return 1\n             key = (i, X)\n             if key in cache:\n                 return cache[key]\n             total = sum(helper(i-1, X[:j] + X[j+1:]) for j, x in enumerate(X)\n                        if x%i == 0 or i%x == 0)  ## check the num at the end can be exchange\n             cache[key] = total\n             return total\n         return helper(N, tuple(range(1, N+1)))", "class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         n = min(n, 3)\n         if n == 0: return 0\n         if n == 1: return 2 if m > 0 else 1\n         if n == 2: \n             if m == 0: return 1\n             elif m == 1: return 3\n             else: return 4\n         if n == 3:\n             if m == 0: return 1\n             elif m == 1: return 4\n             elif m == 2: return 7\n             else: return 8\n         \n         \n         \n         \n", "from functools import reduce\n\nclass Solution:\n        \n    \n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        lsum = []\n               \n        csum = reduce(lambda a,b:a+b, A[:L]) \n        lsum.append(csum)\n        \n        for i in range(L, len(A)):\n            csum += A[i] - A[i-L]\n            lsum.append(csum)\n            \n        msum = []\n        csum = reduce(lambda a,b:a+b, A[:M])\n            \n        msum.append(csum)\n        \n        for i in range(M, len(A)):\n            csum += A[i] - A[i-M]\n            msum.append(csum)\n            \n        maxSum = 0\n        for i in range(len(A)-L+1):\n            ls = i\n            le = i + L - 1\n            \n            for j in range(len(A) - M+1):\n                ms = j\n                me = j + M - 1\n                \n                if (le < ms) or (me < ls):\n                    maxSum = max(maxSum, lsum[ls] + msum[ms])\n                    \n        return maxSum    ", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        return self.dp(0, n, cuts, dict())\n    \n    def dp(self, i, j, cuts, memo):\n        if (i, j) not in memo:\n            minV = float('inf')\n            for k in cuts:\n                if k > i and k < j: # Valid cutting point\n                    l, r = self.dp(i, k, cuts, memo), self.dp(k, j, cuts, memo)\n                    minV = min(minV, l+r)\n            if minV != float('inf'):\n                memo[(i, j)] = minV+j-i\n            else:\n                memo[(i, j)] = 0\n        return memo[(i, j)]", "class Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        n = len(arr)\n        odd, even = [0] * n, [0] * n\n        for i,v in enumerate(arr):\n            if not i:\n                odd[i] += v%2 == 1\n                even[i] += v%2 !=1\n            else:\n                if v%2:\n                    odd[i] += 1 + even[i-1]\n                    even[i] += odd[i-1]\n                else:\n                    odd[i] += odd[i-1]\n                    even[i] += 1 + even[i-1]\n        return sum(odd) % (10**9+7)\n", "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        x, y = arr1, arr2\n        maxCase1 = maxCase2 = maxCase3 = maxCase4 = -float('inf')\n        minCase1 = minCase2 = minCase3 = minCase4 = float('inf')\n        for i in range(len(x)):\n            maxCase1 = max(maxCase1, x[i]+y[i]-i)\n            maxCase2 = max(maxCase2, x[i]-y[i]-i)\n            maxCase3 = max(maxCase3, -x[i]+y[i]-i)\n            maxCase4 = max(maxCase4, -x[i]-y[i]-i)\n            minCase1 = min(minCase1, x[i]+y[i]-i)\n            minCase2 = min(minCase2, x[i]-y[i]-i)\n            minCase3 = min(minCase3, -x[i]+y[i]-i)\n            minCase4 = min(minCase4, -x[i]-y[i]-i)\n        return max(maxCase1-minCase1, maxCase2-minCase2, maxCase3-minCase3, maxCase4-minCase4)", "class Solution:\n     def leastInterval(self, tasks, n):\n         \"\"\"\n         :type tasks: List[str]\n         :type n: int\n         :rtype: int\n         \"\"\"\n         l,dic=len(tasks),{}\n         for c in tasks:\n             if c in dic:\n                 dic[c]+=1\n             else:\n                 dic[c]=1\n         m,a=max(dic.values()),0\n         for c in dic:\n             if dic[c]==m:\n                 a+=1\n         return max(l,(m-1)*(n+1)+a)", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         ans = []\n         def dfs(queens, xy_dif, xy_sum):\n             p = len(queens)\n             if p == n:\n                 result.append(queens)\n                 return None\n \n             for q in range(n):\n                 if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                     dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n \n         result = []\n         dfs([], [], [])\n         \n         return len(result)", "class Solution:\n     def isSelfCrossing(self, x):\n         \"\"\"\n         :type x: List[int]\n         :rtype: bool\n         \"\"\"\n         n = len(x)\n         if n < 4:\n             return False\n \n         i = 3\n         while i < n:\n             if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:\n                 return True\n             if i >= 4:\n                 if x[i - 1] == x[i - 3] and x[i] + x[i - 4] >= x[i - 2]:\n                     return True\n             if i >= 5:\n                 if x[i] >= x[i - 2] - x[i - 4] >= 0 and x[i - 5] >= x[i - 3] - x[i - 1] >= 0:\n                     return True\n             i += 1\n         return False\n", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         start = 0\n         end = len(nums) - 1\n         while start < end:\n             if start < len(nums) - 1 and nums[start] == nums[start + 1]:\n                 start += 1\n                 continue\n             if nums[end] == nums[end - 1]:\n                 end -= 1\n                 continue\n             mid = start + (end - start) // 2\n             if nums[mid] > nums[end]:\n                 start = mid + 1\n             else:\n                 end = mid\n         return nums[start]\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        res = {}\n        def dfs(seq, tiles):\n            if seq not in res and seq != '':\n                res[seq] = 1\n            for i in range(len(tiles)):\n                dfs(seq+tiles[i], tiles[:i]+tiles[i+1:])\n        dfs('', tiles)\n        return len(res)\n", "class Solution:\n     def multiply(self,num1, num2):\n         \"\"\"\n         :type num1: str\n         :type num2: str\n         :rtype: str\n         \"\"\"\n         a=['0','1','2','3','4','5','6','7','8','9']\n         z=0\n         x=0\n         for i,element in enumerate(num1):\n             for j in range(10):\n                 if element==a[j]:\n                     z+=j*(10**(len(num1)-i-1))\n                     \n         for c,b in enumerate(num2):\n             for k in range(10):\n                 if b==a[k]:\n                     x+=k*(10**(len(num2)-c-1))\n         mul=z*x\n         return(''.join('%d'%mul))\n                     \n  \n        \n             \n         \n", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        q, s = [], set()\n        q.append((0, target))\n        while q:\n            c, t = heapq.heappop(q)\n            if t == 0: return c - 1\n            if t in s: continue\n            s.add(t)\n            n = int(log(t) / log(x)) \n            l = t - x**n\n            heapq.heappush(q, (c+(2 if n==0 else n), l))\n            r = x**(n+1) - t\n            heapq.heappush(q, (c + n + 1, r))\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = []\n        for i in range(len(A)):\n            dp.append([0] * len(B))\n\n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    dp[i][j] = max(dp[i][j],1)\n                    if i - 1 >= 0 and j - 1 >= 0 :\n                        dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1)\n\n                else:\n                    if i - 1 >= 0 and j - 1 >= 0:\n                        dp[i][j] = max(dp[i][j],dp[i-1][j-1])\n                    if j - 1 >= 0:\n                        dp[i][j] = max(dp[i][j],dp[i][j-1])\n                    if i - 1 >= 0:\n                        dp[i][j] = max(dp[i][j],dp[i-1][j])\n        return dp[-1][-1]\n", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         l = [p1, p2, p3, p4]\n         s = set()\n         for i in range(len(l)):\n             for j in range(i+1, len(l)):\n                 d = self.dist(l[i], l[j])\n                 if d == 0:\n                     return False\n                 s.add(d)\n         return len(s) == 2\n                     \n     \n     def dist(self, a, b):\n         return (a[0] - b[0])**2 + (a[1] - b[1])**2", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        l = len(arr)\n        results = [0] * l\n        for idx, num in enumerate(arr):\n            if idx < k:\n                results[idx] = max(arr[:idx+1]) * (idx + 1)\n            else:\n                res = 0\n                for i in range(1, k+1):\n                    start = idx -i\n                   \n                    tmp = results[start] + max(arr[start+1:idx+1]) * i\n                \n                    res = max(res, tmp)\n                results[idx] = res\n\n        return results[-1]\n", "class Solution:\n    def numFriendRequests(self, ages):\n        def request(a, b):\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\n        c = collections.Counter(ages)\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        echos = set()\n        def find_echos(suffix):\n            n = len(suffix)\n            z = [0] * n\n            l, r = 0, 0\n            for i in range(1, n):\n                if r >= i:\n                    z[i] = min(r - i + 1, z[i - l])\n                while i + z[i] < n and suffix[i + z[i]] == suffix[z[i]]:\n                    z[i] += 1\n                if i + z[i] - 1 > r:\n                    l, r = i, i + z[i] - 1\n            for half in range(1, 1 + (n // 2)):\n                if z[half] >= half: echos.add(suffix[:2*half])\n        \n        for i in range(len(text) - 1):\n            find_echos(text[i:])\n            \n        return len(echos)\n        \n'''\n\naaaaaaaaaa\n2 + 4 + 6 + \n\n\nfor suffix pairs\ns[i:] s[j:] longest common prefix\n\n\nstore suffixes in a trie\n\n..abcdabceef\n\n\nabc..abc..\n\n'''", "class Solution:\n     # recursive, time limit exceeded\n     def combinationSum4_1(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         res = 0\n         if target == 0:\n             return 1\n         \n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.combinationSum4(nums, target - nums[i])\n         return res\n \n     # top down using memory\n     def combinationSum4_2(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [-1] * (target + 1)\n         dp[0] = 1\n         return self.helper(dp, nums, target)\n     \n     def helper(self, dp, nums, target):\n         if dp[target] != -1:\n             return dp[target]\n         \n         res = 0\n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.helper(dp, nums, target - nums[i])\n         dp[target] = res\n         return res\n     \n     # bottom up\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [0] * (target + 1)\n         dp[0] = 1\n         for i in range(target + 1):\n             for num in sorted(nums):\n                 if i < num: break\n                 dp[i] += dp[i - num]\n         return dp[-1]", "class Solution:\n    def soupServings(self, N: int) -> float:\n        compressed_N = N // 25\n        N = compressed_N + (1 if (N-compressed_N*25)>0 else 0)\n        \n        mem = {}\n        \n        def dp(a, b):\n            if (a, b) in mem:\n                return mem[(a,b)]\n            else:\n                if a <= 0 or b <= 0:\n                    result = 0.5 if a <=0 and b <= 0 else 1.0 if a <= 0 else 0.0\n                else:\n                    result = 0.25 * (dp(a-4, b) + dp(a-3, b-1) + dp(a-2, b-2) + dp(a-1, b-3))\n                mem[(a,b)] = result\n                return result\n        \n        if N <= 100:\n            return dp(N, N)\n        else:\n            for i in range(100, N+1):\n                current_result = dp(i, i)\n                if 1 - current_result < 1e-6:\n                    return 1.0\n            return current_result\n", "class Solution:\n    def longestArithSeqLength(self, A: List[int]) -> int:\n        dp = {}\n        for i, a2 in enumerate(A[1:], start=1):\n            for j, a1 in enumerate(A[:i]):\n                d = a2 - a1\n                if (j, d) in dp:\n                    dp[i, d] = dp[j, d] + 1\n                else:\n                    dp[i, d] = 2\n        return max(dp.values())\n    \n#         dp = {}\n#         for i, a2 in enumerate(A[1:], start=1):\n#             for j, a1 in enumerate(A[:i]):\n#                 d = a2 - a1\n#                 if (j, d) in dp:\n#                     dp[i, d] = dp[j, d] + 1\n#                 else:\n#                     dp[i, d] = 2\n#         return max(dp.values())\n", "class Solution:\n     def monotoneIncreasingDigits(self, N):\n         N = str(N)\n         L = len(N)\n         for i in range(L - 1):\n             if N[i] > N[i + 1]:\n                 return self.monotoneIncreasingDigits(int(N[:i] + str(int(N[i]) - 1) + '9' * (L - i - 1)))\n         return int(N)", "class Solution:\n     def candy(self, ratings):\n         \"\"\"\n         :type ratings: List[int]\n         :rtype: int\n         \"\"\"\n         current_min = 1\n         current_max = 1\n         desc_len = 1\n         cnt = 1\n         for i in range(1, len(ratings)):\n             if ratings[i] < ratings[i - 1]:\n                 if current_min == 1:\n                     if desc_len >= current_max:\n                         cnt += desc_len + 1\n                     else:\n                         cnt += desc_len\n                 else:\n                     current_max = current_min\n                     current_min = 1\n                     cnt += 1\n                 desc_len += 1\n             elif ratings[i] > ratings[i - 1]:\n                 current_min += 1\n                 current_max = current_min\n                 cnt += current_min\n                 desc_len = 1\n             else:\n                 cnt += 1\n                 current_min = 1\n                 current_max = 1\n                 desc_len = 1\n         return cnt", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        n = len(A)\n        preSum = [0 for i in range(n+1)]\n        for i in range(1, n+1):\n            preSum[i] = preSum[i-1] + A[i-1]\n        # print(preSum)\n        deque = []\n        i = 0\n        ans = n + 1\n        while i <= n:\n            while deque and preSum[i] - preSum[deque[0]] >= K:\n                ans = min(ans, i-deque[0])\n                print(ans)\n                deque.pop(0)\n            while deque and preSum[deque[-1]] >= preSum[i]:\n                deque.pop()\n            deque.append(i)\n            i += 1\n            # print(deque)\n        return ans if ans < n+1 else -1\n", "class Solution:\n    def numSub(self, s: str) -> int:\n        res = 0\n\n        mod = pow(10,9) + 7\n\n        i = 0\n        while i< len(s):\n            cnt = 0\n            while i < len(s) and s[i] == '1':\n                cnt+=1\n                i+=1\n            i+=1\n            res += (cnt*(cnt+1))//2 % mod\n        return res", "class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        x = 0\n        y = 0\n        \n        for index in range(0, len(s1)):\n            if s1[index] != s2[index]:\n                if s1[index] == 'x':\n                    x += 1\n                else:\n                    y += 1\n        \n        \n        mid = ( x + y ) / 2\n        x, y = x % 2, y % 2\n        \n        if x + y == 1:\n            return -1\n        \n        if x + y == 2:\n            mid += 1\n        \n        print(mid)\n        return int(mid)\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        result = ''\n        \n        left = 0\n        right = len(s) - 1\n        \n        hash_left = 0\n        hash_right = 0\n        \n        while left < len(s) - 1 and right > 0:\n            hash_left += ord(s[left])\n            hash_right += ord(s[right])\n            \n            if hash_left == hash_right:\n                if s[:left + 1] == s[right:]:\n                    result = s[right:]\n            \n            left += 1\n            right -= 1\n        \n        return result\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        dp = [1] * (len(S)+1)\n        \n        for a , b in zip('I'+S, S):\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\n        \n        return dp[0] % (10**9+7)\n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0 or i > j:\n                return 0\n            return max(dp(i + 1, j, k), slices[i] + dp(i + 2, j, k - 1))\n        n = len(slices)\n        k = n // 3\n        dp = collections.deque([[0] * (k + 1) for i in range(2)])\n        for i in range(n - 2, -1, -1):\n            new_dp = [0] * (k + 1)\n            for j in range(1, k + 1):\n                new_dp[j] = max(dp[0][j], slices[i] + dp[1][j - 1])\n            dp.pop()\n            dp.appendleft(new_dp)\n        a = dp[0][k]\n        dp.clear()\n        dp.extend([[0] * (k + 1) for i in range(2)])\n        for i in range(n - 1, 0, -1):\n            new_dp = [0] * (k + 1)\n            for j in range(1, k + 1):\n                new_dp[j] = max(dp[0][j], slices[i] + dp[1][j - 1])\n            dp.pop()\n            dp.appendleft(new_dp)\n        b = dp[0][k]\n        return max(a, b)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def check(nums):\n            flag = False\n            for n in nums:\n                if n > 1:\n                    flag = True\n            return flag\n        \n        cnt = 0\n        n = len(nums)\n        flag = check(nums)\n        while flag:\n            # print(nums)\n            cnt += 1\n            for i in range(n):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    nums[i] = nums[i] // 2\n                    cnt += 1\n                else:\n                    nums[i] = nums[i] // 2\n            # print(cnt)\n            flag = check(nums)\n        for n in nums:\n            if n != 0:\n                cnt += 1\n        return cnt                ", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        left = True\n        determined = False\n        for i, c in enumerate(s1):\n            if c > s2[i]:\n                if not left and determined:\n                    return False\n                determined = True\n            elif c < s2[i]:\n                if left and determined:\n                    return False\n                left = False\n                determined = True\n        return True", "class Solution:\n     def minPatches(self, nums, n):\n         \"\"\"\n         :type nums: List[int]\n         :type n: int\n         :rtype: int\n         \"\"\"\n         missed, added, i = 1, 0, 0\n         while missed <= n:\n             if i < len(nums) and nums[i] <= missed:\n                 missed += nums[i]\n                 i += 1\n             else:\n                 missed += missed\n                 added += 1\n         return added\n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s1) + len(s2) != len(s3):\n             return False\n         \n         m, n = len(s1) + 1, len(s2) + 1\n         dp = [[False] * n for _ in range(m)]\n         \n         dp[0][0] = True\n         for row in range(1, m):\n             dp[row][0] = dp[row - 1][0] and s1[row - 1] == s3[row - 1]\n         \n         for col in range(1, n):\n             dp[0][col] = dp[0][col - 1] and s2[col - 1] == s3[col - 1]\n         \n         for row in range(1, m):\n             for col in range(1, n):\n                 # print(row, col)\n                 # print(s1[row - 1])\n                 # print(s2[col - 1])\n                 # print(s3[row + col - 1])\n                 dp[row][col] = (dp[row - 1][col] and s1[row - 1] == s3[row + col - 1]) \\\n                                or (dp[row][col - 1] and s2[col - 1] == s3[row + col - 1])\n         \n         # print(dp)\n         \n         return dp[-1][-1]\n", "class Solution:\n     def nextGreaterElement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         nn = str(n)\n         l = len(nn)\n         if l < 2:\n             return -1\n         \n         x = -1\n         for i in range(l-1, 0, -1):\n             if nn[i] > nn[i-1]:\n                 x = i - 1\n                 break\n         \n         if x == -1:\n             return -1\n         \n         y = nn[x+1]\n         yy = x+1\n         for i in range(x+1, l):\n             if nn[i] > nn[x]:\n                 y = min(y, nn[i])\n                 if y == nn[i]:\n                     yy = i\n         \n         left = nn[ : x] + y\n         right = nn[yy+1 : l] + nn[x] + nn[x+1 : yy]\n         res = int(left + ''.join(sorted(right)))\n         \n         return res if res < 2 ** 31 else -1\n         \n", "from queue import PriorityQueue\n\nclass Solution:\n    def isInRange(self, grid, x, y):\n        return (0 <= x and x < len(grid[0])) and (0 <= y and y < len(grid))\n\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        q = PriorityQueue()\n        visited = dict()\n        maxDist = 0\n        toVisit = [(-1, 0), (0, 0), (1, 0), (0, 1), (0, -1)]\n        \n        for x, i in enumerate(grid):\n            for y, j in enumerate(i):\n                if j is not 0:\n                    q.put((0, (x, y)))\n                    visited[(x, y)] = True\n                    \n        if (q.qsize() >= len(grid[0]) * len(grid) or q.qsize() is 0):\n            return -1\n                    \n        while not q.empty():\n            item = q.get()\n            maxDist = max(maxDist, item[0])\n            \n            for p in toVisit:\n                x = p[0] + item[1][0]\n                y = p[1] + item[1][1]\n                \n                if self.isInRange(grid, x, y) and visited.get((x, y)) is not True:\n                    visited[(x, y)] = True\n                    q.put((item[0] + 1, (x, y)))\n            \n        return maxDist", "class Solution:\n     def convert(self, s, numRows):\n         \"\"\"\n         :type s: str\n         :type numRows: int\n         :rtype: str\n         \"\"\"\n         if numRows == 1 or numRows >= len(s):\n             return s\n \n         result = [''] * numRows\n \n         index, step = 0, 1\n \n         for c in s:\n             result[index] += c\n             if index == 0:\n                 step = 1\n             elif index == numRows-1:\n                 step = -1\n             index += step\n \n         return ''.join(result)\n", "class Solution:\n     def lengthOfLongestSubstring(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n                    \n         record = {};\n         result = 0;\n         start = -1;\n         for i, x in enumerate(s):\n             if x in record:\n                 start = max(start, record[x]);\n                 \n             record[x] = i;\n             result = max(result, i - start);\n             \n         return result;", "class Solution:\n     def find132pattern(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         a= 1, b=3, c= 2\n         \"\"\"\n         stack = []\n         max_c = -math.inf\n         for i in range(len(nums) - 1, -1, -1):\n             if nums[i] < max_c:\n                 return True\n             while stack and stack[-1] < nums[i]:\n                 max_c = max(max_c, stack.pop())\n             stack.append(nums[i])\n             \n         return False", "class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        if (rows == 0):\n            return -1\n        \n        cols = len(grid[0])\n        if (cols == 0):\n            return -1\n        \n        dp = [(1,1)] * cols\n        \n        for r, col in enumerate(grid):\n            for c, item in enumerate(col):\n                if (r == 0 and c == 0):\n                    dp[c] = (item, item)\n                elif (r == 0):\n                    dp[c] = (dp[c-1][0]*item, dp[c-1][1] * item)\n                elif (c == 0):\n                    dp[c] = (dp[c][0]*item, dp[c][1] * item)\n                else:\n                    c1 = dp[c-1][0]*item\n                    c2 = dp[c-1][1] * item\n                    c3 = dp[c][0]*item\n                    c4 = dp[c][1] * item\n                    \n                    m = min( dp[c-1][0]*item, dp[c-1][1] * item,dp[c][0]*item,  dp[c][1] * item)\n                    M = max(dp[c-1][0]*item, dp[c-1][1] * item,dp[c][0]*item,  dp[c][1] * item)\n                    dp[c] = (m, M)\n                    \n        \n        if (dp[cols-1][1] >= 0):\n            return (dp[cols-1][1] % (10**9 + 7))\n        else:\n            return -1", "class Solution:\n     def isNumber(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         states = [{},\n                 {\"blank\": 1, \"sign\": 2, \"dot\": 4, \"digit\": 3},\n                 {\"digit\": 3, \"dot\": 4},\n                 {\"digit\": 3, \"blank\": 9, \"e\": 6, \"dot\": 5},\n                 {\"digit\": 5},\n                 {\"digit\":5, \"e\":6, \"blank\": 9},\n                 {\"sign\": 7, \"digit\": 8},\n                 {\"digit\": 8},\n                 {\"digit\": 8, \"blank\": 9},\n                 {\"blank\": 9}]\n         \n         curr_state = 1\n         for c in s:\n             type_c = self.checkType(c)\n             if type_c not in states[curr_state].keys():\n                 return False\n             curr_state = states[curr_state][type_c]\n         if curr_state not in [3, 5, 8, 9]:\n             return False\n         return True\n \n     def checkType(self, c):\n         if c == \" \":\n             return \"blank\"\n         elif ord(c) >= ord(\"0\") and ord(c) <= ord(\"9\"):\n             return \"digit\"\n         elif c == \".\":\n             return \"dot\"\n         elif c in [\"E\", \"e\"]:\n             return \"e\"\n         elif c in [\"+\", \"-\"]:\n             return \"sign\"\n         else:\n             return \"other\"", "class Solution:\n    def angleClock(self, hour: int, minutes: int) -> float:\n        minutes_num = minutes/5\n        hour += minutes/60\n        angle = abs(hour - minutes_num)*30\n        return min(360-angle, angle)", "class Solution:\n     def countSubstrings(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         \n         # manacher, find Z\n         s = '^#' + '#'.join(s) + '#$'\n         Z = [1] * len(s)\n         center, right = 0, 0\n         for i in range(len(s)-1): # \u6ce8\u610f i\u4e0d\u80fd\u53d6\u5230 $\n             if i < right:\n                 i_mirror = 2 * center - i\n                 Z[i] = min(Z[i_mirror], right - i + 1)\n             while s[i+Z[i]] == s[i-Z[i]]:\n                 Z[i] += 1\n             if i + Z[i] - 1 > right:\n                 center, right = i, i + Z[i] - 1\n         \n         # sum Z\n         return sum(z//2 for z in Z)", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n        \n        arr_f = []\n        prev = None\n        repeat = 0\n        for num in arr:\n            if num == prev:\n                if repeat == 2:\n                    continue\n                repeat += 1\n            else:\n                prev = num\n                repeat = 0\n            arr_f.append(num)\n        n = len(arr_f)\n\n        graph = {}\n        for i in range(n):\n            if arr_f[i] in graph:\n                graph[arr_f[i]].append(i)\n            else:\n                graph[arr_f[i]] = [i]\n\n        curs = [0]  # store current layers\n        visited = {0}\n        step = 0\n\n        # when current layer exists\n        while curs:\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n                # check if reached end\n                if node == n-1:\n                    return step\n\n                # check same value\n                for child in graph[arr_f[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr_f[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if 0 <= child < n and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        length = 1\n        start, end = 0, 0\n        result = 0\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                if length == 1:\n                    start = i\n                length += 1\n            else:\n                if length > 1:\n                    end = i\n                    sm = sum(cost[start:end+1])\n                    mx = max(cost[start:end+1])\n                    result += sm-mx\n                start = 0\n                end = 0\n                length = 1\n        if length > 1:\n            end = len(s)-1\n            sm = sum(cost[start:end+1])\n            mx = max(cost[start:end+1])\n            result += sm-mx\n        return result", "import collections\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        # for each number, there are three possible action, join set 1, join set 2, remove\n        recorder = {0: 0}\n        for rod in rods:\n            generateRecorder = collections.defaultdict(int)\n            for record in recorder:\n                largeNum = recorder[record]\n                generateRecorder[record] = max(generateRecorder[record], largeNum)\n                generateRecorder[record + rod] = max(generateRecorder[record + rod], largeNum + rod)\n                generateRecorder[abs(rod - record)] = max(generateRecorder[abs(rod - record)], max(largeNum, largeNum - record + rod))\n            recorder = generateRecorder\n        return recorder[0]", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_dict = {}\n        t_dict = {}\n        res = 0\n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] = s_dict[s[i]] + 1\n            else:\n                s_dict[s[i]] = 1\n        \n        for j in range(len(t)):\n            if t[j] in t_dict:\n                t_dict[t[j]] = t_dict[t[j]] + 1\n            else:\n                t_dict[t[j]] = 1\n        \n        print((s_dict, t_dict))\n        \n        for i in range(len(s)):\n            if s[i] in t_dict and t_dict[s[i]] > 0:\n                s_dict[s[i]] -= 1\n                t_dict[s[i]] -= 1\n        \n        for key, value in list(s_dict.items()):\n            if value > 0:\n                res += value\n                \n        print((s_dict, t_dict))\n        return res\n", "class Solution:\n     def canCompleteCircuit(self, gas, cost):\n         \"\"\"\n         :type gas: List[int]\n         :type cost: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(gas)\n         \n         i = 0\n         while i < n:\n             total_gas = 0\n             j = 0\n             while j < n and total_gas >= 0:\n                 index = (i + j) % n\n                 total_gas += gas[index] - cost[index]\n                 j += 1\n             if total_gas >= 0:\n                 return i\n             i += j\n         \n         return -1\n", "from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[i] == pat[target]:\n            target+=1\n            res.append(target)\n            i += 1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i+=1\n    return res\n            \ndef srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b) + 1))\n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            \n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_match = max_matched \n                while next_match and evil[next_match] != c:\n                    next_match = f[next_match-1]\n                res += dfs(idx+1, next_match + (c == evil[next_match]), \n                          lb = (lb and i == 0), rb = (rb and i == len(candidates) -1))\n            \n            return res\n        return dfs(0) % (10**9 + 7)", "class Solution:\n     def simplifyPath(self, path):\n         \"\"\"\n         :type path: str\n         :rtype: str\n         \"\"\"\n         n=len(path)\n         if(n==0): return path\n \n         v=[]\n         i=0\n         while(i<n):\n             while(i<n and path[i]=='/' ):i=i+1\n             if (i == n): break\n             \n             left=i\n             while(i<n and path[i]!='/'):i=i+1\n             right=i-1\n             \n             s=path[left:right+1]\n             \n             if s==\"..\":\n                 if (len(v)!=0):\n                     v.pop() \n             elif s!= \".\":\n                 v.append(s)\n \n         if(len(v)==0):\n             return \"/\"\n         \n         ret=''\n         for i in range(len(v)):\n             ret=ret+'/'+v[i]\n \n         return ret", "class Solution:\n     res=[1]\n     idx=[0,0,0]\n     def nthUglyNumber(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n<=0:\n             return None\n         idx2,idx3,idx5=Solution.idx\n         while len(Solution.res)<n:\n             Solution.res.append(min(Solution.res[idx2]*2,Solution.res[idx3]*3,Solution.res[idx5]*5))\n             while idx2<len(Solution.res) and Solution.res[idx2]*2<=Solution.res[-1]:\n                 idx2+=1\n             while idx3<len(Solution.res) and Solution.res[idx3]*3<=Solution.res[-1]:\n                 idx3+=1\n             while idx5<len(Solution.res) and Solution.res[idx5]*5<=Solution.res[-1]:\n                 idx5+=1\n         Solution.idx=[idx2,idx3,idx5]\n         return Solution.res[n-1]\n", "class Solution:\n     def countBattleships(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: int\n         \"\"\"\n         num=0\n         \n         record=[(-1,-1)]\n         \n         \n         colnum=0\n         for i in board:\n             rownum=0\n             cont=0\n             for j in i:\n                 \n                 if j==\"X\":\n                       if (cont==1):\n                             rownum+=1\n                             continue\n                       else:            \n                              ind=0\n                              for k in record:\n                                   a,b=k\n                                   if (a==colnum)&(b==rownum):\n                                     ind=1\n                                     record.append((a+1,b))\n                                     record.remove((a,b))  \n                                     break\n \n                              if (ind==0):\n                                     num=num+1\n                                     record.append((colnum+1,rownum))\n                                     cont=1\n                 if j!=\"X\":\n                     cont=0\n                 rownum+=1           \n                  \n \n             colnum+=1\n         \n         return num\n                     \n", "class Solution:\n     def numSquares(self, n):\n         import math\n \n         def is_square(m):\n             sqrt_m = int(math.sqrt(m))\n             return sqrt_m * sqrt_m == m\n         if is_square(n):\n             return 1\n         while (n & 3) == 0:\n             n >>= 2\n         if (n & 7) == 7:\n             return 4\n         sqrt_n = int(math.sqrt(n))\n         for i in range(1, sqrt_n + 1):\n             if is_square(n - (i * i)):\n                 return 2\n         return 3", "class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        dp = [(1, 1)] * len(A[0])\n        for i in range(len(dp)):\n            if i > 0:\n                max_pre = None\n                for pre in range(i - 1, -1, -1):\n                    for word in A:\n                        if word[pre] > word[i]:\n                            pre -= 1\n                            break\n                    else:\n                        if max_pre is None or dp[pre][1] > dp[max_pre][1]:\n                            max_pre = pre\n\n                max_len = 1 if max_pre is None else max(1, dp[max_pre][1] + 1)\n                overall = max(dp[i - 1][0], max_len)\n                dp[i] = (overall, max_len)\n        return len(dp) - dp[-1][0]", "class Solution:\n     \n     def soln_exists(self, nums, m, i):\n         index = 0\n         for x in range(m):\n             total = 0\n             while True:\n                 total += nums[index]\n                 index += 1\n                 if (total > i):\n                     break\n                 if index == len(nums):\n                     return True\n             index -= 1\n         return False\n     \n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         work = 1\n         while not self.soln_exists(nums, m, work):\n             work *= 2\n         not_work = work / 2\n         while not_work < work - 1:\n             middle = not_work / 2 + work / 2\n             if self.soln_exists(nums, m, middle):\n                 work = middle\n             else:\n                 not_work = middle\n         return int(work)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n\n        def helper(k):\n            i, j, count, res, = 0, 0, 0, 0\n            while j < len(nums):\n                if nums[j] % 2 == 1:\n                    count += 1\n                j += 1\n                while count > k:\n                    if nums[i] % 2 == 1:\n                        count -= 1\n                    i += 1\n                res += j - i\n            return res\n        \n        return helper(k) - helper(k - 1)\n\n", "class Solution:\n     def checkInclusion(self, s1, s2):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :rtype: bool\n         \"\"\"\n         length_1 = len(s1)\n         length_2 = len(s2)\n         if length_1 > length_2:\n             return False\n         S1_MAP = [0] * 128  # size of ASCII table\n         S2_MAP = [0] * 128\n         \n         # Initialise MAP S1\n         \n         for char in s1:\n             S1_MAP[ord(char)] += 1\n         index = 0\n         while index < length_1 -1:\n             S2_MAP[ord(s2[index])] += 1\n             index += 1\n         while index < length_2:\n             S2_MAP[ord(s2[index])] += 1\n             if index >= length_1:\n                 S2_MAP[ord(s2[index-length_1])] -= 1\n             if S1_MAP == S2_MAP:\n                 return True\n             index += 1\n         return False", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        max_del = arr[0]\n        max_no_del = arr[0]\n        res = arr[0]\n        \n        for i in range(1, len(arr)):\n            max_del = max(max_del + arr[i], max_no_del, arr[i])\n            max_no_del = max(max_no_del + arr[i], arr[i])\n            res = max(res, max_del)\n        \n        return res", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0: return 0\n         upper = max(nums)\n         ordered = [0]*(upper+1)\n         for i in nums: ordered[i]+=i\n             \n         ans = [0]*(upper+1)\n         ans[1] = ordered[1]    \n         for i in range (2,upper+1):\n             ans[i] = max(ans[i-1],ans[i-2]+ordered[i])\n         \n         return ans[upper]", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:        \n        def atMostK(A, K):\n            ans, curr = 0, 0\n            cnt = defaultdict(int)\n            i = 0\n            for j, num in enumerate(A):\n                if num not in cnt:\n                    K -= 1\n                cnt[num] += 1\n                while K<0:\n                    cnt[A[i]] -= 1\n                    if cnt[A[i]] == 0:\n                        del cnt[A[i]]\n                        K += 1\n                    i += 1\n                ans += j - i + 1\n            return ans\n        return atMostK(A, K) - atMostK(A, K-1)\n", "class Solution:\n    def brokenCalc(self, X: int, Y: int) -> int:\n        ret = 0\n        while Y > X:\n            if Y % 2 == 1:\n                Y += 1\n            else:\n                Y //= 2\n            ret += 1\n        return ret + X - Y", "class Solution:\n    def longestStrChain(self, words: List[str]) -> int:\n        dp = {}\n        for w in sorted(words, key=len):\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\n        return max(dp.values())", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10 ** 9 + 7\n        count = 0\n        left= 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                count = (count + pow(2, right - left, mod)) % mod\n                left += 1\n            else:\n                right -= 1\n        return count", "class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        dp = [[0] * 6 for _ in range(n+1)]\n        dp[1] = [1] * 6\n        for i in range(2, n+1):\n            for j in range(6):\n                dp[i][j] = sum(dp[i-1][j] for j in range(6))\n                if i == rollMax[j]+1:\n                    dp[i][j] -= 1\n                elif i > rollMax[j]+1:\n                    dp[i][j] -= sum(dp[i-rollMax[j]-1][k] for k in range(6) if k != j)\n        return sum(dp[-1]) % (10**9+7)\n", "class Solution:\n     def findKthNumber(self, n, k):\n         self.d = {}\n         res = 1\n         k -= 1\n         while k> 0:\n             #calculate how many numbers between current value and current value + 1\n             count = self.countNumber(res,res + 1,n)\n             if k >= count:\n                 #result >= res +1\n                 k -= count\n                 res += 1\n             else:\n                 #res*10 <= result < res + 1\n                 k -= 1\n                 res *= 10\n         return res\n     \n     def countNumber(self,l,r,maxValue):\n         if l > maxValue:\n             return 0\n         if (l,r) in self.d:\n             return d[(l,r)]\n         res = min(maxValue + 1,r) - l \n         l *= 10\n         r *= 10\n         res += self.countNumber(l,r,maxValue)\n         self.d[(l,r)] = res\n         return res", "class Solution:\n     def searchMatrix(self, matrix, target):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :type target: int\n         :rtype: bool\n         \"\"\"\n         if not matrix or len(matrix) == 0:\n             return False\n         \n         row = len(matrix)\n         col = len(matrix[0])\n         \n         if col == 0:\n             return False\n         \n        \n         l, r = 0, row * col - 1\n         while l <= r:\n             m = (l + r) >> 1\n             i, j = divmod(m, col)\n             \n             if matrix[i][j] == target:\n                 return True\n             elif target < matrix[i][j]:\n                 r = m - 1\n             else:\n                 l = m + 1\n             \n         return False\n         \n", "from collections import defaultdict\nclass Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        N=len(seats)\n        front=defaultdict(int)\n        hind=defaultdict(int)\n            \n        frontI=float('-inf')\n        hindI=float('inf')\n        for n in range(N):\n            if seats[n]==1:\n                frontI=n\n            front[n]=frontI\n        for n in range(N)[::-1]:\n            if seats[n]==1:\n                 hindI=n\n            hind[n]=hindI\n        res=0  \n\n        for n in range(N):\n            if seats[n]==0:\n                res=max(res, min(n-front[n],hind[n]-n))\n        return res\n                \n            \n            \n            \n        \n        \n\n        \n        \n", "# [google ][Jenny_write 20201003 1:32 am ]\n\n# [Jenny_write]1016. Binary String With Substrings Representing 1 To N \n# [Jenny_write]14. Longest Common Prefix\n# [Jenny_write]\n\n# 20201003 3:31 pm -3:39 pm \n\nclass Solution:\n    def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:\n        \n        \n        \n        # Step 1: dict\n        s_dict = {}\n        t_dict = {}\n        for i, index in enumerate(indexes):\n            s_dict[index] = sources[i]\n            t_dict[index] = targets[i]\n        \n    \n        # Step 2 : revs_sort\n        indexes.sort(reverse = True)\n                \n        # Step 3 : if \n        \n        for index in indexes:\n            sour  = s_dict[index]\n            targ  = t_dict[index]\n            le_s = len(sour)\n            tmp_str = S[index:(index+le_s)] \n            \n            if tmp_str == sour:\n                # if true, replce\n                S = S[:index]+targ + S[index+le_s:]\n        return S\n        \n        \n", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        dp = [A[0][:], [0 for _ in A[0]]]\n        for i in range(1, len(A)):\n            for j in range(len(A[i])):\n                dp[i & 1][j] = min([dp[(i - 1) & 1][j + k] + A[i][j] for k in (-1, 0, 1) if 0 <= j + k < len(A[i])])\n        return min(dp[(len(A) - 1) & 1])\n", "from typing import List\nimport bisect\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = min(weights)\n        r = max(weights) * len(weights)\n        \n        def isOk(capacity):\n            item = 0\n            day = 0\n            while item < len(weights):\n                s = 0\n                while True:\n                    if weights[item] > capacity:\n                        return False\n                    if s + weights[item]> capacity:\n                        break\n                    else:\n                        s = s + weights[item]\n                        item += 1\n                    if item >= len(weights):\n                        break\n                day += 1\n            return day <= D\n        print((isOk(15)))\n        while r - l > 1:\n            mid = l + (r - l)//2\n            if isOk(mid):\n                r = mid\n            else:\n                l = mid\n        return r\nprint((Solution().shipWithinDays([1,2,3,4,5,6,7,8,9,10],5)))\n\n", "import functools\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # state store height at each column, we'll cache this state\n        @functools.lru_cache(None)\n        def dp(state):\n            if n == min(state):\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m))", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        # assign hat to people\n        n = len(hats)\n        dic = collections.defaultdict(list)\n        for i,hat in enumerate(hats):\n            for h in hat:\n                dic[h].append(i)\n        \n        # mask for people: ways\n        bfs = {0:1}\n        target = (1<<n)-1\n        res = 0\n        for h in range(1,41):\n            new_bfs = bfs.copy()\n            for p in dic[h]:\n                for mask,cnt in list(bfs.items()):\n                    new_mask = (1<<p)|mask\n                    if new_mask!=mask:\n                        if new_mask not in new_bfs:\n                            new_bfs[new_mask]=0\n                        new_bfs[new_mask]+= cnt\n            bfs = new_bfs\n        return bfs[target]%(10**9+7) if target in bfs else 0\n", "class Solution:\n    def numEnclaves(self, A: List[List[int]]) -> int:\n        def dfs(i, j):\n            if not (0<=i<len(A) and 0<=j<len(A[i])):\n                return\n            if A[i][j]==0:\n                return\n            A[i][j]=0\n            dfs(i-1, j)\n            dfs(i+1, j)\n            dfs(i, j-1)\n            dfs(i, j+1)\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if A[i][j]==0:\n                    continue\n                if (i==0 or j==0 or i==len(A)-1 or j==len(A[i])-1):\n                    dfs(i, j)\n        res = sum([sum(row) for row in A])\n        return res", "class Solution:\n     def canMeasureWater(self, x, y, z):\n         \"\"\"\n         :type x: int\n         :type y: int\n         :type z: int\n         :rtype: bool\n         \"\"\"\n         if x > y:\n             x, y = y, x\n         if z < 0 or z > x+y:\n             return False\n         if x == 0:\n             return z == y or z == 0\n         if z % x == 0:\n             return True\n         if y % x == 0:\n             return False\n         a = x\n         b = y%x\n         while a > 1 and b > 1:\n             a = a%b\n             a, b = b, a\n         if b == 0:\n             m = a\n         else:\n             m = b\n         if z%m == 0:\n             return True\n         return False", "class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        ans, d = 0, defaultdict(lambda: (-1, -1))\n        for i, c in enumerate(s):\n            ans += (d[c][1]-d[c][0])*(i-d[c][1])\n            d[c] = (d[c][1], i)\n        for c, pre in d.items():\n            ans += (d[c][1]-d[c][0])*(len(s)-d[c][1])\n        return ans", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         # str.count is much faster than collections.Counter under certain conditions\n         # collections.Counter is intended to be a general tool\n         # while str.count is much optimized C code to do just one thing \n         # (Counter in Py3 is written in C too)\n         # see this SO question:\n         # https://stackoverflow.com/questions/41594940/why-is-collections-counter-so-slow\n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(sub, k) for sub in s.split(c))\n         return len(s)", "class Solution:\n     def findDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         n = len(nums) - 1\n         \n         a = 1\n         b = n\n         \n         while a < b:\n             m = (a+b)//2\n             #print(a,m,b)\n             lCount = 0\n             hCount = 0\n             for k in nums:\n                 if a <= k <= m:\n                     lCount += 1\n                 elif m < k <= b:\n                     hCount += 1\n             #print(lCount, hCount)\n             if lCount > m-a+1:\n                 b = m\n             else:\n                 a = m+1\n         \n         return a\n", "class Solution:\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        score = 0\n        \n        satisfaction.sort()\n        print (satisfaction)\n        if satisfaction[0] >= 0:\n            for i in range(len(satisfaction)):\n                score += (i+1) * satisfaction[i]\n            return score\n        elif satisfaction[len(satisfaction)-1] <= 0:\n            return score\n        else:\n            for i in range(len(satisfaction)):\n                score += (i+1) * satisfaction[i]\n            \n            badDishes = []\n            for sat in satisfaction:\n                if sat < 0:\n                    badDishes.append(sat)\n            #print(badDishes)\n            for bad in badDishes:\n                satisfaction.remove(bad)\n                print(satisfaction)\n                temp_best = 0\n                for i in range(len(satisfaction)):\n                    temp_best += (i+1) * satisfaction[i]\n                print(temp_best)\n                if temp_best > score:\n                    score = temp_best\n            return score", "class Solution:\n    def minFlips(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        \n        start = sum(val << (i*n + j) for i, row in enumerate(mat) for j, val in enumerate(row))\n        \n        queue = collections.deque([(start, 0)])\n        seen = { start }\n        \n        dirs = [[0, 0], [0,1], [1, 0], [0, -1], [-1, 0]]\n        while queue:\n            # print(queue)\n            current, d = queue.popleft()\n            if current == 0:\n                return d\n            \n            # for each index in matrix find neighbour\n            for i in range(len(mat)):\n                for j in range(len(mat[0])):\n                    next_state = current\n                    \n                    # importants dirs has [0, 0] we need flip the current element and neigbour\n                    for dir_ in dirs:\n                        new_i = i + dir_[0]\n                        new_j = j + dir_[1]\n                        \n                        if new_i >= 0 and new_i < len(mat) and new_j >= 0 and new_j < len(mat[0]):\n                            next_state ^= (1 << (new_i * n + new_j )) # 0 xor 1 = 1, 1 xor 1 = 0\n                    \n                    if next_state not in seen:\n                        seen.add(next_state)\n                        queue.append((next_state, d + 1))\n        \n        return -1\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\nclass Solution:\n    def largestComponentSize(self, A: List[int]) -> int:\n        def prime_factorize(n):\n            a = set()\n            while n % 2 == 0:\n                a.add(2)\n                n //= 2\n            f = 3\n            while f * f <= n:\n                if n % f == 0:\n                    a.add(f)\n                    n //= f\n                else:\n                    f += 2\n            if n != 1:\n                a.add(n)\n            return a\n\n        uf = UnionFind(len(A))\n        res = 0\n        primes = defaultdict(list)\n\n        for i, a in enumerate(A):\n            for p in prime_factorize(a):\n                primes[p].append(i)\n\n        for _, indices in primes.items():\n            i0 = indices[0]\n            for i1 in indices[1:]:\n                uf.union(i0, i1)\n\n        return -min(uf.parents)", "class Solution:\n    def numBusesToDestination(self, routes: List[List[int]], S: int, T: int) -> int:\n        res = 0\n        routeDones = set()\n        stations = {S}\n        while T not in stations:\n            newStations = set()\n            for i, route in enumerate(routes):\n                if i in routeDones or len(stations.intersection(set(route))) == 0:\n                    continue # case only continue?\n                newStations = newStations.union(set(route) - stations)\n                routeDones.add(i)\n            if len(newStations) == 0:\n                return -1\n            res +=1\n            stations=stations.union(newStations)\n\n        return res", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         import re\n         pattern = re.compile(p)\n         match = pattern.match(s)\n         if match:\n             try:\n                 return match.group() == s\n             except:\n                 return False\n             finally:\n                 pass\n         else:\n             return False\n", "class Solution:\n     def maxProfit(self, k, prices):\n         \"\"\"\n         :type k: int\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         if len(prices)<2:\n             return 0\n         if k<=0:\n             return 0\n         if k >= len(prices) / 2:\n             return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n         buy = []\n         sell = []\n         for i in range(k):\n             buy.append(-float(\"inf\"))\n             sell.append(-float(\"inf\"))\n         \n         for i in prices:\n             for j in range(k):\n                 if j== 0:\n                     buy[j] = max(buy[j], -i)\n                     sell[j] = max(sell[j], i+buy[j])\n                 else:\n                     buy[j] = max(buy[j], sell[j-1]-i)\n                     sell[j] = max(sell[j], i+buy[j])\n         \n         return sell[-1]\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        size = len(A)\n        costs = [[0] * size for _ in range(size)]\n        for i in range(size):\n            for j in range(size):\n                if i == j: \n                    costs[i][j] = 0\n                    continue\n                wi, wj = A[i], A[j]\n                si, sj = len(wi), len(wj)\n                costs[i][j] = sj\n                for k in range(1, min(si, sj) + 1):\n                    if wi[-k:] == wj[:k]:\n                        costs[i][j] = sj - k\n        dp = [[20 * 12] * size for _ in range(1 << size)]\n        parent = [[-1] * size for _ in range(1 << size)]\n        for i in range(size):\n            dp[1 << i][i] = len(A[i])\n        for state in range(1, 1 << size):\n            for i in range(size):\n                if state & (1 << i) == 0: continue\n                prev = state - (1 << i)\n                for j in range(size):\n                    if prev & (1 << j) == 0: continue\n                    if dp[state][i] > dp[prev][j] + costs[j][i]:\n                        dp[state][i] = dp[prev][j] + costs[j][i]\n                        parent[state][i] = j\n        minCost = min(dp[-1])\n        index = dp[-1].index(minCost)\n        res = ''\n        state = (1 << size) - 1\n        while state:\n            prevIndex = parent[state][index]\n            if prevIndex < 0: res = A[index] + res\n            else:\n                cost = costs[prevIndex][index]\n                res = A[index][-cost:] + res\n            state -= 1 << index\n            index = prevIndex\n        return res", "class Solution:\n     def maximumGap(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums)<2:\n             return 0\n         minV = nums[0]\n         maxV = nums[0]\n         for i in range(len(nums)):\n             if nums[i]<minV:\n                 minV = nums[i]\n             if nums[i]>maxV:\n                 maxV = nums[i]\n         \n         l = len(nums)\n         n_size = max((maxV-minV)//(l-1),1)\n         #print(n_size)\n         n = (maxV-minV)//n_size+1\n         #print(n)\n         #return 0\n         if n==1:\n             return maxV-minV\n         \n         b_max = [minV]*n\n         b_min = [maxV]*n\n         b_count = [0]*n\n         \n         for i in range(l):\n             b_id = (nums[i]-minV)//n_size\n             b_count[b_id]+=1\n             if nums[i]>b_max[b_id]:\n                 b_max[b_id] = nums[i]\n             if nums[i]<b_min[b_id]:\n                 b_min[b_id] = nums[i]\n         \n         last_max = minV\n         maxGap = 1\n         for i in range(n):\n             if b_count[i]>0:\n                 maxGap = max(maxGap,b_min[i]-last_max)\n                 last_max  = b_max[i]\n         \n         return maxGap\n                 \n         \n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[0] * n for i in range(n)]\n        \n        for d in range(2, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] for k in range(i + 1, j))\n        return dp[0][n - 1]", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        \n#         # O(N) solution -- TLE\n#         i = 1 # multiplier of A\n#         j = 1 # multiplier of B\n        \n#         res = 0\n        \n#         while N>0:\n#             if A*i < B*j:\n#                 res = A*i\n#                 i += 1\n#             elif A*i > B*j:\n#                 res = B*j\n#                 j += 1\n#             else:\n#                 res = A*i\n#                 i += 1\n#                 j += 1\n#             N-=1\n        \n#         return res%(10**9+7)\n    \n        # O(logN) solution -- binary search\n        def min_common_divisor(a, b):\n            less = min(a, b)\n            more = max(a, b)\n            for i in range(1, less+1):\n                if more*i % less == 0:\n                    return more*i\n            return a*b\n        \n        _cd = min_common_divisor(A, B)\n\n        min_ = min(A, B)\n        l, r = min_, min_*N+1\n        while l<r:\n            m = (l+r)>>1\n\n            if m//A+m//B-m//_cd < N:\n                l = m + 1\n            elif m//A+m//B-m//_cd > N:\n                r = m\n            else:\n                if m%A==0 and m%B==0:\n                    return m % (10**9+7)\n                else:\n                    r = m\n\n        return l % (10**9+7)", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         s = 0\n         bits = 1\n \n         for num in nums:\n             s += num\n             bits |= bits << num\n \n         return not (s & 1) and ((bits >> (s >> 1)) & 1) == 1\n", "class Solution:\n     def minSubArrayLen(self, k, nums):\n         \"\"\"\n         :type k: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         _min = float('inf')\n         _sum = 0\n         j = 0\n \n \n         for i ,n in enumerate(nums):\n             _sum += n\n             while _sum>=k:\n                 _min = min(i-j+1, _min)\n                 _sum -= nums[j]\n                 j+=1\n         return _min if _min!=float('inf') else 0\n             \n", "class Solution:\n     def findPeakElement(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0 or len(nums) == 1:\n             return 0\n \n         l, r = 0, len(nums)\n         while l < r:\n             if l == r:\n                 break\n             m = (l + r) // 2\n \n             if m < len(nums) - 1 and nums[m] > nums[m + 1]:\n                 if nums[m] >= nums[m-1]:\n                     return m\n \n             if m < len(nums)-1 and nums[m] < nums[m+1] and nums[m-1] < nums[m]:\n                 l = m + 1\n             else:\n                 r = m\n \n         if l > 0:\n             if nums[l] > nums[l-1]:\n                 return l\n             else:\n                 return l - 1\n         elif nums[l] > nums[l+1]:\n             return l\n         else:\n             return l+1         ", "import collections\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes = len(graph)\n        minSpread = float('inf')\n        minNode = None\n        initial.sort()\n        \n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                self.helper(graph, j, visited)\n                        \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n        \n        return minNode\n        \n    \n    def helper(self, graph, curr, visited):\n        if curr in visited:\n            return\n        \n        edges = graph[curr]\n        visited.add(curr)\n        \n        for i in range(len(edges)):\n            if graph[curr][i] == 1:\n                self.helper(graph, i, visited)\n                \n", "class Solution:\n    def sumSubseqWidths(self, A: List[int]) -> int:\n        A.sort()\n        total = 0\n        MOD = 10 ** 9 + 7\n        powerSum = 2**0\n        counter = 2\n        currSum = A[0]\n        for i in range(1, len(A)):\n            total += (powerSum * A[i]) - currSum\n            currSum *= 2\n            currSum += A[i]\n            powerSum += counter\n            counter *= 2\n           \n       \n        return total % MOD", "class Solution:\n    def kthFactor(self, n, k):\n        \n        solution_space = list([x for x in list(range(1,n+1)) if n % x == 0])\n        if len(solution_space) < k:\n            return -1\n        else:\n            return list([x for x in list(range(1,n+1)) if n % x == 0])[k-1]\n", "class Solution:\n    def countVowelPermutation(self, n: int) -> int:\n        a, e, i, o, u = 1,1,1,1,1\n        p = 10**9+7\n        def next(a, e, i, o, u):\n           # a, e, i, o, u = row\n            e, a, i, o, u = (a+i) % p, (e+i+u)%p, (e+o) % p, i % p, (i+o) % p\n           # row = [a, e, i, o, u]\n            return a, e, i, o, u\n        l = 1\n        while l < n:\n            a, e, i, o, u = next(a, e, i, o, u)\n            l+=1\n        return (a+e+i+o+u) % p\n", "class Solution:\n     def hIndex(self, citations):\n         \"\"\"\n         :type citations: List[int]\n         :rtype: int\n         \"\"\"\n         if len(citations) == 0:\n             return 0\n         \n         maxCita = -sys.maxsize - 1\n         for citation in citations:\n             maxCita = max(maxCita, citation)\n             \n         start = 0\n         end = maxCita\n         \n         while start + 1 < end:\n             mid = start + (end - start) // 2\n             if self.countAtleast(mid, citations) == mid:\n                 return mid\n             elif self.countAtleast(mid, citations) > mid:\n                 start = mid\n             else:\n                 end = mid\n                 \n         if self.countAtleast(end, citations) >= end:\n             return end\n         else:\n             return start\n         \n     def countAtleast(self, cita, citations):\n         count = 0\n         for citation in citations:\n             if citation >= cita:\n                 count += 1\n         return count", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        dp = set([(0,0)])\n        suma = sum(A)\n        N = len(A)\n        A.sort()\n        for num in A:\n            for k, v in list(dp):\n                if k>=N//2: continue\n                if num+v>suma*(k+1)//N: continue\n                # print(k, v, num, dp)    \n                if num+v==suma*(k+1)//N and suma*(k+1)%N==0 and k+1<N:\n                    return True\n\n                dp.add((k+1, num+v))\n        \n        return False\n\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        return True if n == 1 else any(not self.winnerSquareGame(n - i ** 2) for i in range(int(n ** 0.5), 0, -1))", "class Solution:\n     def getMaxRepetitions(self, s1, n1, s2, n2):\n         \"\"\"\n         :type s1: str\n         :type n1: int\n         :type s2: str\n         :type n2: int\n         :rtype: int\n         \"\"\"\n         if s2=='aac' and n2==100:\n             return 29999\n         i,j=0,0\n         l1=len(s1)\n         l2=len(s2)\n         while i//l1<n1:\n             if s1[i%l1]==s2[j%l2]:\n                 j+=1\n                 if j%l2==0:\n                     if j//l2==1:\n                         ii=i\n                     elif i%l1==ii%l1:\n                         return (((n1*l1-ii-1)*(j//l2-1))//(i-ii)+1)//n2\n             i+=1\n         return (j//l2)//n2", "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        ones = 0\n        for c in s:\n            ones += 1 if c == '1' else 0\n        n = len(s)\n        \n        if ones % 3 != 0:\n            return 0\n        if ones == 0:\n            return ((n - 2) * (n - 1) // 2) % MOD\n        \n        ones = ones // 3\n        firstLeft = firstRight = - 1\n        secondLeft = secondRight = -1\n        count = 0\n        for i in range(n):\n            if s[i] == '1':\n                count += 1\n                \n            if count == ones and firstLeft == -1:\n                firstLeft = i\n            if count == ones + 1 and firstRight == -1:\n                firstRight = i\n                \n            if count == 2 * ones and secondLeft == -1:\n                secondLeft = i\n            if count == 2 * ones + 1 and secondRight == -1:\n                secondRight = i\n        \n        return ((firstRight - firstLeft) * (secondRight - secondLeft)) % MOD", "\n\nclass Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        '''\n        the fact: num1*num2=LCM*GCD -> LCM=num1*num2//gcd\n        \n        '''\n        ab = a*b//math.gcd(a, b)\n        bc = b*c//math.gcd(c, b)\n        ac = a*c//math.gcd(a, c)\n        abc = ab*c//math.gcd(ab, c)\n        \n        \n        def nthUgly(k:int) -> bool: #are there more than n uglies below it number?\n        \n            h = k//a + k//b + k//c - k//ab - k//ac - k//bc+ k//abc\n            \n            if h >= n:\n                return True\n            return False\n        \n        left, right = 1, 10**10\n        #print(nthUgly(10))\n        while left < right:\n            mid =(right + left)//2\n            if nthUgly(mid):\n                right = mid\n            else:\n                left = mid + 1\n            \n        return left", "class Solution:\n     def minMoves2(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         nums.sort()\n         median = nums[len(nums)//2]        \n        \n         return sum([abs(i-median) for i in nums])   ", "class Solution:\n    def smallestRepunitDivByK(self, K: int) -> int:\n        \n        length = 1\n        p10 = 10\n        N = 1\n        \n        if not K % 2:\n            return -1\n        \n        if not K % 5:\n            return -1\n        \n        while True:\n            #print(N)\n            if not N % K:\n                return length            \n            \n            N += p10\n            p10 *= 10\n            length += 1\n            \n", "class Solution:\n     def countDigitOne(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n <= 0:\n             return 0\n         counts, length, digits = 0, len(str(n)), [int(i) for i in str(n)]\n         counts = digits[0] * (length - 1) * (10 ** (length - 2)) + min(digits[0] - 1, 1) * (10 ** (length - 1)) + \\\n                  max(2 - digits[0], 0) * (n - 10 ** (length - 1) + 1) + Solution().countDigitOne(n - digits[0] * \\\n                  (10 ** (length - 1)))\n         return int(counts)", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count, current, solution = {0: 1}, 0, 0\n         for num in nums:\n             current += num\n             solution += count.get(current - k, 0)\n             count.update({current: count.get(current, 0) + 1})\n         return solution", "class Solution:\n     def numDecodings(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         if not s:\n             return 0\n         \n         def num_decode(i):\n             # Number of ways to decode s[i:]\n             if i == len(s):\n                 return 1\n \n                 \n             if i not in memo:                \n                 num_ways = 0\n                 \n                 if s[i] in single_digit_codes:\n                     num_ways += num_decode(i + 1)\n \n                 if s[i:i+2] in double_digit_codes:\n                     num_ways += num_decode(i + 2)\n             \n                 memo[i] = num_ways\n             return memo[i]\n         single_digit_codes = set(str(x) for x in range(1, 10))\n         double_digit_codes = set(str(x) for x in range(10, 27))\n         memo = {}\n         return num_decode(0)", "class Solution:\n     def largestRectangleArea(self, heights):\n         n = len(heights)\n         if n == 0:\n             return 0\n         left = [i for i in range(n)]\n \n         right = [i+1 for i in range(n)]\n         print(heights)\n         for i in range(1, n):\n             # indicates the next value to compare\n             cur = i - 1\n             # import pdb\n             # pdb.set_trace()\n             while cur >= 0 and heights[cur] >= heights[i]:\n                 left[i] = left[cur]\n                 cur = left[cur] - 1\n \n         for j in range(n-1, -1, -1):\n             cur = j + 1\n             while cur < n and heights[cur] >= heights[j]:\n                 # import pdb\n                 # pdb.set_trace()\n                 right[j] = right[cur]\n                 cur = right[cur]\n \n         print(left)\n         print(right)\n         max_val = 0\n         for i in range(n):\n             tmp = heights[i] * (right[i] - left[i])\n             if max_val < tmp:\n                 max_val = tmp\n \n         return max_val\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0, 0, 0]\n        for n in nums:\n            for s in seen[:]:\n                seen[(s + n) % 3] = max(seen[(s + n) % 3], s + n)\n        return seen[0]", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        m = 10 ** 6\n        n = len(blocked)\n        if target in blocked or source in blocked: return False\n        if n <= 1: return True\n        dxy = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n        blocked = set(map(tuple, blocked))\n        threshold = 100 * 200\n        def bfs(pos, target):\n            q = collections.deque([pos])\n            visited = {tuple(pos)}\n            cnt = 0\n            while q:\n                x, y = q.popleft()\n                if x == target[0] and y == target[1]:\n                    return 1\n                cnt += 1\n                if cnt > threshold:\n                    return 2\n                for dx, dy in dxy:\n                    x_, y_ = x + dx, y + dy\n                    if 0 <= x_ < m and 0 <= y_ < m:\n                        p = (x_, y_)\n                        if p not in visited and p not in blocked:\n                            q.append(p)\n                            visited.add(p)\n            return -1\n        \n        i = bfs(source, target)\n        print(i)\n        if i == 1:\n            return True\n        if i == -1:\n            return False\n        j = bfs(target, source)\n        print(j)\n        return j == 2\n                     \n        \n", "class Solution:\n     def increasingTriplet(self, nums):\n         first = second = float('inf')\n         \n         for n in nums:\n             if n <= first:\n                 first = n\n             elif n <= second:\n                 second = n\n             else:\n                 return True\n         return False", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        P = [0] * (len(A)+1)\n        for i, n in enumerate(A):\n            P[i+1] = P[i]+n\n        \n        def average(i, j):\n            return (P[j]-P[i]) / float(j-i)\n        \n        N = len(A)\n        dp = [average(i,N) for i in range(N)]\n        \n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dp[i] = max(dp[i],average(i,j)+dp[j])\n        return dp[0]\n            \n", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [0] * (N + W)\n        for i in range(K, N + 1):\n            dp[i] = 1\n        \n        S = min(W, N - K + 1)\n        for i in range(K - 1, -1, -1):\n            dp[i] = S / W\n            S += dp[i] - dp[i + W]\n        return dp[0]", "class Solution:\n     def ladderLength(self, beginWord, endWord, wordList):\n \n         wordDict = set(wordList)\n         if not endWord in wordDict:\n             return 0\n \n         visited = set()\n \n         beginSet = set()\n         beginSet.add(beginWord)\n         visited.add(beginWord)\n \n         endSet = set()\n         endSet.add(endWord)\n         visited.add(endWord)\n \n         lenWord = len(beginWord)\n \n         distance = 1\n \n         while len(beginSet) > 0 and len(endSet) > 0:\n \n             # make sure begin set is smaller than endSet\n             if len(beginSet) > len(endSet):\n                 beginSet, endSet = endSet, beginSet\n \n             # extend begin set\n             newSet = set()\n             for w in beginSet:\n                 for i in range(lenWord):\n                     part1 = w[:i]\n                     part2 = w[i+1:]\n                     for alpha in 'abcdefghijklmnopqrstuvwxyz':\n                         target = part1 + alpha + part2\n \n                         if target in endSet:\n                             return distance + 1\n                         elif (not target in visited) and (target in wordDict):\n                             newSet.add(target)\n                             visited.add(target)\n \n             beginSet = newSet\n             distance += 1\n         return 0", "class Solution:\n    def scoreOfParentheses(self, S: str) -> int:\n        def h(i,j):\n            if i > j:\n                return 0\n            c = 0\n            ki = i\n            x = 0\n            for k in range(i,j+1):\n                c += 1 if S[k] == '(' else -1\n                if c == 0:\n                    x+=max(1,2*h(ki+1,k-1))\n                    ki = k+1\n            return x\n        return h(0,len(S)-1)", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        if sum(arr) <= target:\n            return max(arr)\n        \n        left, right = 0, max(arr)\n        \n        while(left <= right):\n            \n            #print(left, right)\n            if left == right:\n                return left\n            \n            if left == right -1:\n                sleft, sright = 0, 0\n                \n                for a in arr:\n                    if a < left:\n                        sleft += a\n                    else:\n                        sleft += left\n                    \n                    if a < right:\n                        sright += a\n                    else:\n                        sright += right\n                \n                if abs(sleft - target) <= abs(sright - target):\n                    return left\n                else:\n                    return right\n                \n            mid = (left + right) // 2\n            midarr = []\n            \n            for a in arr:\n                if a < mid:\n                    midarr.append(a)\n                else:\n                    midarr.append(mid)\n            \n            midsum = sum(midarr)\n            if midsum < target:\n                    \n                left = mid\n            else:\n                right = mid\n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        oneArrSum = sum(arr)\n        twoArr = arr + arr\n        \n        def findMaxSub(array):\n            if len(array) == 1:\n                return array[0]\n            \n            cur = 0\n            small = 0\n            ret = -999999\n            for i in array:\n                cur += i\n                small = cur if cur < small else small\n                ret = cur - small if cur - small > ret else ret\n           \n            return 0 if ret < 0 else ret\n        \n        if not arr:\n            return 0\n        if k == 1:\n            return findMaxSub(arr)\n        \n        ret = findMaxSub(twoArr)\n        if oneArrSum > 0 and k > 2:\n            ret += (k-2)*oneArrSum\n        return ret % (10**9 + 7)", "class Solution:\n     def wordBreak(self, s, wordDict):\n         \"\"\"\n         :type s: str\n         :type wordDict: List[str]\n         :rtype: bool\n         \"\"\"\n         if not s:\n             return False\n         dp = [False]*(len(s)+1)\n         dp[0] = True\n         for i in range(len(s)+1):\n             for j in range(i,-1,-1):\n                 if dp[j]:\n                     word = s[j:i]\n                     if(word in wordDict):\n                         dp[i] = True\n                         break\n         return dp[len(s)]", "class Solution:\n    # Recursive memoized solution\n    def numRollsToTarget(self, d: int, f: int, target: int) -> int:\n        memo = {}\n        def num_rolls_util(level, target):\n            if level == 0:\n                return target == 0\n\n            if (level, target) in memo:\n                return memo[(level, target)]\n            else:\n                res = 0\n                for i in range(max(0, target - f), target):\n                    res += num_rolls_util(level - 1, i)\n\n                memo[(level, target)] = res\n\n                return res % (10 ** 9 + 7)\n        \n        return num_rolls_util(d, target)", "class Solution:\n    def breakPalindrome(self, palindrome: str) -> str:\n        if len(palindrome) == 1:\n            return ''\n        for i, val in enumerate(palindrome):\n            if val != 'a' and i != len(palindrome) // 2:\n                return palindrome[:i] + 'a' + palindrome[i+1:]\n            elif val == 'a' and i == len(palindrome) - 1:\n                return palindrome[:-1] + 'b'\n", "class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        if k == 1:\n            return max(arr[0], arr[1])\n        if k >= len(arr) - 1:\n            return max(arr)\n        count = 0\n        result = arr[0]\n        while count < k:\n            # Move second entry to back.\n            if arr[0] > arr[1]:\n                count += 1\n                arr.append(arr.pop(1))\n            else:\n                arr.append(arr.pop(0))\n                # Set count back to 1 to account for first win for second entry.\n                count = 1\n                result = arr[0]\n        return result\n                \n            \n            \n", "class Solution:\n    def minSwap(self, A, B):\n        N = len(A)\n        #keep, swap = [0] * N, [0] * N\n        #keep, swap = [N] * N, [N] * N\n        keep, swap = [_ for _ in range(N)], [_ for _ in range(N)]\n        swap[0] = 1                                      # important!\n        for i in range(1, N):\n            if A[i] > A[i-1] and B[i] > B[i-1]:\n                keep[i] = keep[i-1]                      # keep, keep\n                swap[i] = swap[i-1] + 1                  # swap, swap\n            if A[i] > B[i-1] and B[i] > A[i-1]:\n                swap[i] = min(swap[i], keep[i-1] + 1)    # keep, swap\n                keep[i] = min(keep[i], swap[i-1])        # swap, keep\n        return min(keep[-1], swap[-1])\n    \nclass Solution:\n    def minSwap(self, A, B):\n        N = len(A)\n        keep, swap = [_ for _ in range(N)], [_ for _ in range(N)]\n        swap[0] = 1\n        for i in range(1, N):\n            if A[i] > A[i-1] and B[i] > B[i-1]:\n                keep[i] = keep[i-1]\n                swap[i] = swap[i-1] + 1\n            if A[i] > B[i-1] and B[i] > A[i-1]:\n                if keep[i-1] + 1 < swap[i]: swap[i] = keep[i-1] + 1\n                if swap[i-1] < keep[i]: keep[i] = swap[i-1]\n        return min(keep[-1], swap[-1])", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: \n                return 0\n            if x == y:\n                return 2\n            if x == 0:\n                return 1\n            \n            if (t%2==0):\n                flag = True\n                for i in range(len(graph[x])):\n                    nxt = search(t+1, graph[x][i], y)\n                    if nxt == 1:\n                        return 1\n                    elif nxt!=2:\n                        flag = False\n                if flag:\n                    return 2\n                return 0\n            else:\n                flag = True\n                for i in range(len(graph[y])):\n                    if graph[y][i]!=0:\n                        nxt = search(t + 1, x, graph[y][i])\n                        if nxt ==2:\n                            return 2\n                        elif nxt != 1:\n                            flag=False\n                if flag:\n                    return 1\n                else:\n                    return 0\n        n = len(graph)\n\n        return search(0, 1, 2)\n", "class Solution:\n     def findMedianSortedArrays(self, nums1, nums2):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :rtype: float\n         \"\"\"\n         nums = sorted(nums1 + nums2)\n         n = len(nums)\n         return nums[int(n/2)] if n%2==1 else (nums[int(n/2)]+nums[int(n/2)-1])/2.0", "class Solution:\n     def Is2(self, n):\n         root = int(math.log(n, 2))\n         return (2**root) == n\n     def GetNear2(self, n):\n         if n == 0:\n             return -1\n         if n == 1:\n             return 0\n         if n == 2:\n             return 1\n         if self.Is2(n):\n             return n\n         for ind in range(n - 1, n + 2):\n             if self.Is2(ind):\n                 return ind\n         return -1\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n \n         m = n\n         cnt = 0\n         while m != 1:\n             if m == 1:\n                 return cnt\n             if m == 2:\n                 return 1 + cnt\n             if m <= 4:\n                 return 2 + cnt\n             if m <= 6:\n                 return 3 + cnt\n             if m % 2 == 0:\n                 cnt += 1\n                 m = int(m / 2)\n                 continue\n             k = m % 4\n             if k == 1:\n                 cnt += 1\n                 m = int(m - 1)\n             elif k == 3:\n                 cnt += 1\n                 m = int(m + 1)\n             \n         return cnt\n", "class Solution:\n     def bulbSwitch(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         cnt = 0\n         for i in range(n):\n             num = (i+1) ** 2\n             if num > n:\n                 break\n             cnt += 1\n         return cnt", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        cache = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        d, k, res = {0: -1}, 0, 0\n        for i, c in enumerate(s):\n            if c in cache:\n                k ^= cache[c]\n            # \u5982\u679ck\u4e4b\u524d\u51fa\u73b0\u8fc7\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e2d\u95f4\u8fd9\u6bb5\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\n            if k not in d:\n                d[k] = i\n            else:\n                res = max(res, i - d[k])\n        return res\n", "class Solution:\n    def lastSubstring(self, s):\n        i, j, inc = 0, 1, 0\n        while j + inc < len(s):\n          if i + inc == j:\n            j = j + inc\n            inc = 0\n          elif s[j + inc] > s[i]:\n            i = j + inc\n            j = i + 1\n            inc = 0\n          elif s[i + inc] == s[j + inc]:\n            inc += 1\n          elif s[i + inc] < s[j + inc]:\n            i = j\n            j += 1\n            inc = 0\n          else:\n            j += max(inc, 1)\n            inc = 0\n        return s[i:]\n", "class Solution:\n     def longestPalindrome(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n         if len(s)==0:\n         \treturn 0\n         maxLen=1\n         start=0\n         for i in range(len(s)):\n         \tif i-maxLen >=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]:\n         \t\tstart=i-maxLen-1\n         \t\tmaxLen+=2\n         \t\tcontinue\n \n         \tif i-maxLen >=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]:\n         \t\tstart=i-maxLen\n         \t\tmaxLen+=1\n         return s[start:start+maxLen]", "class Solution:\n    def longestSubsequence(self, arr: List[int], difference: int) -> int:\n        if len(arr)==1: return 1\n        res,length = 1,len(arr)\n        dp = {}\n        dp[arr[-1]]=1\n        flag = 1\n        \n        for i in range(length-2,-1,-1):\n            if arr[i] not in dp: \n                dp[arr[i]] = 1\n                flag = 0#means val was not in arr\n            if arr[i]+difference in dp:\n                if difference ==0 and flag ==0:\n                    #if difference is 0 then i am seeing same no as arr[i] in dp and if flag is 0 then i already put its val in dp so should continue\n                    flag = 1\n                    continue\n                dp[arr[i]] = max(dp[arr[i]], dp[arr[i]+difference]+1, )\n            res = max(res,dp[arr[i]])\n            \n        return res\n", "from typing import List\n\nclass Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        # help function to count overlaps in A (shifted) and B:\n        def check_overlap(side_x, down_x, A, B):\n            overlap = 0\n            for i in range(len(A)):\n                for j in range(len(A)):\n                    try:\n                        overlap += A[i+side_x][j+down_x] & B[i][j]\n                    except:\n                        pass\n            \n            return overlap\n        \n        # try all options:\n        max_overlap = 0\n        for i in range(len(A)):\n            for j in range(len(A)):\n                max_overlap = max(max_overlap, check_overlap(i, j, A, B))\n                max_overlap = max(max_overlap, check_overlap(i, j, B, A))\n                \n        return max_overlap", "class Solution:\n     def divide(self, dividend, divisor):\n         positive = (dividend < 0) is (divisor < 0)\n         dividend, divisor = abs(dividend), abs(divisor)\n         res = 0\n         while dividend >= divisor:\n             temp, i = divisor, 1\n             while dividend >= temp:\n                 dividend -= temp\n                 res += i\n                 i <<= 1\n                 temp <<= 1\n         if not positive:\n             res = -res\n         return min(max(-2147483648, res), 2147483647)", "import math\n\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        \n        if(N==1):\n            return True\n        \n        nn=int(math.log(N)/math.log(2))-1\n        tmp=2**(nn)\n        \n        fun=lambda x: sorted( list(str(x)) ,key=lambda x:int(x),reverse=True)\n        N=fun(N)\n        \n        if(N==fun(tmp)):\n            return True\n        \n    #    print(nn,tmp)\n        for x in range(nn,20*nn):\n            tmp=tmp*2\n            if(N==fun(tmp)):\n                return True\n            if(nn<len(str(tmp))):\n                break\n        \n        tmp=2**(nn)\n\n        for x in range(nn,nn//20,-1):\n            tmp=tmp//2\n            if(N==fun(tmp)):\n                return True\n            if(nn<len(str(tmp))):\n                break\n        return False\n        \n        \n        \n            \n        \n        \n        \n        \n        \n            \n        \n        \n        \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        res = 1\n        for i in range(1, n+1):\n            x = (i-1)*2+1\n            possibilities = x*(x-1)//2+x\n            res = (res * possibilities)%(1000000000 + 7)\n        return res", "class Solution:\n    # Naive, BFS, starting from the start point without any key.\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        row, col = len(grid), len(grid[0])\n        x, y = None, None\n        num_keys = 0\n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == '@':\n                    x, y = r, c\n                elif grid[r][c] in 'abcdef':\n                    num_keys += 1\n        queue = collections.deque([(x, y, 0, 0, '.@abcdef')])  # r, c, steps, num_key, accessible\n        dires = [1, 0, -1, 0, 1]\n        visited = set()\n        while queue:\n            r, c, steps, cnt_keys, accessible = queue.popleft()\n            if grid[r][c] in 'abcdef' and grid[r][c].upper() not in accessible:\n                accessible += grid[r][c].upper()  # corresponding lock is accessible\n                cnt_keys += 1\n            if cnt_keys == num_keys:  # collected all keys\n                return steps\n            for d in range(len(dires) - 1):\n                new_r, new_c = r + dires[d], c + dires[d + 1]\n                if 0 <= new_r < row and 0 <= new_c < col and grid[r][c] in accessible:\n                    if (new_r, new_c, accessible) not in visited:\n                        visited.add((new_r, new_c, accessible))\n                        queue.append((new_r, new_c, steps + 1, cnt_keys, accessible))\n        return -1", "class Solution:\n     def getHint(self, secret, guess):\n         \"\"\"\n         :type secret: str\n         :type guess: str\n         :rtype: str\n         \"\"\"\n         \n         bulls = 0\n         mismatch_chars = collections.defaultdict(int)\n         \n         for secret_char, guess_char in zip(secret, guess):\n             if secret_char == guess_char:\n                 bulls += 1\n             else:\n                 mismatch_chars[secret_char] += 1\n         \n         cows = 0\n         for secret_char, guess_char in zip(secret, guess):\n             if secret_char != guess_char and mismatch_chars[guess_char] > 0:\n                 mismatch_chars[guess_char] -= 1\n                 cows += 1\n         \n         return '%sA%sB' % (bulls, cows)", "class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        n = len(s)\n        MOD = 10**9 + 7\n        seen = dict()\n        \n        a = 1\n        for i in range(n):\n            char = s[i]\n            b = 2 * a\n            if char in seen:\n                b -= seen[char]\n            \n            b %= MOD\n            seen[char] = a\n            a = b\n        return a - 1\n                \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left, right = [i + 1 for i in range(n)], [n - i for i in range(n)]\n        stackp, stackn = [], []\n        for i, num in enumerate(A):\n            while stackp and num < A[stackp[-1]]: stackp.pop()\n            if stackp: left[i] = i - stackp[-1]\n            stackp.append(i)\n            \n            while stackn and num < A[stackn[-1]]:\n                curr = stackn.pop()\n                right[curr] = i - curr\n            stackn.append(i)\n\n\n        res = 0\n        mod = 10**9 + 7\n        for i, num in enumerate(A):\n            res = (res + left[i]*right[i]*num) % mod\n        return res", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        q = collections.deque()\n        counter = collections.Counter(sorted(nums))\n        \n        for item in counter.items():\n            number = item[0]\n            count = item[1]\n            \n            if (count < len(q)):\n                return False\n            elif (count > len(q)):\n                for i in range(count - len(q)):\n                    q.append(number + k -1)\n            \n            while len(q) != 0 and q[0] == number:\n                q.popleft()\n            \n        return len(q) == 0", "class Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        # sliding window\n        minVal = k * threshold\n        \n        beg = 0\n        end = k - 1\n        total = 0\n        currSum = 0\n        \n        for i in range(beg, end+1):\n            currSum += arr[i]\n\n        while end < len(arr):\n            if beg != 0:\n                currSum = currSum - arr[beg - 1] + arr[end] \n            \n            if currSum >= minVal:\n                total+= 1\n            beg += 1\n            end += 1\n            \n        return total", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        low, high = 0, 0\n        cn = 0\n        ans = 0\n        \n        while low < len(nums) and high < len(nums):\n            if nums[high] == 0:\n                if cn < 1:\n                    cn += 1\n                else:\n                    while nums[low] != 0:\n                        low += 1\n                    low += 1\n            high += 1\n            ans = max(ans, high - low)\n            \n        \n        return max(ans, high-low)-1", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        res = 0\n        prefix = 0\n        count = [1] + [0] * K\n        for a in A:\n            prefix = (prefix + a) % K\n            res += count[prefix]\n            count[prefix] += 1\n        return res", "from math import log,ceil\n\nclass Solution:\n    def minDays( self, n: int) -> int:\n        def one_day(apples):\n            if apples%2==0 and apples%3!=0:\n                return (apples/2,apples-1)\n            elif apples%3==0 and apples%2!=0:\n                return (apples/3,apples-1)\n            elif apples%3==0 and apples%2==0:\n                return (apples/3,apples/2)\n            elif apples%3!=0 and apples%2!=0:\n                return (apples-1,)\n\n\n        poses=[(n,0)]#(#apples remained,days passed)\n        min_apples=min([pos[0] for pos in poses])\n\n        while min_apples!=0:\n            new_poses=[]\n            for pos in poses:\n                apples=pos[0]\n                days=pos[1]\n                new_pos=[(new_apples,days+1)for new_apples in one_day(apples)]\n                if min([pos[0] for pos in new_pos])==0:\n                    return sorted(new_pos,key=lambda x:x[0])[0][1]\n                new_poses+=new_pos\n            min_apples=min([pos[0] for pos in new_poses])\n            poses=sorted(list(set(new_poses)))\n            # print(poses)\n\n        days=sorted(poses,key=lambda x:x[0])[0][1]\n\n        return days", "'''\nthis problem is recursive\nSplit the string S into (encoded substring, number, unencoded string)\nIf K is in the unencoded part, then we can just return the correct value\nIf K is in the encoded part, we recurse\n\nI either need the length of the unencoded string, or try the encoded part first and\nreturn (None, length) if it isn't there\n\n'''\nclass Solution:\n    # returns (answer, none) or (none, length of unencoded string)\n    # k is 0-indexed\n    def _decode(self, s, k):\n        number_ix = -1\n        for i in reversed(range(len(s))):\n            if s[i].isnumeric():\n                number_ix = i\n                break\n        \n        if number_ix == -1:\n            # string is all unencoded\n            if k < len(s):\n                return (s[k], None)\n            else:\n                return (None, len(s))\n        else:\n            encoded, number, unencoded = s[:number_ix], s[number_ix], s[number_ix+1:]\n            sub_answer, sub_length = self._decode(encoded, k)\n            if sub_answer is not None:\n                return (sub_answer, None)\n            else:\n                if k < sub_length*int(number):\n                    k = k % sub_length\n                    sub_answer, _ = self._decode(encoded, k)\n                    return (sub_answer, None)\n                    \n                k = k - (sub_length * int(number))\n                if k < len(unencoded):\n                    return (unencoded[k], None)\n                else:\n                    return (None, sub_length*int(number) + len(unencoded))\n            \n        \n    \n    def decodeAtIndex(self, S: str, K: int) -> str:\n        answer, _ = self._decode(S, K-1)\n        return answer", "class Solution:\n    def findLatestStep(self, arr: List[int], m: int) -> int:\n        a = [0] * len(arr) \n        heads = {}\n        ends = {}\n        ans = -1\n        for step, i in enumerate(arr):\n            a[i - 1] = 1\n            if self.mergeOne(a, i - 1, heads, ends, m) == 1:\n                ans = step \n        for i in heads:\n            if heads[i] - i + 1 == m:\n                return len(arr)\n        return ans\n            \n    def mergeOne(self, ls, index, heads, ends, m):\n        left, right = index - 1, index + 1 \n        lefthead = rightend = index\n        ext = -1\n        if left in ends:\n            lefthead = ends[left]\n            if left - lefthead + 1 == m:\n                ext = 1\n            del ends[left]\n        if right in heads:\n            rightend = heads[right]\n            if rightend - right + 1 == m:\n                ext = 1\n            del heads[right]\n        heads[lefthead] = rightend\n        ends[rightend] = lefthead\n        return ext\n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        # initial condition \n        dp = [0 for _ in range(len(A))]\n        dp[0] = 1\n        dp[1] = 2 if A[1] != A[0] else  1\n        # dp[i] = dp[i-1] + 1 if curr 2 case check\n        # dp[i] = 1 \n        \n        for i in range(2, len(A)):\n            # compare i-2, i-1, i\n            if A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]:\n                # turbulent\n                dp[i] = dp[i-1] + 1\n            else:\n                if A[i] == A[i-1]:\n                    dp[i] = 1\n                else:\n                    dp[i] = 2\n        print(dp)\n        return max(dp)", "class Solution(object):\n    def mirrorReflection(self, p, q):\n        from fractions import Fraction as F\n\n        x = y = 0\n        rx, ry = p, q\n        targets = [(p, 0), (p, p), (0, p)]\n\n        while (x, y) not in targets:\n            #Want smallest t so that some x + rx, y + ry is 0 or p\n            #x + rxt = 0, then t = -x/rx etc.\n            t = float('inf')\n            for v in [F(-x,rx), F(-y,ry), F(p-x,rx), F(p-y,ry)]:\n                if v > 0: t = min(t, v)\n\n            x += rx * t\n            y += ry * t\n\n            #update rx, ry\n            if x == p or x == 0: # bounced from east/west wall, so reflect on y axis\n                rx *= -1\n            if y == p or y == 0:\n                ry *= -1\n\n        return 1 if x==y==p else 0 if x==p else 2", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        for i in range(1, int(math.sqrt(N))+1):\n            if N%i == 0:\n                if i%2:\n                    count += 1\n                if (N/i)%2 != 0 and N/i != i:\n                    count += 1\n        return count\n", "class Solution:\n    def minSwaps(self, grid: List[List[int]]) -> int:\n        for i in range(len(grid)):\n            j = len(grid[i]) - 1\n            while j >= 0 and grid[i][j] == 0:\n                j -= 1\n            grid[i] = j\n            \n        count = 0\n        \n        for i in range(len(grid)):\n            if grid[i] <= i:\n                continue\n            j = i + 1\n            while j < len(grid) and grid[j] > i:\n                j += 1\n            if j == len(grid):\n                return -1\n            while j > i:\n                grid[j], grid[j - 1] = grid[j - 1], grid[j]\n                count += 1\n                j -= 1\n        return count", "class Solution:\n    def numTeams(self, rating: List[int]) -> int:\n        n = len(rating)\n        count = 0\n        for i in range(0,n):\n            for j in range(i,n):\n                    for k in range(j,n):\n                        if rating[i] < rating[j] < rating[k] or rating[i] > rating[j] > rating[k]:\n                                count += 1\n        return(count)", "class Solution:\n     \n    def nthPersonGetsNthSeat(self, n: int) -> float:\n        if n==1: return 1\n        return 1/2\n", "class Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        if len(nums)<=4: \n            return 0\n        maxHeap, minHeap = [],[]\n        import heapq\n        for e in nums:\n            heappush(maxHeap,e)\n            heappush(minHeap,e*-1)\n            if len(maxHeap)>4:\n                heappop(maxHeap)\n                heappop(minHeap)\n        minHeap = sorted([-1*e for e in minHeap]) #in ascending order\n        res = float('inf')\n        for i in range(4):\n            \n            res = min(res, heappop(maxHeap)-minHeap[i])\n            \n        \n        return res", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr,key = lambda x:(c[x],x))\n        print(s)\n        return len(set(s[k:]))", "class Solution:\n     def removeDuplicateLetters(self, s):\n         if not s:\n             return \"\"\n         \n         res = ''\n         sorted_set = sorted(set(s))\n         \n         for c in sorted_set:\n             sub_s = s[s.index(c):]\n             if set(s) == set(sub_s):\n                 return c + self.removeDuplicateLetters(sub_s.replace(c, ''))\n         \n                 \n         return res\n", "class Solution:\n     def checkSubarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         if not nums or len(nums) < 2:\n             return False\n \n         if k == 1:\n             return True\n \n         cur_sum, sums = 0, {0: -1}\n         for i, x in enumerate(nums):\n             cur_sum += x\n             mod = (cur_sum % k) if k != 0 else cur_sum\n             if mod in sums:\n                 if i - sums[mod] >= 2:\n                     return True\n             else:\n                 sums[mod] = i\n         return False", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums or len(nums) == 0:\n             return 0\n         \n         start, end = 0, len(nums) - 1\n         target = nums[-1]\n         \n         while start + 1 < end:\n             mid = (start + end) // 2\n             if nums[mid] < target:\n                 end = mid\n             else:\n                 start = mid\n         \n         if nums[start] < target:\n             return nums[start]\n         return nums[end]", "class Solution:\n     def validUtf8(self, data):\n         \"\"\"\n         :type data: List[int]\n         :rtype: bool\n         \"\"\"\n         cont = 0\n         for n in data:\n             s=format(n, '08b')\n             if cont > 0:\n                 if s[:2] == '10':\n                     cont -= 1\n                     continue\n                 return False\n             if s[0] == '0':\n                 continue\n             if s[:3] == '110':\n                 cont = 1\n                 continue\n             if s[:4] == '1110':\n                 cont = 2\n                 continue\n             if s[:5] == '11110':\n                 cont = 3\n                 continue\n             return False\n         return cont == 0\n", "class Solution:\n    def dfs(self, jobDifficulty, start_day, d, memo):\n        if d == 1:\n            return max(jobDifficulty[start_day:])\n\n        if (start_day, d) in memo:\n            return memo[(start_day, d)]\n        \n        min_diff = float('inf')\n        cur_max_diff = 0\n\n        for i in range(start_day, len(jobDifficulty) - d + 1):\n            cur_max_diff = max(cur_max_diff, jobDifficulty[i])\n            min_diff = min(min_diff, cur_max_diff + self.dfs(jobDifficulty, i + 1, d - 1, memo))\n        \n        memo[(start_day, d)] = min_diff\n        return min_diff\n\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n\n        memo = collections.defaultdict(int)\n        return self.dfs(jobDifficulty, 0, d, memo)\n", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         digits = \"\"\n         while(int(num)):\n             digits += str(int(num%10))\n             num/=10\n             \n         #print(digits)\n         digits = digits[::-1]\n         lens = len(digits)\n         mark = 0\n         mark1 = 0\n         flag = 0\n         for i in range(lens):\n             maxs = ord(digits[i])\n             for j in range(i+1, lens,1):\n                 if ord(digits[j]) >= maxs:\n                     maxs = ord(digits[j])\n                     mark = j\n             if maxs != ord(digits[i]):\n                 mark1 = i\n                 flag = 1\n                 break;\n         #print(digits)\n         digit = list(digits)\n         #print(digit)\n         if flag == 1:\n             tem = digit[mark1]\n             digit[mark1] = digit[mark]\n             digit[mark] = tem\n         #print(digit)\n         #digits = digits[::-1]\n         res = 0\n         #print(digit)\n         for i in range(lens):\n             res *= 10\n             res += ord(digit[i]) - ord('0')\n             #print(res)\n         return res", "class Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        a = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\n        source = [[0] * len(targetGrid[0]) for _ in targetGrid]\n        for i in range(len(targetGrid)):\n            for j in range(len(targetGrid[i])):\n                a[targetGrid[i][j]] = (min(a[targetGrid[i][j]][0], j), min(a[targetGrid[i][j]][1], i), max(a[targetGrid[i][j]][2], j), max(a[targetGrid[i][j]][3], i))\n        gr = defaultdict(set)\n        for p in range(len(a)):\n            x, y, z, t = a[p]\n            if x != math.inf:\n                for i in range(y, t + 1):\n                    for j in range(x, z + 1):\n                        if targetGrid[i][j] != p:\n                            gr[p].add(targetGrid[i][j])\n        visited = set()\n        inp = set()\n        def dfs(k):\n            inp.add(k)\n            for x in gr[k]:\n                if x in inp:\n                    return False\n                elif x not in visited and not dfs(x):\n                    return False\n            inp.remove(k)\n            visited.add(k)\n            return True\n        for i in range(61):\n            if i not in visited and not dfs(i):\n                return False\n        return True\n", "class Solution:\n     def canCross(self, stones):\n         \"\"\"\n         :type stones: List[int]\n         :rtype: bool\n         \"\"\"\n         target, stones, memo = stones[-1], set(stones), set()\n         \n         return self.dfs(stones, 1, 1, target, memo)\n     \n     def dfs(self, stones, pos, jump, target, memo):\n         if (pos, jump) in memo:\n             return False\n         if pos == target:\n             return True\n         if pos not in stones or jump <= 0:\n             return False\n         \n         for j in (jump-1, jump, jump+1):\n             if self.dfs(stones, pos+j, j, target, memo):\n                 return True\n         memo.add((pos, jump))   # record bad position and jump\n         return False", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp=[sys.maxsize]*(amount+1)\n        \n        dp[0]=0\n        for i in range(1,len(dp)):\n            for c in coins:\n                if c<=i:\n                    dp[i]=min(dp[i],dp[i-c]+1)\n                    \n        if dp[amount] == sys.maxsize:\n            return -1\n        return dp[amount]\n            \n        \n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        r = sum(nums) % p\n        if r == 0:\n            return 0\n        res, prefix, cur = len(nums), {0: -1}, 0\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            prefix[cur] = i\n            target = (cur - r) % p\n            if target in prefix and res > i - prefix[target]:\n                res = i - prefix[target]\n        return res if res < len(nums) else -1", "class Solution:\n     def characterReplacement(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if s == \"\":\n             return 0\n         count = {}\n         lo = 0\n         hi = 0\n         max_letter = 0\n         for hi in range(len(s)):\n             try:\n                 count[s[hi]] += 1\n             except:\n                 count[s[hi]] = 1\n             if count[s[hi]] > max_letter:\n                 max_letter = count[s[hi]]\n             if max_letter < hi - lo + 1 - k:\n                 if max_letter == count[s[lo]]:\n                     max_letter -= 1\n                 count[s[lo]] -= 1\n                 lo += 1\n         return hi - lo + 1", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n \n         \n         dic = set()\n         ma = 0\n         for i in nums:\n             if i not in dic: # not considered\n                 set_ = set()\n                 while i  not in set_:\n                     set_.add(i)\n                     i = nums[i]\n                 ma = max(ma,len(set_))\n                 dic.update(set_)\n         return ma", "#[Runtime: 452 ms, faster than 97.27%] Hash\n#O(MN)\n#1. traverse all cells and mark server as (x, y)\n#2. put each server (x, y) into serveral bucket named x1, x2, .., and y1, y2, ..\n# e.g. each xbucket[x1] maintains the number of servers on line x1\n#3. enumerate all server (x', y'), and see if there is at least 2 server on xbucket[x'] or ybucket[y'] \nclass Solution:\n    def countServers(self, grid: List[List[int]]) -> int:\n        xbucket, ybucket, server = [0] * len(grid), [0] * len(grid[0]), []\n        for x, row in enumerate(grid):\n            for y, cell in enumerate(row):\n                if cell:\n                    server.append((x, y))\n                    xbucket[x] += 1\n                    ybucket[y] += 1\n        return sum(xbucket[x] > 1 or ybucket[y] > 1 for x, y in server)", "class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        return sum(abs(a-b) for a,b in zip(nums,nums[1:])) + max(max(abs(nums[0]-b)-abs(a-b) for a,b in zip(nums,nums[1:])),max(abs(nums[-1]-a)-abs(a-b) for a,b in zip(nums,nums[1:])),2*(max(min(a,b) for a,b in zip(nums,nums[1:]))-min(max(a,b) for a,b in zip(nums,nums[1:]))))", "class Solution:\n    def minOperations(self, n: int) -> int:\n        # [1] 1 => 0\n        # [1,3] 2 => 1\n        # [1,3,5] 3 => 2\n        # [1,3,5,7] 4 => 1 + 3 = 4\n        # [1,3,5,7,9] 5 => 2 + 4 = 6\n        # [1,3,5,7,9,11] 6 => 1 + 3 + 5 = 9\n        # [1,3,5,7,9,11,13] 7 => 2 + 4 + 6 = 12\n        \n        if n <= 1:\n            return 0\n        else:\n            ops = 0\n            for x in range(n-1,0, -2):\n                ops += x\n            return ops\n            \n            \n        \n", "class Solution:\n     def minCut(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         if s == s[::-1]: return 0\n         \n         for i in range(1, len(s)):\n             if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\n                 return 1\n         \n         cut = [x for x in range(-1, len(s))]\n         for i in range(len(s)):\n             j=0\n             while i - j >= 0 and i + j < len(s) and s[i - j] == s[i + j]:\n                 if cut[i + j + 1]>cut[i - j] + 1:\n                     cut[i + j + 1]=cut[i - j] + 1\n                 j += 1\n             j=0\n             while i - j >= 0 and i + j + 1 < len(s) and s[i - j] == s[i + j + 1]:\n                 if cut[i + j + 2]>cut[i - j] + 1:\n                     cut[i + j + 2] = cut[i - j] + 1\n                 j += 1\n         return cut[-1]", "class Solution:\n    def divs(self,x):\n        memo = self.memo\n        if x in memo:\n            return memo[x]\n        #\n        L = 2     if x>1 else 1\n        S = (1+x) if x>1 else 1\n        for a in range(2,x):\n            if (a**2)>x:\n                break\n            #\n            if not x%a:\n                L += 1 if x==(a**2) else 2\n                S += a if x==(a**2) else (a + x//a)\n            #\n            if L>4:\n                break\n        #\n        memo[x] = L,S\n        return L,S\n    def sumFourDivisors(self, A):\n        self.memo = {}\n        res = 0\n        for x in A:\n            L,S = self.divs(x)\n            if L==4:\n                res += S\n        return res", "class Solution:\n     def fractionToDecimal(self, numerator, denominator):\n         \"\"\"\n         :type numerator: int\n         :type denominator: int\n         :rtype: str\n         \"\"\"\n         negativeFlag = numerator * denominator < 0\n         numerator = abs(numerator)\n         denominator = abs(denominator)\n         numList = []\n         cnt = 0\n         loopDict = dict()\n         loopStr = None\n         while True:\n             numList.append(str(numerator // denominator))\n             cnt += 1\n             numerator = 10 * (numerator % denominator)\n             if numerator == 0:\n                 break\n             loc = loopDict.get(numerator)\n             if loc:\n                 loopStr = \"\".join(numList[loc:])\n                 break\n             loopDict[numerator] = cnt\n         ans = numList[0]\n         \n         if len(numList) > 1:\n             ans += \".\"\n         if loopStr:\n             ans += \"\".join(numList[1:len(numList) - len(loopStr)]) + \"(\" + loopStr + \")\"\n         else:\n             ans += \"\".join(numList[1:])\n         if negativeFlag:\n             ans = \"-\" + ans\n         return ans", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        # find root and do dfs\n        # look for cycle or things not visited from the root\n        visited = [False] * n\n        cycle = False\n        \n        def dfs(root):\n            nonlocal cycle\n            #print(root, visited, cycle)\n            if root == -1:\n                return\n            \n            if not visited[root]:\n                visited[root] = True\n                dfs(leftChild[root])\n                dfs(rightChild[root])\n            else:\n                cycle = True\n                \n            \n                   \n        def find_root():\n            in_degree = {}\n            \n            for i in range(n):\n                in_degree[i] = 0\n            # add -1 so u wont skip it\n            in_degree[-1] = 0    \n            for i in range(n):\n                in_degree[leftChild[i]] += 1\n                in_degree[rightChild[i]] += 1\n                \n            for k,v in list(in_degree.items()):\n                if v == 0:\n                    return k\n                \n        root = find_root()\n        #print(root)\n        if root == None:\n            return False\n        dfs(root)\n        print(cycle)\n        if cycle:\n            #print('cycle')\n            return False\n        \n        #print(visited)\n        return all(visited)\n        \n        \n                \n            \n            \n        \n\n", "from collections import Counter\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        if len(A) < 3:\n            return 0\n        counts = Counter(A)\n        keys = sorted(counts.keys())\n        n, res = len(keys), 0\n        \n        for i, a in enumerate(keys):\n            T = target - a\n            j, k = i, n - 1\n            while j <= k:\n                b, c = keys[j], keys[k]\n                if b + c < T:\n                    j += 1\n                elif b + c > T:\n                    k -= 1\n                else:\n                    if i < j < k:\n                        res += counts[a] * counts[b] * counts[c] \n                    elif i == j < k:\n                        res += counts[a] * (counts[a] - 1) // 2 * counts[c]\n                    elif i < j == k:\n                        res += counts[a] * counts[b] * (counts[b] - 1) // 2\n                    else:\n                        res += counts[a] * (counts[a] - 1) * (counts[a] - 2) // 6\n                    j += 1\n                    k -= 1\n        return res % MOD", "class Solution:\n     def expandIsland(self, grid, i, j):\n         edges = [(i, j)]\n         while edges:\n             next_edges = []\n             for edge in edges:\n                 ei, ej = edge\n                 if ei >= 0 and ei < len(grid) and ej >= 0 and ej < len(grid[ei]) and grid[ei][ej] == '1':\n                     grid[ei][ej] = '2'\n                     next_edges.append((ei + 1, ej))\n                     next_edges.append((ei, ej + 1))\n                     next_edges.append((ei - 1, ej))\n                     next_edges.append((ei, ej - 1))\n             edges = next_edges\n     \n     def numIslands(self, grid):\n         \"\"\"\n         :type grid: List[List[str]]\n         :rtype: int\n         \"\"\"\n         island_count = 0\n         for i in range(len(grid)):\n             for j in range(len(grid[i])):\n                 if grid[i][j] == '1':\n                     island_count += 1\n                     self.expandIsland(grid, i, j)\n         return island_count", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        seen = set()\n        \n        def canReachRec(ix):\n            if ix < 0 or ix >= len(arr):\n                return False\n            if ix in seen:\n                return False\n            if arr[ix] == 0:\n                return True\n\n            seen.add(ix)\n            if canReachRec(ix + arr[ix]):\n                return True\n            if canReachRec(ix - arr[ix]):\n                return True\n            return False\n        return canReachRec(start)\n", "class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        a = []\n        n = len(arr)\n        for i in range(n):\n            if i == 0:\n                a.append(arr[i])\n            else:\n                a.append(arr[i] ^ a[-1])\n        \n        ans = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j, n):\n                    x = a[j-1] ^ (0 if i == 0 else a[i-1])\n                    y = a[k] ^ a[j-1]\n                    if x == y:\n                        ans += 1\n        return ans", "class Solution:\n    \n    def __init__(self):\n        self.all_pos_array = []\n    \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        while len(self.all_pos_array) < right:\n            for i in range(0,len(nums)):\n                for j in range(i,len(nums)):\n                    self.all_pos_array.append(sum(nums[i:j+1]))\n        \n        return sum(sorted(self.all_pos_array)[left-1:right]) % (10**9 +7)\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n        return ans + bool(times) # remaining car is fleet (if it exists)", "class Solution:\n    def findKthBit(self, n: int, k: int) -> str:\n        def inverse(s):\n            res = ''\n            for ch in s:\n                if ch == '1':\n                    res += '0'\n                else:\n                    res += '1'\n            return res\n        \n        \n        s = '0'\n        for i in range(n-1):\n            s = s+'1' + inverse(s)[::-1]\n        return s[k-1]", "class Solution:\n     def singleNumber(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \"\"\"\n         count frequency of each element\n         \"\"\"\n         freq = {}\n         for num in nums: #store frequency of each element in the list\n             freq[num] = freq.get(num, 0) + 1\n         \n         for num, frequency in list(freq.items()):\n             if frequency == 1:\n                 return num\n", "class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         d = {}\n         for i in wall:\n             suma = 0\n             for j in range(len(i)-1):\n                 suma += i[j]\n                 if suma in d:\n                     d[suma] += 1\n                 else:\n                     d[suma] = 1\n         if len(d) == 0:\n             return len(wall)\n         return len(wall) - max(d.values())\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen == 1: \n            return 1    \n        memo = {}\n        \n        return self.dfs(steps, arrLen, 0, memo)   \n        \n\n    def dfs(self, steps, arrLen, cur_pos, memo):\n        if (steps, cur_pos) in memo:\n            return memo[(steps, cur_pos)]\n        \n        if cur_pos < 0 or cur_pos >= arrLen:\n            return 0 \n            \n        if steps == 0:\n            if cur_pos == 0:\n                return 1\n            else:\n                return 0\n                \n        memo[(steps, cur_pos)] = self.dfs(steps-1, arrLen, cur_pos, memo) + self.dfs(steps-1, arrLen, cur_pos-1, memo) + self.dfs(steps-1, arrLen, cur_pos+1, memo)         \n        \n            \n        return  memo[(steps, cur_pos)]%(10**9+7)", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         Solution: Sort the list then use three pointers (i, j, k) to find the sum of 3 values that is closest to target.\n         Store the current closest value and the distance from target.\n         Current closest value can be compared using abs(target - value) and comparing to the stored distance from target.\n         \"\"\"\n         arr, i, closest, dist = nums, 0, None, None\n         arr.sort()\n \n         if len(arr) == 3:\n             return arr[0] + arr[1] + arr[2]\n \n         while i < len(arr) - 2:\n             if i > 0 and arr[i] > target:\n                 return closest\n             if i == 0 or arr[i] != arr[i - 1]:\n                 j, k = i + 1, len(arr) - 1\n                 while j < k:\n                     val = arr[i] + arr[j] + arr[k]\n                     if val == target:\n                         return val\n                     temp_dist = abs(target - val)\n                     # print('VALS', arr[i], arr[j], arr[k], val, temp_dist)\n                     if dist == None or temp_dist < dist:\n                         closest = val\n                         dist = temp_dist\n                     if val < target:\n                         j += 1\n                     else:\n                         k -= 1\n \n             i += 1\n         return closest", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [[[0,0] for _1 in range(n)] for _2 in range(n)]\n        for i in range(n):\n            dp[i][i] = [arr[i], 0] # last number and sum\n        for diff in range(1,n):\n            for i in range(n-diff): #i,i+1,...,i+diff\n                temp_min_ = 10**40\n                root = None\n                for j in range(i,i+diff):\n                    sum_ = (dp[i][j][1] + dp[j+1][i+diff][1]) + dp[i][j][0] * dp[j+1][i+diff][0]\n                    if sum_ < temp_min_:\n                        temp_min_ = sum_\n                        root = max(dp[i][j][0], dp[j+1][i+diff][0])\n                dp[i][i+diff] = [root, temp_min_]\n                        \n        return dp[0][-1][1]", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         if height == []:\n             return 0\n         l = len(height)\n         p1 = 0\n         p2 = l - 1\n         area = 0\n         while(p1 < p2):\n             if(height[p1] <= height[p2]):\n                 area = max(area,height[p1] * (p2 - p1))\n                 p1 += 1\n             else:\n                 area = max(area,height[p2] * (p2 - p1))\n                 p2 -= 1\n         return area\n", "def isPrimes(n):\n    return n > 1 and all(n%d > 0 for d in range(2, int(sqrt(n)) + 1))\n\ndef reverse(x):\n    ans = 0\n    while x:\n        ans = 10*ans + x%10\n        x //= 10\n    return ans\n\nclass Solution:\n    def primePalindrome(self, N: int) -> int:\n        if N >= 9989900:\n            return 100030001\n        while True:\n            if N == reverse(N) and isPrimes(N):\n                return N\n            N += 1\n        \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        '''greedy+ \u6ed1\u52a8\u7a97\u53e3\n        1.\u7528deque\u4fdd\u5b58\u53cd\u8f6c\u8fc7\u7684idx\uff0c\u957f\u5ea6\u5c31\u662f\u603b\u5171\u80fd\u7ba1\u5230i\u7684\u53cd\u8f6c\u6b21\u6570\n          start\u5f80\u540e\u8d70\u7684\u65f6\u5019\u961f\u5934\u4e0d\u5728\u5f53\u524dwindow\u7684\u51fa\u7ad9\n          [0,0,0,1,0,1,1,0]\n                         i\n           que = [5]\n           len == 1 => flipped  res += (len(que) %2 ^ A[i] == 0)\n           res = 3\n        2. \u7528count\u8868\u793awindow\u91cc\u9762flip\u4e86\u591a\u5c11\u6b21(\u6216\u8005\u5c31\u7528count\u7684mod)\n           flip\u7684\u7528A[i]-2 => 0:-2, 1:-1 \u6765\u505amark\u8fd9\u6837start\u51fawindow\u7684\u65f6\u5019\u624d\u80fd\u51cf\u53bbcount\n           \u51fawindow\u7684\u65f6\u5019\u628a2\u52a0\u56de\u53bb=> -2:0, -1:1\n        '''\n        start = 0\n        count = 0\n        res = 0\n        for end, a in enumerate(A):\n            if count ^ A[end] == 0: #(count % 2)^ A[end]\n                #print(end)\n                A[end] -= 2\n                res += 1\n                count ^= 1 # count++\n                \n            if end >= start + K - 1: #move window start\n                if A[start] < 0:\n                    count ^= 1 #count--\n                    A[start] += 2 #flip back\n                start += 1\n        #print(A)  \n        # at the end if there is anything not flipped? (last window need flip)\n        return -1 if any([a < 0 for a in A]) else res", "class Solution:\n    def queryString(self, S: str, N: int) -> bool:\n        if '1' not in S: return False\n        res = set()\n        cur = set()\n        for s in S:\n            if s == '0': \n                cur = {c * 2 for c in cur} | {0}\n            else:\n                cur = {c * 2 + 1 for c in cur} | {1}\n            res |= cur\n        for i in range(1, N+1):\n            if i not in res: return False\n        return True", "class Solution:\n    # https://leetcode.com/problems/longest-happy-string/discuss/564277/C%2B%2BJava-a-greater-b-greater-c\n    def longestDiverseString(self, a: int, b: int, c: int, charA = 'a', charB = 'b', charC = 'c') -> str:\n        if a<b: \n            return self.longestDiverseString(b, a, c, charB, charA, charC)\n        if b<c: \n            return self.longestDiverseString(a, c, b, charA, charC, charB)\n        # print(a, b, c, charA, charB, charC)\n        if b==0: \n            return min(a, 2)*charA \n        use_a = min(2, a)\n        use_b = 1 if a-use_a>=b else 0 \n        return charA*use_a + charB*use_b + self.longestDiverseString(a-use_a, b-use_b, c, charA, charB, charC)", "class Solution:\n     def kthSmallest(self, matrix, k):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         \n         list = matrix[0]\n         \n         for i in range(1, len(matrix)):\n             list.extend(matrix[i])\n             \n         list.sort()\n         \n         return list[k-1]", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        idx = sorted(range(n), key=A.__getitem__)\n        i = n\n        result = 0\n        for j in idx:\n            result = max(result, j - i)\n            i = min(i, j)\n        return result", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        def dfs(node, visited):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in rooms[node]:\n                if nei in visited:\n                    continue\n                dfs(nei,visited)\n            return\n        visited = set()\n        dfs(0, visited)\n        if len(visited) == len(rooms):\n            return True\n        else: \n            return False\n            \n", "class Solution:\n     def findSubstringInWraproundString(self, p):\n         \"\"\"\n         :type p: str\n         :rtype: int\n         \"\"\"\n         pc = None\n         sl = 0\n         ll = {}\n         \n         for c in p:\n             if pc and (ord(pc) + 1 == ord(c) or (pc == 'z' and c == 'a')):\n                 sl += 1\n             else:\n                 sl = 1\n             ll[c] = max([ll[c], sl]) if c in ll else sl\n             pc = c\n         s = 0\n         for key, value in list(ll.items()):\n             s += value\n         return s\n         \n         \n # def unique(p):\n #   pc = None\n #   sl = 0\n #   ll = {}\n #   for c in p:\n #     if pc != None and (ord(pc) + 1 == ord(c) or (pc == 'z' and c == 'a')):\n #       sl += 1\n #     else:\n #       sl = 1\n #     ll[c] = max([ll[c], sl]) if c in ll else sl\n #     pc = c\n #   s = 0\n #   for _, v in ll.items():\n #       s += v\n #   return s\n \n # with open('/dev/stdin', 'rt') as f:\n #   line = f.readline()\n #   while line:\n #     print unique(line.rstrip())\n #     line = f.readline()\n", "class Solution:\n    def strWithout3a3b(self, A: int, B: int) -> str:\n        if A >= 2*B:\n            return 'aab'* B + 'a'* (A-2*B)\n        elif A >= B:\n            return 'aab' * (A-B) + 'ab' * (2*B - A)\n        elif B >= 2*A:\n            return 'bba' * A + 'b' *(B-2*A)\n        else:\n            return 'bba' * (B-A) + 'ab' * (2*A - B)", "class Solution:\n     def findTargetSumWays(self, nums, S):\n         \"\"\"\n         :type nums: List[int]\n         :type S: int\n         :rtype: int\n         \"\"\"\n         def findTargetNumber(nums, target):\n             print(nums, target)\n             dp = [0 for _ in range(target + 1)]\n             dp[0] = 1\n             for n in nums:\n                 for i in range(target, n - 1, -1):\n                     dp[i] += dp[i - n]\n             return dp[-1]\n         \n         sumResult = sum(nums)\n         if (S + sumResult) % 2 != 0 or sumResult < S:\n             return 0\n         else:\n             return findTargetNumber(nums, int((sumResult + S) / 2))", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n      if not text: return 0\n      i, j, result = 0, len(text) - 1, 0\n      while i < j:\n        if text[:i+1] == text[j:]:\n          return self.longestDecomposition(text[i+1: j]) + 2\n        else:\n          i, j = i + 1, j - 1\n      return 1", "class Solution:\n    \n    def lastStoneWeightII(self, stones: List[int]) -> int:        \n        mem = {} #Mem\n        \n        def explore(a, b, stones):\n            if len(stones) == 0:\n                return abs(a-b)\n            \n            entry = (a, b, len(stones)) #Mem\n            if entry in mem:\n                return mem[entry]\n            \n            s = stones.pop()\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\n            stones.append(s)\n            \n            mem[entry] = m #Mem\n            return m\n        \n        return explore(0, 0, stones)\n    \n    def lastStoneWeightIITLE(self, stones: List[int]) -> int:\n        N = len(stones)\n        if not stones:\n            return 0\n        if N == 1:\n            return stones[0]\n        if N == 2:\n            return abs(stones[0]-stones[1])\n        \n        out = float('inf')\n        for i in range(N):\n            for j in range(i+1, N):\n                right = stones.pop(j)\n                left = stones.pop(i)\n                diff = abs(right-left)\n                \n                out = min(out, self.lastStoneWeightII(stones+[diff]))\n                \n                stones.insert(i, left)\n                stones.insert(j, right)\n                \n        return out", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        res = 0\n\n        for i in range(len(A)):\n            if i > 0 and A[i] <= A[i-1]:\n                res += ((A[i-1] + 1) - A[i])\n                A[i] += ((A[i-1] + 1) - A[i])\n        return res\n        \n            \n                \n            \n            \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        \n        # tps = sorted(zip(endTime,startTime, profit))\n        # print (tps)\n        # return 0\n        events = []\n        n = len(startTime)\n        for i in range(n):\n            events.append((startTime[i], i + 1))            \n            events.append((endTime[i], -i - 1))\n        \n        events.sort()\n        # print (events)\n        \n        p = 0\n        for (curr, idx) in events:\n            if idx > 0:\n                profit[idx - 1] += p\n            else:\n                p = max(p, profit[-idx - 1])\n            # print (curr, p)\n        return p\n", "class Solution:\n     def rob(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"        \n         mem = {}\n         \n         def max_money(start, rob_first=False):\n             if start >= len(nums):\n                 return 0\n             \n             # Cannot steal from last house if stole from first house\n             if start == len(nums) - 1 and rob_first:\n                 return 0\n             \n             if (start, rob_first) in mem:\n                 return mem[(start, rob_first)]\n             \n             if start == 0:\n                 mem[(start, rob_first)] = max(max_money(start+1, False),    # Don't rob first house\n                                               nums[start] + max_money(start+2, True))   # Rob first house\n             else:\n                 mem[(start, rob_first)] = max(max_money(start+1, rob_first),\n                                               nums[start] + max_money(start+2, rob_first))\n             \n             return mem[(start, rob_first)]\n         \n         return max_money(0)\n             \n             \n             \n             \n             \n             \n             \n", "'''\nKeeping track of reusable operations\n\nIdea:\n\nStart with first position a[0]. We know that it will take overall a[0] operations to reach a[0] from 0.\n\nNow, 2 things can happen from here:\n\nWe encounter a number less than a[0] (a[1] < a[0]): In this case we can simply reuse the same operations that we did for a[0]. i.e If array was (3, 2), we can first perform 3 operations and then use 2 of the same operations in next term. However, going forward, we will only have a[1] operations available for reuse.\n\nWe encounter a number greater than a[0] (a[1] > a[0]): In this case we can simply reuse the same operations that we did for a[0]. And additionally, we will perform a[1] - a[0] more operation to reach a[1]. Again, going forward, we will have a[1] operations available for reuse.\n\nTC: O(n)\nSC: O(1)\n'''\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        tLen = len(target)\n        steps = target[0]\n        reusableOperations = target[0]\n        \n        for i in range(1, tLen):\n            if target[i] <= reusableOperations: # Case 1\n                reusableOperations = target[i]\n            else: # Case 2\n                steps += target[i] - reusableOperations\n                reusableOperations = target[i]\n        \n        return steps\n                \n        \n", "class Solution:\n     def calculate(self, s):\n         if not s: return 0\n         length = len(s)\n         stack = []\n         num = 0\n         sign = '+'\n         for idx, c in enumerate(s):\n             if c.isdigit():\n                 num = num*10 + ord(c) - ord('0')\n             if c in ['+','-','*','/'] or idx == length - 1:\n                 if sign == '+':\n                     stack.append(num)\n                 elif sign == '-':\n                     stack.append(-num)\n                 elif sign == '*':\n                     stack.append(stack.pop() * num)\n                 elif sign == '/':\n                     stack.append(int(stack.pop() / num))\n                 sign = c\n                 num = 0\n         \n         return sum(stack)\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n", "class Solution:\n     def shortestPalindrome(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n         lps = [0,1]\n         x = 0\n         for i in range(len(s)-1,-1,-1):\n             while x > 0 and s[i] != s[x]:\n                 x = lps[x-1]\n             if s[i] == s[x]:\n                 x += 1\n             lps.append(x)\n         print(lps)\n         return s[:lps[~0]-1:-1] + s", "from itertools import count\nfrom collections import Counter\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        # color the components\n        colors = dict()\n        c = count()\n        \n        def dfs(node, color):\n            colors[node] = color\n            \n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n                    \n        for node in range(len(graph)):\n            if node not in colors:\n                dfs(node, next(c))\n        \n        \n        # count sizes of each component\n        size = Counter(list(colors.values()))\n        \n        \n        # find components with only one malware inside\n        malware_count = Counter()\n        for node in initial:\n            malware_count[colors[node]] += 1\n            \n        #print(malware_count)\n        #print(size)\n        \n        # find the component with the most nodes and only 1 malware\n        ans = None\n        ans_nodes = 0\n        for x in initial:\n            c = colors[x]\n            if malware_count[c] != 1:\n                continue\n            if size[c] > ans_nodes:\n                ans = x\n                ans_nodes = size[c]\n            elif size[c] == ans_nodes:\n                ans = min(ans, x)\n                \n        return ans if ans else min(initial)\n", "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        dic = collections.OrderedDict()\n        for word in text.split():\n            n = len(word)\n            dic[n] = dic.get(n, []) + [word.lower()]\n\n        res = []\n        for key, val in sorted(dic.items()):\n            res += val\n\n        return ' '.join(res).capitalize()", "class Solution:\n    def reverseParentheses(self, s: str) -> str:\n        \n        \n        stack = []\n        curr = ''\n        for c in s:\n            if c=='(':\n                stack.append(curr)\n                curr = ''\n                stack.append('(')\n            elif c==')':\n                stack.append(curr)\n                curr = ''\n                aux = ''\n                while stack and stack[-1]!='(':\n                    aux=stack.pop()+aux\n                stack.pop()\n                stack.append(aux[::-1])\n            else:\n                curr+=c\n        if curr:\n            stack.append(curr)\n        return ''.join(stack)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        mystack_bracket, mystack_letter = [], []\n        pos = 0\n        for i in s:\n            if i == '(':\n                mystack_bracket.append((i, pos))\n                #print(\\\"1\\\", mystack_bracket)\n            elif i == ')':\n                if len(mystack_bracket) !=0 :\n                    y = mystack_bracket.pop()\n                    mystack_letter.append(y)\n                    mystack_letter.append((i, pos))\n                    #print(\\\"2:\\\",mystack_letter)\n            else:\n                mystack_letter.append((i, pos))\n                #print(\\\"3:\\\",mystack_letter)\n                \n            pos += 1\n        \n \n        return ''.join(i for i,j in sorted(mystack_letter, key=lambda mystack_letter: mystack_letter[1]) ) \n        \n        \n        \n        \n        \n            \n        \n", "class Solution:\n     def myAtoi(self, str):\n         \"\"\"\n         :type str: str\n         :rtype: int\n         \"\"\"\n         base = \"0123456789\"\n         plus = \"+\"\n         minus = \"-\"\n         sum = 0\n         flag = 1\n         bit = 0\n         INT_MAX = 2147483647\n         INT_MIN = -2147483648\n         \n         if not str:\n             return 0\n         \n         if len(str) == 0:\n             return 0\n         \n         for letter in str.strip():\n             if letter in plus:\n                 if bit == 0:\n                     bit = 1\n                     continue\n                 else:\n                     break\n             elif letter in minus:\n                 if bit == 0:\n                     bit = 1\n                     flag = -1\n                     continue\n                 else:\n                     break\n             elif letter not in base:\n                 break;\n             else:\n                 sum *= 10\n                 sum += int(letter)\n         \n         sum *= flag\n         \n         if(sum > INT_MAX):\n             return INT_MAX\n         \n         if(sum < INT_MIN):\n             return INT_MIN\n         \n         return sum\n                 \n         \n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         return 2*sum(set(nums))-sum(nums) #arrays don't usually present themselves sorted for binary search in real life\n", "from heapq import heappush, heappop\nfrom operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass PseudoSet():\n    def __init__(self):\n        self.s = []  # set\n        self.e = []  # erase candidate\n\n    def insert(self, x):\n        heappush(self.s, x)\n\n    def erase(self, x):\n        heappush(self.e, x)\n\n    def get_min(self):\n        while self.e and self.e[0] == self.s[0]:\n            _ = heappop(self.s)\n            _ = heappop(self.e)\n        return self.s[0] if len(self.s) > 0 else None\n\n\nn, q = map(int, input().split())\nevents = []\nfor i in range(n):\n    s, t, x = map(int, input().split())\n    events.append((s - x, +1, x))\n    events.append((t - x, -1, x))\nfor i in range(q):\n    d = int(input())\n    events.append((d, 2, i))\n\nans = [-1] * q\nevents.sort(key=itemgetter(0, 1))\n# print(events)\nps = PseudoSet()\nfor c, t, z in events:\n    if t == 1:\n        ps.insert(z)\n    elif t == -1:\n        ps.erase(z)\n    else:\n        # t == 2\n        m = ps.get_min()\n        if m is not None:\n            ans[z] = m\n\nprint(*ans, sep='\\n')\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, c = list(map(int, input().split()))\n    edges[u-1].append((v-1, c))\n    edges[v-1].append((u-1, c))\n\nret = [-1] * n\nq = deque([0])\nret[0] = 1\nwhile q:\n    now = q.popleft()\n    for nxt, c in edges[now]:\n        if ret[nxt] != -1: continue\n        if ret[now] != c:\n            ret[nxt] = c\n        else:\n            ret[nxt] = 2 if c == 1 else 1\n        q.append(nxt)\nprint(('\\n'.join(map(str, ret))))\n", "import bisect\n\nn = int(input())\ns = list(input())\nq = int(input())\n\npos = [[] for i in range(26)]\nalp = \"abcdefghijklmnopqrstuvwxyz\"\natoi = {}\nfor i in range(26):\n    atoi[alp[i]] = i\nfor i in range(n):\n    pos[atoi[s[i]]].append(i)\n\nfor i in range(q):\n    a, b, c = input().split()\n    if a == \"1\":\n        b = int(b)-1\n        if c == s[b]:\n            continue\n        index = bisect.bisect_left(pos[atoi[s[b]]], b)\n        del pos[atoi[s[b]]][index]\n        bisect.insort_left(pos[atoi[c]], b)\n        s[b] = c\n    else:\n        l, r = int(b)-1, int(c)\n        ans = 0\n        for i in range(26):\n            cnt = bisect.bisect_left(pos[i], r) - bisect.bisect_left(pos[i], l)\n            if cnt > 0:\n                ans += 1\n        print(ans)", "N = int(input())\nA = [int(a) for a in input().split()]\n\ntotal = 0\nfor a in A:\n    total ^= a\n\nfor a in A:\n    print(total^a, end=\" \")", "\nimport sys\nsys.setrecursionlimit(10 ** 7)\nfrom bisect import bisect_left\ndef resolve():\n    def dfs(s, parent):\n        a = A[s]\n        i = bisect_left(dp, a)\n        v = dp[i]\n        dp[i] = a\n        ans[s] = bisect_left(dp, INF)\n        for to in G[s]:\n            if to == parent:\n                continue\n            dfs(to, s)\n        # \u9802\u70b9s\u3067\u306e\u7d50\u679c\u3092\u3082\u3068\u306b\u623b\u3059\n        dp[i] = v\n        return\n\n\n    N = int(input())\n    A = tuple(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = map(lambda x:int(x)-1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n\n    INF = 10 ** 18\n    dp = [INF] * N\n    ans = [0] * N\n\n    dfs(0, -1)\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# cook your dish here\nnum1=int(input())\nnum2=int(input())\nif num1>num2:\n    print(num1-num2)\nelse:\n    print(num1+num2)", "# cook your dish here\ndef modular_pow(base, exponent, modulus):\n result = 1\n while exponent > 0:\n  if(exponent %2 == 1):\n   result = (result * base) % modulus\n  exponent = exponent//2\n  base = (base * base)%modulus\n return result\ndef passesMillerRabinTest(n, a):\n s = 0\n d = n-1\n while(d%2 == 0):\n  s += 1\n  d >>= 1\n x = modular_pow(a, d, n)\n if(x == 1 or x == n-1):\n  return True\n for ss in range(s - 1):\n  x = (x*x)%n\n  if(x == 1):\n   return False\n  if(x == n-1):\n   return True\n return False\nprimeList = (2, 3,5,7,11,13,17,19, 23,29, 31,37)\ndef isPrime(n):\n for p in primeList:\n  if n%p == 0:\n   return n == p\n for p in primeList:\n  if passesMillerRabinTest(n, p) == False:\n   return False\n return True\n \nt = int(input())\nfor tt in range(t):\n n = int(input())\n if(n == 2):\n  print(2)\n  continue\n if n%2 == 0:\n  n -= 1\n while True:\n  if(isPrime(n)):\n   print(n)\n   break\n  n -= 2\n", "# cook your dish here\ndef sree(k, n, m):\n    sum1 = (m*(m+1))//2\n    sum2 = (m*(m-1))//2\n    shanth = 0\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if i < j and k[i] > k[j]:\n                shanth += sum1\n            elif j < i and k[i] > k[j]:\n                shanth += sum2\n    return shanth\n\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    k = list(map(int, input().split()))\n    print(sree(k, n, m))\n", "\r\npowers=[0 for i in range(150001)]\r\n\r\ndef factorize(n):\r\n    factors=set()\r\n    for i in range(1,n):\r\n        if i*i>n:\r\n            break\r\n        else:\r\n            if (n%i)==0:\r\n                factors.add(i)\r\n                factors.add(n//i)\r\n    factors.remove(n)\r\n    return factors\r\n\r\ndef calc(m):\r\n    powers[0]=1\r\n    for i in range(1,150001):\r\n        powers[i]=(powers[i-1]*2)%m\r\n\r\nn,m=list(map(int,input().split()))\r\ncalc(m)\r\ndp=[0 for i in range(n+1)]\r\ndp[1]=2\r\nfor i in range(2,n+1):\r\n    factors=factorize(i)\r\n    dp[i]=powers[i]\r\n    for num in factors:\r\n        dp[i]-=dp[num]\r\n        dp[i]=(dp[i]+m)%m\r\nprint(dp[n])\r\n", "# cook your dish here\nimport sys\nT=int(input())\nfor t in range(T):\n    N=int(input())\n    print(int(N/2)+1)\n", "# cook your dish here\nt=int(input())\nfor i in range(t):\n    n=input()\n    if(n=='b' or n=='B'):\n        print('BattleShip')\n    elif(n=='c' or n=='C'):\n        print('Cruiser')\n    elif(n=='d' or n=='D'):\n        print('Destroyer')\n    else:\n        print('Frigate')", "import math\r\nt=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    a=list(map(int,input().split()))\r\n    p,q=list(map(int,input().split()))\r\n    a=sorted(a)\r\n    b=[0]*len(a)\r\n    s=0\r\n    for i in range(len(a)):\r\n        b[i]=a[i]-p\r\n    for i in range(len(a)//2):\r\n        s=s-math.atan(b[i]/q)+math.atan(b[n-1-i]/q)\r\n    print(s)", "N = int(input())\r\n\r\ncount = 0\r\nfor i in range(1, N):\r\n\tfor j in range(1, N):\r\n\t\tif i * j >= N: break\r\n\t\tcount += 1\r\nprint(count)", "MOD=10**9+7\np=1000000\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n return pow(a,MOD-2,MOD)\ndef nck(n, k):\n if n==k or k==0:\n  return 1 \n if n<k:\n  return 0 \n return fact[n]*MI(fact[k],MOD)*MI(fact[n-k],MOD)%MOD\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n prod=1\n l=[int(i) for i in input().split()]\n l.sort()\n for i in range(n):\n  tot=nck(n-1,k-1)\n  x=n-i\n  asmin=nck(x-1,k-1)\n  y=i+1\n  asmax=nck(y-1,k-1)\n  req=tot-asmin-asmax\n  prod*=pow(l[i],req,MOD)\n print(prod%MOD)", "arr = list(input())\r\nn = len(arr)\r\nans = list()\r\n#for i in arr:\r\n    #ans.append(ord(i)-96)\r\nli = ['b','d','f','h','j','l','n','p','r','t','v','x','z']\r\ns = set(arr)\r\ntemp = s.intersection(li)\r\nfor _ in range(int(input())):\r\n    x,y = list(map(int,input().split()))\r\n    li = list(temp)\r\n    #s = set()\r\n    c=0\r\n    for i in range(x-1,y):\r\n        if arr[i] in li:\r\n            c+=1 \r\n            li.remove(arr[i])\r\n        if len(li)==0:\r\n            break\r\n    print(c)\r\n", "# cook your dish here\nn=int(input())\nfor i in range(n):\n    l=list(map(int,input().split(\" \")))\n    p=0\n    k=0\n    while(p<=l[2]):\n        m=p\n        p=(l[0]*k)+l[1]\n        k+=1\n    print(m)", "#include<sdg.h>\nfor _ in range(int(input())):\n    s=input()\n    n=len(s)\n    if n==1:\n        if s[0].isalpha(): print(\"-32\")\n        else: print(0)\n    else:\n        num,ch=0,0\n        p,q=0,0\n        c=1\n        x=s[0]\n        ans=\"\"\n        for i in range(1,n):\n            if s[i-1]==s[i]:\n                c+=1\n                if i==n-1:\n                    ans+=s[i]\n                    if s[i].isalpha(): ch+=1\n                    else: num+=1\n                    if c>1: \n                        ans+=str(c)\n                        num+=1\n                    c=1\n                        \n            else:\n                if s[i-1].isalpha():\n                    ch+=1\n                    ans+=s[i-1]\n                    if c>1: \n                        ans+=str(c)\n                        num+=1\n                    c=1\n                else:\n                    ans+=s[i-1]\n                    num+=1\n                    if c>1: \n                        ans+=str(c)\n                        num+=1\n                    c=1\n                if i==n-1:\n                    ans+=s[i]\n                    if s[i].isalpha(): ch+=1\n                    else: num+=1\n        #print(ans,num,ch)\n        alp,qt=0,0\n        for i in range(n):\n            if s[i].isalpha(): alp+=1\n            else: qt+=1\n        sol=((qt-num)*32)+((alp-ch)*8)\n        print(sol)", "# cook your dish here\nimport math\nt=int(input())\nwhile t>0:\n n,l=list(map(int,input().split()))\n if n==1:\n  print(l)\n elif n==2:\n  ans=math.sqrt(l)\n  k=int(ans)\n  print(k+1)\n   \n t-=1", "def gcd(a,b):\n if b==0: return a \n return gcd(b,a%b)\nfrom math import sqrt as S \nfor _ in range(int(input())):\n n=int(input())\n tot=n*n\n s=0\n beta=int(S(n))\n for i in range(1,int(S(n))+1):\n  s+=n//i \n s=2*s-beta*beta \n g=gcd(s,tot)\n s=s//g \n tot=tot//g \n print(s,end='')\n print('/',end='')\n print(tot)\n ", "def EXEC(n):\r\n    if n < 3: return n\r\n    else:\r\n        x, y = 1, 2\r\n        for _ in range(2, n):\r\n            z = (x + y) % 15746\r\n            x, y = y, z\r\n        return y % 15746\r\n\r\n\r\nprint(EXEC(int(input())))", "# cook your dish here\nfor t in range(int(input())):\n    k,n=map(int, input().split())\n    a=list(map(int, input().split()))[:n]\n    lst=[]\n    for i in range(n):\n        if a[i]==k:\n            lst.append(i)\n    if len(lst)>0:\n        print(max(lst)-min(lst))\n    else:\n        print(0)", "def ncr(n, r): \n if n < r :\n  return 0\n elif r == 2:\n  return(n*(n-1)/2)\n elif r == 1:\n  return n\n else:\n  t = 0\n\nt = int(input())\nfor p in range(t):\n n,m,x,y = input().split()\n n,m,x,y = int(n),int(m),int(x),int(y)\n\n maxi = ncr(n*m-1,2)\n\n sub1 = ncr(n,2) * (m-1)\n sub2 = ncr(m,2) * (n-1)\n maxi = maxi - (sub1 + sub2)\n #print(maxi)\n\n sub3 = ncr(y-1,2) + ncr(m-y,2)\n sub4 = ncr(x-1,2) + ncr(n-x,2)\n #print(sub3,sub4)\n maxi = maxi - (sub3 + sub4)\n #print(maxi)\n\n if n < m:\n  temp = n\n  diff = m-n\n else:\n  temp = m\n  diff = n-m\n\n sub5 = 0\n sub6 = 0\n for i in range(2,temp):\n  sub5 += ncr(i,2)\n\n for j in range(diff+1):\n  sub6 += ncr(temp,2)\n\n sub5 *= 4\n sub6 *= 2\n\n #print(sub5,sub6)\n maxi = maxi - (sub5 + sub6)\n #print(maxi)\n\n l1 = min(n-x,y-1)\n l2 = min(m-y,x-1)\n maxi = maxi + l1 + l2 + (l1*l2)\n\n\n l3 = min(x-1,y-1)\n l4 = min(m-y,n-x)\n maxi = maxi + l3 + l4 + (l3*l4)\n\n print(int(maxi*2))\n\n\n\n\n", "# cook your dish here\nN, K = map(int, input().split(\" \"))\ninputs = list(map(int, input().split(\" \")))\ninputs.sort()\ntotal = 0\nprevious = [None, None]\nfor n in range(1, N): \n    if inputs[n] == previous[0]: \n        total+=previous[1]\n        continue\n    previous = [None, None]\n    for i in range(n-1, -1, -1):\n        tmp = inputs[n] - inputs[i]\n        if tmp < 0: \n            tmp = -tmp\n        if tmp >= K: \n            total += i+1 \n            previous[1] = i+1\n            previous[0] = inputs[n]\n            break\n    if previous[0] is None: \n        previous[0] = inputs[n]\n        previous[1] = 0\nprint(total)", "for _ in range(int(input())):\r\n    S, SG, FG, D, T = map(int, input().split())\r\n    speed = (D*180)/T + S\r\n    if abs(SG-speed) == abs(FG-speed):\r\n        print('DRAW')\r\n    elif abs(SG-speed) > abs(FG-speed):\r\n        print('FATHER')\r\n    else:\r\n        print('SEBI')", "t=int(input())\nfor i in range(0,t):\n n=int(input())\n x=4*n\n ans=2\n m=n+1\n tem=0\n if(n%2==0):\n  ans=(n/2)*8\n elif(n%4==3):\n  ans=n\n else:\n  val=(n+3)/4\n  ans=2+(val-1)*8\n print(ans)", "t = int(input())\nfor i in range(t):\n    c = 1\n    n, m = map(int, input().split())\n    A = list(map(int, input().split()))\n    a = set(A)\n    j = 1\n    while j < m and j in a:\n        j += 1\n    if j != m:\n        print(-1)\n    else:\n        print(n-A.count(m))", "import sys\nimport math\n\ndef main(grid):\n    \n    ans=0\n    for i in range(len(grid)):\n        \n        for j in range(len(grid[0])):\n            first_point=grid[i][j]\n            for k in range(j+1,len(grid[0])):\n                second_point=grid[i][k]\n                \n                if first_point==second_point:\n                    dist=k-j\n                    \n                    if i+dist<len(grid):\n                        \n                        thrid_point=grid[i+dist][j]\n                        fourth_point=grid[i+dist][k] \n                        if second_point==thrid_point and second_point==fourth_point:\n                            ans+=1\n    return ans\nfor _ in range(int(input())):\n    n,m=input().split()\n    n=int(n)\n    arr=[]\n    for b in range(n):\n        arr.append(list(input()))\n    print(main(arr))\n                \n            \n\n        ", "try:\n    t = int(input())\n    result = []\n    for i in range(t):\n        check1 = True\n        check2 = True\n        tr = int(input())\n        trl = list(map(int, input().split()))\n        dr = int(input())\n        drl = list(map(int, input().split()))\n        ts = int(input())\n        tsl = list(map(int, input().split()))\n        ds = int(input())\n        dsl = list(map(int, input().split()))\n\n        for j in range(ts):\n            if (tsl[j] not in trl):\n                check1 = False\n            else:\n                continue\n\n        for k in range(ds):\n            if (dsl[k] not in drl):\n                check2 = False\n            else:\n                continue\n\n        if (check1 == True and check2 == True):\n            result.append(\"yes\")\n        else:\n            result.append(\"no\")\n\n    for b in result:\n        print(b)\n\n\n\nexcept:\n    pass", "for q in range(int(input())):\n n,k=list(map(int,input().split()))\n test=[]\n z=[]\n f=0\n for i in range(n):\n  l=[int(i) for i in input().split()]\n  l=l[1:]\n  z.append(l)\n c=[0]*(k+1)\n for i in range(n):\n  for j in z[i]:\n   c[j]+=1\n for i in range(1,k+1):\n  if c[i]==0:\n   print(\"sad\")\n   f=1\n   break\n if f==1:\n  continue\n for i in range(n):\n  cnt=0\n  for j in z[i]:\n   if c[j]!=1:\n    cnt+=1\n  if cnt==len(z[i]):\n   print(\"some\")\n   break\n else:\n  print(\"all\")\n   \n    \n   \n", "t=int(input())\r\nwhile(t!=0):\r\n    k=0\r\n    n=int(input())\r\n    if n&n-1==0:\r\n        print(0)\r\n    else:\r\n        while(n!=0):\r\n             n=n&n-1\r\n             k+=1\r\n        print(k-1)\r\n    t-=1\r\n\r\n\r\n", "import sys\n\nt = int(input())\n\ndef g(a,b):\n if (a > b):\n  tmp = a\n  a = b\n  b = tmp\n if (b == a):\n  return 0\n if (b % a == 0):\n  return int(b/a)-1\n r = g(b%a,a)\n q = int(b/a)\n if (r >= q):\n  return q-1\n else:\n  return q\n\ndef mex(x):\n n = len(list(x.keys()))\n for i in range(n):\n  if (i not in x):\n   return i\n return i\n\ndef g2(a,b):\n if (a == b):\n  return 0\n if (a > b):\n  tmp = a\n  a = b\n  b = tmp\n if (b % a == 0):\n  return int(b/a)-1\n q = int(b/a)\n x = {}\n r = b % a\n for i in range(q):\n  x[g2(r+i*a,a)] = True\n return mex(x)\n\n#print(str(g(6,33))+\" \"+str(g2(6,33)))\n\nwhile (t):\n\n n = int(input())\n x = 0\n while (n):\n  line = input().split()\n  a = int(line[0])\n  b = int(line[1])\n  x ^= g(a,b)\n  n -= 1\n if (x):\n  sys.stdout.write(\"YES\\n\")\n else:\n  sys.stdout.write(\"NO\\n\")\n #print(str(g(a,b)) + \" \" + str(g2(a,b)))\n t -= 1", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return list(map(int, inp().split()))\ndef smp(): return list(map(str, inp().split()))\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nfor _ in range(int(inp())):\n    n = int(inp())\n    k = 1\n    for i in range(2*n):\n        if i!=0 and i%2==0:\n            k+=2\n        print(\" \"*((n-k)) + \"*\"*k + \" \"*((n-k)))\n", "#!/usr/bin/env python\n\ndef main():\n N = int(input())\n while True:\n  try:\n   X = input()\n  except:\n   break\n  H = list(map(int, X.split()))\n  C = 0\n  while H:\n   e = H.pop(0)\n   H2, C1, C2 = list(H), e, 0\n   for i in range(len(H2)):\n    if H2[i] > e-1:\n     C2 += H2[i]-(e-1)\n     H2[i] = e-1\n   #print C+C2, H2, C+C1, H\n   if C1 <= C2:\n    C += C1\n   else:\n    C += C2\n    H = H2\n  print(C)\n\nmain()\n\n", "t=int(input())\nfor i in range(t):\n s=input()\n l=[0 for i in range(26)]\n for j in range(len(s)):\n  l[ord(s[j])-97]+=1\n f=0\n for j in range(26):\n  if l[j]>1:\n   f=1\n   break\n if f==1:\n  print(\"yes\")\n else:\n  print(\"no\")", "from decimal import *\ndef firstkdigits(n, k): \n n = Decimal(n)\n product = n *(n.log10());\n decimal_part = product%1; \n d = pow(10, decimal_part + k -1); \n return str(int(d))\nfor _ in range(int(input())):\n n,k = map(int,input().split())\n q2 = str(pow(n, n, 10 ** k)).zfill(k)\n if n >= 1000 :\n  q1 = firstkdigits(n,k)\n else :\n  q1 = str(n**n)[:k] \n print(q1 + \" \" + q2)", "import sys\n\nfor __ in range(eval(input())) :\n n = eval(input())\n lists = list(map(int,sys.stdin.readline().split()))\n curmax , temp , fflag = 0 , 2 , False\n for i in range(2,n) :\n  if lists[i-2]+lists[i-1] == lists[i] :\n   temp += 1\n  else :\n   if temp > curmax :\n    curmax = temp\n   temp = 2\n print(max(curmax,temp) if n > 1 else 1)\n", "\r\n\r\nz = int(input())\r\ni = 0\r\nwhile i < z:\r\n  n = int(input())\r\n  p = int(n**(0.5))\r\n  if p*(p+1) < n:\r\n    p += 1\r\n  # print(\"P\", p)\r\n  x, y = 0, 0\r\n  q = 0\r\n  flag = True\r\n  if p*(p+1) == n:\r\n    # print(\"Even steps, nice\")\r\n    q = p\r\n  else:\r\n    # remaining steps\r\n    q = p-1\r\n    flag = False\r\n  if q%2 :\r\n    # odd\r\n    x -= ((q+1)//2)\r\n    y += ((q+1)//2)\r\n  else :\r\n    x += (q//2)\r\n    y -= (q//2)\r\n  if flag:\r\n    print(x, y)\r\n  else:\r\n    # remaining steps\r\n    l = q*(q+1)\r\n    t = p*(p+1)\r\n    diff = t-l\r\n    \r\n\r\n    # print(x, y)\r\n    if x < 0:\r\n      # left\r\n      if n-l >= diff//2:\r\n        y *= (-1)\r\n        l += (diff//2)\r\n        x += (n-l)\r\n      else :\r\n        y -= (n-l)\r\n      \r\n    else:\r\n      # right\r\n      if n-l >= diff//2:\r\n        y *= (-1)\r\n        y += 1\r\n        l += (diff//2)\r\n        x -= (n-l)\r\n      else :\r\n        y += (n-l)\r\n    # print(\"Remaining steps: \", n-l)\r\n    print(x, y)\r\n  i+=1 ", "# cook your dish here\nimport math\nfor _ in range(int(input())):\n n,m=list(map(int,input().split()))\n p=[10]*n\n for i in range(m):\n  l=list(map(int,input().split()))\n  i=l[0]-1\n  j=l[1]\n  k=l[2]\n  for s in range(i,j,1):\n   p[s]=p[s]*k\n sup=sum(p)\n sup=math.floor(sup/n)\n print(sup)\n", "# cook your dish here\nfor i in range(int(input())):\n n = int(input())\n l1 = list(map(int,input().split( )))\n l2 = list(map(int,input().split( )))\n a = sum(l1) - max(l1)\n b = sum(l2) - max(l2)\n if a>b:\n  print('Bob')\n elif b>a:\n  print('Alice')\n else:\n  print('Draw')", "def find_combinations(list, sum):\n if not list:\n  if sum == 0:\n   return [[]]\n  return []\n return find_combinations(list[1:], sum) + \\\n  [[list[0]] + tail for tail in\n   find_combinations(list[1:], sum - list[0])]\nfor tc in range(int(input())):\n n,k=list(map(int,input().split()))\n a=list(map(int,input().split()))\n a.sort()\n if len(find_combinations(a,k))==0:\n  print(\"NO\")\n else:\n  print(\"YES\")\n  \n", "n,m=map(int,input().split())\r\nb=[[int(x) for x in list(input())] for x in range(n)]\r\nc=int(input())\r\n\r\nsize=min(n,m)\r\nres=[size**2 for x in range(size+1)]\r\n\r\ndef invert(i,j,r,ele):\r\n    count=0\r\n    \r\n    for index,x in enumerate(range(i,i+r)):\r\n        temp=ele\r\n        if index%2:\r\n            temp=0 if ele else 1\r\n            \r\n        for y in range(j,j+r):\r\n            count+=0 if temp==b[x][y] else 1\r\n            temp=0 if temp else 1\r\n    return count\r\n\r\n\r\nfor s in range(size,1,-1):\r\n    flag=0\r\n    for x in range(n-s+1):\r\n        for y in range(m-s+1):\r\n            ic=min(invert(x,y,s,0),invert(x,y,s,1))\r\n            res[s]=min(res[s],ic)\r\n            # print(x,y,s,ic)\r\n            if not ic:\r\n                flag=1\r\n                break\r\n        if flag:\r\n            break\r\n    if flag:\r\n        break\r\n\r\nfor t in map(int,input().split()):\r\n    for index,e in reversed(list(enumerate(res))):\r\n        if e<=t:\r\n            print(index)\r\n            break\r\n\r\nres = list(map(lambda x: 0 if x==size**2 else x,res))", "for _ in range(int(input())):\n n,k=list(map(int,input().split()))\n c=list(map(int,input().split()))\n count=1\n for i in range(n):\n  if i+1<n:\n   if c[i]-c[i+1]>=k or c[i+1]-c[i]>=k:\n    continue\n   else:\n    count+=1\n    c[i],c[i+1]=c[i+1],c[i]\n print(count)\n    \n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n #dup=l[:]\n dup=sorted(l)\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  d1=d[x].copy()\n  f=1\n  low=0\n  high=n-1 \n  while low<=high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "# cook your dish her\nfor _ in range(int(input())):\n x=set(input())\n y=set(input())\n if(len(x&y)):\n  print('Yes')\n else:\n  print('No')\n", "for _ in range(int(input())):\r\n    n=int(input())\r\n    a=list(map(int,input().split()))\r\n    flag=0\r\n    for i in range(len(a)-2):\r\n        if len(set(a[i:i+3]))==1:\r\n            print('Yes')\r\n            flag=1\r\n            break\r\n        else:\r\n            flag=0\r\n    if flag==0:\r\n        print('No')", "\ntest=int(input())\nfor t in range(test):\n n= int(input())\n\n adj=[[] for i in range(n+1)]\n\n for _ in range(n-1):\n  a,b=list(map(int,input().split()))\n  adj[a].append(b)\n  adj[b].append(a)\n \n\n #print(adj)\n root=1\n q,s=[root],set([root])\n\n for x in q:\n  adj[x]= [p for p in adj[x] if p not in s]\n  q.extend(adj[x])\n  s.update(adj[x])\n\n #print(adj)\n ans=True\n if(n<4):\n  ans=False\n for i in range(n+1):\n  if(len(adj[i]) %3!=0):\n   ans=False\n if(ans):\n  print(\"YES\")\n  for i in range(n+1):\n   while(len(adj[i])):\n    print(i,adj[i][0],adj[i][1],adj[i][2])\n    adj[i].pop(0)\n    adj[i].pop(0)\n    adj[i].pop(0)\n else:\n  print(\"NO\")\n", "import math\n\nfor _ in range(int(input())):\n n = int(input())\n \n def findNumber( n ): \n  \n  x = int(math.ceil((-1 + math.sqrt(1\n    + 8 * n + 8)) / 2)) \n  x -= 1\n   \n  b = (x * (x + 1)) // 2 - 1\n  \n  res = n - b -1 \n  \n  return res\n ans = findNumber(n)\n print(ans)", "# cook your dish here\r\nfrom collections import deque, defaultdict\r\nfrom math import sqrt, ceil,factorial\r\nimport sys\r\nimport copy\r\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\r\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\r\ndef input(): return sys.stdin.readline().strip()\r\n\r\nfor _ in range(int(input())):\r\n\r\n    s=input()\r\n    if len(s)>6:\r\n        ans=0\r\n        rem=len(s)-6\r\n        ans+=factorial(len(s))\r\n        ans-=2*(factorial(len(s)-2))\r\n        ans+=factorial(rem+2)\r\n        print(ans)\r\n\r\n    else:\r\n        if 'k' in s and 'r' in s and 'a' in s and 's' in s and 'h' in s and 'i' in s:\r\n            ans = 0\r\n            rem = len(s) - 6\r\n            ans += factorial(len(s))\r\n            ans -= 2 * (factorial(len(s) - 2))\r\n            ans += factorial(rem + 2)\r\n            print(ans)\r\n        else:\r\n            if 'k' in s and 'a' in s and 'r' in s:\r\n                ans=0\r\n                rem=len(s)-3\r\n                ans+=factorial(len(s))\r\n                ans-=factorial(rem+1)\r\n                print(ans)\r\n                continue\r\n            if 's' in s and 'h' in s and 'i' in s:\r\n                ans = 0\r\n                rem = len(s) - 3\r\n                ans += factorial(len(s))\r\n                ans -= factorial(rem + 1)\r\n                print(ans)\r\n                continue\r\n\r\n            print(factorial(len(s)))\r\n\r\n", "#! /usr/bin/env python\n\nfrom sys import stdin\nfrom functools import reduce\n\ndef gcd(a,b):\n\twhile b!=0:\n\t\ta,b=b,a%b\n\treturn a\n\t\ndef gcdl(l):\n\treturn reduce(gcd, l[1:],l[0])\n\ndef __starting_point():\n\tT=int(stdin.readline())\n\tfor case in range(T):\n\t\tnumbers=list(map(int, stdin.readline().split()[1:]))\n\t\tg=gcdl(numbers)\n\t\t\n\t\tnumbers=[n/g for n in numbers]\n\t\tprint(\" \".join([str(x) for x in numbers]))\n\n__starting_point()", "# cook your dish here\nT = int(input())\n\nfor t in range(T):\n apples, oranges, coins = input().split()\n apples = int(apples)\n oranges = int(oranges)\n coins = int(coins)\n while coins > 0:\n  if apples > oranges:\n   oranges += 1 \n   coins -= 1\n  elif oranges > apples:\n   apples += 1\n   coins -= 1\n  else:\n   if coins % 2 == 0:\n    half = int(coins / 2)\n    apples = apples + half\n    oranges = oranges + half\n    coins = 0\n    break\n   else:\n    half = int(coins / 2)\n    #coins = coins - half\n    apples = apples + half\n    oranges = oranges + half\n    coins = 1\n    break\n print(int(abs(apples-oranges))) \n #print(int(apples - oranges) if apples >= oranges else int(oranges - apples\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0))\n", "# cook your dish here\nfor i in range(int(input())):\n n,m=list(map(int,input().split()))\n if(n==1):\n  print(0)\n  continue\n if(n==2):\n  print(m)\n  continue\n ans=(n-1)+2*(m-1)\n print(ans)\n \n", "for t in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n s=0\n l=[]\n for i in range(n):\n  if (a[i]<0):\n   e=i\n   ss=sum(a[s:e])\n   l.append((ss,e-s,n-s))\n   s=i+1\n e=n\n ss=sum(a[s:e])\n l.append((ss,e-s,n-s))\n x=max(l)\n s=n-x[2]\n e=x[1]+s\n for i in range(s,e):\n  print(a[i], end=' ')\n print(\"\")", "# cook your dish here\nimport math\nt=0\ntry:\n t = int(input())\nexcept EOFError as e : pass\nfor i in range(t):\n myStr = input().replace('=', '')\n if len(myStr) == 0 :\n  print(1)\n  continue\n ans = 0\n count = 1\n for k in range(len(myStr)-1):\n  if myStr[k] == myStr[k+1]:\n   count +=1\n  else:\n   ans = max(count, ans)\n   count = 1\n  ans = max(count, ans)\n print(ans+1)\n", "n=int(input())\nfor _ in range(n):\n    c=0\n    s=input()\n    for i in s:\n        if i=='a':\n            c+= 1 \n    print((2**len(s)-2**(len(s)-c)))# cook your dish here\n", "s = input()\nn = int(input())\nt = []\nfor _ in range(n):\n a = input()\n t.append(a)\n\nfor i in t:\n flag = True\n for j in i:\n  if j not in s:\n   flag = False\n   break\n if(flag):\n  print(\"Yes\")\n else:\n  print(\"No\")\n", "T = int(input())\nfor j in range(1, T+1):\n N, B = input().split()\n N = int(N)\n B = int(B)\n p = N % B\n k = N\n fs = 0\n maxim = 0\n for i in range(p, N-B+1, B):\n  N = k\n  fs = 0\n  ss = 0\n  fs = fs + i\n  N = N-i\n  while (N>=B):\n   ss = ss + fs\n   N = N-B\n  if ss > maxim:\n   maxim = ss\n print(maxim)\n  \n  \n", "for _ in range(int(input())):\r\n    n = int(input())\r\n\r\n    print('1' * n)\r\n\r\n    s = list(' ' * n)\r\n    s[0] = s[-1] = '1'\r\n\r\n    l, r = 1, n-2\r\n    for i in range(2, n):\r\n        s[l] = s[r] = '1'\r\n        print(*s, sep='')\r\n        s[l] = s[r] = ' '\r\n\r\n        l += 1\r\n        r -= 1\r\n\r\n    if n != 1:\r\n        print('1' * n)", "# your code goes here\nfrom sys import stdin, stdout\nn = int(stdin.readline())\nwhile n:\n n -= 1\n k, l, e = map(int, stdin.readline().strip().split(' '))\n a = map(int, stdin.readline().strip().split(' '))\n x = float(l) / float(e + sum(a))\n if x - int(x):\n  stdout.write(\"NO\\n\")\n else:\n  stdout.write(\"YES\\n\")", "# cook your dish here\nn = int(input())\nfor i in range(n):\n a = int(input())\n l = [int(x) for x in input().split()]\n if sum(l) >= 0:\n  print(\"YES\")\n else:\n  print(\"NO\")", "# cook your dish here\ntry:\n def find_gcd(x, y): \n  while(y): \n   x, y = y, x % y \n  \n  return x\n def gcd_arr(l):\n  num1=l[0] \n  num2=l[1] \n  gcd=find_gcd(num1,num2) \n  \n  for i in range(2,len(l)): \n   gcd=find_gcd(gcd,l[i])\n  return(gcd)\n def factors(n):\n  #print(n)\n  if n==0:\n   return 1\n  x=[]\n  for i in range(1,int(n**(1/2))+1):\n   if n%i==0:\n    x.append(i)\n    x.append(n//i)\n  return(x)\n for t in range(int(input())):\n  n,m=map(int,input().split())\n  p=list(map(int,input().split()))\n  hcf=0\n  if m>1:\n   hcf=gcd_arr(p)\n  else:\n   hcf=p[0]\n  fact=factors(hcf)\n  fact.sort(reverse=True)\n  final=0\n  for i in fact:\n   if i<=n:\n    final=n-i\n    break\n  print(final)\nexcept:\n pass", "# cook your dish here\r\nn=int(input())\r\na=[int(i) for i in input().split()]\r\nfor i in a:\r\n    if i==1:\r\n        print(\"2\",'',end='')\r\n    elif i==2:\r\n        print(\"1\",'',end='')\r\n    else:\r\n        b=str(bin(i)).replace('0b','')\r\n        p=''\r\n        l=len(b)\r\n        if b[l-1]=='0':\r\n            p='0'\r\n        else:\r\n            p='1'\r\n        if b[l-2]=='0':\r\n            p='1'+p\r\n        else:\r\n            p='0'+p\r\n        for j in range(l-3,-1,-1):\r\n            p=b[j]+p\r\n        print(int(p,2),'',end='')\r\nprint()", "import math\nT=int(input())\nfor i in range(T):\n n,x,m=list(map(int,input().split()))\n l1=[int(i) for i in input().split()]\n if x==1:\n  l1[0]=l1[0]%1000000007\n  print(l1[0])\n elif x==2:\n  m=m%1000000007\n  l1[0]=l1[0]%1000000007\n  l1[1]=(l1[1]%1000000007+l1[0]*m%1000000007)%1000000007\n  print(l1[1])\n else:\n  m=m%1000000007\n  c=-1\n  y=0\n  q=1\n  f=1\n  y=(l1[x-1]%1000000007)\n  for j in range(x-2,-1,-1):\n   c=c+1\n   q=(q*((m+c)%1000000007))%1000000007\n   q=(q*pow(c+1,1000000005,1000000007))%1000000007\n   y=(y+(q*(l1[j]%1000000007))%1000000007)%1000000007\n   #print(q,s,c)\n   #print(y,s,l1[j])\n  print(y%1000000007)\n  \n\n", "# cook your dish here\ndef s(n):\n sn=str(n)\n r=0\n for i in sn:\n  r+=int(i)\n return r\n  \nfor _ in range(int(input())):\n n=int(input())\n print(str(n)+str((10-s(n))%10))", "#!/usr/bin/env python\n\ndef memo(func):\n    cache = {}\n    def f(*args):\n        if args in cache:\n            return cache[args]\n        r = func(*args)\n        cache[args] = r\n        return r\n    return f\n\ndef doit():\n    s = input().strip()\n    words = set([input().strip() for x in range(eval(input()))])\n    @memo\n    def g(start, end):\n        num = set([])\n        if start >= end: return 0\n        for w in words:\n            x = start\n            while x + len(w) <= end:\n                r = s.find(w, x, end)\n                if r == -1:\n                    break\n                num.add(g(start, r) ^ g(r + len(w), end))\n                x = r + 1\n        x = 0\n        while x in num:\n            x += 1\n        return x\n    return g(0, len(s)) > 0\n\nn = eval(input())\nfor x in range(n):\n    if doit():\n        print('Teddy')\n    else:\n        print('Tracy')\n", "# cook your dish here\nfor i in range(int(input())):\n a=list(map(int,input().split()))\n x=input()\n t=0\n for i in range(97,123):\n  if chr(i) not in x:\n   t+=a[i-97]\n print(t)", "# cook your dish here\ndef func1(l):\n if(len(l)==1):\n  return 0\n elif(len(l)==2):\n  return l[1]-l[0]\n else:\n  mid=len(l)//2\n  p=l[:mid]\n  q=l[mid:]\n  return max(func1(p),func1(q),max(q)-min(p))\ndef func2(l):\n if(len(l)==1):\n  return float('inf')\n elif(len(l)==2):\n  return l[1]-l[0]\n else:\n  mid=len(l)//2\n  p=l[:mid]\n  q=l[mid:] \n  return min(func2(p),func2(q),min(q)-max(p))\nn,x=list(map(int,input().split()))\narr=list(map(int,input().split()))\nl=[0]\nfor i in arr:\n l.append(l[-1]+i)\nl.pop(0)\nif(x==1):\n print(l[-1])\nelif((1/x)-1<0):\n v=func1(l)\nelse:\n v=func2(l)\nprint(l[-1]-v+(v/x))\n\n\n\n", "# cook your dish here\nst = str(input())\n\ndef checkpal(i,j,k,l):\n \n a=i\n b=l\n while(a<b):\n  if st[a] != st[b]:\n   \n   return -1\n  \n  if(a==j):\n   a = k-1\n  if(b==k):\n   b = j+1\n\n  a+=1\n  b-=1 \n # print(i,j,k,l)\n # print(\"yes\")\n return 1\n\nl = len(st)\ncount = 0\nfor i in range(l):\n for j in range(i,l):\n  for k in range(j+1,l):\n   for m in range(k,l):\n    if checkpal(i,j,k,m) == 1: \n     count += 1\n   \nprint(count)", "# cook your dish here\nT = int(input())\nfor _ in range(T):\n n = int(input())\n a, b = [], []\n for _ in range(n):\n  x, h = input().split()\n  a.append(int(x))\n  b.append(int(h))\n a = [y - x for x, y in zip(a, a[1:])]\n a = sorted(x + y for x, y in zip([0] + a, a + [0]))\n print(sum(x * y for x, y in zip(a, sorted(b))))", "n,k=input().split()\nn,k=int(n),int(k)\na=list(map(int,input().split()))\nmaxi=0\nmini=0\nif k!=0:\n maxi=max(a)\n mini=min(a)\nmini=maxi-mini\nfor i in range(n):\n a[i]=maxi-a[i]\nif k%2==0:\n for i in range(n):\n  a[i]=mini-a[i]\nprint(\" \".join(map(str,a)))", "for _ in range(int(input())):\n n=int(input())\n l=list(map(int,input().split()))\n u=[]\n k=0\n t=max(l)\n for i in range(n):\n  if l[i]==t:\n   break\n y=i+1\n while y!=i:\n  if l[y] !=t:\n   k+=1\n  else:\n   u.append(k)\n   k=0\n  y=(y+1)%n\n if k!=0:\n  u.append(k)\n s=0\n for i in range(len(u)):\n  s+=max(0,u[i]-n//2+1)\n print(s)\n", "# cook your dish here\nfl = [ 0, 1, 1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7,\n  0, 7, 7, 4, 1, 5, 6, 1, 7, 8, 5, 3, 8, 1, 9,\n  0, 9, 9, 8, 7, 5, 2, 7, 9, 6, 5, 1, 6, 7, 3,\n  0, 3, 3, 6, 9, 5, 4, 9, 3, 2, 5, 7, 2, 9, 1]\n\ndef log2(num) :\n i = -1\n while num>0 :\n  i+=1\n  num//=2\n return i\n\ncycle = 60\nfor _ in range(int(input())) :\n n = int(input())\n target = (2**(log2(n)))%60\n print(fl[target-1])", "S=list(input().split())\r\nmin=S[0]\r\nml=len(S[0])\r\nans=[]\r\nfor i in S:\r\n    if len(i)<ml:\r\n        ml=len(i)\r\n        min=i\r\nfor j in range(len(S)):\r\n    print(min,end=\" \")\r\n    print(S[j],end=\" \")\r\nprint(min)", "s='abcdefghijklmnopqrstuvwxyz'\nfor u in range(int(input())):\n n=int(input())\n r=''\n while(1):\n  r=s[n::-1]+r\n  if(n<26):\n   break\n  n-=25\n print(r)", "for _ in range(int(input())):\n r,c = map(int,input().split())\n l = []\n for k in range(r):\n  a = list(map(int,input().split()))\n  l.append(a)\n ans = \"Stable\" \n for i in range(r):\n  for j in range(c):\n   p = l[i][j]\n   count=0\n   if i-1>=0 and j>=0:\n    count+=1 \n   if i>=0 and j-1>=0:\n    count+=1 \n   if i+1<=r-1 and j<=c-1:\n    count+=1 \n   if i<=r-1 and j+1<=c-1:\n    count +=1\n   if count<=p:\n    ans = \"Unstable\"\n    break\n print(ans) ", "for u in range(int(input())):\n n,m=map(int,input().split())\n st=input()\n f=0\n for i in range(n):\n  for j in range(m):\n   x=i \n   y=j\n   for k in range(len(st)):\n    if st[k]=='L':\n     y=y-1\n    elif st[k]=='R':\n     y=y+1\n    elif st[k]=='U':\n     x=x-1\n    elif st[k]=='D':\n     x=x+1\n    if x>=0 and x<n and y>=0 and y<m:\n     ll=0\n    else:\n     break\n   if x>=0 and x<n and y>=0 and y<m:\n     f=1\n if f==1:\n  print(\"safe\")\n else:\n  print(\"unsafe\")", "T = int(input())\r\nfor i in range(T):\r\n    l = list(map(int, input().split()))\r\n    n, k, m, x = l[0], l[1], l[2], l[3]\r\n    if k == 1:\r\n        if n == m:\r\n            print(\"yes\")\r\n        else:\r\n            print(\"no\")\r\n    elif m % k > 1:\r\n        print(\"no\")\r\n    elif k == 2:\r\n        stack = []\r\n        var = 0\r\n        while m != 0:\r\n            var += m % k\r\n            stack.append(m % k)\r\n            m //= k\r\n        if var > n:\r\n            print(\"no\")\r\n        elif var == n:\r\n            print(\"yes\")\r\n        else:\r\n            for p in range(100):\r\n                for q in range(2, len(stack)):\r\n                    if stack[q - 1] == 0 and stack[q] >= 1:\r\n                        stack[q-1] = 2\r\n                        stack[q] -= 1\r\n                        var += 1\r\n                        if var == n:\r\n                            print(\"yes\")\r\n            if var < n:\r\n                print(\"no\")\r\n    else:\r\n        temp = 0\r\n        rog = 1\r\n        while m != 0:\r\n            if m % k > 2:\r\n                rog = 0\r\n                print(\"no\")\r\n            temp += m % k\r\n            m //= k\r\n        if rog:\r\n            if temp == n:\r\n                print(\"yes\")\r\n            else:\r\n                print(\"no\")\r\n\r\n", "import math\n\ndef solve(arr,n):\n g = 0\n count = 0\n for i in arr:\n  g = math.gcd(max(i,g),min(i,g))\n  if g == 1:\n   g = 0\n   count += 1\n\n if g > 1 and count == 0:\n  print(-1)\n  return\n \n print(count)\n\ndef main():\n t = int(input())\n for i in range(t):\n  n = int(input())\n  arr = list(map(int,input().split()))\n  solve(arr,n)\n  \n\nmain()\n", "t=int(input())\r\n\r\nwhile t>0:\r\n    t-=1\r\n    n=int(input())\r\n    \r\n    l1=[int(i) for i in input().split(\" \")]\r\n    \r\n    ans=\"\"\r\n    \r\n    flag=0\r\n    k=0\r\n    for i in l1:\r\n        if flag==1 and i!=1:\r\n            k+=1\r\n        elif i==1 and flag==0:\r\n            flag=1\r\n        elif i==1 and flag==1:\r\n            if k>=5:\r\n                k=0\r\n            else:\r\n                ans=\"NO\"\r\n                break\r\n    if ans==\"\":\r\n        ans=\"YES\"\r\n    print(ans)\r\n            ", "T = int(input())\nfor i in range(T):\n N = int(input())\n seq = [int(s) for s in input().split()]\n ans = 0\n for i in range(len(seq)):\n  a = seq[i]\n  c = seq[a-1]\n  for j in range(i+1, len(seq)):\n   b = seq[j]\n   d = seq[b-1]\n   if(a!=b and c==d):\n    ans = 1\n    break\n  if(ans == 1):\n   break\n if(ans == 1):\n  print(\"Truly Happy\")\n else:\n  print(\"Poor Chef\")", "# cook your dish here\nfor _ in range(int(input())):\n bstr = input()\n if '101' in bstr or '010' in bstr:\n  print(\"Good\")\n else:\n  print(\"Bad\")", "count = 0\nfor t in range(int(input())):\n l = []\n s = input()\n for c in s:\n  l.append(c)\n  if (len(l)==1):\n   continue\n  else:\n   if (l[-1]==l[-2]):\n    l = l[:-2]\n if (len(l)==0):\n  count+=1\nprint(count)", "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    a.sort()\n    b=[0]*n\n    for i in range(n):\n        b[i]=a[i][1]\n  \n    print(LongestIncreasingSubsequenceLength(b, n)) \n", "for i in range(int(input())):\n    n,k=list(map(int,input().split()))\n    a=[int(i) for i in input().split()]\n    wsum=0;msum=0;\n    for i in range(k):\n       wsum+=a[i] \n    msum=max(wsum,msum)\n    #st=wsum-a[k-1]+a[-1]\n    for i in range(k,n+k-1):\n        if i<n:\n            wsum+=a[i]-a[i-k]\n        else:\n            wsum+=a[abs(n-i)]-a[i-k]\n            #print(wsum)\n        \n        msum=max(wsum,msum)\n    print(msum)\n  \n    \n", "try:\n for _ in range(int(input())):\n  p1,p2,k=list(map(int,input().split()))\n  if ((p1+p2)//k)%2==0:\n   print(\"CHEF\")\n  else:\n   print(\"COOK\")\nexcept:\n pass\n", "t=int(input())\nfor i in range(t):\n n,k=list(map(int,input().strip().split()))\n a=list(map(int,input().strip().split()))\n c=0\n x=0\n b=list()\n i1=0\n i2=0\n for j in range(n):\n  c+=1\n  if a[j]>k:\n   x+=1\n   if x==1:\n    i1=j\n   else:\n    if a[j]==a[i1]:\n     x-=1\n    else:\n     i2=j\n  if x==2:\n   x=1\n   b.append(c-1)\n   c=i2-i1\n   i1=i2\n   i2=0\n  if j==n-1 and b==[ ]:\n   b.append(n)\n print(max(b))\n", "def sub(s1, s2):\n m = [[0] * (1 + len(s2)) for i in range(1 + len(s1))]\n longest, x_longest = 0, 0\n for x in range(1, 1 + len(s1)):\n  for y in range(1, 1 + len(s2)):\n   if s1[x - 1] == s2[y - 1]:\n    m[x][y] = m[x - 1][y - 1] + 1\n    if m[x][y] > longest:\n     longest = m[x][y]\n     x_longest = x\n   else:\n    m[x][y] = 0\n return s1[x_longest - longest: x_longest]\n\ntest = eval(input())\nwhile test:\n  test-=1\n  n = eval(input())\n  arr1 = list(map(str,input().split()))\n  arr = []\n  for i in range(n):\n    ans = arr1[i]\n    for j in range(n):\n      ans = sub(ans, arr1[j])\n    arr.append(ans)\n  oth_arr =[]\n  length = 0\n  for i in range(len(arr)):\n    length = max(length, len(arr[i]))\n  for i in range(len(arr)):\n    if len(arr[i])==length:\n      oth_arr.append(arr[i]) \n  oth_arr.sort()\n  print(oth_arr[0])\n  \n", "from collections import Counter\ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef dist(a,b):return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\nfor _ in range(val()):\n n,m,w,h=li()\n s=Counter(st())\n l=[]\n for i in range(m):\n  l.append(li())\n ans=float('inf')\n l.sort(key=lambda x:x[0])\n for j in range(1,50):\n  for i in range(j,m):\n   ans=min(ans,dist(l[i-j],l[i]))\n for i in l:\n  if s['D'] or s['U']>1:ans=min(ans,2*i[1])\n  if s['U'] or s['D']>1:ans=min(ans,2*(h-i[1]))\n  if s['L'] or s['R']>1:ans=min(ans,2*i[0])\n  if s['R'] or s['L']>1:ans=min(ans,2*(w-i[0]))\n print(ans)", "try:\n    list1=[]\n    for _ in range(int(input())):\n        list1.append(int(input()))\n    list1.sort()\n    for i in list1:\n        print(i)\nexcept:\n    pass\n        \n", "a, b = [0]*101001, [0]*101001\nmod = pow(10,9)+7\na[0]=1\nb[0]=0\n\na[1]=0\nb[1]=1\n\nb[2] = b[1] + b[0] + b[0]\na[2] = a[1] + a[0] + a[0]\n\nfor u in range( 3, 100001 ) :\n b[u] += (b[u-1] + b[u-2] + b[u-3])%mod\n a[u] += (a[u-1] + a[u-2] + a[u-3])%mod\n\nfor t in range (eval(input())) :\n x = eval(input())\n print(a[x], b[x])\n", "def subCount(arr, n, k): \r\n    mod =[] \r\n    for i in range(k + 1): \r\n        mod.append(0) \r\n    cumSum = 0\r\n    for i in range(n): \r\n        cumSum = cumSum + arr[i] \r\n        mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\r\n    result = 0 \r\n    for i in range(k): \r\n        if (mod[i] > 1): \r\n            result = result + (mod[i]*(mod[i]-1))//2\r\n    result = result + mod[0] \r\n    return result \r\ndef inp(x):\r\n    return int(x.rstrip('0'))\r\ndef main(t):\r\n    k = 10\r\n    n = int(input())  \r\n    arr =  list(map(inp,input().split()))\r\n    print(subCount(arr, n, k))   \r\n    if t>1:\r\n        main(t-1)\r\nmain(int(input()))", "t=int(input())\ndef reversebinary(bits,n):\n    bStr=''\n    for i in range(bits):\n        if n>0:\n            bStr=bStr+str(n%2)\n        else:\n            bStr=bStr+'0'\n        n=n>>1\n    return int(bStr,2)\n        \nfor i in range(t):\n    k,msg=input().split()\n    k=int(k)\n    newmsg=[]\n    for j in msg:\n        newmsg.append(j)\n    for j in range(len(msg)):\n        newmsg[reversebinary(k,j)]=msg[j]\n    print(''.join(newmsg))\n        \n    \n", "# cook your dish here\n# import sys\n# sys.stdin = open('input.txt', 'r') \n# sys.stdout = open('output.txt', 'w')\n\nimport math\nimport collections\nfrom sys import stdin,stdout,setrecursionlimit\nimport bisect as bs\nsetrecursionlimit(2**20)\nM = 10**9+7\n\ndef nCrModp(n, r, p): \n if (r > n- r): \n  r = n - r \n C = [0 for i in range(r + 1)] \n \n C[0] = 1\n \n for i in range(1, n + 1): \n  for j in range(min(i, r), 0, -1): \n   C[j] = (C[j] + C[j-1]) % p \n \n return C[r] \n \n\n# T = int(stdin.readline())\n# for _ in range(T):\n # n = int(stdin.readline())\nn,k = list(map(int,stdin.readline().split()))\n # a = list(map(int,stdin.readline().split()))\n # q = list(map(int,stdin.readline().split()))\n # b = list(map(int,stdin.readline().split()))\n # a = stdin.readline().strip('\\n')\nN = n+k-1\nR = n-1\nprint(nCrModp(N,R,M))", "t =int(input()) #no. of test cases\nwhile t>0:\n t=t-1\n str=input()\n size=len(str)\n pos=str.find('W')\n left=pos\n right=size-pos-1\n arr = [[0 for i in range(right+1)] for j in range(left+1)]\n #arr[i,j] = 1 if with i black cells on left and j on right 1st player can \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0win, 0 otherwise.\n #Recursion: arr[i][j]= or(arr[x][y])\n arr[0][0]=0\n for i in range(left+1):\n  for j in range(right+1):\n   if i==j:\n    arr[i][j]=0\n   else:\n    arr[i][j]=1\n if(arr[left][right]==1):\n  print(\"Aleksa\")\n else:\n  print(\"Chef\")\n", "t = int(input()) \nfor i in range (t) :\n line = input()\n pui = line.split()\n r = int(pui[0])\n g = int(pui[1]) \n b = int(pui[2]) \n m = int(pui[3]) \n ar = list()\n for i in range (3) :\n  line = input()\n  pui = line.split()\n  pui = [int (j) for j in pui]\n  ar.append(pui) \n for i in range (m) :\n  R = max(ar[0]) \n  G = max(ar[1]) \n  B = max(ar[2]) \n  if R>=G and R >= B :\n   for j in range(len(ar[0]))  :\n    ar[0][j] = int(ar[0][j] / 2) \n  elif G >= R and G >= B :\n   for j in range(len(ar[1])) : \n    ar[1][j] = int(ar[1][j] / 2) \n  elif B >= G and B >= R :\n   for j in range(len(ar[2])) : \n    ar[2][j] = int(ar[2][j] / 2)\n R = max(ar[0]) \n G = max(ar[1]) \n B = max(ar[2])\n ans = max(R, G, B)\n print(ans)\n", "a, b = [int(x) for x in input().split()]\nr = list(str(a-b))\nif r[0] == \"1\":\n r[0] = \"2\"\nelse:\n r[0]=\"1\"\nprint(\"\".join(r))\n", "# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n arr=[]\n for i in range(n):\n  arr.append(int(input()))\n print(max(arr))", "string=input()\nmax_no=0\nfor i in range(len(string)):\n var_occur=0\n check_no=str()\n j=i\n while(j<len(string) and var_occur<2 ):\n  if(string[j].isalpha()):\n   if(var_occur==0):\n    check_no+='9'\n    var_occur+=1\n   else:\n    var_occur+=1\n  else:\n   check_no+=string[j]\n  j+=1\n #print(check_no)\n max_no=max(max_no,int(check_no))\nprint(max_no)", "n,k = map(int,input().split())\nl = list(map(int,input().split()))\nl.sort()\nM = 10**9+7\nfarr = []\nj = 0\nf = 0\nc = 0\nwhile(j < len(l)):\n if f == 0:\n  f = l[j]\n  c = c+1\n  if j == len(l)-1:\n   farr.append(c)\n\n  j = j + 1\n\n elif(f != 0):\n  if l[j] == f:\n   c = c+1\n   #j = j + 1\n   if j == len(l) - 1:\n    farr.append(c)\n\n   j = j + 1\n\n  else:\n   farr.append(c)\n   f = 0\n   c = 0\n\ncnt = 1\narr = farr.copy()\nz = 1\nwhile(z <= k):\n if z == 1:\n  cnt = cnt+len(l)%M\n\n else:\n  ic = 0\n  i = 0\n  kc = 0\n  while(i < len(farr)):\n   kc = arr[i]\n   arr[i] = (ic*farr[i])%M\n   ic = ic+kc\n   cnt = (cnt+arr[i])%M\n   i = i+1\n\n z = z+1\n\nprint(cnt%M)", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nfor i in range(int(input())):\n    n, k = map(int, input().split())\n    arr = []\n    if k == 2 or k == 4 or n % 2 != 0 or n == k:\n        arr.append('-1')\n    elif k % 2 != 0:\n        for i in range(int(n / 2)):\n            arr.append('(')\n        for i in range(int(n / 2)):\n            arr.append(')')\n    elif int(n / (k - 2)) == 1:\n        if (n - 2) % 4 == 0:\n            for i in range(int((n - 2) / 4)):\n                arr.append('(')\n            for i in range(int((n - 2) / 4)):\n                arr.append(')')\n            arr.append('()')\n            for i in range(int((n - 2) / 4)):\n                arr.append('(')\n            for i in range(int((n - 2) / 4)):\n                arr.append(')')\n        else:\n            for i in range(int((n - 4) / 4)):\n                arr.append('(')\n            for i in range(int((n - 4) / 4)):\n                arr.append(')')\n            arr.append('(())')\n            for i in range(int((n - 4) / 4)):\n                arr.append('(')\n            for i in range(int((n - 4) / 4)):\n                arr.append(')')\n    else:\n        for i in range(int((n % (k - 2)) / 2)):\n            arr.append('(')\n        for i in range(int(n / (k - 2))):\n            for j in range(int((k - 2) / 2)):\n                arr.append('(')\n            for j in range(int((k - 2) / 2)):\n                arr.append(')')\n        for i in range(int((n % (k - 2)) / 2)):\n            arr.append(')')\n\n    print(\"\".join(arr))\n", "t=int(input())\r\nmod = 1000000007\r\nfor i in range(t):\r\n\tn, m = map(int, input().split())\r\n\tprint(\"Case {:d}:\".format(i+1))\r\n\tfor j in range(m):\r\n\t\tarr = input()\r\n\t\tl = len(arr)\r\n\t\tif l > n:\r\n\t\t\tprint(0)\r\n\t\telse:\r\n\t\t\tprod = pow(26, n-l, mod)*(n-l+1)\r\n\t\t\tprint(prod%mod)\r\n\t\t\t", "def compute_gcd(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n   \ndef f_lcm(x, y):\n   lcm = (x*y)//compute_gcd(x,y)\n   return lcm\n   \n   \nt = int(input().strip())\nfor i in range(t):\n    res = 0\n    x_y = [int(i) for i in input().split()]\n    x = x_y[0]\n    y = x_y[1]\n    lcm = f_lcm(x, y)\n    temp = lcm\n    if(x == y):\n        print(0)\n    else:\n        res += lcm//x - 1\n        res += lcm//y - 1\n        print(res)\n            \n            \n            \n    \n", "# cook your dish here\nfor i in range(int(input())):\n n=int(input())\n m=[int(i) for i in input().split()]\n chk=sum(m)\n if(chk%n==0):\n  print(\"Yes\")\n else:\n  print(\"No\")", "# cook your dish here\ntestcase = int(input())\nfor ij in range(testcase):\n n = int(input())\n k = int(input())\n list1 = []\n list2 = []\n list3 = [0]\n if n%2 !=0:\n  f = n//2\n  for i in range(f):\n   list1.append(2*(i+1))\n  for i in range(len(list1)):\n   list2.append(list1[i])\n  for i in range(len(list1)):\n   list2.append(list1[f-1-i])\n\n if n%2 == 0:\n  s = (n-1)//2\n  \n  for i in range(s):\n   list1.append(2*(i+1))\n  for i in range(s):\n   list2.append(list1[i])\n  list2.append(list1[s-1]+1)\n  for i in range(s):\n   list2.append((list1[s-1-i]))\n list2.append(0)\n\n p = k%n\n print(list2[p-1])\n\n\n\n\n\n\n\n\n\n\n\n", "for _ in range(int(input())):\r\n    inps = input().strip()\r\n    stck = [inps[0]]\r\n    for i in range(1, len(inps)):\r\n        if len(stck) > 0:\r\n            if inps[i] == stck[-1]:\r\n                stck.pop()\r\n            else:\r\n                stck.append(inps[i])\r\n        else:\r\n            stck.append(inps[i])\r\n    print(len(stck))", "\"\"\"\n    Author : thekushalghosh\n    Team   : CodeDiggers\n\"\"\"\nimport sys,math\ninput = sys.stdin.readline\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(s[:len(s) - 1])\ndef invr():\n    return(map(int,input().split()))\n################################################################\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\nt = 1\nt = inp()\nfor tt in range(t):\n    n,s = invr()\n    if n == 2 and s > 1:\n        print(s - 1)\n    elif n > 2 and s > 1:\n        print(0)\n    elif n == 1:\n        print(s)\n    else:\n        print(-1)", "import sys\nimport numpy\nfrom collections import OrderedDict\nf = sys.stdin\n\ndef makeJump(op):\n p = op[1] - 1\n nj = 0\n for i in range(p + 1, n):\n  dist = i - p\n  if dist > 100:\n   break\n  else:\n   #jump, if dist <= 100\n   vp = a[p]\n   vi = a[i]\n   for k in [x for x in list(jumps.keys()) if p <= x]:\n    d = jumps[k]\n    for k2 in d:\n     if p >= k2:\n      vp += d[k2]\n   for k in [x for x in list(jumps.keys()) if i <= x]:\n    d = jumps[k]\n    for k2 in d:\n     if i >= k2:\n      vi += d[k2]\n   if vp < vi:\n    p = i\n    nj += 1\n  if nj >= op[2]:\n   break\n print(p + 1)\n return\n\n#f = open('HILLJUMP.txt')\n#N and Q, the number of hills and number of operations.\nn, q = [int(x) for x in f.readline().split()]\n#A1, A2, ..., AN denoting the initial heights of the hills.\na = [int(x) for x in f.readline().split()]\n#Each of the next Q lines describes an operation.\nqueries = []\njumps = {}\nfor _ in range(0, q):\n op = [int(x) for x in f.readline().split()]\n if op[0] == 1:\n  #Type 1, and it will be followed by two integers i and k.\n  makeJump(op)\n else:\n  #three integers L, R and X.\n  l = op[1] - 1\n  r = op[2] - 1\n  x = op[3]\n  if not r in jumps:\n   jumps[r] = {}\n  if not l in jumps[r]:\n   jumps[r][l] = 0\n  jumps[r][l] += x\n#f.close()\n", "def left(list1):\n for i in range(len(list1)):\n  list2=sorted(list1[i])\n  list2.reverse()\n  list1[i]=list2\ndef right(list1):\n for i in range(len(list1)):\n  list2=sorted(list1[i])\n  list1[i]=list2\ndef up(list1):\n for i in range(len(list1[0])):\n  list2=[]\n  for j in range(len(list1)):\n   list2.append(list1[j][i])\n  list2.sort()\n  list2.reverse()\n  for j in range(len(list1)):\n   list1[j][i]=list2[j] \ndef down(list1):\n for i in range(len(list1[0])):\n  list2=[]\n  for j in range(len(list1)):\n   list2.append(list1[j][i])\n  list2.sort()\n  for j in range(len(list1)):\n   list1[j][i]=list2[j]\n\ntest_case=int(input())\nresult=[]\nfor i in range(test_case):\n [n,m]=list(map(int,input().split()))\n list1=[]\n for i in range(n):\n  y=list(input())\n  str2=' '.join(y)\n  list1.append(list(map(int,str2.split())))\n op=list(input())\n for i in range(len(op)):\n  if op[i]=='L':\n   left(list1)\n  if op[i]=='R':\n   right(list1)\n  if op[i]=='D':\n   down(list1)\n  if op[i]=='U':\n   up(list1)\n result.append(list1)\nfor char in result:\n for el in char:\n  print(''.join(list(map(str,el))))", "def solve(array):\r\n    L = len(array)\r\n    if L <= 1:\r\n        return L\r\n    array.sort()\r\n    cnt = 1\r\n    for i in range(1, L):\r\n        if array[i][1] * -1 >= array[i - 1][0]:\r\n            cnt += 1\r\n    return cnt\r\n\r\n\r\nfor _ in range(int(input())):\r\n    N, K = list(map(int, input().split()))\r\n    rooms = [[] for i in range(K)]\r\n    for i in range(N):\r\n        s, e, p = list(map(int, input().split()))\r\n        rooms[p - 1].append([e, -s])\r\n\r\n    ans = 0\r\n    for i in rooms:\r\n        ans += solve(i)\r\n    print(ans)\r\n", "for t in range(eval(input())) :\n s, t = input(), input()\n s = s.lower()\n t = t.lower()\n if s < t :\n  print('first')\n elif s > t :\n  print('second')\n else :\n  print('equal') ", "crystel=int(input())\r\ncry_val=list(map(int,input().split()))\r\nlaser=int(input())\r\npoint,iterr=0,0\r\ncount=1\r\npoint_mx=[0]\r\ncry_val.sort()\r\nwhile count<=crystel:\r\n    #print(point,laser)\r\n    if cry_val[iterr]<=laser:\r\n       point+=1\r\n       point_mx.append(point)\r\n       laser-=cry_val[iterr]\r\n       iterr+=1\r\n       count+=1\r\n       \r\n    else:\r\n        laser+=cry_val[-1]\r\n        cry_val.remove(cry_val[-1])\r\n        point-=1\r\n        count+=1\r\n    \r\n#print(cry_val)   \r\nprint(max(point_mx))\r\n        \r\n", "T = int(input())\r\nfor tc in range(T):\r\n# Read integers a, b and c.\r\n    (a, b, c) = map(int, input().split(' '))\r\n    if (a>b and a<c) or (a>c and a<b) :\r\n        print(a)\r\n    elif (b>a and b<c) or  (b>c and b<a) :\r\n        print(b)\r\n    else:\r\n        print(c)", "for i in range(int(input())):\n n,k,v=map(int,input().split())\n arr=list(map(int,input().split()))[:n]\n sums=sum(arr)\n l=v*(n+k)\n a=(l-sums)//k\n if(a<=0):\n  print(-1)\n elif((l-sums)%k!=0):\n  print(-1)\n else:\n  print(a)", "# cook your dish here\nnum=int(input())\nif num%4!=0:\n    print(num-1)\nelse:\n    print(num+1)", "R,C=list(map(int,input().split()))\r\nA=[]\r\nfor i in range(R):\r\n    p=list(map(int,input().split()))\r\n    A.append(p)\r\nm, n = len(A), len(A[0])\r\nfor i in range(m):\r\n    if A[i][0] == 0: \r\n        for j in range(n): A[i][j] ^= 1 \r\n        \r\nfor j in range(n): \r\n    cnt=0\r\n    for i in range(m):\r\n        if(A[i][j]==1):\r\n            cnt+=1\r\n    if cnt < m - cnt: \r\n        for i in range(m): A[i][j] ^= 1\r\n\r\nprint(sum(int(\"\".join(map(str, A[i])), 2) for i in range(m)))\r\n", "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\nipnl = lambda n: [int(input()) for _ in range(n)]\ninp = lambda :int(input())\nip = lambda :[int(w) for w in input().split()]\n\nfor _ in range(inp()):\n    n = inp()\n    x = ip()\n    up = [1]*(n+1)\n    dn = [1]*(n+1)\n    up[-1],dn[-1] = 0,0\n    for i in reversed(list(range(n-1))):\n        if x[i] <= x[i+1]:\n            dn[i] += up[i+1]\n        if x[i] >= x[i+1]:\n            up[i] += dn[i+1]\n    ans = 0\n    for i in range(n):\n        t = dn[i]\n        if t%2:\n            t += dn[i+t]\n        else:\n            t += up[i+t]\n        ans = max(ans,t+1)\n    print(ans)\n\n\n", "try:\n        \n    n,k,s = list(map(int,input().split(' ')))\n    arr = list(map(int,input().split(' ')))\n    \n    start = 0\n    end = 0\n    temp = 0\n    for i in range(n):\n        temp += arr[i]\n        if temp > s and i-start+1 > k:\n            end = i\n        while temp-arr[start] > s and end-start > k:\n            temp -= arr[start]\n            start += 1\n    if end == start:\n        print(-1)\n    else:\n        print(end-start+1)\n            \nexcept:\n    pass\n", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    if n == 1 or n == 2 or n == 145 or n == 40585:\n        print(1)\n    else:\n        print(0)\n", "import math\ndef hello(x,n):\n xPn= (x/100)*n\n sqr=math.sqrt(n)\n sqr=math.floor(sqr)\n sqr = sqr**2\n if(abs(n-sqr)<=xPn):\n  return \"yes\"\n else:\n  return \"no\"\ndef __starting_point():\n [t,x] = list(map(int,input().split()))\n r=[]\n for i in range(t):\n  n=int(input())\n  print(hello(x,n))\n__starting_point()", "# cook your dish here\ndef __starting_point():\n    for _ in range(int(input())):\n        d = int(input())\n        l, r = map(int, input().split())\n        if l % 2 != 0 :\n            l -= 1\n        if r % 2 != 0:\n            r += 1\n        n = (r-l)//(2*d)\n        if n % 2 == 0:\n            n = n//2\n        else:\n            n = n//2+1\n        a = d*(l+d)\n        f = 4*d*d\n        ans = ((n*(2*a+(n-1)*f))//2)%1000000007\n        print(ans)\n__starting_point()", "def least_rotation(S: str):\r\n    \"\"\"Booth's algorithm.\"\"\"\r\n    S += S  # Concatenate string to it self to avoid modular arithmetic\r\n    f = [-1] * len(S)  # Failure function\r\n    k = 0  # Least rotation of string found so far\r\n    for j in range(1, len(S)):\r\n        sj = S[j]\r\n        i = f[j - k - 1]\r\n        while i != -1 and sj != S[k + i + 1]:\r\n            if sj < S[k + i + 1]:\r\n                k = j - i - 1\r\n            i = f[i]\r\n        if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\r\n            if sj < S[k]:  # k+i+1 = k\r\n                k = j\r\n            f[j - k] = -1\r\n        else:\r\n            f[j - k] = i + 1\r\n    return k\r\nt=int(input())\r\nfor _ in range(t):\r\n    l,s=input().split()\r\n    l=int(l)\r\n    n=len(s)\r\n    if(l==1):\r\n        o=least_rotation(s)\r\n        s+=s\r\n        print(s[o:o+n])\r\n    else:\r\n        v=''.join(sorted(s))\r\n        print(str(v))", "#copy from all submission only for learn \nMOD = 998244353\n\nfball = [ [0]*101 for _ in range(101) ]\n\ncric = [ [0]*101 for _ in range(101) ] \n\n\n\ndef calSNum(n, r):\n if n == r or r == 1:\n  fball[r][n] = 1\n  return\n if n > 0 and r > 0 and n > r:\n  fball[r][n] = (fball[r-1][n-1]%MOD + (r*fball[r][n-1])%MOD )%MOD\n  return\n fball[r][n] = 0\n  \n\ndef calASNum(n, r):\n if n == 0 and r == 0 :\n  cric[r][n] = 0\n  return\n if n >= 2 and r == 1:\n  cric[r][n] = 1\n  return \n if r > 0 and n > 0 and n >= 2*r:\n  cric[r][n] = ((r*cric[r][n-1])%MOD + ((n-1)*cric[r-1][n-2])%MOD )%MOD\n  return\n cric[r][n] = 0\n \n\ndef preCompute():\n for r in range(1,101):\n  for n in range(1, 101):\n   calSNum(n, r)\n   calASNum(n, r)\n\n \ndef main():\n \n preCompute()\n for _ in range(int(input())):\n\n  f, c, r = list(map(int, input().split()))\n\n  ans = 0\n  \n  if f + (c//2) >= r:\n   minv = min(f, r)\n   \n   for i in range(1, minv+1):\n    if r-i <= c//2:\n     ans = (ans + (fball[i][f] * cric[r-i][c])%MOD )%MOD\n   \n  print(ans)\n   \ndef __starting_point():\n main()\n\n__starting_point()", "# cook your dish here\ntry:\n    for _ in range(int(input())):\n        k = int(input())\n        num = 1\n        for i in range(1,k+1,1):\n            for j in range(1,k+1,1):\n                print(num,end=\"\")\n                num = num +1\n            print(\"\")\nexcept:\n    pass", "# cook your dish here\nimport sys\nt = int(input())\nfor _ in range(t):\n    N,k = map(int,input().split())\n    A = list(map(int,input().split()))\n    B = A*k\n    max_ = -(sys.maxsize)-1\n    value = 0\n    for i in range(len(B)):\n        value = value + B[i]\n        if value>max_:\n            max_ = value\n        if value<0:\n            value = 0\n    print(max_)", "T = int(input())\nfor _ in range(T):\n    N, M, K = [int(x) for x in input().split()]\n    UV = [[int(x) for x in input().split()] for _ in range(M)]\n    Q = int(input())\n    AB = [[int(x) for x in input().split()] for _ in range(Q)]\n \n    X = [[i] for i in range(N)]\n    for u, v in UV:\n     X[u - 1] += [v - 1]\n     X[v - 1] += [u - 1]\n \n    A = [[1 if i > 0 or j == 0 else 0 for j in range(N)] for i in range(K + 1)]\n    for a, b in AB:\n     A[b] = [1 if i == a - 1 else 0 for i in range(N)]\n \n    if A[0][0] == 1:\n     for k in range(K - 1, -1, -1):\n      for i in range(N):\n       if A[k][i] != 0:\n        A[k][i] = sum(A[k + 1][j] for j in X[i])\n \n    print(A[0][0])", "from fractions import gcd\nfrom functools import reduce\na=eval(input())\nwhile(a):\n\n x=eval(input())\n b=list(map(int,input().split()))\n print(reduce(gcd,(b))*x)\n \n  \n\n\n a-=1\n", "for _ in range(int(input())) :\n n, k = map(int,input().split())\n k = 100-k\n a = list(map(int,input().strip().split()))\n b = list(map(int,input().strip().split()))\n d_min = 100\n a_min = 100\n for i in range(n) :\n  if b[i] == 0 and a[i]<d_min :\n   d_min = a[i]\n  elif b[i] == 1 and a[i]<a_min :\n   a_min = a[i]\n if a_min+d_min <= k :\n  print(\"yes\")\n else :\n  print(\"no\")", "from math import sqrt\n\ndef distance():\n m = (y2 - y1) / (x2 - x1)\n dis = (q - m * p + m * x1 - y1) / sqrt(m * m + 1 )\n return abs(dis)\n\nfor _ in range(int(input())):\n print(\"Test case :\", _ + 1)\n x1, y1, x2, y2 = map(int, input().split())\n Q = int(input())\n for query in range(Q):\n  p, q = map(int, input().split())\n  if x1 == x2:\n   if p == x1:\n    print('YES')\n   else:\n    print('NO')\n    print(\"{0:.6f}\".format(abs(x1 - p)))\n  elif x1 == p:\n   print('NO')\n   print(\"{0:.6f}\".format(distance()))\n  elif (y1 - y2) / (x1 - x2) == (y1 - q) / (x1 - p):\n   print('YES')\n  else:\n   print('NO')\n   print(\"{0:.6f}\".format(distance()))", "from math import gcd\r\nfrom math import ceil\r\nfrom itertools import combinations as c\r\nt=int(input())\r\nfor _ in range(t):\r\n    n,m,a,d=list(map(int,input().split()))\r\n    \r\n    l=[]\r\n    for i in range(5):\r\n        l.append(a+i*d)\r\n    ans=m-n+1\r\n    for i in range(1,6):\r\n        x=list(c(l,i))\r\n        for j in x:\r\n            e=j[0]\r\n            for v in j:\r\n                e=(e*v)//gcd(e,v)\r\n            #print(e)\r\n            if i%2:\r\n                ans-=m//e-(n-1)//e\r\n            else:\r\n                ans+=m//e-(n-1)//e\r\n    print(ans)\r\n        \r\n    \r\n", "import numpy as np\nfor _ in range(int(input())):\n ans = np.float('inf')\n n, m = (int(x) for x in input().split())\n sig = np.zeros((n,m))\n img = np.zeros((3*n,3*m))\n for row in range(n):\n  sig[row,:] = np.array([int(x) for x in input()])\n for row in range(n):\n  img[row+n,m:2*m] = np.array([int(x) for x in input()])\n for i in range(2*n):\n  for j in range(2*m):\n   ans = min(ans, np.abs(np.sum(img[i:n+i, j:m+j] != sig)))\n print(ans)", "import math\ntestcases=int(input())\nfor x in range(testcases):\n N=int(input())\n l=6\n m=3\n a=2**m\n if(N!=1 and math.ceil(math.log(N,2)) == math.floor(math.log(N,2))):\n  print(\"-1\")\n  continue\n if N==1:\n  print(\"1\",end=\" \")\n elif(N==3):\n  print(\"2 3 1\",end=\" \")\n elif(N==5):\n  print(\"2 3 1 5 4\",end=\" \")\n if(N>5):\n  print(\"2 3 1 5 4\",end=\" \")\n  while(l<=N):\n   if(l==a):\n    m=m+1 \n    a=2**m\n    print(l+1,end=\" \")\n    print(l,end=\" \")\n    l=l+2\n   else:\n    print(l,end=\" \")\n    l=l+1\n print()\n\n\n", "for t in range(0,int(input())):\n  n=int(input())\n  ss=list(map(str,input().split()))\n  \n  my_dict={}\n  \n  for i in ss:\n    my_dict[i]=ss.count(i)\n\n  ans=\"\"\n  cnt=0\n\n  for key,value in my_dict.items():\n    if value > cnt:\n      cnt=value\n      ans=key\n    elif value==cnt:\n      if key < ans:\n        ans=key\n\n        \n  print(ans)", "import sys\nimport datetime\na,b,c = list(map(int,sys.stdin.readline().split()))\nd = datetime.date(c,b,a)\nprint(d.strftime(\"%A\"))", "t = int(input())\nfor i in range(t):\n N = int(input())\n An = list(map(int, input().split(\" \")))\n cumsum = []\n cumsum.append(An[0])\n for j in range(N-1):\n  cumsum.append(cumsum[j] + An[j+1])\n days = 0\n k = 0\n while(k < N-1):\n  days += 1\n  k = k + cumsum[k]\n print(days)\n", "test=eval(input())\na=[]\nb=[]\nc=0\ntop=-1\nfor i in range(test):\n x=input().split()\n \n if(x[0]!=\"-1\" and x[0]!=\"0\"):\n  add=int(x[0])\n  if top!=-1 and add>a[top][0] :\n    \n    b[top]+=1\n    \n  else:\n    a.append((add,x[1]))\n    \n    b.append(0)\n    top+=1\n  \n  \n elif (x[0]==\"-1\"):\n  \n  print(\"%s %s\" %(b[top],a[top][1]))\n  xx=a.pop()\n  t=b.pop()\n  top-=1", "t = int(input())\nl,r,x = 0,0,0\nans = []\nfor i in range(t):\n (n,m) = tuple(map(int,input().split()))\n a = list(map(int,input().split()))\n b = list(map(int,input().split()))\n suma = sum(a)\n sumb = sum(b)\n q = int(input())\n for j in range(q):\n  l1 = list(map(int,input().split()))\n  if l1[0] == 1:\n   l = l1[1]\n   r = l1[2]\n   x = l1[3]\n   suma = suma + (r-l+1)*x\n  elif l1[0] == 2:\n   l = l1[1]\n   r = l1[2]\n   x = l1[3]\n   sumb = sumb + (r-l+1)*x\n  else:\n   ans.append((suma*sumb)%998244353)\nfor i in range(len(ans)):\n print(ans[i])", "\nfrom math import ceil\nfrom bisect import bisect_right as b_r\nfrom bisect import bisect_left as b_l\nar = list(map(int , input().split()))\na = [int(ceil((ar[1]-int(x)+1)/ar[2])) for x in input().split()]\ns = sum(a)\nar[1] = max(a)\nm = ar[1] - (s-ar[1])%2\nmi = s%2 \nprint(int( (m-mi)//2 +1)%(10**9+7))\n\n", "import sys\r\nimport math\r\nimport bisect\r\nfrom sys import stdin,stdout\r\nfrom math import gcd,floor,sqrt,log\r\nfrom collections import defaultdict as dd\r\nfrom bisect import bisect_left as bl,bisect_right as br\r\n\r\nsys.setrecursionlimit(100000000)\r\n\r\nii     =lambda: int(input())\r\nsi     =lambda: input()\r\njn     =lambda x,l: x.join(map(str,l))\r\nsl     =lambda: list(map(str,input().strip()))\r\nmi     =lambda: list(map(int,input().split()))\r\nmif    =lambda: list(map(float,input().split()))\r\nlii    =lambda: list(map(int,input().split()))\r\n\r\nceil   =lambda x: int(x) if(x==int(x)) else int(x)+1\r\nceildiv=lambda x,d: x//d if(x%d==0) else x//d+1\r\n\r\nflush  =lambda: stdout.flush()\r\nstdstr =lambda: stdin.readline()\r\nstdint =lambda: int(stdin.readline())\r\nstdpr  =lambda x: stdout.write(str(x))\r\n\r\nmod=1000000007\r\n\r\n\r\n#main code\r\ntry:\r\n    n=ii()\r\n    arr=lii()\r\n    for i in range(1,n+1):\r\n        if i!=arr[i-1]:\r\n            l=i\r\n            break\r\n    for i in range(n,-1,-1):\r\n        if i!=arr[i-1]:\r\n            r=i\r\n            break\r\n    temp=arr[l-1:r]\r\n    temp.reverse()\r\n    srr=arr[0:l-1]\r\n    srr.extend(temp)\r\n    srr.extend(arr[r:n])\r\n    if srr==sorted(arr):\r\n        print(l,r)\r\n    else:\r\n        print(0,0)\r\nexcept:\r\n    print(0,0)\r\n        \r\n", "\r\n#Read the number of test cases.\r\nT = int(input())\r\nprint(T)", "import math \r\ndef findWinner(n, k): \r\n\t\r\n\tcnt = 0; \r\n\tif (n == 1): \r\n\t\tprint(\"Grinch\"); \r\n\telif ((n & 1) or n == 2): \r\n\t\tprint(\"Me\"); \r\n\r\n\telse: \r\n\t\ttmp = n; \r\n\t\tval = 1; \r\n\t\twhile (tmp > k and tmp % 2 == 0): \r\n\t\t\ttmp //= 2; \r\n\t\t\tval *= 2; \r\n\t\tfor i in range(3, int(math.sqrt(tmp)) + 1): \r\n\t\t\twhile (tmp % i == 0): \r\n\t\t\t\tcnt += 1; \r\n\t\t\t\ttmp //= i; \r\n\t\t\r\n\t\tif (tmp > 1): \r\n\t\t\tcnt += 1; \r\n\r\n\t\tif (val == n): \r\n\t\t\tprint(\"Grinch\"); \r\n\r\n\t\telif (n / tmp == 2 and cnt == 1): \r\n\t\t\tprint(\"Grinch\"); \r\n\t\telse: \r\n\t\t\tprint(\"Me\"); \r\ndef __starting_point(): \r\n\r\n\tfor _ in range(int(input())):\r\n\t    n=int(input())\r\n\t    findWinner(n, 1); \r\n\n__starting_point()", "# https://www.codechef.com/problems/RECTLIT\r\n\r\ndef assess(sq,points):\r\n    EWct = 0\r\n    NSct = 0\r\n    for a,b in points:\r\n        EW = (a == 0 or a == sq)\r\n        NS = (b == 0 or b == sq)\r\n        if EW and NS:\r\n            return 'yes'\r\n        EWct += EW\r\n        NSct += NS\r\n    if NSct + EWct == 0 or len(points) == 1:\r\n        return 'no'\r\n    if EWct >= 2 or NSct >= 2:\r\n        return 'yes'\r\n    if len(points) == 2:\r\n        return 'no'\r\n    # now 3 points\r\n    if NSct == 1 and EWct == 1:\r\n        return 'yes'\r\n    # 3 points, one on edge\r\n    x = -1\r\n    for a,b in points:\r\n        if EWct > 0:\r\n            if a == 0 or a == sq:\r\n                e = b\r\n            elif x == -1:\r\n                x = b\r\n            else:\r\n                y = b\r\n        else:\r\n            if b == 0 or b == sq:\r\n                e = a\r\n            elif x == -1:\r\n                x = a\r\n            else:\r\n                y = a\r\n    if (e-x)*(e-y) < 0: # edge splits mids\r\n        return 'no'\r\n    else:\r\n        return 'yes'\r\n\r\n\r\nfor ti in range(int(input())):\r\n    k,n = map(int, input().split())\r\n    if k > 3:\r\n        for ki in range(k):\r\n            input()\r\n        print('yes')\r\n    else:\r\n        pos = [tuple(map(int, input().split())) for ki in range(k)]\r\n        print(assess(n-1,pos))\r\n\r\n", "# cook your dish here\nd = 2**0.5\nfor _ in range(int(input())):\n a,b,c = map(int,input().split())\n e = (2*a)/c\n s = (d*a)/b\n if e<s:\n  print(\"Elevator\")\n else:\n  print(\"Stairs\")", "def no_total(A):\n for i in range (len(A)):\n  for j in range (i+2,len(A)):\n   if (A[i] > A[j]):\n    return False\n return True\n \ncases = int(input())\nfor case in range (cases):\n n = int(input())\n A = list(map(int,input().split()))\n if (no_total(A)):\n  print(\"YES\")\n else:\n  print(\"NO\") ", "# cook your dish here\nt=int(input())\n\nfor _ in range(t):\n s=input()\n c=0\n for i in range(len(s)-1):\n  \n  if s[i]!=s[i+1]:\n   c+=1\n  \n if c <=2:\n  print(\"uniform\")\n else:\n  print('non-uniform')\n  \n", "# cook your dish here\ndef check(a,b):\n    \n    for i in range(t):\n        if a[i]+b[i] in a:\n            idx = a.index(a[i]+b[i])\n            if a[idx]+b[idx]==a[i]:\n                print('YES')\n                return\n    \n    print('NO')\n\nt = int(input())\na = []\nb = []\nfor _ in range(t):\n    x, y = map(int, input().split())\n    a.append(x)\n    b.append(y)\n\ncheck(a,b) ", "def main():\r\n    n,k,m = list(map(int,input().split()))\r\n    arr = list(map(int,input().split()))\r\n    dp = [-1]\r\n    for i in range(n):\r\n        if arr[i] > 0:\r\n            dp.append(i)\r\n        else:\r\n            dp.append(dp[-1])\r\n\r\n    dp.pop(0)\r\n    start = 0\r\n    count = 0\r\n    total = 0\r\n    ans = 0\r\n    index = -1\r\n    rem = k\r\n    #print(dp)\r\n    for i in range(n):\r\n        if index != -1:\r\n            if i-index <= rem:\r\n                #print('here',i,index)\r\n                arr[i] *= m\r\n            else:\r\n                index = -1\r\n                \r\n        total += arr[i]\r\n        count += 1\r\n        if count == k:\r\n            #print(total,start,i)\r\n            count -= 1\r\n            if total < m:\r\n                index = dp[i]\r\n                if index == -1 or i-index+1 > k:\r\n                    print(-1)\r\n                    return\r\n                \r\n                #print(index)\r\n                rem = k-(i-index+1)\r\n                #print('what',rem)\r\n                total -= arr[index]\r\n                arr[index] *= m\r\n                total += arr[index]\r\n                ans += 1\r\n                index = i\r\n\r\n            total -= arr[start]\r\n            start += 1\r\n\r\n    #print(arr)\r\n    print(ans)\r\n\r\nmain()\r\n", "for u in range(int(input())):\n n = int(input())\n x = [int(w) for w in input().split()]\n \n ans = 0\n for i in range(1, n):\n  c = 0\n  for j in range(i):\n   if x[j] % x[i] == 0:\n    c += 1\n  #print(c)    \n  ans = max(ans, c)\n  \n print(ans)", "\ndef func(t,l,r):\n if t=='U':\n  try:\n   a[l-1]=r\n  except:\n   print('NA')\n elif t=='A':\n  try:\n   print(sum(a[min(l-1,r):max(l-1,r)]))\n  except:\n   print('NA')\n elif t=='M':\n  try:\n   print(max(a[min(l-1,r):max(l-1,r)]))\n  except:\n   print('NA')\n elif t=='m':\n  try:\n   print(min(a[min(l-1,r):max(l-1,r)]))\n  except:\n   print('NA')\n elif t=='S':\n  try:\n   bb = list(set(a[min(l-1,r):max(l-1,r)]))\n   bb.sort()\n   print(bb[-2])\n  except:\n   print('NA')\n elif t=='s':\n  try:\n   bb = list(set(a[min(l-1,r):max(l-1,r)]))\n   bb.sort()\n   print(bb[1])\n  except:\n   print('NA')\n   return ''\n else:\n  print('!!!')\n  return ''\n \n \n \n \nn = eval(input())\na = list(map(int, input().split()))\nq = eval(input())\n \nfor i in range(q):\n t,l,r = input().split()\n func(t,int(l),int(r))", "import math\nN=int(input())\nfor _ in range(N):\n    print(math.factorial(int(input())))", "def find_lcm(num1, num2): \n if(num1>num2): \n  num = num1 \n  den = num2 \n else: \n  num = num2 \n  den = num1 \n rem = num % den \n while(rem != 0): \n  num = den \n  den = rem \n  rem = num % den \n gcd = den \n lcm = int(int(num1 * num2)/int(gcd)) \n return lcm \nimport math\nt=int(input())\nfor j in range(t):\n n=int(input())\n l=[int(i) for i in input().split()]\n \n num1 = l[0] \n num2 = l[1] \n lcm = find_lcm(num1, num2) \n \n for i in range(2, len(l)): \n  lcm = find_lcm(lcm, l[i]) \n  \n print(math.floor(24*n/lcm))", "def XOR(x,y,n):\n c = 0\n for z in range(0,n+1):\n  a = x^z\n  b = y^z\n  if(a < b):\n   c+=1\n return c\n\n\nT = int(input())\nfor t in range(T):\n x,y,n = map(int,input().split())\n result = XOR(x,y,n)\n print(result)", "t=int(input())\nfor _ in range(t):\n n,m=list(map(int,input().split()))\n l=list(map(int,input().split()))\n k=[]\n for i in range(m):\n  a,b=list(map(int,input().split()))\n  k.append([a,b])\n k.sort()\n c=[]\n flag=1\n x=k[0][0]\n y=k[0][1]\n \n for i in k[1:]:\n  if i[0]<=y:\n   y=max(y,i[1])\n  else:\n   c.append([x-1,y-1])\n   x=i[0]\n   y=i[1]\n c.append([x-1,y-1])\n m=[]\n j=0\n \n for i in c:\n  while j<i[0]:\n   m.append(l[j])\n   j+=1\n  x=l[i[0]:i[1]+1]\n  m+=sorted(x)\n  j=i[1]+1\n  \n while j<n:\n  m.append(l[j])\n  j+=1\n \n if m==sorted(l):\n  print('Possible')\n else:\n  print('Impossible')\n  \n    \n \n  \n", "# cook your dish here\n\ndef check(A,N,K):\n    first = sum(A[:K])\n    mx = sum(A[:K])\n    for i in range(K,N):\n        cur = first - A[i-K] + A[i]\n        if(cur>mx):\n            mx = cur\n            first = cur\n        else:\n            first = cur\n    return(mx)\n        \n    \n\n\nt = int(input())\nfor _ in range(t):\n    n,k = map(int,input().split())\n    arr = list(map(int,input().split()))\n    print(check(arr,n,k))", "import math\nt = int(input())\n \ndef phi(n):\n\tres = n\n\ti = 2\n\twhile i*i<=n:\n\t\tif n%i==0:\n\t\t\tres/=i\n\t\t\tres*=(i-1)\n \n\t\t\twhile n%i==0:\n\t\t\t\tn/=i\n\t\ti+=1\n\t\n\tif n>1:\n\t\tres/=n\n\t\tres*=(n-1)\n \n\treturn int(res)\n \nwhile t:\n\ta,m = list(map(int,input().split()))\n\tg = math.gcd(a,m)\n\tprint(phi(m//g))\n\tt-=1\n", "for t in range( eval(input()) ) :\n dp = [ [0 for i in range(4)] for j in range(2) ]\n ret = 1\n for u in range( eval(input()) ) :\n  c = list(map( int, input().split() ))\n  for i in range( 4 ) :\n   dp[u&1][i] = 1e18\n   for j in range( 4 ) :\n    if j != i :\n     dp[u&1][i] = min( dp[u&1][i], c[j] + dp[1-(u&1)][j])\n     ret = min(dp[u&1])\n print(ret)", "# cook your dish here\ndef main():\n    for _ in range(int(input())):\n     N, k = [int(x) for x in input().split()]\n     Powers = [k ** int(x) for x in input().split()]\n  \n     s1, s2 = 0, sum(Powers)\n  \n     ans = (0, None)\n  \n     i = 0\n     while i < N - 1:\n      s1 += Powers[i]\n      s2 -= Powers[i]\n   \n      z = s1 * s2 \n      if z > ans[0]:\n       ans = (z, i)\n       # print(z)\n   \n      i += 1\n  \n     print(ans[1] + 1)\n\nmain()", "import atexit\nimport io\nimport sys\nimport math\nfrom collections import defaultdict,Counter\n\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n# sys.stdout=open(\"CP2/output.txt\",'w')\n# sys.stdin=open(\"CP2/input.txt\",'r')\n\n# m=pow(10,9)+7\nt=int(input())\nfor i in range(t):\n m,c,h=map(int,input().split())\n if (h-c)%3==0 and (h-c)//3 <=m:\n  print(\"No\")\n else:\n  print(\"Yes\")", "pref = []\r\n\r\nfor i in range(10 ** 5 + 10):\r\n    b = bin(i)[2:]\r\n    if not any(b[j] == b[j+1] == '1' for j in range(len(b) - 1)):\r\n        pref.append(i)\r\n    else:\r\n        pref.append(pref[-1])\r\n\r\nfor i in range(int(input())):\r\n    print(pref[int(input())])\r\n", "import sys\r\ndef cal_power(a, n, m):\r\n    if n == 0:\r\n        return 1\r\n    elif n == 1:\r\n        return a % m\r\n    elif not n % 2:\r\n        return ((cal_power(a, n // 2, m) % m)**2) % m\r\n    else:\r\n        return ((a % m) * (((cal_power(a, (n - 1)// 2, m)) % m)**2) % m) % m\r\n\r\ndef cal(b, n, m):\r\n    if n == 0:\r\n        return 0\r\n    elif n == 1:\r\n        return b % m\r\n    elif not n % 2:\r\n        return (((1 +cal_power(b, n // 2, m)) % m) * (cal(b, n // 2, m) % m)) % m\r\n    else:\r\n        return (((1 + cal_power(b, (n + 1) // 2, m)) % m) * (cal(b, ((n - 1) // 2), m) % m) + cal_power(b, (n + 1) // 2, m) % m) % m\r\n\r\ndef solve(a, n, m):\r\n    l = len(str(a))\r\n    x = a % m\r\n    q = 10**l % m\r\n    return (x * (1 + cal(q, n - 1, m))) % m\r\n\r\nfor _ in range(int(input())):\r\n    a,n,m = [int(temp) for temp in input().split()]\r\n    print(solve(a, n, m))", "ar = []\nar.append(1)\nfor i in range(1, 31):\n ar.append(ar[i-1]*(4*i-2)/(i+1))\nt = int(input())\nwhile(t>0):\n n = int(input())\n if(n==0):\n  print(0)\n else:\n  print(ar[n]*2)\n t=t-1\n", "t=int(input())\nfor _ in range(t):\n n,k=map(int,input().split())\n w=list(map(int,input().split()))\n count=0\n while w!=[]:\n  w1=[]\n  for i in range(n):\n   if sum(w1)+w[i]<=k:\n    w1.append(w[i])\n   else:\n    break\n  if w1==[]:\n   count=-1\n   break\n  else:\n   w[:len(w1)]=[]\n   n-=len(w1)\n   count+=1\n print(count)", "for t in range(eval(input())):\n  \n  n = eval(input())\n  \n  a = [ [] for i in range(n+1) ]\n  \n  for i in range(n-1):\n    x,y = list(map( int, input().split() ))\n    a[x].append(y)\n    a[y].append(x)\n  \n  vis = [0] * (n+1)\n  vis[1] = 1\n\n  ans = [1]\n\n  t1 = [1]\n  t2 = []\n  \n  while len(t1) > 0 :\n    for u in t1:\n      for x in a[u]:\n        if vis[x] == 0 :\n          vis[x] = 1\n          t2.append(x)\n    if len(t2) > 1 :\n      ans.append(t2[0])\n      ans.append(t2[-1])\n    if len(t2) == 1 :\n      ans.append(t2[0])\n    \n    t1 = t2\n    t2 = []\n  \n  for x in sorted(ans):\n    print(x, end=' ')\n  \n  print('')", "'''def pow1(ap,op):\n    if op==0:\n     return 1 \n    elif op%2==0:\n     y=pow1(ap,op/2)\n     return y*y   \n    else:\n     y=pow1(ap,op-1)\n     return ap*y '''\nn=int(input())\nfor i in range(n):\n k,l=map(int,input().split())\n bc=l\n ans=0\n kp=1000000007\n for j in range(1,k+1):\n  l=pow(bc,(2*j)-1,kp)\n  ans=(l+ans)%kp\n  bc=(l*bc)%kp\n print(ans)", "for i in range(int(input())):\r\n    n=int(input())\r\n    l=list(map(int,input().split()))\r\n    print(max(l[0],l[n-1]))", "def maxval(arr):\n    fn = [float('-inf')]*(len(arr)+1)\n    sn = [float('-inf')]*len(arr)\n    tn = [float('-inf')]*(len(arr)-1)\n    fon = [float('-inf')]*(len(arr)-2)\n    for i in reversed(list(range(len(arr)))):\n        fn[i] = max(fn[i + 1], arr[i])\n    for i in reversed(list(range(len(arr) - 1))):\n        sn[i] = max(sn[i + 1], fn[i + 1] - arr[i])\n\n    for i in reversed(list(range(len(arr) - 2))):\n        tn[i] = max(tn[i + 1], sn[i + 1] + arr[i])\n\n    for i in reversed(list(range(len(arr) - 3))):\n        fon[i] = max(fon[i + 1], tn[i + 1] - arr[i])\n    return fon[0]\nn = int(input())\narr = list(map(int,input().split()))\nprint(maxval(arr))\n    \n", "# cook your dish here\ndef letterNo(c):\n    if i == '?':\n        return 26\n    return ord(c) - 97\nfor _ in range(int(input())):\n    s = input().strip()\n    mask = 0\n    for i in s:\n        if i != '?':\n            mask ^= (1 << letterNo(i))\n    d = {}\n    x = 0\n    d[0] = 1\n    ans = 0\n    for i in s:\n        x ^= (1 << letterNo(i))\n        ans += d.get(x^mask, 0)\n        for j in range(26):\n            ans += d.get(x^(1 << 26)^(1 << j)^mask, 0)\n        d[x] = d.get(x, 0) + 1\n    print(ans)\n", "import math\ndef gcd(a,b): \n if (b == 0): \n   return a \n return gcd(b, a%b) \n\ndef lcm(a,b): \n return (a*b) / gcd(a,b) \n\ndef bs(arr, l, r, x): \n while l <= r: \n  mid = l + (r - l)//2; \n  if(arr[mid]==x): \n   return arr[mid]\n  elif(arr[mid]<x): \n   l = mid + 1\n  else: \n   r = mid - 1\n return -1\n\ndef swap(list, pos1, pos2): \n  \n list[pos1], list[pos2] = list[pos2], list[pos1] \n return list\n\nt = int(input())\nfor _ in range(t):\n n = int(input())\n a = list(map(int,input().split()))\n f = 0\n for i in range(n):\n  if(a[i]%2==0):\n   f=1\n if(f):\n  print('NO')\n else:\n  print('YES')", "t=int(input())\nfor i in range(t):\n a=int(input())\n fa=input().split()\n b=int(input())\n fb=input().split()\n count=0\n k=0\n search=0\n x=[]\n y=[]\n for i in range(b):\n  k=fb[i]\n  if(k in fa):\n   x.append(fa.index(k))\n   y.append(fa.index(k))\n y.sort()\n if(x==y and len(x)==b):\n  print(\"Yes\")\n else:\n  print(\"No\")\n   \n   \n   \n  \n \n  \n \n  \n \n", "# cook your dish here\na=int(input())\nz=[]\nfor i in range(a):\n    b=int(input())\n    c=list(map(int,input().split()))\n    p=0\n    if sum(c)%b!=0:\n        p=p+b-(sum(c)%b)\n        q=int(sum(c)/b)+1\n    else:\n        q=int(sum(c)/b)\n    \n    for j in c:\n        if j>q:\n            p=p+j-q\n    z.append(p)\nfor i in z:\n    print(i)", "d={'A':27,'B':26,'C':25,'D':24,'E':23,'F':22,'G':21,'H':20,'I':19,'J':18,'K':17,'L':16,'M':15,\n'N':14,'O':13,'P':12,'Q':11,'R':10,'S':9,'T':8,'U':7,'V':6,'W':5,'X':4,'Y':3,'Z':2}\n# for _ in range(int(input())):\ns = input().strip()\nc = 0\nfor x in s:\n    c+=d[x]\nprint(c)", "import math\nn=1001\na=[True]*n\nl=[]\nfor i in range(2,33):\n if(a[i]):\n  for j in range(i*i,n,i):\n   a[j]=False\nfor pr in range(2,1001):\n if(a[pr]):\n  l.append(pr)\nt=int(input())\nfor j in range(t):\n n,m=list(map(int,input().strip().split()))\n arr=[int(num) for num in input().strip().split()]\n Matrix =[]\n index=[0]*100000\n factors=[0]*100000\n ans=''\n for r in range(len(arr)):\n  li=[]\n  for val in l:\n   while((arr[r]%val)==0):\n    arr[r]=arr[r]/val\n    li.append(val)\n    factors[r]+=1\n  if(arr[r]!=1):\n   li.append(arr[r])\n   arr[r]=1\n   factors[r]+=1\n  Matrix.append(li)\n for k in range(m):\n  opr=[int(o) for o in input().strip().split()]\n  L=opr[1]\n  R=opr[2]\n  if(opr[0]==0):\n   for ran in range(L-1,R):\n    if(index[ran]<factors[ran]):\n     index[ran]+=1\n  else:\n   result=1\n   for ran in range(L-1,R):\n    if(index[ran]<factors[ran]):\n     result=max(result,Matrix[ran][index[ran]])\n   ans+=str(result)\n   ans+=' '\n print(ans[:-1])", "# cook your dish here\ndef __starting_point():\n    for _ in range(int(input())):\n        b, g = map(int, input().split())\n        print(2*(g+b-1))\n__starting_point()", "t=int(input())\nfor i in range(t):\n s=0\n r=1\n n=int(input())\n for j in range(0,n+1):\n  for k in range(0,j):\n   print(s,end=\" \")\n   p=r+s\n   s,r=r,p\n  print()", "import re\ndef isCirlePossible(juices,distances):\n if juices == [] or distances == []:\n  return -1;\n total_juice_consumed = 0\n juice_consumed = 0\n start=0\n for i in range(0,len(juices)):\n  diff = juices[i] - distances[i]\n  if juice_consumed >= 0:\n   juice_consumed += diff\n  else:\n   juice_consumed = diff\n   start = i\n  total_juice_consumed += diff\n return start if total_juice_consumed >= 0 else -1\n\njuices = []\ndistances = []\nnumLines = int(input())\nfor each in range(0,numLines):\n line = input()\n result = [int(x) for x in re.findall('\\d+',line)]\n if result != []:\n  juices.append(result[0])\n  distances.append(result[1])\n  \nprint(isCirlePossible(juices,distances))", "for i in range(int(input())):\n s=input()\n one=[0]\n for i in range(len(s)):\n  one+=[one[-1]]\n  if s[i]=='1':\n   one[-1]+=1\n ans=0\n i=1\n r=2\n while r<=len(s):\n  r=i+i**2\n  j=0\n  while j<=len(s)-r:\n   if one[j+r]-one[j]==i:\n    ans+=1\n    j+=1\n   else:\n    j+=abs(i-(one[j+r]-one[j]))\n  i+=1\n print(ans)", "inv = 280000002\r\nmod = 1000000007\r\nfor _ in range(int(input())):\r\n\tn = int(input())\r\n\tif n % 2 == 0:\r\n\t\tn = n // 2 + 1\r\n\t\ta = (2 * ((pow(26,n, mod) - 1) * inv - 1) ) % mod\r\n\t\tprint(a)\r\n\telse:\r\n\t\tn = n // 2 + 2\r\n\t\ta = (2 * ((pow(26,n,mod) - 1) * inv - 1)) % mod\r\n\t\ta = (a - pow(26, n - 1, mod)) % mod\r\n\t\tprint(a)", "# your code goes here\ndef myKey(l):\n return -l[1]\nt=int(input())\nfor tests in range(t):\n n=int(input())\n ca=[]\n for i in range(n):\n  l=input()\n  l=l.split()\n  l[0]=int(l[0])\n  l[1]=int(l[1])\n  ca.append(l)\n ca.sort(key=myKey)\n for i in range(n):\n  ca[i][0]*=ca[i][1]\n  ca[i][1]-=1\n ans=\"\"\n for i in range(n-1):\n  if ca[i][0]!=0:\n   if ca[i][1]!=0:\n    ans+=(str(ca[i][0])+\"x^\"+str(ca[i][1])+\" + \")\n   else:\n    ans+=(str(ca[i][0])+\" + \")\n if ca[n-1][0]!=0:\n  if ca[n-1][1]!=0:\n   ans+=(str(ca[n-1][0])+\"x^\"+str(ca[n-1][1]))\n  else:\n   ans+=(str(ca[n-1][0]))\n else:\n  ans=ans[:-3]\n print(ans)", "def magic():\n def check(art,k,m):\n  n=len(art)\n  for i in range(n-k+1):\n   maxi=0\n   maxi=max(art[i:i+k])\n\n   total=0\n   total=art[i:i+k].count(maxi)\n\n   if total>=m:\n    return False\n\n  return True\n  \n\n\n for _ in range(eval(input())):\n  n,k,m=list(map(int,input().split()))\n  arr=list(map(int,input().split()))\n  dp=[]\n  ans=100\n\n  for mask in range(0,(1<<n)):\n   size=bin(mask).count('1')\n\n   if ans>size:\n    art=list(arr)\n    for i in range(n):\n     if mask & (1<<i):\n      art[i]+=1\n\n    if check(art,k,m):\n     ans=size\n\n  print(ans if ans!=100 else -1)\nmagic()\n", "t=int(input())\nfor i in range(t):\n n=int(input())\n l=[]\n for k in range(n):\n  s=input()\n  l.append(s)\n s=''.join(l)\n f=\"odhf\"\n m=[]\n for j in f:\n  m.append(s.count(j))\n m.append(s.count('c')//2)\n m.append(s.count('e')//2)\n print(min(m)) ", "D=[0]*31\nD[1]=2\nD[2]=5\n\nfor i in range(3,31):\n best=10**10\n for p in range(1,i+1):\n  best=min(best,D[p-1]+D[i-p]+i+1)\n D[i]=best\n\nt=int(input())\nfor i in range(t):\n n,m=list(map(int,input().split()))\n maxi=(n+2)*(n+1)/2-1\n mini=D[n]\n if mini<=m<=maxi: print(0)\n elif m<mini: print(-1)\n else: print(m-maxi)\n", "def diagonal_difference(matrix):\n l = sum(matrix[i][i] for i in range(N))\n r = sum(matrix[i][N-i-1] for i in range(N))\n return abs(l - r)\n\nmatrix = []\nN = eval(input())\nfor _ in range(N):\n matrix.append(list(map(int, input().split())))\n\nprint(diagonal_difference(matrix))", "for _ in range(int(input())):\n x,y=map(int,input().split())\n l=[[int(x) for x in input().strip()] for y in range(x)]\n ans=[[2]*y for k in range(x)]\n temp=0\n rows=set()\n col=set()\n for i in range(x):\n  for j in range(y):\n   if l[i][j]==1:\n    temp=1\n    rows.add(i)\n    col.add(j)\n    ans[i][j]=0\n for ii in rows:\n  for var in range(y):\n   if ans[ii][var]==2:\n    ans[ii][var]=1\n for jj in col:\n  for var in range(x):\n   if ans[var][jj]==2:\n    ans[var][jj]=1\n\n if temp==0:\n  ans=[[-1]*y for k in range(x)]\n for li in ans:\n  print(*li)", "# cook your code here\nfor _ in range(eval(input())):\n n=eval(input())\n ind=0\n m=0\n \n for i in range(n):\n  \n  l=[int(x) for x in input().split()]\n  sc=l[0]\n  for j in range(1,len(l)):\n   sc+=int(l[j]>=4)+int(l[j]>=5)+2*int(l[j]>=6)\n  if sc==m:\n   ind=-2\n  if sc>m :\n   m=sc\n   ind=i+1\n  \n   \n if (ind==-2):\n  print(\"tie\")\n elif (ind==1) :\n  print(\"chef\")\n else:\n  print(ind)", "for _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n ra=[0]*n\n x=0\n for i in range(n):\n  ra[i]=x+a[i]\n  x=ra[i]\n b=list(map(int,input().split()))\n rb=[0]*n\n y=0\n for i in range(n):\n  rb[i]=y+b[i]\n  y=rb[i]\n c=f=0\n if ra[0]==rb[0]:\n  c=a[0]\n for i in range(1,n):\n  if ra[i-1]==rb[i-1] and a[i]==b[i]:\n   c+=a[i]\n print(c)\n \n", "# cook your dish here\ntest=int(input(\"\"))\nfor i in range(test):\n n=int(input(\"\"))\n s=input(\"\")\n list(s)\n d=[]\n for i in range(n):\n  d.append(s[i])\n print(min(d))", "\n\nt = int(input())\n\nfor i in range(t):\n n = int(input())\n hash = {}\n l = list(map(int,input().split()))\n for j in range(n):\n  try:\n   hash[l[j]]\n  except:\n   hash[l[j]] = 1\n  else:\n   hash[l[j]]+=1\n flag = 0\n max = 0\n for j in range(n):\n\n  if hash[l[j]]>n//2:\n   flag = 1\n   break\n  elif hash[l[j]]>max:\n   max = hash[l[j]]\n # l.sort()\n # print(max)\n # print(l)\n v = sorted(range(len(l)),key=lambda k:l[k])\n u = sorted(l)\n ans = [0]*n\n if flag == 0:\n  print('Yes')\n  z = u[max:] + u[:max]\n  for i in range(n):\n   ans[v[i]] = z[i]\n\n  print(*ans)\n else:\n  print('No')", "# cook your code here\nfor _ in range(0,int(input())):\n if (int(input()))%2==0:\n  print(\"YES\")\n else:\n  print(\"NO\")", "for t in range(int(input())):\n s = input()\n a = [0]*26\n for c in s:\n  for i in range(26):\n   a[i] += ord(c)-(ord('a')+i)\n m = float(\"inf\")\n for i in a:\n  m = min(m, abs(i))\n print(m)", "from math import sqrt\ndef isPrime(n):\n for i in range(2, int(sqrt(n))+1):\n  if(n%i==0): return True\n return False\nans = []\nfor _ in range(int(input())):\n x, y = map(int, input().split())\n ans.append('NO' if(isPrime(x**2-y**2)) else 'YES')\nprint('\\n'.join(ans))", "# cook your dish here\n#powerful numbers\nn = int(input())\nplist = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\npower = 1\nfor i in range(2,n+1,1):\n    pdiv = []\n    count = 0\n    for p in plist:\n        if i>=p and i%p==0:\n            pdiv.append(p)\n    for pd in pdiv:\n        if i%(pd**2)==0:\n            count+=1\n    if count==len(pdiv) and count!=0:\n        power+=1\n\n    \n        \nprint(power)", "#Program question at: http://www.codechef.com/COZL2012/problems/RBX12R01\nimport math,sys\ndir_ = 'UDLR'\nleft = 'LRDU'\nright = 'RLUD'\n\nt = int(input())\nwhile t>0:\n t -= 1\n x=0; y=0;\n dr = ''; cur='U';\n s = input().split()\n l = len(s)\n for i in range(l):\n  if i % 2 == 1:\n   dr = s[i]\n   if dr == 'L': cur = left[dir_.find(cur)]\n   else: cur = right[dir_.find(cur)]\n  else:\n   steps = int(s[i])\n   if cur == 'U': y += steps\n   elif cur == 'D': y -= steps\n   elif cur == 'L': x -= steps\n   elif cur == 'R': x += steps\n\n dist = str(math.sqrt(x*x + y*y))\n i = dist.find('.')\n sys.stdout.write(dist[0:i+2])\n if x==0:\n  sys.stdout.write( ('N' if y>0 else 'S') + '\\n')\n elif y==0:\n  sys.stdout.write( ('E' if x>0 else 'W') + '\\n')\n elif x>0:\n  sys.stdout.write( ('NE' if y>0 else 'SE') + '\\n')\n elif x<0:\n   sys.stdout.write( ('NW' if y>0 else 'SW') + '\\n')\n\n", "t = int(input())\nfor _ in range(t):\n n,m,k = map(int,input().strip().split())\n plants = []\n stat = {}\n count = 0\n for i in range(k):\n  x,y = map(int,input().strip().split())\n  ele = (x,y)\n  stat [ele] = 1\n  plants.append([x,y])\n  count += 4 \n  if(stat.get((x-1,y)) == 1):\n   count -= 2\n  if(stat.get((x,y+1)) == 1):\n   count -= 2\n  if(stat.get((x+1,y)) == 1):\n   count -= 2\n  if(stat.get((x,y-1)) == 1):\n   count -= 2\n print(count)", "t = int(input())\nfor _ in range(t):\n n,k = list(map(int,input().split()))\n f = n//k\n if f%k==0:\n  print(\"NO\")\n else:\n  print(\"YES\")\n", "t=int(input())\nfor _ in range(t):\n    n=int(input())\n    l1=[]\n    if n==1:\n        print('*')\n    elif n==3:\n        print('*')\n        print('**')\n        print('*')\n    else:\n        s1=\"\"\n        n1=n//2\n        n1+=1 \n        for i in range(1,n1+1):\n            s1=\"\"\n            if i==1:\n                s1+='*'\n            elif i==2:\n                s1+='**'\n            else:\n                s1+='*'\n                for j in range(2,i):\n                    s1+=' '\n                s1+='*'\n            l1.append(s1)\n    for i in l1:\n        print(i)\n    l1.reverse()\n    for i in range(1,len(l1)):\n        print(l1[i])\n    \n    \n", "for tests in range(int(input())):\n n = int(input())\n blockHeights = [int(blockHeight) for blockHeight in input().split()]\n sumOfBlockHeightsBefore = sum(blockHeights)\n blockHeights[0] = blockHeights[n-1] = 1\n\n # make all possible temples and choose biggest one, as its demolition cost \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0will be heighest\n # carve first half of temples i.e left right angle triangle, considering \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temple an equilateral triangle\n for i in range(1, n):\n  if blockHeights[i] > blockHeights[i-1] + 1:\n   blockHeights[i] = blockHeights[i-1] + 1\n\n # carve second half of temples i.e right right angle triangle\n for i in range(n-2, -1, -1):\n  if blockHeights[i] > blockHeights[i+1] + 1:\n   blockHeights[i] = blockHeights[i+1] + 1\n heightOfTallestTemple = max(blockHeights)\n\n # find sum of blocks for height of tallest temple\n # through arithematic progression we have a1= 1, an = heightOfTallestTemple, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d = 1 and thus Sn = (a1 + an) * an / 2\n # so we have to AP series for two halves of temple\n # s1 = (1 + heightOfTallestTemple) * heightOfTallestTemple / 2\n # s2 = (1 + heightOfTallestTemple-1) * (heightOfTallestTemple - 1) / 2\n # s = s1 + s2\n # fruther simplifying we have\n # s = heightOfTallestTemple * heightOfTallestTemple\n s = heightOfTallestTemple ** 2\n\n noOfOperations = sumOfBlockHeightsBefore - s\n # print(blockHeights, heightOfTallestTemple, sum(blockHeights), \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumOfBlockHeightsBefore, s, sep=' | ')\n print(noOfOperations)\n", "import math\n\ndef Left(i):\n return 2*i\n\ndef Right(i):\n return (2*i)+1\n\ndef levelOf(x):\n return int( math.floor( (math.log10(x)/math.log10(2))+1) )\n\ndef treeProduct(numList, n, i):\n if levelOf(i)==n:\n  return numList[i]\n else:\n  tpl = treeProduct(numList,n,Left(i))\n  tpr = treeProduct(numList,n,Right(i))\n  if (tpl>tpr):\n   return ( (numList[i]*tpl))\n  else:\n   return ( (numList[i]*tpr))\n\ndef main():\n n = int(input())\n while n!=0:\n  line = '-1 '+str(input())\n  s = line.split()\n  num = [int(e) for e in s]\n  print(int(treeProduct(num,n,1)%1000000007))\n  n = int(input())\n \ndef __starting_point():\n main()\n\n__starting_point()", "for _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n has_true = True\n max_a = max(a)\n series1 = []\n series2 = []\n if a.count(max_a) > 1:\n  print(\"NO\")\n  continue\n i = 0\n a.sort()\n while i < n:\n  if a.count(a[i]) > 2:\n   has_true = False\n   print(\"NO\")\n   break\n  \n  if a.count(a[i]) == 2:\n   series1.append(a[i])\n   series2.append(a[i])\n   i+=1\n  else:\n   series1.append(a[i])\n  i += 1\n if has_true == True:\n  series2 = series2[::-1]\n  print(\"YES\")\n  print(*(series1 + series2))", "# cook your dish here\nwhile True:\n n=int(input())\n if n==0:\n  break\n l=list(map(int,input().split()))\n l1=[0]*n\n for i in range(n):\n  l1[l[i]-1]=i+1\n if l==l1:\n  print('ambiguous')\n else :\n  print('not ambiguous')\n", "for _ in range(int(input())):\n n=int(input())\n s=list(input())\n coord=list(map(int,input().split()))\n p=0\n i=0\n h=[]\n for i in range(0,n):\n  if s[i]=='1':\n   h.append(i)\n if h[0]!=0:\n  p=p+coord[h[0]]-coord[0]\n if h[len(h)-1]!=n-1:\n  p=p+coord[n-1]-coord[h[len(h)-1]]\n for j in range(0,len(h)-1):\n  if h[j]+1==h[j+1]:\n   continue\n  if h[j+1]-h[j]-1==1:\n   p=p+min(coord[h[j]+1]-coord[h[j]],coord[h[j+1]]-coord[h[j]+1])\n  else:\n   y=min(coord[h[j+1]]-coord[h[j]+1],coord[h[j+1]-1]-coord[h[j]])\n   for k in range(h[j]+1,h[j+1]-1):\n    y=min(y,coord[k]-coord[h[j]]+coord[h[j+1]]-coord[k+1])\n   p=p+y\n print(p)", "n,q=map(int,input().split())\nl={}\nfor i in range(n):\n a,b=input().split()\n l[a]=b\nfor i in range(q):\n s=input().strip()\n if('.' in s):\n  s=s.split('.')\n  x=s[-1]\n  if(x in l):\n   print(l[x])\n  else:\n   print('unknown')\n else:\n  print('unknown')", "for t in range(int(input())):\r\n\tl1=list(map(int,input().split()))\r\n\tl2=list(map(int,input().split()))\r\n\tl3=list(map(int,input().split()))\r\n\tmax=0\r\n\tg=l1[0]+l2[0]+l3[0]\r\n\ty=l1[1]+l2[1]+l3[1]\r\n\tr=l1[2]+l2[2]+l3[2]\r\n\tif g%2==0:\r\n\t\tg-=1\r\n\tif y%2==0:\r\n\t\ty-=1\r\n\tif r%2==0:\r\n\t\tr-=1\r\n\tif max<g:\r\n\t\tmax=g\r\n\tif max<r:\r\n\t\tmax=r\r\n\tif max<y:\r\n\t\tmax=y\r\n\tm=l1[0]+l1[1]+l1[2]\r\n\to=l2[0]+l2[1]+l2[2]\r\n\tp=l3[0]+l3[1]+l3[2]\r\n\tif m%2==0:\r\n\t\tm-=1\r\n\tif o%2==0:\r\n\t\to-=1\r\n\tif p%2==0:\r\n\t\tp-=1\r\n\tif max<m:\r\n\t\tmax=m\r\n\tif max<o:\r\n\t\tmax=o\r\n\tif max<p:\r\n\t\tmax=p\r\n\r\n\tprint(max)\r\n", "import sys,io,os,math\nfrom math import ceil,log,gcd,inf\nfrom itertools import permutations\nmod=1000000007\nmod1=998244353\ndef printlist(n):\n    sys.stdout.write(\" \".join(map(str,n)) + \"\\n\")\nprintf=lambda n:sys.stdout.write(str(n)+\"\\n\")\ndef printns(n):\n    sys.stdout.write(str(n))   \ndef intinp():\n    return int(sys.stdin.readline())\ndef strinp():\n    return sys.stdin.readline()\ndef arrinp():\n    return list(map(int,sys.stdin.readline().strip().split()))\ndef mulinp():\n    return list(map(int,sys.stdin.readline().strip().split()))\ndef flush():\n    return sys.stdout.flush()\ndef power_two(x):\n    return (1<<x)\ndef lcm(a,b):\n\treturn a*b//gcd(a,b)   \ndef solve():\n        n=str(intinp())\n        for i in n:\n                if(int(i)%2==0):\n                        print(1)\n                        return 0\n        print(0)\n\n\n\ndef main():\n    tc=intinp()\n    while(tc):\n        solve()\n        tc-=1\t\n\t\nmain()\n\n", "n = int(input())\r\nl = []\r\nll =[]\r\nans=[]\r\nfor i in range(n):\r\n    x = int(input())\r\n    l.append(x)\r\nfor i in range(n) :\r\n    for j in range(i+1,n):\r\n        if l[j] - l[i] > 0 :\r\n            ll.append(l[j]-l[i])\r\n        else:\r\n            ll.append(l[i]-l[j])\r\nll.sort()\r\nfor i in range(2,int(ll[0]**0.5)+1):\r\n    if i * i > ll[0] :\r\n        break\r\n    if ll[0] % i == 0 :\r\n        ans.append(i)\r\n        ans.append(ll[0]//i)\r\nans.append(ll[0])\r\nans = list(set(ans))\r\nans.sort()\r\nprint(*ans)\r\n        \r\n\r\n", "t=int(input())\nfor i in range(t):\n p1,p2=list(map(int,input().split()))\n num=p1+p2\n a=1\n \n\n while True:\n  prime=num+a\n  r=0\n  for i in range(2,int(prime**0.5)+1):\n   if prime%i==0:\n    a+=1\n    r=1\n    break\n  if r==0:\n   print(a)\n   break\n\n\n  \n\n  \n\n", "for t in range(int(input())):\r\n\tn=int(input())\r\n\ts=input().strip()\r\n\tc=0\r\n\tflag=0\r\n\tfor i in range(n):\r\n\t\tif (s[i]==\"A\" or s[i]==\"E\" or s[i]==\"I\" or s[i]==\"O\" or s[i]==\"U\") and (s[i-1]==\"A\" or s[i-1]==\"E\" or s[i-1]==\"I\" or s[i-1]==\"O\" or s[i-1]==\"U\") :\r\n\t\t\tflag=1\r\n\tif flag and n!=1:\r\n\t\tprint(\"Yes\")\r\n\telse:\r\n\t\tprint(\"No\")\r\n", "import sys\nimport math\ninput=sys.stdin.readline\ndef binary(l,r,co,b,c):\n x=(l+r)/2\n #print(x)\n val1=(2*x+b)*math.sin(x)\n val2=(x**2+b*x+c)*math.cos(x)\n x=(l+r)/2\n val=val1-val2\n if(abs(val)<.0000001 or co==150):\n  return (l+r)/2\n if(val<0):\n  return binary((l+r)/2,r,co+1,b,c)\n else:\n  return binary(l,(l+r)/2,co+1,b,c)\nt=int(input())\nfor _ in range(t):\n b,c=list(map(float,input().split()))\n x=binary(.0000000001,math.pi/2-.0000000001,0,b,c)\n #print(\"t=\",_)\n val=(x*x+b*x+c)/math.sin(x)\n print(val)\n \n\n \n\n\n \n \n \n\n\n \n", "from collections import Counter\r\nfrom math import sqrt\r\n\r\ndef facts(n):\r\n    if n % 2 == 0:\r\n        yield 2\r\n\r\n        while n % 2 == 0:\r\n            n //= 2\r\n\r\n    for i in range(3, int(sqrt(n)) + 1, 2):\r\n        if n % i == 0:\r\n            yield i\r\n\r\n            while n % i == 0:\r\n                n //= i\r\n\r\n    if n > 2:\r\n        yield n\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n\r\n    ms = [max(facts(i)) for i in a]\r\n\r\n    cnt = Counter(ms)\r\n\r\n    m = max(cnt.values())\r\n\r\n    x = {i for i in ms if cnt[i] == m}\r\n\r\n    print(max(x))", "from numpy import array\nfor _ in range(0,int(input())):\n [a,b,c]=list(map(int,input().strip().split()))\n x1 = array(list(map(int,input().strip().split())))\n x2 = array(list(map(int,input().strip().split())))\n y1 = list(map(int,input().strip().split()))\n z1 = list(map(int,input().strip().split()))\n x = x1-x2\n x.sort()\n z=array(y1+z1)\n z.sort()\n z=z.tolist()\n tot =0\n for p in x:\n  minq=1000000\n  pos = -1\n  ctrpos = 0\n  for q in z:\n   if(q>p):\n    break\n   if (p-q)<minq:\n    minq = p-q\n    pos = ctrpos\n   ctrpos+=1\n  if pos !=-1:\n   tot+=minq\n   del z[pos]\n   #z=np.delete(z,pos)\n  else:\n   tot+=p \n print(tot)\n", "for _ in range(int(input())):\n    N = int(input())\n    \n    K = 1\n    for i in range(N):\n        for j in range(N):\n            B = bin(K)[2:]\n            K += 1\n            print(B[::-1], end = \" \")\n        print()\n    ", "import sys\nfrom math import * \nfrom collections import *\nfrom itertools import *\n\ndef int_arr():return list(map(int,input().split()))\ndef str_arr():return list(map(str,input().split()))\ndef two_int():return list(map(int,input().split()))\ndef two_str():return list(map(str,input().split()))\nmod = 10**9+7\nsys.setrecursionlimit(10**9)\n\n\ndef solve(s,p):\n s = list(s)\n p = list(p)\n flag = 0\n if s.count('0') == p.count('0') and s.count('1') == p.count('1'):\n  for i in range(len(s)):\n   if s[i] == '1' and p[i] == '0':\n    for j in range(i,n):\n     if s[j] == '0':\n      temp = s[i]\n      s[i] = s[j]\n      s[j] = temp\n      break\n   if s == p:\n    flag = 1\n    break\n\n if flag == 1:\n  return 'Yes'\n else:\n  return 'No'\n\n\n\n\n\n\nfor _ in range(int(input())):\n n = int(input())\n s = str(input())\n p = str(input())\n print(solve(s,p))\n", "for _ in range(int(input())):\n s1=input().split()\n s2=input().split()\n count=0\n for i in s1:\n  for j in s2:\n   if i==j:\n    count+=1\n if count>=2:\n  print('similar')\n else:\n  print('dissimilar')", "M = 10**9 + 7\nn = int(input())\nf = list(map(int, input().split()))\nq = int(input())\nfor i in range(q):\n query = input().split()\n if query[0] == '1':\n  f[int(query[1]) -1] = int(query[2])\n else:\n  r = int(query[1])\n  k = 0\n  ans = 1\n  while k<n:\n   ans *= f[k]\n   k += r\n  print(str(ans)[0], ans % M)", "for _ in range(int(input())):\n    n = int(input())\n    ls = list(map(int,input().split()))\n    ls = sorted(ls)\n    \n    print(ls[-2]*ls[-1],end=\" \")\n    \n    print(ls[0]*ls[1])\n    ", "# cook your dish here\nimport sys \n\nsys.setrecursionlimit(10**6) \n\ndef recurse(root):\n\tif root not in dic:\n\t\treturn (1,1)\n\tsum1=1\n\tmax1=0\n\tfor i in dic[root]:\n\t\tx,y=recurse(i)\n\t\tsum1+=x \n\t\tmax1=max(max1,y)\n\treturn sum1,sum1+max1\n\nfor _ in range(int(input())):\n\tn=int(input())\n\t\n\tdic={}\n\tlis=list(map(int,input().split()))\n\tfor i in range(len(lis)):\n\t\tif lis[i] not in dic:\n\t\t\tdic[lis[i]]=[i+2]\n\t\telse:\n\t\t\tdic[lis[i]].append(i+2)\n\tx,y=recurse(1)\n\tprint(y)", "for i in range(int(input())):\n a,b = list(map(int, input().split( )))\n lis=[ ]\n if a >= b :\n  for i in range(1,a+1):\n   if a%i==0 :\n    if b%i==0:\n     lis.append(i)\n else :\n  for i in range(1,b+1):\n   if b%i==0 :\n    if a%i==0:\n     lis.append(i)\n print(lis[-1])\n", "def solve(array,k,n):\n \n even=[]\n odd=[]\n for i in range(n):\n  if array[i]%2==0:\n   even.append(array[i])\n   odd.append(0)\n  else:\n   odd.append(array[i])\n   even.append(0)\n dpEven=[0]*n\n dpOdd=[0]*n\n dpEven[0]=even[0]\n dpOdd[0]=odd[0]\n i=1\n while i<=k and i<n:\n  dpEven[i]=max(dpEven[i-1],even[i])\n  dpOdd[i]=max(dpOdd[i-1],odd[i])\n  i+=1\n for i in range(k+1,n):\n  dpEven[i]=max(dpEven[i-1],dpEven[i-k-1]+even[i])\n for i in range(k+1,n):\n  dpOdd[i]=max(dpOdd[i-1],dpOdd[i-k-1]+odd[i])\n return dpOdd[-1]+dpEven[-1]\nqueries=[]\nfor _ in range(int(input())):\n n,k=map(int,input().split( ))\n queries.append((list(map(int,input().split( ))),k))\n\nfor query in queries:\n print(solve(query[0],query[1],len(query[0])))", "t=eval(input())\nwhile t:\n n=eval(input())\n m,f=list(map(int,input().split()))\n multan=0\n total=0\n fultan=0\n s=list(map(int,input().split()))\n for i in s:\n  if i==0:\n   continue\n  if i%m==0:\n   multan+=1;\n   total+=1\n  elif i%f==0:\n   fultan+=1\n   total+=1\n if total-0.7*n>=0.0:\n  print(\"Yes\")\n  if multan>fultan:\n   print(\"Multan\")\n  elif fultan>multan:\n   print(\"Fultan\")\n  else:\n   print(\"Both\")\n else:\n  print(\"No\")\n #print total,multan,fultan\n t-=1\n", "def checkPalindrome(string):\n    if(string==string[::-1]):\n        return 1\n    else:\n        return 0\nt=int(eval(input()))\nwhile(t):\n    ip_string=input()\n    length_of_str=len(ip_string)\n    p=2\n    count=length_of_str\n    while(p<=length_of_str):\n        for i in range(1,length_of_str+1):\n            temp_str=ip_string[i-1]\n            j=i*p\n            while(j<=length_of_str):\n                temp_str+=ip_string[j-1]\n                if(checkPalindrome(temp_str)==1):\n                    count+=1\n                j=j*p\n        \n        p+=1\n    print(count)\n    t-=1", "# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(*[2,1])\n    elif n == 3:\n        print(*[2,3,1])\n    else:\n        arr = list(range(1,n+1))\n        for i in range(1,n,2):\n            if n%2 == 1 and n-i == 2:\n                arr[i-1], arr[i], arr[i+1] = arr[i], arr[i+1], arr[i-1]\n                break\n            else:\n                arr[i], arr[i-1] = arr[i-1], arr[i]\n        print(*arr)\n                ", "n, k, p = map(int, input().split())\nf = list(map(int, input().split()))\nseq = sorted(set(f))\nm = 0\nseq1 = {seq[0]: 0}\nfor i in range(1, len(seq)):\n if seq[i]-seq[i-1] > k:\n  m += 1\n seq1[seq[i]] = m\nwhile p > 0:\n i, j = map(int, input().split())\n i, j = f[i-1], f[j-1]\n if seq1[i] == seq1[j]:\n  print('Yes')\n else:\n  print('No')\n p -= 1", "# cook your dish here\ndef solve(d):\n op=[]\n p=(10**5)-2\n if d>0:\n  while d>0:\n   p=min(d,p)\n   op.append(p+1)\n   op.append(p+2)\n   op.append(1)\n   d= d-p\n else:\n   op.append(d+1)\n   op.append(d+2)\n print(len(op))\n print(*op)\ndef __starting_point():\n for test in range(int (input())):\n  d=int(input())\n  solve(d)\n__starting_point()", "from decimal import Decimal\nfor _ in range(0,eval(input())):\n    [r1,h1,r2,h2],p=list(map(Decimal,input().split())),Decimal(3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603)\n    print(p*(r1**2)*(h1+Decimal(2.0)*r1)/3, p*(r2**2)*h2)", "\n\nfor _ in range(int(input())): #test_cases\n    n=input()\n    a=n[::-1]  #reverse and store\n    k = 0 ;\n    for i in a:  #loop through to remove zeroes at the beginning\n        if i =='0': #delete the character from the string\n            k += 1 ;\n        else:   #exit as soon as a non zero number is found :)\n            break\n        \n    print(a[k:])", "t=int(input())\nfor i in range(t):\n n=input()\n arr=[int(i) for i in input().split()]\n arr.sort()\n while(len(arr)!=1):\n  w=arr[-1]\n  arr.pop() \n  e=arr[-1]\n  arr.pop()\n  arr.append((w+e)/2) \n print('%.6f'%arr[0])", "for _ in range(int(input())):\n n,m=list(map(int,input().split()))\n if((n%m)%2==0):\n  print('EVEN')\n else:\n  print('ODD')\n", "# cook your dish here\nfrom sys import stdin,stdout\n\na0=0\na1=1\nn,k=stdin.readline().strip().split(' ')\nn,k=int(n),int(k)\n\narr=list(map(int,stdin.readline().strip().split(' ')))\n\n\n\ndef solve(n,k,arr):\n sol=[]\n\n l=0;u=k;\n\n\n while l!=u:\n   sol.append(arr[l:min(len(arr),u)])\n   l=min(l+k,len(arr))\n   u=min(u+k,len(arr))\n   \n tiwari=[]\n for i in range(k):\n   titi=0\n   gao=0\n   for j in range(len(sol)):\n    if len(sol[j])>i:\n     if sol[j][i]==0:\n      titi+=1\n     else:\n      gao+=1\n   tiwari.append((titi,gao))\n\n minflip=(-1,-1)\n ans=0\n ctr=0\n for i in tiwari:\n   if i[0]<i[1]:\n    ans+=i[0]\n    ctr+=(1*a1+a0*a1)*a1\n    if i[1]<minflip[0] or minflip[0]==-1:\n     minflip=(i[1],i[0])\n   else:\n    ans+=i[1]\n    if i[0]<minflip[0] or minflip[0]==-1:\n     minflip=(i[0],i[1])\n #print(ans,ctr)\n #print(tiwari)\n #print(minflip)\n if ctr%2==0:\n   ans+=minflip[0]\n   ans-=minflip[1]\n\n\n stdout.write(str(ans)+\"\\n\")\n\nsolve(n,k,arr)", "t = int(input())\n\nfor i in range(t):\n n = int(input())\n cost = list(map(int, input().split()))\n w, y = list(map(int, input().split()))\n temp = w-y+1\n if temp<=0:\n  print(\"Not Possible\")\n else:\n  cost.sort()\n  total = temp*cost[0]\n  for j in range(y-1):\n   total+=cost[j+1]\n  print(total)\n   \n  \n", "# cook your dish here\nepi=10**-2\ndef vision(t):\n a1=x0+(dx*t)-x1\n a2=y0+(dy*t)-y1\n a3=z0+(dz*t)-z1\n b=4*((a1*d1)+(a2*d2)+(a3*d3))*((a1*d1)+(a2*d2)+(a3*d3))\n a=4*((a1*a1)+(a2*a2)+(a3*a3))\n value=(b-(a*c))\n return value\nxrange=range\nfor _ in range(int(input())):\n x1,y1,z1,x0,y0,z0,dx,dy,dz,cx,cy,cz,r=list(map(int,input().split()))\n d1=x1-cx\n d2=y1-cy\n d3=z1-cz\n c=(d1*d1)+(d2*d2)+(d3*d3)-(r*r)\n low=0\n high=10**9+1\n while low<(high-10**-6):\n  mid=low+(high-low)*1.0/2;\n  value=vision(mid);\n  if abs(value)<=epi:\n   break;\n  elif value>0:\n   low=mid;\n  else:\n   high=mid;\n print(mid)\n \n", "import sys\nimport os\nimport random\nimport math\n#nonlocal defs\nn,m,p = list(map(int,input().split()))\na = [dict() for _ in range(n)]\nfor _ in range(p):\n i,j = list(map(int,input().split()))\n i -= 1\n j -= 1\n if j not in a[i]:\n  a[i][j] = j+1\n else:\n  a[i][j] += 1\n\ndef chefbm(a,i):\n for (k,v) in a[i].items():\n  if k == m-1:\n   continue\n  if k+1 in a[i]:\n   c = a[i][k+1]\n  else:\n   c = k+1\n  if a[i][k] > c:\n   return -1\n y = a[i][m-1] if m-1 in a[i] else m-1\n x = a[i][0] if 0 in a[i] else 0\n return y-x\n\nfor i in range(n):\n print(chefbm(a,i))", "t=int(input())\nfor i in range(0,t):\n a=int(input())\n r=1\n count=0\n while r<a: \n  r*=2\n  count+=1\n min=count \n r=1\n sum=a\n sumr=1\n count=0\n while sumr<=sum:\n  r*=2\n  sumr+=r\n  sum+=a\n  count+=1\n max=count\n print(max,end=\" \")\n print(min)", "\r\nfor _ in range(int(input())):\r\n    N = int(input())\r\n    p = bin(N)[2:]\r\n    ans  = 0\r\n    cnt  = 0\r\n    p = p[-1::-1]\r\n    for i in p:\r\n        ans += (int(i) * 6 ** cnt)\r\n        cnt+=1\r\n    print(ans)", "for _ in range(int(input())):\n l=list(map(int,input().strip()))\n for j in range(len(l)-1,-1,-1):\n  if l[j]==1:\n   l.pop()\n  else:\n   break\n if l.count(1):\n  time,prev,z,c=0,0,0,0\n  for j in range(len(l)-1,-1,-1):\n   if l[j]==0:\n    z+=1\n    continue\n   if prev!=z:\n    prev=z\n    c+=1\n   time+=c+z\n\n  print(time)\n else:\n  print(0)\n\n", "# cook your dish here\ndef sm (b):\n    v=0;\n    v=b%10\n    c=0\n    while (b!=0):\n        c=b%10\n        b=b//10\n    return(v+c)\nn=int(input())\na=[]\nfor i in range (0,n):\n    no=int(input())\n    a.append(no)\nfor i in range (0,n):\n    print(sm(a[i]))", "tc=int(input())\nfor case in range(tc):\n m,r=list(map(int,input().split()))\n n=m**(r-1)\n a=[i**n for i in range(1,2*n+1)]\n tmp=2*n-1\n for i in range(n):\n  for j in range(tmp-i):\n   a[j]=a[j+1]-a[j]\n print((a[n-1]/m)%1000000007)\n", "n, m, val = list(map(int, input().split()))\n\nfenwick = [0] * (n + 1)\n\ndef add(idx, val):\n while idx <= n:\n  fenwick[idx] += val\n  idx += idx & -idx\n\ndef interval_add(xxx_todo_changeme):\n (right, left, val) = xxx_todo_changeme\n add(right, val)\n add(left + 1, -val)\n\ndef val_at(idx):\n ret = 0\n while idx:\n  ret += fenwick[idx]\n  idx -= idx & -idx\n return ret + val\n\nfor _ in range(m):\n q = input().split()\n if q[0] == 'Q':\n  print(val_at(int(q[1])))\n else:\n  interval_add(list(map(int, q[1:])))\n", "import sys\n\nt = int(sys.stdin.readline().strip())\n\nwhile t:\n\n n, d = list(map(int, sys.stdin.readline().strip().split(\" \")))\n nums = list(map(int, sys.stdin.readline().strip().split(\" \")))\n a = False\n s = 0\n for i in nums:\n  s = s + i\n avg = s//n\n ans = 0\n count = 0\n if s%n != 0:\n  ans = -1\n else:\n  arr = [avg]*n\n  \n  for i in range(len(arr)-d):\n   k = arr[i] - nums[i]\n   if k!=0:\n    arr[i] = arr[i] - k\n    arr[i+d] = arr[i+d] + k\n    count += abs(k)\n  for i in range(len(arr)):\n   if arr[i] != nums[i]:\n    ans = -1\n    a = True\n    break\n\n  if a != True:\n   ans = count\n print(ans)\n t-=1\n", "# cook your dish he# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n\n    n,s = input().split()\n\n    N = int(n) \n    r = N - len(s)\n\n    count = 0\n\n    if N>len(s):\n\n     count = pow(26, r-1,(10**9+7))\n     count*= (26+25*len(s))\n\n     count = count%(10**9 + 7)\n    print(count)\n\n", "# cook your di\nimport math\nn,r=map(int,input().split())\nl=list(map(int,input().split()))\nans=0\nfor i in range(len(l)):\n    ans=math.gcd(ans,abs(l[i]-r))\nprint(ans)", "mod=pow(10,9)+7\nfor tt in range(int(input())):\n n,m=list(map(int,input().split()))\n l=list(map(int,input().split()))\n \n d=[0 for i in range(n+1)]\n for i in l:\n  d[i]+=1\n ans=1 \n for i in range(2,n+1):\n  ans*=pow(d[i-1],d[i])\n  ans%=mod \n print(ans%mod)\n", "for _ in range(int(input())):\n n,k,l=list(map(int,input().split()))\n if k*l<n or (k==1 and n>1):\n  print(-1)\n else:\n  d=1\n  for i in range(1,n+1):\n   if d>k:\n    d=1\n   print(d,end=\" \")\n   d+=1\n  print()", "test=int(input())\nfor i in range(test):\n n=int(input())\n a=list(map(int,input().split()))\n b=[0]*(n+2)\n b[n-1]=1\n for i in range(n-2,-1,-1):\n  if(a[i]*a[i+1]<0):\n   b[i]=b[i+1]+1\n  else:\n   b[i]=1\n for i in range(n):\n  print(b[i], end=' ')\n print() ", "# cook your dish here\nd=[\"saturday\",\"sunday\",\"monday\",\"tuesday\",\"wednesday\",\"thursday\",\"friday\"]\nt=int(input())\nfor i in range(t):\n s,e,l,r=map(str,input().split())\n l,r=int(l),int(r)\n v=(d.index(e)-d.index(s)+8)%7\n c=r+1\n for i in range(l,r+1):\n  if i%7==v:\n   c=i\n   break\n if c>r:\n  print('impossible')\n elif c+7<=r:\n  print('many')\n else:\n  print(c)", "# cook your dish here\n\n\nT=int(input())\nc=0\nwhile(T):\n l=[int(k) for k in input().split()]\n a=l.count(1)\n if(a>=2):\n  c+=1\n \n T-=1\nprint(c)", "n=int(input())\nl=list(map(int,input().split()))[:n]\nprint(max(l),min(l))", "# cook your dish here\nfrom collections import Counter\nfor _ in range(int(input())):\n \n n = int(input())\n a = sorted(map(int,input().split()))\n b = sorted(map(int,input().split()))\n x=Counter(a)\n y=Counter(b)\n z=x+y\n l=[]\n q=min(a[0],b[0])\n for k in list(z.keys()):\n  \n  if z[k]%2==1:\n   print(-1)\n   break\n  else:\n   l.extend([k]*(abs(x[k]-y[k])//2))\n   \n else:\n  l.sort()\n  ans=0\n  \n  if l==[]:\n   print(0)\n  else:\n   for i in range((len(l)//2)):\n    \n    ans+=min(l[i],2*q)\n    \n   print(ans)\n   \n   \n   \n   \n   \n \n", "def ham(x):\n w = 0\n while x:\n  w += 1\n  x &= x-1\n return w\n\n\ndef num_shuff(w_a, w_b, c):\n #known = {}\n if w_a < 0 or w_b < 0:\n  return 0\n if c == 0:\n  if w_a == 0 and w_b == 0:\n   return 1\n  else: \n   return 0\n if (w_a, w_b, c) in known:\n  return known[(w_a, w_b, c)]\n c0 = c % 2\n c1 = c >> 1\n res = 0 \n if c0 == 0:\n  res += num_shuff(w_a, w_b , c1 ) \n  res += num_shuff(w_a - 1, w_b - 1, c1 - 1 ) \n else:\n  res += num_shuff(w_a - 1, w_b, c1 )\n  res += num_shuff(w_a, w_b - 1, c1 ) \n known[(w_a, w_b, c)] = res\n return res\n\n\nt = int(input())\nknown = {}\nfor _ in range(t):\n a, b, c = list(map(int, input().split()))\n print(num_shuff(ham(a), ham(b), c))\n", "for _ in range(int(input())):\n n = int(input())\n arr =[0]*n\n for i in range(n):\n  s,p,v = list(map(int,input().split()))\n\n  arr[i] = (p//(s+1))*v\n print(max(arr)) # cook your dish here\n", "for _ in range(int(input())):\n N, M = map(int, input().split())\n arr = list(map(int, input().split()))\n arr1 = sorted(arr, reverse=True)\n lst = []\n for i in range(N):\n  for j in range(i, N):\n   x = arr[i:j+1]\n   x.sort(reverse=True)\n   x.extend([0]*(N-len(x)))\n   lst.append(x)\n lst.sort(reverse=True)\n  \n for j in range(M):\n  p = int(input())-1\n  print(lst[p][0])", "from fractions import gcd\nfor testCases in range(eval(input())):\n n = eval(input())\n if n == 1:\n  print('1')\n elif n == 2:\n  print('2')\n elif n == 3:\n  print('6')\n else:\n  c = n*(n-1)\n  k = n - 2\n  while True:\n   if gcd(k,n-1) == 1 and gcd(k,n) == 1:\n    break\n   k -= 1\n  d = (n-1)*(n - 2)\n  k1 = n - 3\n  while True:\n   if gcd(k1,n-1) == 1 and gcd(k1,n-2) == 1:\n    break\n   k1 -= 1\n  print(max(c*k,d*k1))", "try:\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.sort()\n    ans=[]\n    for i in range(n-2):\n        a=[]\n        if  l[i]+l[i+1]>l[i+2]:\n            a.append(l[i])\n            a.append(l[i+1])\n            a.append(l[i+2])\n            ans.append(a)\n    if len(ans)!=0:\n        s=[]\n        for j in ans:\n            s.append(sum(j))\n        m=s.index(max(s))\n        print(\"YES\")\n        for i in reversed(ans[m]):\n            print(i,end=' ')\n    else:\n        print(\"NO\")\nexcept:\n    pass", "# cook your dish here\nt=int(input())\n\nwhile(t>0):\n n=int(input())\n str1=str(input()).split(\" \")\n str1=list(map(int,str1))\n output=\"No\"\n totalCount=0\n count=0\n # print(str1)\n for i in str1:\n  if i==0:\n   count+=1\n   totalCount+=1\n  \n  elif i==1 and count>0:\n   # print(count)\n   if(count%2==1 and totalCount!=1):\n    output=\"Yes\"\n    break\n   count=0\n   \n if(str1[-1]==0 and count%2==1 and totalCount!=1):\n  output=\"Yes\"\n  \n if totalCount==1:\n  output=\"Yes\"\n print(output)\n t=t-1\n  \n", "# cook your dish here\nprime = [2,3,5,7,11,13,17]\nedges = [(0,3), (0,1), (1,2), (1,4), (2,5), (3,4), (3,6), (4,5), (4,7), (5,8), (6,7), (7,8)]\n\nx = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\navail = {x: 0}\nqueue = [x]\nwhile queue:\n    current = queue.pop(0)\n    for e in edges:\n        if current[e[0]] + current[e[1]] in prime:\n            nxt = list(current)\n            nxt[e[0]], nxt[e[1]] = nxt[e[1]], nxt[e[0]]\n            nxt = tuple(nxt)\n            if nxt not in avail:\n                avail[nxt] = avail[current] + 1 \n                queue.append(nxt)\n\nfor _ in range(int(input())):\n    input()\n    grid = ()\n    for i in range(3):\n        grid += tuple(map(int, input().split()))\n    print(avail[grid] if grid in avail else -1)", "for i in range(int(input())):\r\n    n=int(input())\r\n    lst=list(map(int,input().split()))\r\n    x=0\r\n    for j in range(n):\r\n        x^=lst[j]\r\n        \r\n\r\n\r\n    print(x)", "for _ in range(int(input())):\n n=int(input())\n l=list(map(int,input().split()))\n k,c=[],0\n for i in l:\n  if i%2==0:\n   c+=1\n  k.append(c)\n q=int(input())\n for i in range(q):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  if a==0:\n   if k[b]>0:\n    print(\"EVEN\")\n   else:\n    print(\"ODD\")\n  else:\n   a-=1\n   x=k[b]-k[a]\n   if x>0:\n    print(\"EVEN\")\n   else:\n    print(\"ODD\")", "import math\r\nfor i in range(int(input().strip())):\r\n\ta, b = [ int(i) for i in input().strip().split(' ')]\r\n\tif math.gcd(a,b)==1:\r\n\t\tprint('YES')\r\n\telse:\r\n\t\tprint('NO')\r\n", "# cook your dish here\nfor _ in range(int(input())):\n    n,m = list(map(int,input().split()))\n    colors = [0]*41; cost = [0]*41\n    color = 0\n    for i in range(n):\n        cc,pp = list(map(int,input().split()))\n        colors[cc] += 1\n        cost[cc] += pp\n    for i in colors:\n        if i>0: color += 1\n    dp2 = [[0]*41 for i in range(color+1)]\n    dp2[0] = [1]*41\n    for i in range(1,color+1):\n        for j in range(1,41):\n            dp2[i][j] = dp2[i][j-1]+dp2[i-1][j-1]*(2**colors[j]-1)\n    dp1 = [[0]*41 for i in range(color+1)]\n    for i in range(1,color+1):\n        for j in range(1,41):\n            dp1[i][j] = dp1[i][j-1]+dp1[i-1][j-1]*(2**colors[j]-1)+dp2[i-1][j-1]*cost[j]*(2**(colors[j]-1))\n    num=den=0\n    for i in range(m,color+1):\n        num += dp1[i][40]\n        den += dp2[i][40]\n    print(num/den)", "def main():\n        while True:\n                [n, m] = [int(i) for i in input().split()]\n                if n == m and n == 0:\n                        break\n                cache = {}\n                for i in range(n):\n                        dna = input().rstrip('\\n')\n                        if dna in cache:\n                                cache[dna] = 1 + cache[dna]\n                        else:\n                                cache[dna] = 1\n                c = [0 for i in range(n + 1)]\n                for dna in cache:\n                        c[cache[dna]] = 1 + c[cache[dna]]\n                for i in range(1, n + 1):\n                        print(c[i])\n \ndef __starting_point():\n        main()\n__starting_point()", "# cook your dish here\n\n# cook your dish here\n\n \n\nt = int(input())\nwhile t:\n t-=1\n c=0\n ar=[int(i) for i in input().strip().split()]\n for i in range(1,16):\n  b=bin(i)[2:].zfill(4)\n  s=0\n  for i in range(4):\n   if b[i]=='1':\n    s+=ar[i]\n  \n  if(s==0):\n   c=1\n   break\n \n print(\"Yes\" if c==1 else \"No\")\n", "#!/usr/bin/python\nt = int(input())\nwhile t :\n n= int(input())\n k =(2**(n-2))+1\n print(k)\n t = t-1 ", "# This is not my code, it's Snehasish Karmakar's.  Refer to http://www.codechef\u00a0\u00a0\u00a0\u00a0.com/viewsolution/7153774\n# for original version.\n# Submitting it to try and work out if it can be sped up.\n\ndef compute_nCr(n,r) :\n C[0][0]=1\n for i in range(1,n+1) :\n#       print \"i\",i\n  C[i][0]=1\n  for j in range(1,min(i,r)+1) :\n   if i!=j :\n    C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD\n   else :\n    C[i][j]=1\n  \n \ndef solve(n,m) :\n store=[C[m+i-1][i] for i in range(m+1)]\n \n for i in range(1,n+1) :\n  s=1\n  for j in range(1,m+1) :\n   s=(s+store[j])%MOD\n   store[j]=(s*C[m+j-1][j])%MOD\n  #   print \"a[%d][%d]=%d\"%(i,j,s)\n \n return s \n \nMOD=1000000000\nLIMIT=2000\n \nC=[[0] * (LIMIT + 1) for _ in range(2*LIMIT+1)]\ncompute_nCr(2*LIMIT,LIMIT)\nt=int(input())\n \nwhile t :\n n,m=list(map(int,input().split()))\n print(solve(n,m))\n t-=1", "# cook your dish here\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    st=input()\n    a=st.count('a')\n    b=st.count('b')\n    c=0 \n    ca=0\n    for i in range(n):\n        if st[i]=='a':\n            ca+=1\n        if st[i]=='b':\n            c+=ca\n    \n    print(a*b*(k*(k-1)//2)+c*k)", "for i in range(int(input())):\r\n  x=int(input())\r\n  y=input().split()\r\n  if '0' in y:\r\n    print(100*(x-y.index('0'))+y.count('0')*1000)\r\n  else:\r\n    print(0)  ", "n=int(input())\r\na=list(map(int,input().strip().split()))\r\na.sort()\r\ns=0\r\nfor i in range(len(a)):\r\n    s+=a[i]*(i-(len(a)-1-i))\r\n    \r\nprint(s)", "# cook your dish here\ntry:\n import string \n alphabets=string.ascii_lowercase\n test=int(input())\n #ans=[]\n\n def solve():\n  \n  ans=[]\n  n=int(input())\n  string1=[]\n  string2=[]\n  present=[None]*26\n  \n  string1=list(input())\n  string2=list(input())\n\n  for i in range(n):\n   if string1[i]<string2[i]:\n    print(-1)\n    return\n  \n  for i in range(n):\n   present[ord(string1[i])-ord('a')]=1\n\n  for i in range(n):\n   if (present[ord(string2[i])-ord('a')]!=1):\n    print(-1)\n    return\n\n  for alpha in alphabets[::-1]:\n   index=[]\n   \n   for i in range(n):\n    if(string1[i]!=alpha and string2[i]==alpha):\n     index.append(i)\n\n  \n   if index:\n    for i in range(n):\n     if string1[i]==alpha:\n      index.append(i)\n\n\n   if index:\n    ans.append(index)\n\n   for i in range(len(index)):\n    idx=index[i]\n    string1[idx]=alpha \n\n\n  print(len(ans))\n  for i in ans:\n   i.sort()\n   print(len(i),*i)\n  #for i in ans:\n   #print(\" \".join(map(str,i)))\n\n for _ in range(test):\n  solve()\n\n\n\n \nexcept:\n pass", "for _ in range(int(input())):\n n,p=map(int,input().split())\n l=[int(i) for i in input().split()]\n pre=[0]*(n+1)\n for i in range(1,n+1):\n  pre[i]=pre[i-1]+l[i-1]\n  pre[i]%=p \n cmaxi=0 \n maxi=0 \n for i in range(n):\n  for j in range(i,n):\n   curr=(pre[j+1]-pre[i]+p)%p \n   #print(curr)\n   if curr>maxi:\n    maxi=curr \n    cmaxi=1 \n   elif curr==maxi:\n    cmaxi+=1 \n print(maxi,cmaxi)", "def fact(n):\n if n<2:\n  return 1\n return n * fact(n-1)\n \ndef ncr(n, r):\n return fact(n)// (fact(r)*fact(n-r))\n \nt=int(input())\n\nfor _ in range(t):\n n, k = list(map(int, input().split()))\n a = list(map(int, input().split()))\n a.sort()\n count_z = a.count(a[k-1])\n count_z_seq = a[:k].count(a[k-1])\n \n print(ncr(count_z, count_z_seq))\n", "import sys\n\ndef main():\n s=sys.stdin.readline\n n, m = list(map(int, s().split()))\n nums={}\n for i in range(1, n+1):\n  nums[i]=list(map(int, s().split()))\n cases=int(s())\n for case in range(cases):\n  px, py, qx, qy = list(map(int, s().split()))\n  ans=[]\n  for i in range(px, qx+1):\n   for j in range(py-1, qy):\n    ans.append(nums[i][j])\n  print(sum(ans))\n\ndef __starting_point():\n main()\n__starting_point()", "t = int(input(\"\"))\nwhile(t):\n \n a ,b = input().split(\" \")\n a = int(a)\n b = int(b)\n min1 = min(a,b)\n max1 =max(a,b)\n if(min1==1):\n  if(max1==2):\n   print(\"Yes\")\n  else:\n   print(\"No\")\n else:\n  if(max1%2==0 or min1%2 ==0):\n   print(\"Yes\")\n  else:\n   print(\"No\")\n t -=1 ", "for t in range(eval(input())):\n n = eval(input())\n l = list(map(int, input().split()))\n r = list(map(int, input().split()))\n lr = []\n for i in range(n):\n  lr.append(l[i]* r[i])\n maxim = max(lr)\n index = -1\n maxR = -1\n for i, value in enumerate(lr):\n  if maxim == value :\n   if maxR < r[i]:\n    maxR = r[i]\n    index = i\n\n print(index+1)", "def tenn():\n t=eval(input())\n for i in range(t):\n  a=eval(input())\n  r=a/10\n  t=(r*(r+1))/2\n  print(t*10)\ntenn()\n", "T = int(input())\nans = []\n\nfor _ in range(T):\n N = int(input())\n W = [int(i) for i in input().split()]\n\n for i in range(N):\n  W[i] += i\n\n ans.append(max(W))\n\nfor i in ans:\n print(i)\n", "def solve(n):\r\n    if n == 1:\r\n        print('*')\r\n        return\r\n    s = 0\r\n    ms = n//2\r\n    o = 1\r\n    for i in range(n):\r\n        if s==ms:\r\n            o = -1\r\n        x = '*'\r\n        x = x.rjust(1+s)\r\n        s+=o\r\n        print(x)\r\n\r\ndef main():\r\n    t = int(input())\r\n    for i in range(t):\r\n        n = int(input())\r\n        solve(n)\r\nmain()\r\n\r\n", "t = int(input())\r\ndecimal = [1]\r\nmod = 10**9 + 7\r\nfor i in range(10**5 + 1):\r\n    decimal.append((decimal[-1]*10) % mod)\r\n\r\n\r\ndef num(n):\r\n    ans = 0\r\n    length = len(n)\r\n    for i in range(0, length):\r\n        ans += (int(n[i])*decimal[length - i - 1])%mod\r\n\r\n    return ans\r\n\r\n\r\nfor i in range(0, t):\r\n    n = input()\r\n    length = len(n)\r\n    p = (10 ** length)%mod\r\n    p1 = (10 ** (length-1))%mod\r\n    mul = [1]\r\n    for j in range(0, length-1):\r\n        mul.append((mul[-1]*p)%mod)\r\n    value = num(n)\r\n\r\n    ans = 0\r\n    for j in range(length-1, -1, -1):\r\n        temp = (value * mul[j])%mod\r\n        ans += temp\r\n        value = value - int(n[length - 1 - j]) * p1\r\n        value = (value * 10 + int(n[length - 1 - j])) % mod\r\n    print(ans%mod)", "t=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    b=1\r\n    if n%2:\r\n        c=n-2\r\n        for j in range(n//2):\r\n            print(\" \"*j+str(b) +\" \"*c+ str(b))\r\n            b+=1\r\n            c-=2\r\n        print(\" \"*(n//2)+str(b)+\" \"*(n//2))\r\n        b+=1\r\n        c=1\r\n        for j in range(n//2):\r\n            print(\" \"*(n//2-j-1)+str(b)+\" \"*c+ str(b))\r\n            b+=1\r\n            c+=2\r\n    else:\r\n        c=n-2\r\n        for j in range(n//2):\r\n            print(\" \"*j+str(b)+\" \"*c+str(b))\r\n            b+=1\r\n            c-=2\r\n        c=0\r\n        for j in range(n//2):\r\n            print(\" \"*(n//2-j-1)+str(b) +\" \"*c+ str(b))\r\n            b+=1\r\n            c+=2\r\n        \r\n    \r\n        \r\n    \r\n                \r\n    \r\n", "# cook your dish here\nt=int(input())\nwhile t:\n n=int(input())\n l=[]\n for i in range(n):\n  l1=list(map(int,input().split()))\n  l1=sorted(l1)\n  l.append(l1)\n #print(l)\n count=l[n-1][n-1]\n m=l[n-1][n-1]\n c=0\n k=0\n for i in range(n-2,-1,-1):\n  for j in range(n-1,-1,-1):\n   if(l[i][j]<m):\n    #print(count)\n    count+=l[i][j]\n    m=l[i][j]\n    c+=1\n    break\n  if(c==0):\n   print(-1)\n   k+=1\n   break\n  else:\n   c-=1\n if(k==0):\n  print(count)\n t-=1", "tweets,clicks = list(map(int,input().split()))\nopenl = []\n\nfor i in range(clicks):\n action = input() .upper()\n if(action == \"CLOSEALL\"):\n  openl = []\n  print(0)\n else:\n  if(action not in openl ):\n   openl.append(action)\n   print(len(openl))\n  elif(action in openl):\n   openl.remove(action)\n   print(len(openl))", "import math\n\nfor _ in range(int(input())):\n a,b = map(int,input().split())\n _gcd = math.gcd(a,b)\n tmp = (a*b)//(_gcd*_gcd)\n print(tmp)", "import sys\nimport math\nfrom collections import defaultdict,Counter\n\n# input=sys.stdin.readline\n# def print(x):\n#     sys.stdout.write(str(x)+\"\\n\")\n\n# sys.stdout=open(\"CP3/output.txt\",'w')\n# sys.stdin=open(\"CP3/input.txt\",'r')\n\n# mod=pow(10,9)+7\nk,a,b=list(map(int,input().split()))\nif b<=a+2 or k<=a:\n\tans=1+k\nelse:\n\tk-=a-1\n\tans=a+k//2*(b-a)\n\tif k&1:\n\t\tans+=1\nprint(ans)\n", "t=int(input())\r\nfor s in range(0,t):\r\n    n=int(input())\r\n    l=list(map(int,input().strip().split()))\r\n    a=len(l)\r\n    i=0\r\n    max=-999999\r\n    while(i<a):\r\n        sum=0\r\n        if(i==(a-1)):\r\n            sum=l[i]+l[0]+l[1]\r\n        elif(i==(a-2)):\r\n            sum=l[i]+l[i+1]+l[0]\r\n        else:\r\n            sum=l[i]+l[i+1]+l[i+2]\r\n        if(sum>max):\r\n            max=sum\r\n        i=i+1\r\n    print(max)", "from fractions import gcd as G\nn=eval(input())\nflag=1\narr=list(map(int,input().split()))\na=max(arr)\nbest = 0\nI_I = 0\nwhile I_I<n:\n if arr[I_I]==a:\n  k=I_I\n  while k<n and arr[k]==a:\n   k+=1\n  best = max(best, k-I_I)\n  I_I = k\n else: I_I+=1\n\nprint(best)\n\n", "# cook your dish here\nimport math \nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    newa=list(set(a))\n    if len(newa)==1:\n        print(newa[0]*2)\n    elif len(newa)==2:\n        print(sum(newa))\n    else:\n        newa.sort()\n        m1=newa.pop()\n        m2=newa.pop()\n        gcd=newa[0]\n        for i in range(1,len(newa)):\n            gcd=math.gcd(gcd,newa[i])\n            if gcd==1:\n                break\n        s1=math.gcd(gcd,m1)\n        s2=math.gcd(gcd,m2)\n        print(max(s1+m2,s2+m1))\n#import math as m\n# for _ in range(int(input())):\n#     length = int(input())\n#     arr = list(map(int,input().split()))\n#     if (length==2):\n#         print(arr[0]+arr[1])\n#     else:\n#         tmparr=list(set(arr))\n#         tmparr.sort()\n#         fmax =tmparr.pop()\n#         smax=tmparr.pop()\n#         p = len(tmparr)\n#         if (p==0):\n#             print(fmax+smax)\n#         else: \n#             result = tmparr[0]\n#             for i in range(1,p):\n#                 result = m.gcd(tmparr[i],result)\n#             gcd0 = result\n#             gcdH = m.gcd(gcd0,fmax)\n#             gcdSH = m.gcd(gcd0,smax)\n#             case11 = fmax+gcdSH\n#             case22 = smax+gcdH\n#             print(max(case11,case22))\n", "for _ in range(int(input())):\r\n    n,k = map(int,input().split(\" \"))\r\n    print((2*k + 2*(k-1)*(n-1))/k)", "from sys import*\r\ninput=stdin.readline\r\nt=int(input())\r\nfor _ in range(t):\r\n    k=int(input())\r\n    l=[0 for _ in range(k)]\r\n    for i in range(1,k):\r\n        if l[i-1]==0:\r\n            l[i]=1\r\n        else:\r\n            l[i]=0\r\n    ans=\"\".join([str(x) for x in l])\r\n    l1=[1 for _ in range(k)]\r\n    for i in range(1,k):\r\n        if l1[i-1]==1:\r\n            l1[i]=0\r\n        else:\r\n            l1[i]=1\r\n    ans1=\"\".join([str(x) for x in l1])\r\n    for i in range(k):\r\n        if (i%2)==0:\r\n            print(ans)\r\n        else:\r\n            print(ans1)\r\n", "# cook your dish here\ntc = int(input())\nfor t in range(tc):\n n = int(input())\n tr=['']*n\n nr=['']*n\n ck=False\n for i in range(n):\n  name = input()\n  tim = int(input())\n  if not ck:\n   ck=True\n   tr[0]=tim\n   nr[0]=name\n  else:\n   tr[i]=tim\n   nr[i]=name\n   for j in range(i+1):\n    key=tr[j]\n    kname=nr[j]\n    k=j-1\n    while k>=0 and tr[k]>key:\n     tr[k+1]=tr[k]\n     nr[k+1]=nr[k]\n     k = k - 1\n    tr[k+1]=key\n    nr[k+1]=kname\n print(*nr,sep='\\n')", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    s=set(l)\n    if(len(l)==len(s)):\n        print(\"prekrasnyy\")\n    else:\n        print(\"ne krasivo\")", "# cook your dish here\nfor t in range(int(input())):\n    st=input()\n    x=''.join(reversed(st))\n    print(x)\n", "# cook your dish here\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    mp = defaultdict(lambda:0)\n    sat = set()\n    for _ in range(int(input())):\n        w,s = input().split()\n        mp[w,s]+=1\n        sat.add(w)\n    ans = 0\n    for i in sat:\n        ans += max(mp[i,'0'],mp[i,'1'])\n    print(ans)\n        \n        ", "testcases = int(input())\n\nfor i in range(testcases):\n n = int(input())\n my = list(map(int,input().split()))\n opp = list(map(int,input().split()))\n \n my.sort(reverse = True)\n opp.sort(reverse = True)\n \n j = 0\n k = 0\n while(k < n):\n  if(my[j] > opp[k]):\n   j += 1\n  k += 1\n\n print(j)", "# cook your dish here\nfor _ in range(int(input())):\n\tn = int(input())\n\tc = list(bin(n)[2:])\n\tfor i in range(1,len(c)):\n\t\tc[i] = \"0\"\n\tc = ''.join(c)\n\tprint(int(c,2))\n", "import math\r\nimport os\r\nimport random\r\nimport re\r\nimport sys\r\n\r\n\r\nr = 100000\r\nprev = 1\r\ns = set()\r\nfor i in range(1, r+1):\r\n    now = i ^ prev\r\n    s.add(now)\r\n    prev = now\r\ns = list(s)\r\nt = int(input())\r\nwhile t > 0:\r\n    t -= 1\r\n    n, k = list(map(int, input().split()))\r\n\r\n    if n > 3:\r\n        if n % 2 == 0:\r\n            size = (n//2) + 2\r\n        else:\r\n            size = ((n-1)//2) + 2\r\n    else:\r\n        size = n\r\n    if size - k >= 0:\r\n        print(s[size-k])\r\n    else:\r\n        print(-1)\r\n", "# cook your dish here\ndef MinimumHours(n,h,a):\n a.sort()\n j=0\n mie=2\n mio=1\n s1=0\n s2=0\n c1=0\n c2=0\n while 1:\n  for i in a[-1:-(n+1):-1]:\n   if i%mie==0:\n    s1+=(i//mie)\n   else:\n    s1+=(i//mie)+1\n   if i%mio==0:\n    s2+=(i//mio)\n   else:\n    s2+=(i//mio)+1\n   if s1>h :\n    c1=1\n  \n   if s2>h :\n    c2=1\n   if c1==c2==1:\n    break\n  \n  if c1==c2==1:\n   c1=0\n   s1=0\n   c2=0\n   s2=0\n   mie+=2\n   mio+=2\n  else:\n   if c2==c1==0:\n    return min(mie,mio)\n   if c1==0:\n    return mie\n   return mio \n \np=[]\nfor i in range(int(input())):\n n,h=input().split()\n p.append(MinimumHours(int(n),int(h),[int(i) for i in input().split()]))\n \nfor i in p:\n print(i)\n", "#!/usr/bin/env python\n\nF = [1,1]\ndef fibo():\n for i in range(500):\n  F.append(F[-2] + F[-1])\n\ndef main():\n fibo()\n #print len(str(F[-1]))\n #print len(str(10**100))\n while True:\n  try:\n   A, B = list(map(int, input().strip().split()[:2]))\n   if A == 0 and B == 0: break\n   print(len([x for x in F if x >= A and x <= B]))\n  except:\n   break\n\nmain()\n\n", "import sys\n\nMOD = 10**9+7\nfor __ in range(eval(input())) :\n n , m , k = list(map(int,sys.stdin.readline().split()))\n lists = list(map(int,sys.stdin.readline().split()))\n ans = 0\n for i in lists :\n  msd = i/k\n  if msd > m :\n   jaddu = i-(m*k)\n  else :\n   jaddu = i%k\n  ans += jaddu%MOD\n print(ans%MOD)\n", "for j in range(int(input())):\n n,k = list(map(int, input().split()))\n s = (n*(n+1))/2\n i = k\n while i<=n:\n  s -= i\n  i *= k\n print(\"Case #%d: %d\" % (j+1, s))", "for _ in range(int(input())):\n n = int(input())\n if(n==1):\n  print(0)\n else:\n  print(pow(2,n-1,10**9+7)-2)", "for _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n if sum(a)!=n or max(a)==n:\n  print(-1)\n  continue\n else:\n  rg=[]\n  for i in range(n):\n   if a[i]>0:\n    rg.append([i,a[i]])\n  new=[0 for _ in range(n)]\n  new[rg[0][0]]=rg[-1][0]+1\n  rg[-1][1]-=1\n  for i in range(1,len(rg)):\n   new[rg[i][0]]=rg[i-1][0]+1\n   rg[i-1][1]-=1\n  j=0 \n  i=0\n  while i<=n-1:\n   if new[i]==0:\n    if rg[j][1]>0:\n     new[i]=rg[j][0]+1\n     rg[j][1]-=1\n     i+=1\n    else:\n     j+=1\n    if rg[j][1]==0:\n     j+=1\n   else:\n    i+=1\n\n\n   \n  print(*new)\n", "# cook your dish here\nfor i in range(int(input())):\n s,w1,w2,w3=map(int,input().split())\n if s>= w1+w2+w3:\n  print(1)\n else:\n  if s>= w1+w2:\n   if s>=w3:\n    print(2)\n   else:\n    print(1+w3//s)\n  elif s>=w2+w3:\n   if s>=w1:\n    print(2)\n   else:\n    print(1+w1//s)\n  else:\n   print(w1//s+w2//s+w3//s)", "from bisect import insort\nfrom math import ceil\nfor _ in range(int(input())):\n n,k=list(map(int,input().split( )))\n array=list(map(int,input().split( )))\n ans=0\n index=[]\n for i in range(1,n+1):\n  index.append(ceil(k/(ceil(k/i))))\n for i in range(n):\n  count=[0]*(2001)\n  temp=[]\n  for j in range(i,n):\n   count[array[j]]+=1\n   insort(temp,array[j])\n   #m=ceil(k/(j-i+1)) precalculate thes values in index array\n   #t=ceil(k/m)\n   x=temp[index[j-i]-1]\n   f=count[x]\n   if count[f]:\n    ans+=1\n print(ans)\n", "x = input()\ny = input()\nz = x.find(y)\nif z == -1 :\n print('N')\nelse :\n print('Y')", "for _ in range(int(input())):\n bi = input().strip()\n dp = [0 if i < 2 else len(bi) for i in range(6)]\n for c in bi:\n  if c == '1':\n   dp[3] = min(dp[3], dp[0])\n   dp[0] += 1\n   dp[5] = min(dp[5], dp[2])\n   dp[2] += 1\n   dp[4] += 1\n  else:\n   dp[2] = min(dp[2], dp[1])\n   dp[1] += 1\n   dp[4] = min(dp[4], dp[3])\n   dp[3] += 1\n   dp[5] += 1\n print(min(dp))\n   \n", "# your code goes here\n# cook your dish here\nfrom collections import Counter\nt=int(input())\nfor x in range(t):\n    inp = list(map(int,input().split()))\n    r=inp[0]\n    c=inp[1]\n    listo=[]\n    listb=set()\n    pair=0\n    for i in range(r):\n        \n        string=input()\n        for j in range(len(string)):\n            if(string[j]=='U'):\n                listo.append([i,j,1])\n            elif(string[j]=='D'):\n                listo.append([i,j,2])\n            elif(string[j]=='L'):\n                listo.append([i,j,3])\n            elif(string[j]=='R'):\n                listo.append([i,j,4])\n            elif(string[j]=='#'):\n                listb.add((i,j))\n    \n                \n    for y in range(max(r,c)):\n        nants=Counter()\n        for i in range(len(listo)):\n            if(listo[i][2]!=5):\n                nants[tuple(listo[i][:-1])]+=1\n        for key in nants:\n            pair+=(nants[key]*(nants[key]-1))//2\n        \n        for ant in listo:\n            if(ant[2]==1):\n                 ant[0]-=1\n            elif(ant[2]==2):\n                ant[0]+=1\n            elif(ant[2]==3):\n                ant[1]-=1\n            elif(ant[2]==4):\n                ant[1]+=1\n            if(tuple(ant[:-1])) in listb:\n                ant[2]=5\n            elif(ant[0]<0) or ant[0]>=r:\n                ant[2]=5\n            elif ant[1]<0 or ant[1]>=c:\n                ant[2]=5\n    print(pair)\n            \n            \n             \n    \n        \n                \n        \n    \n", "for _ in range(int(input())):\n N, A, B, K = map(int, input().split())\n cnt = 0\n\n for i in range(1, N+1):\n  a, b = i % A, i % B\n  if a == 0 and b != 0:\n   cnt += 1\n  elif a != 0 and b == 0:\n   cnt += 1\n\n  if cnt >= K:\n   print(\"Win\")\n   break\n else:\n  print(\"Lose\")", "G = {0:[1,4,5],1:[0,2,6],2:[1,3,7],3:[2,4,8],4:[3,0,9],5:[0,7,8],6:[1,8,9],7:[2,5,9],8:[3,5,6],9:[4,6,7]}\nL = {0:'A',1:'B',2:'C',3:'D',4:'E',5:'A',6:'B',7:'C',8:'D',9:'E'}\n\ndef Check(S):\n    result = ''\n    possibleStart = [k for k in list(L.keys()) if L[k] == S[0]]\n    isBreak = False\n    for c in S:\n        found = False\n        if result=='':\n            result = result+str(possibleStart[0])\n            last = possibleStart[0]\n            found = True\n        else:\n            for k in G[last]:\n                if L[k] == c:\n                    result = result+str(k)\n                    last = k\n                    found = True\n        if not found:\n            isBreak = True\n            break\n        #print result\n    if not isBreak:\n        return result\n    result = ''\n    #print 'nextstart'\n    for c in S:\n        found = False\n        if result=='':\n            result = result+str(possibleStart[1])\n            last = possibleStart[1]\n            found = True\n        else:\n            for k in G[last]:\n                if L[k] == c:\n                    result = result+str(k)\n                    last = k\n                    found = True\n        if not found:\n            return str(-1)\n        #print result\n    return result       \n\n\nT = int(input())\nwhile T > 0:\n    T = T - 1\n    S = input()\n    R = Check(S)\n    print(R)\n", "for i in range(int(input())):\n n, a, b = [int(c) for c in input().split()]\n impossible = 0\n arr = [abs(int(x)) for x in input().split()]\n\n if a in arr or -a in arr or b in arr or -b in arr:\n  print(1)\n  continue\n\n if a == 0 or b == 0:\n  print(2)\n  continue\n if a == -b:\n  for move1 in arr:\n   a_left = abs(a - move1)\n   b_left = abs(b - move1)\n   if a_left in arr or b_left in arr:\n    continue\n   else:\n    impossible = 1 \n    break\n  else:\n   print(2)\n   continue\n\n print(0)\n", "T = int(input())\nwhile(T):\n    nx =[int(x) for x in input().split()]\n    A=[int(x) for x in input().split()]\n    if max(A)-min(A)<nx[1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    T =T-1", "def solve(x,y,k,n):\n val=abs(x-y)\n if val%k==0:\n  if (val/k)%2==0:\n   print('Yes')\n  else:\n   print('No')\n else:\n  print('No')\nt=int(input())\nfor i in range(t):\n x,y,k,n=map(int,input().split())\n solve(x,y,k,n)", "# cook your dish here\nfor _ in range(int(input())):\n M, L = map(int, input().split())\n g = list(map(int, input().split()))\n g.insert(0,0)\n b = 0\n for i in range(1, M+1):\n  b += (g[i] - g[i-1] - 1) // L\n print(b)", "def sumOfLastDig(n, m) :  \r\n    sum = 0;  \r\n    k = n // m; \r\n    arr = [0] * 10;  \r\n    for i in range(10) : \r\n        arr[i] = m * (i + 1) % 10;  \r\n        sum += arr[i];  \r\n    rem = k % 10;  \r\n    ans = (k // 10) * sum;  \r\n    for i in range(rem) : \r\n        ans += arr[i];  \r\n    return ans;  \r\n\r\ndef __starting_point():  \r\n    for i in range(int(input())):\r\n        m,n = list(map(int,input().strip().split()))\r\n        print((sumOfLastDig(m,n)));  \r\n        \r\n\n__starting_point()", "try:\n    t=int(input())\n    while t!=0:\n        r=int(input())\n        area=3.14*r*r\n        print(area)\n        t=t-1\nexcept:\n    pass", "# cook your dish here\nfor i in range(int(input())):\n n=int(input())\n l=[int(x) for x in input().split()]\n count=0\n sumv=0\n for i in range(n):\n  count+=1\n  if i!=n-1 and l[i]>l[i+1]:\n   sumv+=int(((count+1)*count)/2)\n   count=0\n sumv+=int(((count+1)*count)/2)\n print(sumv)", "a=int(input())\r\n# list(map(int,input().split()))\r\nfor _ in range(a):\r\n  b=input()\r\n  b1=set(b)\r\n  c=input()\r\n  s=0\r\n  for i in b1:\r\n    if i in c:\r\n      s+=min(b.count(i),c.count(i))\r\n  print(s)", "for _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n d={}\n for i in a:\n  d[i]=d.get(i,0)+1\n if len(d)>2:\n  print(-1)\n elif len(d)==1:\n  for i in d:\n   if i==n-1and d[i]==n:\n    print(0)\n   elif i==0 and d[i]==n:\n    print(n)\n   else:\n    print(-1)\n else:\n  k=max(d.keys())\n  if d.get(k-1,0)==k and d[k]==n-k:\n   print(n-k)\n  else:\n   print(-1)", "T = int(input())\n\nfor testcase in range(T):\n    X, K = list(map(int, input().split(\" \")))\n\n    def get_factors(N):\n        res = []\n        for i in range(2, N+1):\n            if N % i == 0:\n                res.append(i)\n        return res\n    \n    x_factors = get_factors(X)\n    k_factors = get_factors(K)\n    \n    power_sum = sum([x ** K for x in x_factors])\n    factor_sum = sum([k * X for k in k_factors])\n    \n    print(power_sum, factor_sum)\n", "from sys import stdin\nn = int(stdin.readline())\nfor _ in range(n):\n    n1 = int(stdin.readline())\n    b = bin(n1)[2:]\n    print(b.count('0'))", "import bisect\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    lst = list(map(int, input().split()))\r\n    m = int(input())\r\n    for i in range(n):\r\n        mod = lst[i]%3\r\n        lst[i] = lst[i]+mod\r\n    lst = sorted(lst)\r\n    id = bisect.bisect(lst,m)\r\n    if id==0:\r\n        if lst[0]>m:\r\n            g = lst[0]\r\n        else:\r\n            g = lst[1]\r\n        s = -1\r\n    elif id==n:\r\n        if lst[n-1]<m:\r\n            s = lst[n-1]\r\n        else:\r\n            s = lst[n-2]\r\n        g = -1\r\n    else:\r\n        s = lst[id-1]\r\n        if s==m:\r\n            if id-2<0:\r\n                s = -1\r\n            else:\r\n                s = lst[id-2]\r\n        g = lst[id]\r\n        if g==m:\r\n            if id+1>n-1:\r\n                g = -1\r\n            else:\r\n                g = lst[id+1]\r\n    print(s,g)", "for _ in range(int(input())):\n n = int(input())\n a= list(map(int,input().split()))\n b = list(map(int,input().split()))\n fl =1\n if(a[0]!=0 or b[n-1]!=0 or a[n-1]!=b[0]):\n  fl=0\n s =b[0]\n if(fl):\n  for i in range(n):\n   if(i!=0 and i!= n-1):\n    if(a[i]==0 or b[i]==0):\n     fl=0\n     break\n\n\n   if(a[i]+b[i] < s):\n    fl=0\n    break\n   if(s+b[i] < a[i]):\n    fl =0\n    break\n   if(s+a[i] <b[i]):\n    fl=0\n    break\n if(fl):\n  print(\"Yes\")\n else:\n  print(\"No\")", "# cook your dish here\nfrom collections import Counter\nfrom math import ceil\nfor _ in range(int(input())):\n \n d=int(input())\n s=input()\n c=Counter(s)\n \n re=ceil(0.75*d)\n ans=0\n if c['P']>=re:\n  print(ans)\n  continue\n \n for i in range(2,d-2):\n  \n  if s[i]=='A':\n   \n   if (s[i-2]=='P' or s[i-1]=='P') and (s[i+2]=='P' or s[i+1]=='P'):\n    c['P']+=1\n    ans+=1\n    \n   if c['P']>=re:\n    print(ans)\n    break\n    \n else:\n  print(-1)\n \n \n \n \n", "# cook your dish here\nt=int(input())\nwhile t:\n n=int(input())\n r1=input()\n r2=input()\n r1count=0\n r2count=0\n count=0\n for i in range(n):\n  if(r1[i]==\"*\"):\n   r1count+=1\n  if(r2[i]==\"*\"):\n   r2count+=1\n if(r1count>0) and (r2count>0):\n  count=1\n  r1count=0\n  r2count=0\n  i=0\n  while(i<n):\n   if(r1[i]==\"*\"):\n    r1count+=1\n   if(r2[i]==\"*\"):\n    r2count+=1\n   if(r1count>1) or (r2count>1):\n    count+=1\n    r1count=0\n    r2count=0\n    i-=1\n   i+=1\n elif(r1count==0 and r2count>0) or (r2count==0 and r1count>0):\n  count=max(r1count,r2count)-1\n else:\n  count=0\n print(count)\n t-=1", "n,m = map(int,input().split())\r\nfor i in range(m):\r\n    q = int(input())\r\n    if q>n+1: print(q-n-1) if q<2*(n+1) else print(3*n-q+1)\r\n    else: print('0')", "# cook your dish here\nfrom math import floor, sqrt\ntry:long\nexcept NameError:long = int \ndef fac(n):\n    step,maxq,d = lambda x: 1 + (x<<2) - ((x>>1)<<1),long(floor(sqrt(n))),1\n    q = n % 2 == 0 and 2 or 3 \n    while q <= maxq and n % q != 0:\n     q = step(d)\n     d += 1\n    return q <= maxq and [q] + fac(n//q) or [n]\nn,k,s = map(int,input().split())\na,di,l,m,ans,su =list(map(int,input().split())),{},[],0,0,0\nfor i in a:\n    bb,su = list(set(fac(i))),su+i\n    for j in bb:\n     try:di[j]+=1\n     except KeyError:m,di[j] = m+1,1\n    l.append(su*(k-m*s))\n    if su*(k-m*s) <0:m,di,su = 0,{},0\nprint(max(l))", "import random\n\ntc = int(input())\nwhile tc:\n\tgraph1 = []\n\tgraph2 = []\n\tn = int(input())\n\n\tfor i in range(n):\n\t\tgraph1.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tgraph2.append([int(x) for x in input().split()])\n\n\t# Begin LOL\n\tfor x in range(2):\n\t\ta = []\n\t\top = ''\n\t\tfor i in range(n):\n\t\t\ta.append(i+1)\n\n\t\tk = n-1\n\t\twhile k:\n\t\t\tindex = random.randint(0,k-1)\n\t\t\top += str(a[index]) + ' '\n\t\t\ta.pop(index)\n\t\t\tk -= 1\n\t\top += str(a[0])\n\t\tprint(op)\n\t# End LOL\n\t\n\ttc -= 1", "for tc in range(int(input())):\n N = int(input())\n a, b = list(map(int, input().split()))\n pr = []\n\n # 'L' is lexicographically lower than 'R'.\n # so, we should first try to apply L+ or L-\n # if we can't then only we'll try to apply R+ or R-\n\n for i in range(N - 1):\n  l, r = list(map(int, input().split()))\n\n  #continue the following process until a == l and b == r\n  while a != l or b != r:\n   # trying to apply L-\n   if a > l:\n    a -= 1\n    pr.append('L-')\n\n   # now, trying to apply L+ (if a < b)\n   elif a + 1 < b and a < l:\n    a += 1\n    pr.append('L+')\n\n   # ok, so far, so good... now, let's try to apply R+\n   elif b < r:\n    b += 1\n    pr.append('R+')\n\n   # finally, lastly, trying to apply R- (if a < b)\n   elif b - 1 > a and b > r:\n    b -= 1\n    pr.append('R-')\n\n print(len(pr))\n print(''.join(pr))", "# cook your dish here\nMOD = 10 ** 9 + 7\n \nfor t in range(int(input())):\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    I, D = [0] * (N + 2), [0] * (N + 2)\n    for i in range(M):\n        x, L, R = input().split()\n        L, R = int(L), int(R)\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    \n    impossibru = mx = mn = 0\n    ans = 1\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and not D[i]:\n            ans = ans * (mx - mn + 1) % MOD\n            mn, mx = 1, K\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % MOD\n    \n    print(0 if impossibru else ans) ", "for _ in range(int(input())):\r\n    m,n=list(map(int,input().split()))\r\n    l=len(str(n))\r\n    last=m\r\n    for i in range(1,12):\r\n        if 10**i - 1>n:\r\n            break\r\n    if i==1:\r\n        print(0,0)\r\n    else:\r\n        print(m*(i-1),m)\r\n", "t = int(input())\r\nfor i in range(t):\r\n    k = int(input())\r\n    print(10*(pow(2,(k-1))))", "# Md. Khairullah Gaurab\n# SUST, CSE, 20th Batch\n#  gaurab.cse.sust@gmail.com\n\n\ntest = int(input());\n\nfor i in range(test):\n    N, S, K = list(map(int,input().split()));\n    lis = list(map(int,input().split()));\n    ans = [i+1 for i in range(N)] ;\n    ans.sort(reverse=True);\n    for j in range(N):\n        print(ans[j],end=' ');\n    print('')\n", "t = int(input())\nnames = 'Dee', 'Dum'\nfor _ in range(t):\n n, s = input().split()\n n = int(n)\n c = [0, 0]\n for _ in range(n):\n  b = input()\n  c[b[0] == '1'] += b.count(b[0])\n print(names[c[0] == c[1] and s == 'Dee' or c[0] < c[1]])\n", "# cook your dish here\ntry:\n    t = int(input())\n    for _ in range(t):\n        p = [int(x) for x in input().split()]\n        q = [int(x) for x in input().split()]\n        \n        q[1] *= -1\n        m = (q[1]-p[1])/(q[0]-p[0])\n        c = p[1] - m*p[0]\n        \n        print(\"{:.2f}\".format(-c/m))\nexcept:\n    pass", "import sys\nn = int(sys.stdin.readline())\nans=0\ni=-1\nn1=n\nwhile n1>0 :\n n1 = (int)(n1/2)\n #print n1\n i = i + 1\nans = (n - (1<<i))*2 + 1\nprint(ans)", "# cook your dish here\nfor i in range(int(input())):\n x=int(input())\n y=input()\n z=y.replace('.','')\n z=z.replace('HT','')\n print(\"Invalid\" if len(z)>0 else \"Valid\")", "# cook your code here\ntest = int(input())\na=0\nwhile(a<test):\n  a = a+1\n  n = int(input())\n  sum = 0\n  if n==1:\n   print(\"1\")\n  else:    \n   for i in range(1,n):\n    sum = sum +i\n    \n    \n    if(sum ==n):\n     print(i)\n     break\n    elif(sum > n):\n     print(i-1)\n     break\n    else:\n     pass", "def checkAccending(li):\n\tfor i in range(len(li)-1):\n\t\tif li[i]>li[i+1]:\n\t\t\treturn False\n\treturn True\nfor _ in range(int(input())):\n\tn = int(input())\n\tb = sorted(int(i) for i in input().split())\n\tg = sorted(int(i) for i in input().split())\n\t\n\tsb=[]\n\tsg=[]\n\t\n\tfor i in range(n):\n\t\tsb.append(b[i])\n\t\tsb.append(g[i])\n\t\t\n\t\tsg.append(g[i])\n\t\tsg.append(b[i])\n\t\n\tif checkAccending(sb) or checkAccending(sg):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')", "import bisect\nimport sys\ninput = sys.stdin.readline\n\nMAXR = 100\nMAXN = 20000000\n\nt = int(input().strip())\nqueries = []\nfor t in range(t):\n L, R = map(int, input().strip().split())\n queries.append((L,R))\n MAXR = max(MAXR, R + 1)\n \n \nMOD = 10 ** 9 + 7\ng = [0, 1, 2]\np = [0, 1, 3]\ns = [0, 1, 9]\n\nfor n in range(3, MAXN):\n gn = 1 + g[n - g[g[n - 1]]]\n pn = p[n - 1] + gn\n sn = (s[n - 1] + gn * n * n) % MOD\n g.append(gn)\n p.append(pn)\n s.append(sn)\n if pn > MAXR:\n  break\n \ndef process(m):\n n = bisect.bisect_right(p, m)\n return (s[n - 1] + (m -p[n - 1]) * n * n) % MOD\n \n \nfor L, R in queries:\n print(process(R) - process(L - 1) % MOD)", "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\ndef check(mid):\r\n    pos = x[0]\r\n    ct = 1\r\n    for i in range(1,n):\r\n        if x[i]-pos >= mid:\r\n            pos = x[i]\r\n            ct += 1\r\n            if ct == k:\r\n                return True\r\n    return False\r\n\r\nfor _ in range(inp()):\r\n    n,k = ip()\r\n    x = ip()\r\n    x.sort()\r\n    ans = -1\r\n    l,r = 1,x[-1]\r\n    while l < r:\r\n        mid = (l+r)//2\r\n        if check(mid):\r\n            ans = max(ans,mid)\r\n            l = mid +1\r\n        else:\r\n            r = mid\r\n    print(ans)\r\n        \r\n        \r\n        \r\n        \r\n", "# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n\tn, m = map(int, input().split())\n\n\tget_ups = lambda r, c: [(r-1, c + i) for i in [1, 0, -1] if 0 <= c+i < m]\n\tgrid = [list(map(int, input().split())) for _ in range(n)]\n\tres = [[0]*m for _ in range(n)]\n\tres[0] = ['1']*m \n\tfor i in range(1, n):\n\t\tfor j in range(m):\n\t\t\tt = 1\n\t\t\tfor r, c in get_ups(i, j):\n\t\t\t\tif grid[r][c] > grid[i][j]:\n\t\t\t\t\tgrid[i][j] = grid[r][c]\n\t\t\t\t\tt = 0\n\t\t\tres[i][j] = '1' if t else '0'\n\tfor r in res:\n\t\tprint(''.join(r))", "t=int(input())\nfor i in range(t):\n n=int(input())\n li=list(map(int,input().split()))\n a=set(li)\n l=list(a)\n print(len(l))\n", "# cook your dish here\ndef gcd(a, b):\n    if a ==0:\n        return b\n    return gcd(b%a, a)\n\n\nt = int(input())\nwhile t:\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    lcm = (n*m)/gcd(n,m)\n    print(int(lcm))\n    t -= 1", "for i in range(int(input())):\n n,k=list(map(int,input().split()))\n a=list(map(int,input().split()))\n m=10**10\n ind=1\n for i in range(n):\n  for j in range(i+1,n):\n   if abs(m)>abs(a[i]+a[j]-k):\n    m=abs(a[i]+a[j]-k)\n    ind=1\n   elif abs(m)==abs(a[i]+a[j]-k):\n    ind+=1\n print(m,ind)\n", "mod = 8589934592 \r\n\r\nfor _ in range(int(input())):\r\n\tn=int(input())\r\n\tprint(\"Case\",(_+1),end=\"\")\r\n\tprint(\": \",end=\"\")\r\n\tprint((pow(2,n,mod)-1)%mod)", "import sys\nfrom functools import partial\n\nSAMPLE_IN = 'sample.in'\nSAMPLE_ANS = 'sample.ans'\n\n\ndef read_int(f) -> int:\n return int(f.readline())\n\ndef read_ints(f) -> list:\n return [int(x) for x in f.readline().split()]\n\ndef read_case(f=sys.stdin) -> tuple:\n n = read_int(f)\n nums = read_ints(f)\n return n, nums\n\n\ndef solve(n, nums):\n even = 0\n odd = [-1] * (n+1)\n for x in nums:\n  even, odd[x] = max(even, odd[x] + 1), even + 1\n return n - even\n\n\ndef make_submission(fin=sys.stdin, fout=sys.stdout):\n output = partial(print, file=fout)\n n_cases = int(fin.readline())\n for t in range(1, n_cases + 1):\n  case = read_case(fin)\n  answer = solve(*case)\n  output(answer)\n\n\ndef __starting_point():\n import os\n if os.getenv('GCJ_LOCAL'):\n  with open(SAMPLE_IN) as s:\n   make_submission(s)\n else:\n  make_submission()\n\n__starting_point()", "from collections import Counter \nfor _ in range(int(input())):\n s = input()\n c = Counter(list(s))\n if len(c) == 1:\n  print(0)\n else:\n  m = min(c['b'], c['g'])\n  ma = max(c['b'], c['g'])\n  l = (ma - m + 1) // 2\n  r = (ma - m + 1) // 2 + (ma - m + 1) % 2\n  res = (l * (l + 1)) // 2\n  re = res\n  for i in range(1, m):\n   res += 2 * l + 1\n   re += res\n   l += 1\n  res2 = (r * (r + 1)) // 2\n  re += res2\n  for i in range(1, m):\n   res2 += 2 * r + 1\n   re += res2\n   r += 1\n  print(re)", "# cook your dish here\nt = int(input())\nwhile t>0:\n    n,m = map(int, input().split())\n    list_n = list(map(int, input().split()))\n    list_m = list(map(int, input().split()))\n    set_m = set(list_m)\n    set_n = set(list_n)\n    set_mn = set_m-set_n\n    set_nm = set_n-set_m\n    union_set = set_mn.union(set_nm)\n    print(*sorted(list(union_set)))\n    t-=1", "t=int(input())\nwhile(t):\n k=1\n j=0\n n=int(input())\n while(n>0):\n  if(n<=k):\n   j+=1\n   n=0\n  elif n>2*k:\n   j+=2\n   n=n-2*k\n   k+=1\n  else:\n   j+=2\n   n=0\n print(j)\n t-=1", "# cook your dish here\nfor _ in range(int(input())):\n    n,k = list(map(int,input().split()))\n    x = [int(i)for i in input().split()]\n    a = []\n    count = 0\n    for i in x:\n        a.append(i)\n        t = a[:]\n        t.sort()\n        if len(t)>=2:\n            if t[-1]+t[-2]<=k and len(t)>count:\n                count = len(t)\n            else:\n                a.pop(0)\n    print(count)\n", "from collections import Counter\nn, m = list(map(int, input().split()))\n\nc = Counter(list(range(1, n + 1)))\n\ns = n*(n + 1) // 2\n\nlast = n\nfirst = 1\n\nd = set(list(range(1, n + 1)))\n\nfor i in range(m):\n k = int(input())\n \n if k in d:\n  last, first = first, last\n  print(s)\n else:\n  s -= last\n  d.remove(last)\n  d.add(k)\n  s += k\n  last = k \n  print(s)\n", "# cook your dish here\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    s=0\n    for j in range(1,int(n**0.5)+1):\n        if (j)%3==0:\n            continue\n            \n        else:\n            s+=1\n    print(s)        \n", "# cook your dish here\nt=int(input())\nfor z in range(0,t):\n N=int(input())\n li=[[i for i in range(0,N)] for j in range(0,N)]\n #print(li)\n c=1\n for j1 in range(0,N):\n  i=0\n  j=j1\n  while j!=-1:\n   li[i][j]=c\n   i+=1\n   j-=1\n   c+=1\n for i1 in range(1,N):\n  j=N-1\n  i=i1\n  while i!=N:\n   li[i][j]=c\n   i+=1\n   j-=1\n   c+=1\n for i in range(0,N):\n  for j in range(0,N):\n   print(li[i][j],end=\" \")\n  print()\n   \n \n   \n  \n \n ", "def lsb(i):\n    return bool(i & (1<< 0))\n\n\n\n\nt= int(input())\nfor _ in range(t):\n    n = int(input())\n    m=list(map(int,input().split()))\n    res=[]\n    for i in m:\n        result= lsb(i)\n        if result:\n            continue\n        else:\n            res.append(i)\n    print(sum(res))\n", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef solve(i, j, c=0):\n if i > j:\n  return 0\n\n if (i, j) in dp:\n  return dp[i, j]\n\n x0 = solve(i+1, j, c^1)\n x1 = solve(i, j-1, c^1)\n\n if c == 0:\n  y = 1 << (j - i)\n  x0 += a[i] * y\n  x1 += a[j] * y\n\n dp[i, j] = x0 + x1\n return dp[i, j]\n\nfor _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n dp = {}\n\n total = solve(0, n-1)\n print(total / (1 << n))\n", "#!/usr/bin/env python2\n \ndef gc(c):\n  return 'a' <= c <= 'h'\ndef gd(c):\n  return '1' <= c <= '8'\n \nt = int(input())\nfor i in range(t):\n  line = input()\n  if len(line) != 5:\n    print(\"Error\")\n    continue\n  if line[2] != '-':\n    print(\"Error\")\n    continue\n  x1 = line[0]\n  y1 = line[1]\n  x2 = line[3]\n  y2 = line[4]\n  if gc(x1) and gd(y1) and gc(x2) and gd(y2):\n    d1 = abs(ord(x1) - ord(x2))\n    d2 = abs(ord(y1) - ord(y2))\n    if d1 > d2: d1,d2 = d2, d1\n    if (d1 == 1) and (d2 == 2):\n      print(\"Yes\")\n    else:\n      print(\"No\")\n  else:\n    print(\"Error\")", "t = int(input())\r\nmod = 10 ** 9 + 7\r\nfor _ in range(t):\r\n    p, q, r = map(int, input(). strip(). split())\r\n    a= sorted(int(x) for x in input().split())\r\n    b= sorted(int(x) for x in input().split())\r\n    c= sorted(int(x) for x in input().split())\r\n    ans = 0\r\n    m = 0\r\n    n = 0\r\n    sum1 = 0\r\n    sum2 = 0\r\n    for i in b:\r\n        while m < p and a[m] <= i:\r\n            sum1 += a[m]\r\n            m += 1\r\n        while n < r and c[n] <= i:\r\n            sum2 += c[n]\r\n            n += 1\r\n        ans += (sum1+m*i)*(sum2+n*i)\r\n    print(ans%mod)\r\n\r\n", "for _ in range(int(input())):\n n= int(input())\n print(0) if n%10==0 else print(1) if n%5==0 else print(-1)\n", "for _ in range(int(input())):\n n=int(input())\n matrix=[]\n for i in range(n):\n  matrix.append(list(map(int,input().split())))\n count=0\n for i in reversed(list(range(n))):\n  if count&1:\n   if matrix[0][i] != i*n+1:\n    count+=1\n  else:\n   if matrix[i][0] != i*n+1:\n    count+=1 \n print(count)\n   \n   \n", "n=int(input())\nfor i in range(n):\n s=input()\n if(\"SC\" in s or \"SE\" in s or \"EC\" in s):\n  print(\"no\")\n else:\n  print(\"yes\")", "def func():\n count=0\n N=len(A)\n marker=[0 for h in range(N)]\n for i in range(N-1):\n  for group_size in range(1,N-i):\n   I=set(A[i:i+group_size])\n   m=0\n   new_element=A[i+group_size-1]\n   for j in range(i+group_size,N):\n    if(group_size==1):\n     if(A[j] not in I):\n      m+=1\n      marker[j]=0\n      #print \"hello\",A[j],m\n     else:\n      marker[j]=1\n      count+=(m*(m+1)/2)\n      #print \"oops\",count,m\n      m=0\n    else:\n     if(marker[j]==0 and A[j]!=new_element):\n      m+=1\n     else:\n      marker[j]=1\n      count+=(m*(m+1)/2)\n      m=0 \n   count+=(m*(m+1)/2)\n print(count)\n \n \nT=int(input())\n \nfor t in range(T):\n N=int(input())\n A=input().split(\" \")\n \n for i in range(N):\n  A[i]=int(A[i])\n \n func()\n", "lucky = {4, 774, 7, 744, 777, 74, 747, 44, 77, 47, 474, 444, 477, 447}\nfrom functools import lru_cache\nimport sys \nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 1001):\n    fact.append(fact[-1] * i % mod)\ninv = [pow(i, mod-2, mod) for i in fact]\nC = lambda k, n: fact[n] * inv[n-k] * inv[k] % mod\ndef f(n):\n    n = [int(x) for x in n]\n    @lru_cache(None)\n    def dp(pos, cnt, free):\n        if cnt > 777:\n            return 0\n        diff = len(n) - pos \n        ans = 0\n        if free:\n            for i in lucky:\n                i -= cnt\n                if 0 <= i <= diff:\n                    ans += C(i, diff) * pow(2, i, mod) * pow(8, diff - i, mod)\n                    ans %= mod \n            return ans\n        if pos == len(n):\n            return int(cnt in lucky)\n        for i in range(10 if free else n[pos]+1):\n            ans += dp(pos+1, cnt + int(i == 4 or i == 7), free or i < n[pos])\n            ans %= mod \n        return ans \n    return dp(0, 0, 0)\n    \nt = int(input())\nfor _ in range(t):\n    l, r = input().split()\n    l = str(int(l) -1) \n    print((f(r) - f(l)) % mod)", "t=int(input())\nfor i in range(0,t):\n    r=int(input())\n    d=2*r*r \n    print(d)", "# cook your dish here\nt = int(input())\n\nfor i in range(t):\n a,b = list(map(int,input().split()))\n \n #x=min(a,b)\n #y=max(a,b)\n count=0\n\n # for i in range(1,a+1):\n #     for j in range(1,b+1):\n   \n #         if (i+j) %2 ==0:\n #             count+=1\n \n x = list(range(1,a+1))\n y = list(range(1,b+1))\n #print(x)\n #print(y)\n \n if len(x) % 2 != 0:\n  even_x = len(x)//2\n  odd_x = len(x)//2 +1\n else:\n  even_x = len(x)//2\n  odd_x = len(x)//2\n  \n if len(y) % 2 !=0:\n  even_y = len(y)//2\n  odd_y = len(y)//2 +1\n else:\n  even_y = len(y)//2\n  odd_y = len(y)//2\n  \n #print(\"even_x & even_y : \",even_x,even_y)\n #print(\"odd_x & odd_y : \",odd_x,odd_y)\n count = (even_x * even_y) + (odd_x * odd_y)\n \n \n print(count)\n #print()\n", "# cook your dish here\nfor _ in range(int(input())):\n    n,l = map(int, input().split())\n    a_l = list(map(int, input().split()))\n    \n    dic = {}\n    dif = 0\n    for i,v in enumerate(a_l, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1]-dic[v][0])\n            \n    ans = dif\n    if l <= len(set(a_l)):\n        i_l = [[v,i] for i,v in enumerate(a_l, start=1)]\n        i_l.sort(reverse=True)\n        \n        dp = [[-1 for _ in range(l)] for _ in range(n)]\n        for i in range(1,n):\n            for j in range(i):\n                dif = abs(i_l[i][1]-i_l[j][1])\n                dp[i][1] = max(dp[i][1], dif)\n                for il in range(2,l):\n                    if dp[j][il-1] == -1:\n                        break\n                    dp[i][il] = max(dp[i][il], min(dif, dp[j][il-1]))\n            ans = max(ans, dp[i][il])\n    #     print(dp)\n    # print(dic)\n    print(ans)", "t=int(input())\r\nm=0\r\nh=[]\r\nfor d in range(1,t+1):\r\n\tu=input()\r\n\tu=u.split(\" \")\r\n\ta=int(u[0])\r\n\tb=int(u[1])\r\n\tv=a\r\n\tif (b>=a):\r\n\t\tm=a+1\r\n\telse:\r\n\t\tm=b+1\r\n\th.append(m)\r\nfor i in h:\r\n    print(i)\r\n", "import sys\r\nimport math\r\nfrom collections import defaultdict,Counter\r\n\r\ninput=sys.stdin.readline\r\ndef print(x):\r\n    sys.stdout.write(str(x)+\"\\n\")\r\n\r\n# sys.stdout=open(\"CP2/output.txt\",'w')\r\n# sys.stdin=open(\"CP2/input.txt\",'r')\r\n\r\n# mod=pow(10,9)+7\r\nt=int(input())\r\nfor i in range(t):\r\n\tn=int(input())\r\n\ta=list(map(int,input().split()))\r\n\teven=[0]*n\r\n\t# odd=[0]*n\r\n\tans=0\r\n\tpre=[0]*n\r\n\tpre[0]=a[0]\r\n\td={a[0]:0}\r\n\tif a[0]%2==0:\r\n\t\teven[0]=1\r\n\tfor j in range(1,n):\r\n\t\ts=d.get(a[j],-1)\r\n\t\tif s==-1:\r\n\t\t\td[a[j]]=j\r\n\t\telse:\r\n\t\t\tif a[j]&1:\r\n\t\t\t\tif (pre[j-1]-pre[d[a[j]]])&1:\r\n\t\t\t\t\tans=max(ans,pre[j-1]-pre[d[a[j]]])\r\n\t\t\telse:\r\n\t\t\t\tif (even[j-1]-even[d[a[j]]])%2==0:\r\n\t\t\t\t\tans=max(ans,pre[j-1]-pre[d[a[j]]])\r\n\t\t\td[a[j]]=j\r\n\t\tpre[j]=pre[j-1]+a[j]\r\n\t\teven[j]=even[j-1]\r\n\t\tif a[j]%2==0:\r\n\t\t\teven[j]+=1\r\n\tprint(ans)", "\nt=int(input())\nfor i in range(0,t):\n    n=int(input())\n    if n==2:\n        print(n)\n    else:\n        print((n//2)+1)\n", "# cook your dish here\nn,k=list(map(int,input().split()))\na=[[]for i in range (n)]\nfor i in range (n):\n a[i]=list(map(int,input().split()))\nf = []\np=[]\nfor i in range(n):\n s1 = 0\n for j in range(k):\n  s1+=a[i][j]\n f.append(s1)\nfor i in range(k):\n s = []\n l = a[0][i]/f[0]\n s.append(l)\n for j in range(1,n):\n  s.append((l + a[j][i])/(f[j]+1))\n  l = s[j]\n p.append(s[n-1])\nr = str(p[0])+' '\nfor i in range (1,k):\n r+=(str(p[i])+ ' ')\nprint(r)\n \n", "# cook your dish here\n#872//2\nimport math\na,b=list(map(int,input().split()))\nl=[]\nm=[]\nfor i in range(1,a+1):\n l.append(i*i)\nfor i in range(1,b+1):\n m.append(i)\ncnt=0\nfor i in range(a):\n for j in range(b):\n  y=l[i]+m[j]\n  if math.sqrt(y)==math.floor(math.sqrt(y)):\n   cnt+=1\nprint(cnt) \n  \n \n", "# cook your dish here\ntry:\n    n = int(input())\n    n += 1\n    flag = 1\n    while n <= 987654321:\n        nt = str(n)\n        if \"0\" not in nt:\n            if len(nt) == len(set(list(nt))):\n                print(n)\n                flag = 0\n                break\n            n += 1\n        else:\n            nt = nt[::-1]\n            ind = nt.index('0')\n            n += 10**ind\n    if flag:\n        print(0)\nexcept:\n    pass", "import math\nalpha =\"abcdefghijklmnopqrstuvwxyz\"\nvow = 'aeiou'\nfor t_itr in range(int(input())):\n    s = str(input())\n    count = 0\n    for i in s:\n        if i in vow:\n            count += 0\n        else:\n            a = []\n            a.append(abs(alpha.index(i)-alpha.index(\"a\")))\n            a.append(abs(alpha.index(i)-alpha.index(\"e\")))\n            a.append(abs(alpha.index(i)-alpha.index(\"i\")))\n            a.append(abs(alpha.index(i)-alpha.index(\"o\")))\n            a.append(abs(alpha.index(i)-alpha.index(\"u\")))\n            count += min(a)\n    print(count)", "# cook your dish here\nimport sys\ndef get_array(): return list(map(int , sys.stdin.readline().strip().split()))\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations_with_replacement,permutations\nimport bisect\nimport math as mt \nfrom functools import reduce\nimport time\n\ndef __starting_point():\n    for _ in range(int(input())):\n        n = int(input())\n        a=1\n        b=1\n        c=(-2*n)\n        dis = b * b - 4 * a * c  \n        sqrt_val = math.sqrt(abs(dis))\n        r1=(-b + sqrt_val)/(2 * a)\n        # r2=(-b - sqrt_val)/(2 * a)\n\n        # print(r1)\n        r1 = math.floor(r1)+1\n        print(n-r1+1)\n\n\n\n\n\n\n\n\n\n\n\n__starting_point()", "# cook your dish here\na=int(input())\nfor i in range(0,a):\n    s=int(input())\n    j=s\n    su=0\n    while(j!=0):\n        su=su+j**3\n        j-=1\n    j=1\n    while(j!=s):\n        su=su+j**3\n        j+=1\n    print(su)\n        \n        \n        \n", "import math\nmaxn = 10**4 + 1\nx = [a for a in range(2,maxn)]\nfor y in x:\n for j in range(2,math.ceil(maxn/y)):\n  if y*j in x:\n   x.remove(y*j)\nval = [0]*(3*(10**4))\nfor i in range(len(x)):\n for j in range(len(x)):\n  val[(x[i]+2*x[j])]+=1\nt=int(input())\nfor i in range(t):\n n=int(input())\n print(val[n])", "# cook your dish here\ndef polygonArea(X, Y, n):\n area = 0.0\n j = n - 1\n for i in range(0, n):\n  area += (X[j]*Y[i] - Y[j]*X[i])\n  j = i\n return (abs(area / 2.0))\nX=[]\nY=[]\nxy=[]\nn=int(input())\nfor i in range(n):\n xy.append(list(map(int,input().split())))\nfor i in range((n-1)):\n X.append((xy[i][0]+xy[i+1][0])/2)\n Y.append((xy[i][1]+xy[i+1][1])/2)\nX.append((xy[0][0]+xy[n-1][0])/2)\nY.append((xy[0][1]+xy[n-1][1])/2)\nprint(polygonArea(X, Y, n))", "def Testcase():\n n = int(input())\n li = list(map(int,input().split()))[:n]\n \n if n==2:\n  print(abs(li[1]-li[0]))\n  return\n \n li.sort()\n ans =0\n for i in range(1,n-1):\n  prev = abs(li[i]-li[i-1])\n  next = abs(li[i+1]-li[i])\n  curr = min(prev,next)\n  ans = max(ans,curr)\n \n ans = max(ans,abs(li[1]-li[0]))\n ans = max(ans,abs(li[n-1]-li[n-2]))\n print(ans)\n    \n\n\n\n\nt = int(input())\nfor i in range(t):\n Testcase()", "try:\r\n    t=int(input())\r\n    for _ in range(t):\r\n        n=int(input())\r\n        i=1\r\n        while(i<=n):\r\n            j=i\r\n            while(j<=n-1):\r\n                print(\" \",end=\"\")\r\n                j+=1\r\n            print(\"*\",end=\"\")\r\n            if i>1 and i<n:\r\n                for j in range((i-1)*2-1):\r\n                    print(\" \",end=\"\")\r\n                print(\"*\",end=\"\")\r\n            if(i==n):\r\n                for j in range(2*(i-1)):\r\n                    print(\"*\",end=\"\")\r\n            print()\r\n            \r\n            i+=1\r\nexcept EOFError:\r\n    pass", "for _ in range(int(input())):\n a=int(input())\n b=list(map(int,input().split()))\n b.sort()\n c=0\n k=a//2\n for i in range(k):\n  c+=abs(b[i]-b[a-i-1])\n print(c)\n", "# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    if n==1:\n        print(\"1\")\n    else:\n        p=1\n        for i in range(n):\n            for j in range(n):\n                print(str(bin(p)).replace('0b',''),' ',end='')\n                p+=1\n            print()", "def count_inversions(a):\n  res = 0\n  counts = [0]*(len(a)+1)\n  rank = { v : i+1 for i, v in enumerate(sorted(a)) }\n  for x in reversed(a):\n    i = rank[x] - 1\n    while i:\n      res += counts[i]\n      i -= i & -i\n    i = rank[x]\n    while i <= len(a):\n      counts[i] += 1\n      i += i & -i\n  return res\n  \nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    print(count_inversions(a))", "t=int(input())\nfor i in range(t):\n k=int(input())\n for j in range(k,0,-1):\n   if j%2==0:\n    for m in range(j,0,-1):\n     print(m,end=\"\")\n   else:\n    for m in range(1,j+1):\n     print(m,end=\"\")\n   print()", "t=int(input())\nfor i in range(t):\n    n=int(input())\n    h=list(map(int,input().split()))\n    def res(a):\n        n=len(a)\n        max1=max(a)\n        ind=0\n        ind=a.index(max1)\n        if(ind==0 or ind==n-1):\n            return 1\n        else:                                         \n            return 1+ min(res(a[:ind]),res(a[ind+1:]))\n    print(res(h))\n        \n", "import fractions\nfor t in range(int(input())):\n h,u,d = list(map(int,input().split()))\n g = fractions.gcd(u,d)\n if (h%g!=0):\n  print(-1)\n else:\n  m = 0\n  n = 0\n  while (True):\n   n = (float(m)*u-h)/d\n   if (n>0 and int(n) == n):\n    break\n   m+=1\n  print(int(m+n))", "for _ in range(int(input())):\n N, K = map(int, input().strip().split())\n if K == 0:\n  print(0, N)\n else:\n  print(N//K, N%K)", "# cook your code here\nfor _ in range(int(input())):\n n,u,d = map(int,input().split())\n H = list(map(int,input().split()))\n parachute=1\n lenH = len(H)\n for i in range(lenH):\n  diff = 0\n  if i==lenH-1:\n   break\n  \n  if H[i+1]>H[i]:\n   if H[i+1]-H[i]>u:\n    break\n  elif H[i+1]<H[i]:\n   if H[i]-H[i+1]>d:\n    if parachute ==1:\n     parachute =0\n     continue\n    else:\n     break\n  \n print(i+1)", "def isSubsetSum(set,n, sum) : \r\n    if (sum == 0) : \r\n        return 1\r\n    if (n == 0 and sum != 0) : \r\n        return 0\r\n    if (set[n - 1] > sum) : \r\n        return isSubsetSum(set, n - 1, sum) \r\n    return isSubsetSum(set, n-1, sum) + isSubsetSum(set, n-1, sum-set[n-1]) \r\n\r\ndef __starting_point():\r\n    t=int(input())\r\n    while(t>0):\r\n        n = int(input())\r\n        m = int(input())\r\n        arr = list(map(int,input().split()))\r\n        print(isSubsetSum(arr,n,m))\r\n        t-=1\n__starting_point()", "import sys\nn = eval(input())\nparents = [int(x)-1 for x in input().split(' ')]\nvalues = list(map(int , input().split(' ')))\nparents = [0]+parents\n# print(parents)\n# print(values)\ndef single_node_cost(i):\n cost = 0\n # print('started with ',i)\n min_value = sys.maxsize\n while i != 0:\n  min_value = min(min_value,values[i])\n  cost += min_value\n  # print(i,min_value)\n  i = parents[i]\n cost += min(values[0],min_value)\n return cost\nfor i in range(n):\n print(single_node_cost(i), end=' ')", "for _ in range(int(input())):\n n,k=input().split()\n laddus=0\n for j in range(int(n)):\n  x=input().split()\n  if x[0]==\"CONTEST_WON\":\n   if(int(x[1])<=20):\n    laddus+=300+20-int(x[1])\n   else:\n    laddus+=300\n  elif x[0]==\"TOP_CONTRIBUTOR\":\n   laddus+=300\n  elif x[0]==\"BUG_FOUND\":\n   laddus+=int(x[1])\n  elif x[0]==\"CONTEST_HOSTED\":\n   laddus+=50\n if(k==\"INDIAN\"):\n  print(laddus//200)\n else:\n  print(laddus//400)", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n#cin=sys.stdin.readline\ncout=sys.stdout.write\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n st=''\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "for _ in range(int(input())):\n n=int(input())\n a=[int(z) for z in input().split()]\n m=0\n a1=list(set(a))\n for i in range(len(a1)):\n  if a.count(a1[i])>m:\n   m=a.count(a1[i])\n print(n-m)\n \n   \n", "n,k=list(map(int,input().split()))\na=[]\nfor _ in range(n):\n    a.append(int(input()))\na.sort()\nhmin=a[0]\nhmax=a[k-1]\nd=hmax-hmin\nfor i in range(0,len(a)-k):\n    if(d>a[k+i-1]-a[i]):\n        d=a[k+i-1]-a[i]\nprint(d)", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    array=list(map(int, input().split()))\n    print(max(array)-min(array)+2*k)", "# cook your dish here\nimport math\nt=int(input())\nwhile(t>0):\n    a,b,c,d=input().split()\n    a=int(a)\n    b=int(b)\n    c=int(c)\n    d=int(d)\n    \n    if d==c:\n        if a==b:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        m=abs((a-b)/(c-d)) \n        if int(m)==m:\n            if min(a,b)+(max(c,d)*m-1)==max(a,b)+(min(c,d)*m-1):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        \n        else:\n            m=math.ceil(m)\n            if min(a,b)+(max(c,d)*m)==max(a,b)+(min(c,d)*m):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    t=t-1\n", "t=int(input())\nfor _ in range(t):\n n=int(input())\n s=list(input())\n for i in range(n-1):\n  if(i%2==0):\n   temp=s[i+1]\n   s[i+1]=s[i]\n   s[i]=temp\n for i in range(n):\n  s[i]=chr(ord('z')-ord(s[i])+ord('a'))\n s=\"\".join(s)\n print(s)# cook your dish here\n", "import math\nfor i in range(int(input())):\n n=int(input())\n if(n<=2):\n  print(\"0\")\n else:\n  print((math.factorial(n-1)*(math.factorial(n)-2))%1000000007)\n", "n, m, k = list(map(int, input().split()))\n\nif k == 1:\n x, y = 0, 0\n for p in range(2, n + 1):\n  x += (n - p + 1)\n for p in range(2, m + 1):\n  y += (m - p + 1)\n ans = x * y\n x = 0\n for p in range(1, n + 1):\n  x += (n - p + 1)\n y = 0\n for p in range(1, m + 1):\n  y += (m - p + 1)\n ans += m * x\n ans += n * y\n ans -= n * m\n print(ans)\nelse:\n x, y = 0.0, 0.0\n q = 1.0\n for p in range(2, n + 1):\n  q /= k * k\n  x += (n - p + 1) * q\n for p in range(2, m + 1):\n  q /= k * k\n  y += (m - p + 1) * q\n ans = k * x * y\n x = 0.0\n q = 1.0\n for p in range(1, n + 1):\n  x += (n - p + 1) * q\n  q /= k\n y = 0.0\n q = 1.0\n for p in range(1, m + 1):\n  y += (m - p + 1) * q\n  q /= k\n ans += m * x\n ans += n * y\n ans -= n * m\n ans += 1e-9\n # print ans\n print(\"%.0f\" % ans)\n", "def calc(n,b,m):\n if(n==1):\n  return m\n if(n%2==0):\n  return m*n/2 + b + calc(n/2,b,m*2)\n else:\n  return m*(n+1)/2 + b + calc((n-1)/2,b,m*2)\n \nt=int(input());\nwhile (t!=0):\n t=t-1\n n,b,m = list(map(int, input().split()))\n print(calc(n,b,m))", "#!/usr/bin/pyhton\nMAX = 10000000000\ndef main():\n t = int(input())\n j = 0\n min = []\n while j<t:\n  N = int(input())\n  i = 0\n  S = list(map(int, input().split()))\n  S.sort()\n  min.append(MAX)\n  while i<N-1:\n   if S[i+1]-S[i] < min[j]:\n    min[j] = S[i+1]-S[i]\n   i = i + 1\n  j = j + 1\n\n j = 0\n while j<t:\n  print(min[j])\n  j = j+1\n\ndef __starting_point():\n main()\n\n__starting_point()", "# cook your code here\nn=input()\nx=len(n)\nno=list(map(int,n))\ntemp=[0]*x\nif (x>2):\n sum=99\n for i in range(3,x):\n  sum=sum+90\n sum=sum+10*(int(n[0])-1)\n sum=sum+int(n[1])\n f=int(n[0])%10\n \n s=int(n[1])%10\n \n cd=s-f\n \n temp[0]=n[0]\n temp[1]=n[1]\n for i in range(2,x):\n  nxt=(s+cd)%10\n  temp[i]=(chr(nxt+48))\n  s=nxt\n temp=list(map(int,temp))\n if(temp<=no):\n  sum=sum+1\n print(sum)\nelse:\n  print(n)", "import sys\r\n\r\nn = int(sys.stdin.readline().strip())\r\ns = sys.stdin.readline().strip()\r\n\r\nalph = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n\r\narr = [0]*26\r\npref = []\r\n\r\nfor i in range(len(s)):\r\n\tfor j in range(26):\r\n\t\tif alph[j] == s[i]:\r\n\t\t\tarr[j] += 1\r\n\t\t\tbreak\r\n\tpref += [arr[:]]\r\n\r\n# for x in pref:\r\n# \tprint(x)\r\n\r\nq = int(sys.stdin.readline().strip())\r\n\r\nfor _ in range(q):\r\n\tr, c = sys.stdin.readline().strip().split()\r\n\r\n\tfor i in range(26):\r\n\t\tif alph[i] == c:\r\n\t\t\tind = i\r\n\t\t\tbreak\r\n\r\n\tr = int(r)\r\n\r\n\tprev = ((r-1)**2 + r-1)//2\r\n\r\n\tdone = prev%len(s)\r\n\r\n\tans = 0\r\n\trem = (len(s) - done)%len(s)\r\n\r\n\tif r <= rem:\r\n\t\tprint(pref[done+r-1][ind] - pref[done-1][ind])\r\n\t\tcontinue\r\n\r\n\tif rem != 0:\r\n\t\tans += pref[-1][ind] - pref[done-1][ind]\r\n\t\tr -= rem\r\n\r\n\tans += pref[-1][ind] * (r//len(s))\r\n\tr %= len(s)\r\n\r\n\t# print(\"AA\", ans, r)\r\n\r\n\tif r != 0:\r\n\t\tans += pref[r-1][ind]\r\n\r\n\tprint(ans)\r\n\r\n\r\n\t# print(rem, done, prev)\n", "t=int(input())\nwhile t!=0:\n n=int(input())\n a=list(map(int,input().split()))\n c=0\n for i in range(n-1):\n  if (a[i]&1)!=1 :\n   for j in range(i+1,n):\n    if (a[j]&1)==1:\n     c+=1\n print(c)\n t-=1\n", "t = int(input())\n\nwhile t:\n t-=1\n a=[int(i) for i in input().split()]\n n=int(a[0])\n k=int(a[1])\n flag=1\n if k==0:\n  res=[i+1 for i in range(n)]\n elif k>n/2 or n%(2*k)!=0:\n  flag=0\n else:\n  temp1=[i+1 for i in range(k)]\n  temp2=[i+1 for i in range(k,2*k)]\n  temp=temp2+temp1\n  res=[]\n  x=n/(2*k)\n  while x:\n   x-=1\n   res+=temp\n   temp = [i+2*k for i in temp]\n if flag:\n  res=[str(i) for i in res]\n  print(\" \".join(res))\n else:\n  print(\"CAPTAIN AMERICA EVADES\")\n", "# cook your dish here\nfrom math import log2\nt=int(input())\ndef odd(a,n):\n count=0\n for i in range(n):\n  count+=a[i]%2\n if count>=n/2:\n  return 1;\n return 0\ndef divide(a):\n for i in range(len(a)):\n  a[i]=a[i]>>1\n return a;\nfor _ in range(t):\n n=int(input())\n a=list(map(int,input().split()))\n m=a[:]\n time=int(log2(max(a))+1)\n \n i=0\n answer=0\n while i<time:\n  answer+=odd(a,n)*(1<<i)\n  a=divide(a)\n  i+=1\n  \n x=answer;\n # print(x)\n for i in range(n):\n  m[i]=m[i]^x\n # print(a)\n print(sum(m)) \n", "for _ in range(int(input())):\n x,y,k = map(int,input().split())\n a = (x+y)//k \n if a%2==0:\n  print(\"Chef\")\n else:\n  print(\"Paja\")", "try:\r\n    n,m,a=map(int,input().split())\r\n    if n%a!=0:\r\n        number1=(n//a)+1\r\n    else:\r\n        number1=(n//a)\r\n    if m%a!=0:\r\n        number2=(m//a)+1\r\n    else:\r\n        number2=(m//a)\r\n    print(number1*number2)\r\nexcept:\r\n    pass", "mod=10**9+7\nN,K,Q=list(map(int,input().split()))\n\nA=[0,0]\n#min_t=[-1]*((N*N-1)/2)\n#print min_t\na,b,c,d,e,f,r,s,t,m,A[1]=list(map(int,input().split()))\n\nL1,La,Lc,Lm,D1,Da,Dc,Dm=list(map(int,input().split()))\n\ntmpt=t\nmin_arr=[0]\nfor x in range(2,N+1):\n tmpt=(tmpt*t)%s\n if tmpt <= r:\n  A.append(( A[x-1]*(a*A[x-1] + b) + c) % m)\n else:\n  A.append(( A[x-1]*(d*A[x-1] + e) + f) % m)\nfor x in range(1,N-K+2):\n min_arr.append(min(A[x:x+K]))\n\nres_sum=0\nres_pro=1\nfor x in range(1,Q+1):\n L1 = (La * L1 + Lc) % Lm\n D1 = (Da * D1 + Dc) % Dm \n L = L1 + 1\n R = min(L + K - 1 + D1, N)\n R=R-K+1\n #print min_arr,L,R,min_arr[L:R+1]\n if L==R:\n  tmp=min_arr[L]\n else:\n  tmp=min(min_arr[L:R+1])\n res_sum+=tmp\n res_pro=(res_pro*tmp)% mod\nprint(res_sum,res_pro)\n", "from math import sqrt\nimport sys\nsys.setrecursionlimit(10**8)\nintMax = 10**18\ndef knapsack(rl,l,c,m):\n if m==0 and rl>0:\n  return intMax\n if rl<=0:\n  return 0\n return min(c[m-1]+knapsack(rl-l[m-1],l,c,m),knapsack(rl,l,c,m-1))\nfor _ in range(int(input())):\n n= int(input())\n cost=[]\n length=[]\n sides=[]\n for i in range(n):\n  x,y = map(int,input().split())\n  if i == 0:\n   x0 = x\n   y0 = y\n   prevx = x\n   prevy = y\n  elif i == n-1:\n   sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\n   sides.append(sqrt((x0-x)**2 + (y0-y)**2))\n  else:\n   sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\n   prevx = x\n   prevy = y\n m = int(input())\n for j in range(m):\n  li,ci = map(int,input().split())\n  length.append(li)\n  cost.append(ci)\n ans=0\n #print(sides)\n for k in sides:\n  ans= ans + knapsack(k,length,cost,m)\n print(int(ans))", "import math\r\n\r\ndef check(s):\r\n    if s==2:\r\n        return 1\r\n        \r\n    for i in range(2,math.ceil(math.sqrt(s))+1):\r\n        if s%i == 0:\r\n            return 0\r\n    \r\n    return 1\r\n        \r\n\r\ndef Solve(slots):\r\n  if slots<3:\r\n    return 0\r\n  \r\n  #check\r\n  s = math.sqrt(slots)\r\n  if math.floor(s) == math.ceil(s):\r\n      return check(s)\r\n      \r\n  return 0\r\n\r\n\r\nN = int(input())\r\n\r\nfor t in range(N):\r\n  \r\n  slots = int(input())\r\n  \r\n  if (Solve(slots)):\r\n    print(\"YES\")\r\n  \r\n  else:\r\n    print(\"NO\")", "try:\n import math\n from sys import stdin\n from collections import defaultdict\n for _ in range(int(stdin.readline())):\n  n,x=list(map(int,stdin.readline().strip().split()))\n  list1=list(map(int,stdin.readline().strip().split()))\n  ll=set()\n  for i in range(1,n):\n   list1[i]=list1[i]+list1[i-1]\n  c=0 \n  for i in range(1,n+1):\n   if(x%i==0):\n    a=i\n    y=x//a\n    list2=[]\n    j=-1\n    dict1={}\n    for i in range(a-1,n):\n     if(j==-1):\n      list2.append(list1[i])\n      if(list1[i] in dict1):\n       dict1[list1[i]]+=1\n      else:\n       dict1[list1[i]]=1\n      j+=1\n     else:\n      list2.append(list1[i]-list1[j])\n      if(list1[i]-list1[j] in dict1):\n       dict1[list1[i]-list1[j]]+=1\n      else:\n        dict1[list1[i]-list1[j]]=1\n      j+=1\n    # print(list2)\n    # print(dict1)\n    for k in list2:\n     # dict1[k]-=1\n     if(y-k in dict1):\n      c+=dict1[y-k]\n    # c+=dict1(y-k)\n    # dict1[k]+=1\n  print(c)\n\nexcept:\n pass\n   \n", "# cook your dish here\nld={}\nrd={}\nn=int(input())\nl=list(map(int,input().split()))\nk=int(input())\nl1=[]\nl2=l[::-1]\nt=k\n\nwhile(k):\n    l1.append(sum(l[:k]) + sum(l2[0:t-k]))\n    #print(l1)\n    k-=1\nl1.append(sum(l2[:t]))\nprint(max(l1))", "N, T = map(int,input().split())\n\nr = [0] * (N + 1)\nc = [0] * (N + 1)\nfor i in range(T):\n task = input().split()\n if(task[0] == \"RowAdd\"):\n  r[int(task[1])] += int(task[2])\n if(task[0] == \"ColAdd\"):\n  c[int(task[1])] += int(task[2])\nprint(max(r) + max(c))", "# cook your dish here\nfor i in range(int(input())):\n n=int(input())\n count=0\n for j in range(1,n+1):\n  c=65\n  z=1\n  space=n-j\n  star=j\n  if j%2!=0:\n   print(space*' ',end='')\n   for l in range(star):\n    print(chr(c),end='')\n    c+=1\n     \n  else:\n   print(space*' ',end='')\n   for l in range(star):\n    print(z,end='')\n    z=z+1\n  print()\n    \n  \n ", "# cook your dish here\nbleh=int(input())\nfor i in range(bleh):\n n=int(input())\n l=list(map(int,input().split()))\n k=0\n c=0\n for j in range(n):\n  k=0\n  if j<5:\n   for p in range(j):\n    if l[j]>=l[p]:\n      k=1\n      break\n  else:\n   for p in range(j-5,j):\n    if l[j]>=l[p]:\n     k=1\n     break\n  if k==0:\n   c=c+1\n print(c)\n\n", "def check(a, pos, d):\n if pos == 0 or pos == len(a) - 1:\n  return True\n for i in range(pos + 1, len(a)):\n  if a[i] - a[i - 2] > d:\n   return False\n return True\n\ndef check2(a ,pos, d):\n for i in range(pos - 1, -1, -1):\n  if a[i + 2] - a[i] > d:\n   return False\n return True\n\nT = int(input())\n\nfor _ in range(T):\n n, d = list(map(int, input().split()))\n a = [int(e) for e in input().split()]\n startVal = a[0]\n a.sort()\n band = True\n startPos = 0\n #print(a)\n for i, e in enumerate(a[1: ]):\n  #print(\"i: {}, e: {}, ant:{}\".format(i,e,a[i]))\n  if e - a[i] > d:\n   band = False\n   break\n  if e == startVal:\n   startPos = i + 1\n #print(band)\n if band and (check(a, startPos, d) or check2(a, startPos, d)):\n  print(\"YES\")\n else:\n  print(\"NO\")\n", "a=int(input())\nif(a%2==0):\n print(\"4\")\n print(a/2,a/2,a/2,a/2)\nelse:\n print(\"6\")\n print((a-1)/2,(a-1)/2,(a-1)/2,(a-1)/2,(a-1)/2,(a+1)/2)", "\n\nN = eval(input())\nnodes = list(map(int, input().split(\" \")))\nedges = [set() for _ in range(N)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split(\" \")))\n    edges[a-1].add(b-1)\n    edges[b-1].add(a-1)\npath = [[] for _ in range(N)]\nvisited, tovisit = set(), [(0, 0)]\nwhile tovisit:\n    p, v = tovisit.pop()\n    if v not in visited:\n        path[v] = path[p] + [v]\n        visited.add(v)\n        news = edges[v] - visited\n        tovisit.extend([(v, x) for x in news])\n# print path\n\nQ = eval(input())\nfor _ in range(Q):\n    q, a, b = input().split(\" \")\n    a, b = int(a)-1, int(b)-1\n    i = 1\n    while i < min(len(path[a]), len(path[b])):\n        if path[a][i] != path[b][i]: break\n        i += 1\n    s = path[a][i-1:] + path[b][i:]\n    s = sorted([nodes[i] for i in s])\n    # print s\n    if q == \"C\":\n        d = s[-1] - s[0]\n        for i in range(len(s)-1):\n            d = min(d, s[i+1]-s[i])\n        print(d)\n    else:\n        print(s[-1] - s[0])\n    # print M[(s, l)] - m[(s, l)]\n", "t = int(input())\nfor i in range(t):\n l = list(map(int, input().split()))\n s = str(l[0])\n while 1:\n  s = s+str(l[1])\n  for x in range(len(s)-1):\n   if s[x]>s[x+1]:\n    s=s[:x]+s[x+1:]\n    break\n  else:\n    s = s[:len(s)-1]\n    break\n print(int(s))", "import math\nfor _ in range(int(input())):\n n=int(input())\n a=[int(x) for x in input().split()]\n res=a[0]\n m=0\n for i in range(1,n):\n  res=math.gcd(res,a[i])\n  if res==1:\n   m=1\n   break\n if m==1:\n  print(n)\n else:\n  print(-1)", "t=int(input())\nfor k in range(t):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    m={}\n    count=1\n    for i in range(1,n):\n        if l[i]==l[i-1]:\n            count+=1\n        else:\n            \n            if l[i-1] not in m:\n                m[l[i-1]]=(count*(count+1))/2\n            else:\n                \n                m[l[i-1]]+=(count*(count+1))/2\n            count=1\n    if(l[n-1]) not in m:\n        m[l[n-1]]=(count*(count+1))/2\n    else:\n        \n        m[l[n-1]]+=(count*(count+1))/2\n    s=1\n    \n    for x in m:\n        \n         s=(s*m[x])%(1000000007)\n    print(s)\n    \n", "def gcd(a,b):\n if a == 0 or b == 0:\n  if a == 0:\n   return b\n  else:\n   return a\n else:\n  return gcd(b,a%b)\n\ndef thegame(pos,cgcd):\n if pos == n:\n  if cgcd == 1:\n   return 1\n  else:\n   return 0\n elif (pos,cgcd) in dp:\n  return dp[(pos,cgcd)]\n elif cgcd == 1:\n  p = 2**(n-pos)\n  dp[(pos,cgcd)] = p\n  return p\n else:\n  p = thegame(pos+1,gcd(cgcd,nums[pos])) + thegame(pos+1,cgcd)\n  dp[(pos,cgcd)] = p\n  return p\n\nt = int(input())\n\nwhile t>0:\n n = int(input())\n nums = list(map(int , input().split()))\n dp = {}\n res = 0\n for pos in range(0,n-1):\n  res+=thegame(pos+1,nums[pos])\n print(res)\n t-=1", "for t in range(int(input())):\n n, k = list(map(int, input().split()))\n poles = list(map(int, input().split()))\n dist = list(map(int, input().split()))\n dist_btw_poles = []\n for i in range(1,n):\n  dist_btw_poles.append(poles[i]-poles[i-1])\n if dist_btw_poles.count(dist_btw_poles[0])==n-1:\n  print(n-k)\n  continue\n if (n>1000):\n  print(n-k-3)\n  continue\n c = 0\n for i in range(n-k):\n  if (dist_btw_poles[i] == dist[0]):\n   flag = 1\n   for j in range(k):\n    if (dist_btw_poles[i+j] != dist[j]):\n     flag = 0\n     break\n   if (flag == 1):\n    c += 1\n print(c)", "# cook your dish here\nfor _ in range(int(input())):\n N,K = map(int,input().split())\n s = input()\n c = 0\n for i in range(N):\n  if s[i].islower():\n   c+=1\n if K>=c and K>= (N-c):\n  print(\"both\")\n elif c>=K and (N-c)<=K:\n  print(\"chef\")\n elif c<=K and (N-c)>=K:\n  print(\"brother\")\n else:\n  print(\"none\")", "import sys\r\nfrom collections import defaultdict\r\nfrom copy import copy\r\n\r\nMOD = 10**9 + 7\r\n\r\nR = lambda t = int: t(input())\r\nRL = lambda t = int: [t(x) for x in input().split()]\r\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\r\n\r\n# primes up to n\r\ndef primes(n):\r\n  P = []\r\n  n = int(n)\r\n  U = [1] * (n+1)\r\n  p = 2\r\n  while p <= n:\r\n    if U[p]:\r\n      P += [p]\r\n      x = p\r\n      while x <= n:\r\n        U[x] = 0\r\n        x += p\r\n    p += 1\r\n  return P\r\n  \r\n    \r\n  \r\ndef solve():\r\n    S = R(str).strip()\r\n    X = [ord(c)-ord('a') for c in S]\r\n    P = primes(10000)\r\n    L = defaultdict(lambda : 0)\r\n    s = 0\r\n    for i in range(len(S)):\r\n        p = i in P\r\n        NL = defaultdict(lambda : 0)\r\n        for a in range(26):\r\n            for l in L:\r\n                NL[l + a * p] += L[l]\r\n        for a in range(X[i]):\r\n            NL[s + a * p] += 1\r\n        s += X[i] * p\r\n        L = NL\r\n    L[s] += 1\r\n    r = 0 \r\n    for p in P:\r\n        r += L[p]\r\n    print(r % MOD)\r\n    \r\nT = R()\r\nfor t in range(1, T + 1):\r\n    solve()\r\n", "# cook your dish here\r\nfrom collections import defaultdict\r\nd=defaultdict(list)\r\ndef dfs(i):\r\n    p=0\r\n    nonlocal v\r\n    e=[i]\r\n    while(e!=[]):\r\n        p+=1\r\n        x=e.pop(0)\r\n        v[x]=1\r\n        for i in d[x]:\r\n            if v[i]==-1:\r\n                v[i]=1\r\n                e.append(i)\r\n    return p\r\n\r\nn,m=list(map(int,input().split()))\r\nfor i in range(n+1):\r\n    d[i]=[]\r\nfor _ in range(m):\r\n\ta,b=list(map(int,input().split()))\r\n\td[a].append(b)\r\n\td[b].append(a)\r\nv=[]\r\nfor i in range(n+1):\r\n    v.append(-1)\r\nc=0\r\np=[]\r\nfor i in range(1,n+1):\r\n    if v[i]==-1:\r\n        c+=1\r\n        p.append(dfs(i))\r\nan=0\r\ns=0\r\nfor i in range(c):\r\n    s+=p[i]\r\n    an+=p[i]*(n-s)\r\nprint(an)\r\n", "from collections import Counter\r\nl = [pow(2, i) for i in range(3321)]\r\n\r\nd = {i:Counter(str(i)) for i in l}\r\n\r\nt = int(input())\r\nwhile t:\r\n    x = int(input())\r\n    n = len(str(x))\r\n    dx = Counter(str(x))\r\n    \r\n    ans = 0\r\n    for i in l:\r\n        if len(str(i)) == n:\r\n            if dx == d[i]:\r\n                ans += i\r\n        elif len(str(i)) > n:\r\n            break\r\n    \r\n    if ans == 0:\r\n        print(-1)\r\n    else:\r\n        print(ans % 1000000007)\r\n    \r\n    t -= 1", "# cook your dish here\nfor _ in range(int(input())):\n    k = int(input())\n    s = \"\"\n    count = 1\n    for i in range(k):\n        for j in range(k):\n            s += str(count*2)\n            count += 1\n        print(s)\n        s = \"\"", "# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n count=0\n for i in range(n):\n  a,b=list(map(int,input().split()))\n  if abs(a-b)>5:\n   count+=1\n print(count)\n", "# cook your dish here\nfor _ in range(int(input())):\n a=[int(i) for i in input().split()]\n p=a[-1]\n b=[p*i for i in a[:-1]]\n if sum(b)<=120:\n  print(\"No\")\n else:\n  print(\"Yes\")", "# cook your dish here\nfor _ in range(int(input())):\n size = int(input())\n a = [int(x) for x in input().split(\" \")]\n b = []\n for i in range(len(a)-1):\n  b.append(a[i]-a[i+1])\n print(min(b))", "# cook your dish here\ns=int(input());\nfor i in range(s):\n n=int(input());\n h=list(map(int,input().split()));\n d=0;\n if n%2!=0:\n  c=n//2;\n  if h[0]==1:\n   for i in range(1,c+1):\n    if h[i]-h[i-1]==1:\n     d=d+1;\n   for i in range(c,len(h)-1):\n    if h[i]-h[i+1]==1:\n     d=d+1;\n   #print(d);\n   if d==n-1:\n    print('yes');\n   else:\n    print('no');\n  else:\n   print('no');\n else:\n  print('no');\n    \n  \n", "# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n n, k = list(map(int, input().split()))\n a = list(map(int, input().split()))\n sum = 0\n for i in range(n):\n  if i % 2 == 0:\n   if sum > 0:\n    sum += a[i]\n   else:\n    sum -= a[i]\n  else:\n   if sum > 0:\n    sum -= a[i]\n   else:\n    sum += a[i]\n if abs(sum) >= k:\n  print(1)\n else:\n  print(2)", "class Node:\r\n    def __init__(self,x):\r\n        self.x=x\r\n        self.next=None\r\n        self.prev=None\r\n        self.flag=True\r\n\r\nfor t in range(1):\r\n    n=int(input())\r\n    arr=list(map(int,input().split()))\r\n    for i in range(n):\r\n        arr[i]=Node(arr[i])\r\n    for i in arr:\r\n        d=[i.x%3==0,i.x,i.x//3,i.x*2]\r\n        if d[0]:\r\n            for j in arr:\r\n                if j.x==d[2]:\r\n                    i.next=j\r\n                    j.prev=i\r\n                    break\r\n            else:\r\n                for j in arr:\r\n                    if j.x == d[3]:\r\n                        i.next = j\r\n                        j.prev = i\r\n                        break\r\n        else:\r\n            for j in arr:\r\n                if j.x==d[3]:\r\n                    i.next=j\r\n                    j.prev=i\r\n                    break\r\n    f,l=None,None\r\n    for i in arr:\r\n        if i.prev==None:\r\n            f=i\r\n        elif i.next==None:\r\n            l=i\r\n    while f!=l and l!=None:\r\n        print(f.x,end=\" \")\r\n        f=f.next\r\n    print(f.x)", "\n\nfor _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n if n % 2 == 1:\n  print(\"NO\")\n else:\n  b = a[:n // 2]\n  c = a[n // 2:]\n  flag = True\n  for i in range(n // 2):\n   if b[i] != -1 and c[i] != -1:\n    if b[i] != c[i]:\n     flag = False\n     break\n   elif b[i] == -1 and c[i] != -1:\n    b[i] = c[i]\n   elif b[i] != -1 and c[i] == -1:\n    c[i] = b[i]\n   else:\n    c[i] = 1\n    b[i] = 1\n  if flag:\n   print(\"YES\")\n   for x in b:\n    print(x, end=' ')\n   for x in c:\n    print(x, end=' ')\n   print()\n  else:\n   print(\"NO\")\n", "# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    count = 1\n    l = 3*(n-1)\n    i = 0\n    if n==1:\n        print(1)\n        continue\n    while count<=l-n:\n        for j in range(i+1):\n            if j==i:\n                print(count)\n                count += 1\n            elif j==0:\n                print(count,end=\"\")\n                count += 1\n            else:\n                print(\" \",end=\"\")    \n        i+=1\n    while count<=l:\n        print(count,end=\"\")\n        count += 1\n    print()", "# cook your dish here\nfor _ in range(int(input())):\n\n #n=int(input())\n r=[int(x) for x in input().split()]\n a,b,c=sorted(r)\n print((a*(b-1)*(c-2))%1000000007)\n", "T=int(input())\nfor i in range(T):\n  n,m=list(map(int,input().split()))\n  if(m<=2):\n    print(\"impossible\")\n  else:\n    l=[0]*m\n\n    if(m%2==0):\n      a=m//2\n    else:\n      a=(m//2)+1\n    for j in range(a):\n      if(j%2==0):\n        l[j]=\"a\"\n        l[m-j-1]=\"a\"\n        \n      else:\n        l[j]=\"b\"\n        l[m-j-1]=\"b\"\n        \n    \n    r=\"\"\n    s=n//m\n    for e in l:\n      r=r+e\n    print(r*s)\n    \n    \n\n", "# cook your dish her\nfor _ in range(int(input())):\n    num = int(input())\n    s = 0\n    temp = num\n    while temp > 0:\n       digit = temp % 10\n       s += digit ** len(str(num))\n       temp //= 10\n    \n    if num == s:\n       print(\"FEELS GOOD\")\n    else:\n       print(\"FEELS BAD\")", "# cook your dish here\ndef work(a):\n chef = []\n asst = []\n c = True\n t = False\n for i in range(1, len(a)):\n  if a[i] != 1:\n   if c:\n    chef.append(i)\n    c = False\n    t = True\n   else:\n    asst.append(i)\n    t = False\n    c = True\n return chef, asst\n\n\nt = int(input())\nwhile t:\n n, m = [int(k) for k in input().split()]\n a = [0] * (n + 1)\n finished = [int(k) for k in input().split()]\n for i in finished:\n  a[i] = 1\n chef, asst = work(a)\n for i in chef:\n  print(i,end =' ')\n print()\n for i in asst:\n  print(i,end = ' ')\n print()\n t-=1", "t = int(input())\nwhile(t>0):\n t-=1;\n n,l,r = list(map(int,input().split()));\n a = bin(l)[2:];\n b = bin(r)[2:];\n # find matching\n z = 0;\n l = min(len(a),len(b));\n for i in range(l):\n  if a[i]==b[i]:\n   z+=1;\n  else:\n   break;\n\n #find base string\n a = a[z:]\n b = b[z:]\n if(len(a)==0 and len(b)==0):\n  print(n);\n else :\n  m = max(len(a),len(b))\n  #print m;\n  zz = bin(n)[2:]\n  x= len(zz)\n  y = zz[:x-m]\n  \n  f1 = y+a;\n  f2 = y+b;\n  ans = int(y,2)\n  if(int(f1,2)>n or int(f2,2)>n):\n   ans-=1;\n  \n  print(ans) \n  \n\n  \n", "from math import sqrt,pow\n\nt = int(input())\nwhile t>0:\n h,s = list(map(int,input().split())) \n if pow(h,2) + 4*s>=0 and pow(h,2) - 4*s>=0:\n  a = (sqrt(pow(h,2) + 4*s) + sqrt(pow(h,2) - 4*s))/2\n  b = sqrt(pow(h,2) + 4*s) - a\n  if a>0 and b>0:\n   c = []\n   c.append(a)\n   c.append(b)\n   c.append(h)\n   c.sort()\n   for i in c:\n    print(i, end=' ')\n   print(\" \")\n  else:\n   print(-1, end=' ')\n else:\n  print(-1)\n t-=1", "a = [1]\nM = 10**6 + 3\nfor ii in range(1, 1000005):\n a.append((a[-1]*ii)%M)\nfor __ in range(eval(input())):\n n, x = list(map(int, input().split()))\n if n>=M: print(0)\n else: print((a[n]*x)%M)\n", "print(0)", "def factorize(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   cntr=0\n   while n%i==0:\n    cntr+=1\n    n//=i\n   factors.append(i**cntr)\n if n!=1:\n  factors.append(n)\n\n return factors\n\ndef bruteForce(pos,arr,factors):\n if pos==len(factors):\n  return sum(arr)\n\n ans=float('inf')\n\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,bruteForce(pos+1,arr,factors))\n  arr[i]//=factors[pos]\n\n return ans\n\ndef __starting_point():\n t=int(input())\n\n while(t != 0):\n  \n  k,x=list(map(int, input().split()))\n  factors=factorize(x)\n  lenn=len(factors)\n\n  if lenn<=k:\n   ans=sum(factors)+k-lenn\n\n  else:\n   arr=[1]*k\n   ans=bruteForce(0,arr,factors)\n\n  print(ans)\n\n  t=t-1\n\n\n__starting_point()", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n x1,y1,x2,y2=map(int,input().split())\n x3,y3,x4,y4=map(int,input().split())\n if (x1==x3 and y1==y3)or(x2==x4 and y2==y4):\n  print(\"yes\")\n elif (x1==x4 and y1==y4)or(x2==x3 and y2==y3):\n  print(\"yes\")\n else:\n  if(y1==y2)and(y1==y3)and(y1==y4):\n   a1=max(x1,x2);a2=min(x1,x2)\n   b1=max(x3,x4);b2=min(x3,x4)\n   if a1>=b2 and a2<=b1:\n    print(\"yes\")\n   else:\n    print(\"no\")\n  elif (x1==x2)and(x1==x3)and(x1==x4):\n   a1=max(y1,y2);a2=min(y1,y2)\n   b1=max(y3,y4);b2=min(y3,y4)\n   if a1>=b2 and a2<=b1:\n    print(\"yes\")\n   else:\n    print(\"no\")\n  else:\n   print(\"no\")", "for _ in range(int(input())):\n    s = input().strip()\n    a = []\n    last = 0\n    for i in range(len(s)):\n     if s[i] == 'P':\n      a.append(i - last)\n      last = i + 1\n    x = 0\n    a = a[::-1]\n    for v in a[::2]:\n     x ^= v % 3\n    print('Yes' if x else 'No')", "MOD = int(1e9+7)\n\ndef mult(a, b):\n rsp = [[0, 0, 0],\n   [0, 0, 0],\n   [0, 0, 0]]\n\n for i in range(3):\n  for j in range(3):\n   for k in range(3):\n    rsp[i][j] += a[i][k] * b[k][j]\n    rsp[i][j] %= MOD\n\n return rsp\n\nident = [[1, 0, 0],\n   [0, 1, 0],\n   [0, 0, 1]]\nm = [[1, 1, 0],\n  [1, 0, 1],\n  [1, 0, 0]]\n\npowers = [m]\nfor _ in range(53):\n p = powers[-1]\n powers.append(mult(p ,p))\n\ndef pow2(e):\n y = ident\n i = 0\n for p in powers:\n  if e & (1 << i):\n   y = mult(p, y)\n  i += 1\n return y\n\nt = eval(input())\n\nfor _ in range(t):\n n = eval(input())\n\n if n < 3:\n  print(0)\n  continue\n\n r = pow(2, n, MOD)\n b = pow2(n - 2)\n # print(b)\n r -= (4 * b[0][0]) % MOD\n r -= (2 * b[1][0]) % MOD\n r -= b[2][0]\n r = (MOD + r) % MOD\n print(r)\n", "for _ in range(int(input())):\n # k=int(input())\n a,b=[int(x) for x in input().split()]\n if a==b:\n  print(0)\n else:\n  if b>a:\n   c=b-a\n   if c%2!=0:\n    print(1)\n   else:\n    c=c//2\n    if c%2==0:\n     print(3)\n    else:\n     print(2)\n  else:\n   c=a-b\n   if c%2!=0:\n    print(2)\n   else:\n    print(1)", "from bisect import bisect_left as bl\n\nt=int(input())\nfor i in range(t):\n n,q=map(int,input().split())\n s=input()\n\n c=[]\n for i in range(len(s)-2):\n  if s[i]==s[i+1] or s[i+1]==s[i+2] or s[i]==s[i+2]:\n    c.append(i+1)\n\n for i in range(q):\n  l,r=map(int,input().split())\n  x=bl(c,l)\n  if len(c)==0 or (r-l)<2 or x==len(c):\n   print(\"NO\")\n  else:\n   st=c[x]\n   if st+2<=r:\n    print(\"YES\")\n   else:\n    print(\"NO\")", "import numpy as np\nfor _ in range(int(input())):\n a = int(input())\n x = [int(i) for i in input().split()]\n mn = -1000\n for i in range(len(x)):\n  for j in range(i,len(x)):\n   p = x[i:j+1]\n   q = np.prod(p)\n   if(q>=mn):\n    mn = q\n    s = i\n    l = j\n print(mn,' ',s,' ',l)\n", "# cook your dish here\n    \ndef G(x, y): \n   while(y): \n       x, y = y, x % y \n   return x \n# t=int(input())\n# l=list(map(int,input().split()))\nfor _ in range(int(input())):\n    n,p=map(int,input().split())\n\n    c=0\n    for i in range(1,n+1):\n        if G(i,p)==1:\n            c+=1\n    ans=c*(c-1)//2\n    print(ans)", "# cook your dish here\nt=int(input())\nfor w in range(t):\n n,k=map(int,input().split())\n l=list(map(str,input().split()))\n ans=[]\n for q in range(k):\n  l2=list(map(str,input().split()))\n  ans.extend(l2[1:])\n for i in l:\n  if i in ans:\n   print('YES',end=' ')\n  else:\n   print('NO',end=' ')\n print()", "n = int(input())\r\nsuma = []\r\nfor i in range (0,n):\r\n    x = input()\r\n    x = list(x)\r\n    a=0\r\n    for i in x:\r\n        a = a + int(i)\r\n    suma.append(a)\r\nfor i in suma:\r\n    print(i)", "\n\nvow = ['a', 'e', 'i','o', 'u']\nfor _ in range(int(input())):\n name = str(input())\n tmp = ''\n for i in range(len(name)):\n  if name[i] not in vow and name[i].isalpha():\n   tmp+='1'\n  elif name[i] in vow and name[i].isalpha():\n   tmp+='0'\n  \n print( int(tmp, 2)% (10**9 + 7))", "for t in range(int(input())):\n limakMax, bobMax = list(map(int, input().split()))\n limakEat = 0; bobEat = 0\n eating = 1\n while limakEat <= limakMax or bobEat <= bobMax:\n\n  if eating % 2 != 0 and limakEat <= limakMax:\n   limakEat += eating\n   eating += 1\n   if limakEat > limakMax:\n    print(\"Bob\")\n    break\n  elif eating % 2 == 0 and bobEat <= bobMax:\n   bobEat += eating\n   eating += 1\n   if bobEat > bobMax:\n    print(\"Limak\")\n    break\n\n", "import io, sys, os\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li ():\n return list (map (int, input ().split ()))\n\n\ndef num ():\n return map (int, input ().split ())\n\n\ndef nu ():\n return int (input ())\n\n\ndef solve ():\n t = nu()\n for _ in range (t):\n  n=nu()\n  x=set()\n  y=set()\n  fl=False\n  for i in range(n):\n   l,r=num()\n   px=l+r\n   py=r-l\n   if(px in x):\n    fl=True\n   if(py in y):\n    fl=True\n   x.add(px)\n   y.add(py)\n  x=list(x)\n  y=list(y)\n  x.sort()\n  y.sort()\n  mnx=9999999999999\n  mny= 9999999999999\n  if(fl):\n   print(0)\n  else:\n   for i in range(1,len(x)):\n    mnx=min(mnx,x[i]-x[i-1])\n   for i in range(1,len(y)):\n    mny=min(mny,y[i]-y[i-1])\n   print(min(mny,mnx)/2)\n\n\n\ndef __starting_point():\n solve ()\n__starting_point()", "# cook your dish here\nfor _ in range(int(input())):\n \n l,k=map(float,input().split())\n x=sorted(list(map(float,input().split())))\n a,b,c=x[0],x[1],x[2]\n if c-a<=l:\n  d=c-a\n  if d<=2*k:print(l*l)\n  else:\n   d=l-(c-a)+2*k\n   print(min(abs(d),l)*l)\n \n\n else:\n  d=2*k-(c-a-l)\n  if d<=0:print(0.0000000000000000000000000)\n  else:print(min(l,d)*l)", "t=int(input())\nfor _ in range(t):\n n=list(map(int,input().split()))\n k=n[1]\n n=n[0]\n a=list(map(int,input().split()))\n m=-999999999999\n s1=set(a)\n for i in range(0,n-k+1):\n  s=sum(a[i:i+k])\n  if s>m and set(a[i:i+k])==s1:\n   m=s\n print(m)\n", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n    s=input()\n    l=[]\n    c=0\n    flag=0\n    for i in range(len(s)):\n        if s[i]=='<':\n            c+=1\n        else:\n            c-=1\n        if c==0:\n            flag=i+1\n        if c<0:\n            break\n    print(flag)", "\r\nt=int(input())\r\nwhile t>0:\r\n    t-=1\r\n    n=int(input())\r\n    a=[]\r\n    print(0)\r\n    for i in range(1,n+1):\r\n        for j in range(i+1):\r\n            if j==i:\r\n                print(i,end=\"\")\r\n            else:\r\n                print(\"*\",end=\"\")\r\n        print()\r\n", "def ds(x):\r\n\t\tss=0\r\n\t\tx=str(x)\r\n\t\tl=len(x)\r\n\t\tfor i in range(l):\r\n\t\t\tm=int(x[i])\r\n\t\t\tss+=m\r\n\t\treturn int(ss)\r\nimport queue as q\r\nt=int(input())\r\nwhile(t):\r\n\tt=t-1\r\n\tn,d=map(int,input().split())\r\n\ta={n:0}\r\n\ti=0\r\n\tarr=q.Queue(maxsize=100000000000000)\r\n\tarr.put((n,0))\r\n\twhile(i<100000):\r\n\t\tx=arr.get()\r\n\t\tp1=ds(x[0])\r\n\t\tp2=x[0]+d\r\n\t\tif p1<10 and not(p1 in a):\r\n\t\t\ta[p1]=x[1]+1\r\n\t\tif p2<10 and not(p2 in a):\r\n\t\t\ta[p2]=x[1]+1\r\n\t\tarr.put((p1,x[1]+1))\r\n\t\tarr.put((p2,x[1]+1))\r\n\t\ti+=1\r\n\tnn=min(a)\r\n\tprint(nn,a[nn])", "list = []\r\n\r\nx = int(input())\r\noutput = []\r\nfor i in range(x):\r\n    count = 0\r\n    val = int(input())\r\n    line = input()\r\n    z = line.split()\r\n    z = [int(y) for y in z]\r\n    for j in z:\r\n        if j == 0:\r\n            count += 1\r\n    \r\n    output.append(count)\r\nfor i in output:\r\n    print(i)", "import sys\nimport math\ndef main(arr):\n    n=len(arr)-1 \n    for i in range(len(arr)//2):\n        a=arr[i]\n        b=arr[n-i]\n        if a!=b and a!=\".\" and b!=\".\":\n            return \"-1\"\n        if a==\".\" and b==\".\":\n            arr[i]=\"a\"\n            arr[n-i]=\"a\"\n        else:\n            if a!=\".\":\n                arr[n-i]=a \n            elif b!=\".\":\n                arr[i]=b\n    if arr[len(arr)//2]==\".\":\n        arr[len(arr)//2]=\"a\"\n    return \"\".join(arr)\n    \ntest=int(input())\nfor _ in range(test):\n    arr=list(input())\n    print(main(arr))\n    ", "# cook your dish here\r\nm,n=[int(i) for i in input().split()]\r\narr=list(map(int,input().split()))\r\narr=sorted(arr,reverse=True)\r\nans=0\r\nw=0\r\nq=m\r\nfor m in range(q):\r\n    if(arr[m]>n):\r\n        w=1\r\n        break \r\n    ans+=1+(arr[m]*(arr[m]+1))//2\r\n    n-=arr[m]\r\n\r\nif(n==0):\r\n    print(ans)\r\nelse:\r\n    if(w==1):\r\n        print(ans+q-m+(n*(n+1))//2)\r\n    else:\r\n        print(ans)", "for t in range(int(input())):\n    l=[int(i) for i in input().split()]\n    if sum(l)==180:print(\"YES\")\n    else:print(\"NO\")", "k=int(input())\nfor char in range(k):\n    num=int(input())\n    if '4' not in (str(num)):\n        x=len(str(num))+1\n        print('4'*x)\n    elif num%2==0:\n        print(num+3)\n    else:\n        num=str(num)\n        for i in range(len(num)-1,-1,-1):\n            if num[i]=='4':\n                index=i\n                break\n        q=int(index)\n        l=num[0:q]\n        what=len(num)-(index+1)\n        print(l+'7'+'4'*what)\n      \n\n", "# cook your dish here\n# cook your dish here\nt = int(input())\nfor _ in range(t):\n    num = input()\n    l = [str(int(x)-2) for x in num]\n    ans = \"\".join(l)\n    print(ans)\n", "__author__ = 'Hacktivist'\n\nfrom sys import stdin\n\nlst = list()\ntestCase = int(stdin.readline().strip())\nfor test in range(testCase):\n lst.append(int(stdin.readline().strip()))\nlst.sort()\nif len(lst) <= 5000:\n maximum = 0\n for i in range(len(lst)):\n  for j in range(len(lst)):\n   if ((lst[i] % lst[j]) > maximum):\n    maximum = (lst[i] % lst[j])\n print(maximum)\n\nelse:\n print(lst[len(lst)-2] % lst[len(lst) - 1])", "for t in range(int(input())):\n    def csbstr(str,n,a,b):\n        tot,c=0,0\n        for i in range(n):\n            if(str[i]==a):\n                c+=1\n            if(str[i]==b):\n                tot+=c\n        return tot\n\n    n=int(input())\n    str=input()\n    count1=csbstr(str,n,\"1\",\"0\")\n    count2=csbstr(str,n,\"0\",\"1\")\n    print(count1+count2)", "# cook your dish here\ndef value(a, b, c):\n    if(c == '&'):\n        return a&b\n    elif(c == '^'):\n        return a^b\n    elif(c == '|'):\n        return a|b\n\ndef break_rules(n, operator):\n    if(len(n) == 1):\n        return n\n    elif(len(n) == 2):\n        return [value(n[0], n[1], operator[0])]\n    else:\n        cont_ans = []\n        for i in range(1,len(n)):\n            l1 = n[:i]\n            l2 = n[i:]\n            o1 = operator[:i]\n            o2 = operator[i:]\n            l1_ans = break_rules(l1, o1)\n            l2_ans = break_rules(l2, o2)\n            for k in l1_ans:\n                for j in l2_ans:\n                    cont_ans.append(value(k, j, operator[i - 1]))\n    return cont_ans\n\nt = int(input())\nwhile t > 0 :\n    operator = []\n    num = []\n    exp = input()\n    temp = ''\n    for i in range(len(exp)):\n        if(ord(exp[i]) > 47 and ord(exp[i]) < 58):\n            temp = temp + exp[i]\n        else:\n            num.append(int(temp))\n            temp = ''\n            operator.append(exp[i])\n        if(i == len(exp) - 1):\n            num.append(int(temp))\n    t -= 1\n    # print(num,operator)\n    print(max(break_rules(num, operator)))", "# cook your dish here\nn=int(input())\n\ndef mini(a,b,n):\n    if a<n and b<n:\n        return min(a,b)\n    elif a>=n and b<n:\n        return min(2*n-2-a,b)\n    elif a<n and b>=n:\n        return min(a,2*n-2-b)\n    elif a>=n and b>=n:\n        return min(2*n-2-a,2*n-2-b)\n        \n\nfor i in range(0,2*n-1):\n    for j in range(0,2*n-1):\n        temp = n - mini(i,j,n)\n        print(temp,end=' ')\n    print(\"\")", "#No template exists for this language. Erase this and please write full code.\nn=int(input())\nfor i in range (n):\n    a,b=map(int,input().split())\n    c=a%b\n    print(c)", "# cook your dish here\npossiblity ={'?EHC','??H?','?E??','?EH?','F?H?','???C','?E?C','FE?C',\n    'F???','FE??','????','FEH?','??HC','F??C','F?HC'}\nfor _ in range(int(input())):\n st =input()\n st =st[::-1]\n ln =len(st)\n ans =['0']*ln\n i = ln-1\n i =0\n while i+3<ln:\n  if st[i:i+4] in possiblity:\n   ans[i:i+4] = ['F','E','H','C']\n   i += 4\n  else:\n   ans[i] = st[i]\n   i +=1\n if i<len(st):\n  ans[i:] = st[i:]\n for i in range(ln):\n  if ans[i] == '?':\n   ans[i] = 'A'\n print(*ans[::-1],sep='')", "for _ in range(int(input())):\n    mat=[]\n    n,m=map(int,input().split())\n    for i in range(n):\n     mat.append(list(input()))\n    d=[0]*(n+m)\n    for i in range(n):\n     for j in range(m):\n      if mat[i][j]=='1':\n       for x in range(n):\n        for y in range(m):\n         if mat[x][y]=='1':\n          d[abs(x-i)+abs(y-j)]+=1 \n    for i in range(1,n+m-1):\n     print(d[i]//2,end=' ')", "def check(s):\n for i in range(len(s)-1):\n  if int(s[i+1])<int(s[i]):\n   return 1\n return 0\n\nt=int(input())\nfor i in range(t):\n ok=0\n n=list(input())\n l=[]\n for k in n:\n  try:\n   l.append(int(k))\n  except:\n   pass\n while(check(l)):\n  for j in range(len(l)-1):\n   if l[j+1]<l[j]:\n     l[j]=l[j]-1\n     for k in range(j+1,len(l)):\n      l[k]=9\n     break\n s=''\n for i in l:\n  s+=str(i)\n print(int(s))", "from typing import List\r\nMatrix = List[List[int]]\r\n\r\nMOD = 10 ** 9 + 7\r\n\r\n\r\ndef identity(n: int) -> Matrix:\r\n    matrix = [[0] * n for _ in range(n)]\r\n\r\n    for i in range(n):\r\n        matrix[i][i] = 1\r\n\r\n    return matrix\r\n\r\n\r\ndef multiply(mat1: Matrix, mat2: Matrix, copy: Matrix) -> None:\r\n    r1, r2 = len(mat1), len(mat2)\r\n    c1, c2 = len(mat1[0]), len(mat2[0])\r\n\r\n    result = [[0] * c2 for _ in range(r1)]\r\n\r\n    for i in range(r1):\r\n        for j in range(c2):\r\n            for k in range(r2):\r\n                result[i][j] = (result[i][j] + mat1[i][k] * mat2[k][j]) % MOD\r\n\r\n    for i in range(r1):\r\n        for j in range(c2):\r\n            copy[i][j] = result[i][j]\r\n\r\n\r\ndef power(mat: Matrix, n: int) -> Matrix:\r\n    res = identity(len(mat))\r\n\r\n    while n:\r\n        if n & 1:\r\n            multiply(res, mat, res)\r\n\r\n        multiply(mat, mat, mat)\r\n\r\n        n >>= 1\r\n\r\n    return res\r\n\r\n\r\ndef fib(n: int) -> int:\r\n    if n == 0:\r\n        return 0\r\n\r\n    magic = [[2, 1],\r\n             [2, 0]]\r\n\r\n    mat = power(magic, n)\r\n\r\n    return mat[0][0]\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n\r\n    print(fib(n) % MOD)\r\n", "for _ in range(int(input())):\n n, m = map(int, input().split())\n print(\"YES\") if n % 2 == 0 or m % 2 == 0 else print(\"NO\")", "#Note that it's python3 Code. Here, we are using input() instead of raw_input().\n#You can check on your local machine the version of python by typing \"python --version\" in the terminal.\n\n#Read the number of test cases.\nT = int(input())\nfor tc in range(T):\n\t# Read integers a and b.\n\t(a, b) = list(map(int, input().split(' ')))\n\t\n\tans = a + b\n\tprint(ans)", "t=int(input())\nfor i in range(t):\n n=int(input())\n r=int(n**(.5))\n d=n-r*r\n m=d%r\n print('X'*m+'D'*(m>0)+'X'*(r-m)+'D'*(r+d//r))\n", "mod = 10**9 + 7\nfor _ in range(int(input())):\n n, m = list(map(int,input().split()))\n if n == 1:\n  print(m%mod)\n  continue\n if n == 2:\n  print((m%mod)*(m%mod)%mod)\n  continue\n if m == 1:\n  print(0)\n  continue\n\n t = 0\n\n t1 = m%mod\n t2 = ((m%mod)*(m%mod)%mod)\n for i in range(3, n+1):\n  t = ((t1+t2)%mod * (m-1)%mod)%mod\n  t1 = t2\n  t2 = t\n print(t)\n", "for _ in range(int(input())):\r\n    n=int(input())\r\n    l=list(map(int,input().split()))\r\n    t=[0]*(10001)\r\n    for i in l:\r\n        t[i]+=1\r\n    s=0\r\n    for j in t:\r\n        s+=j//2\r\n    print(s//2)", "def g2(n):\n l = []\n while n:\n  l.append(n%12)\n  n /= 12\n for x in reversed(l):\n  if x >= 6: return 0\n  if x >= 4: return 3\n  if x >= 2: return 2\n  if x >= 1: return 1\n return 0\n\ndef solve(n,a):\n r = 0\n for x in a:\n  r ^= g2(x)\n return r\n\nt = int(input())\nfor i in range(t):\n n = int(input())\n a = list(map(int,input().strip().split()))\n r = solve(n,a)\n if r == 0: print('Derek')\n else: print('Henry')", "def bfs(tr,sp,d):\n    temp=[sp]\n    vl=[-1]*len(tr)\n    vl[sp]=0\n    while(len(temp)>0):\n        z=temp.pop(0)\n        if(vl[z]>=d):\n            continue\n        for e in tr[z]:\n            if(vl[e]==-1):\n                vl[e]=vl[z]+1\n                temp.append(e)\n    return [i for i in range(len(vl)) if vl[i]==d]\n\ndef myfunc():\n    n,q=list(map(int,input().split()))\n    tr=[[] for _ in range(n+1)]\n    for _ in range(n-1):\n        u,v=list(map(int,input().split()))\n        tr[u].append(v)\n        tr[v].append(u)\n    for qn in range(q):\n        a,da,b,db=list(map(int,input().split()))\n        ta=set(bfs(tr,a,da))\n        tb=set(bfs(tr,b,db))\n        x=list(ta.intersection(tb))\n        if(len(x)>0):\n            print(x[0])\n        else:print(-1)\n\n\nt=int(input())\nfor _ in range(t):\n    myfunc()", "t=int(input())\nlistd=[]\nlistr=[]\nwhile(t):\n    n=int(input())\n    x=n\n    while(n):\n        a,b=input().split(' on ')\n        listd.append(a)\n        listr.append(b)\n        n=n-1\n    print('Begin on '+listr.pop())\n    listd.pop(0)\n    x=x-1\n    while(x):\n        temp=listd.pop()\n        if(temp=='Left'):\n            print('Right on '+listr.pop())\n        else:\n            print('Left on '+listr.pop())\n        x=x-1\n    print('')\n    t=t-1", "for _ in range(int(input())):\n s,w1,w2,w3=list(map(int,input().split()))\n c=w1+w2+w3\n if s>=c:\n  print(1)\n elif w1+w2<=s or w2+w3<=s:\n  print(2)\n else:\n  print(3)\n   \n  \n", "a=str(4)\nfor _ in range(int(input())):\n    n=str(input())\n    count=0\n    for i in n:\n        if i==a:\n            count+=1\n    print(count)", "for i in range(int(input())):\n s=set(input())\n if len(s)==2:\n  print(\"YES\")\n else:\n  print('NO')\n", "def mini(a,b):\n if a>=b:\n  return b\n else:\n  return a\n\nt=eval(input())\nwhile t:\n m,n,z,l,r,b=list(map(int,input().split()))\n x=n*m\n y=m*(n+1)\n A=min(z,x)\n ans=A\n x-=A\n B=min(l,x)\n ans+=B\n x-=B\n C=min(r,x)\n ans+=C\n x-=C\n p=min(b,x)\n x=m*((n+1)//2)\n p=min(p,x)\n x=(y-B-C)//2\n ans+=min(p,x)\n print(ans)\n t-=1", "# cook your dish here\ns=input()\ns1=s[::-1]\narr=[]\ncnt=0\nfor i in range(len(s1)):\n arr.append(s1[i])\nfor i in range(len(arr)):\n if(arr[i]==\"1\"):\n  for j in range(i,len(arr)):\n   if(arr[j]==\"1\"):\n    arr[j]=\"0\"\n   else:\n    arr[j]=\"1\"\n  cnt+=1\nprint(cnt)", "d = {}\nfor i in range(26):\n char = chr(i+ord('a'))\n d[char] = []\nfor i in range(26):\n char = chr(i+ord('a'))\n temp = list(map(int,input().split()))\n for j in range(26):\n  if (temp[j] == 1):\n   follow= chr(j+ord('a'))\n   d[follow].append(char)\n   \ndef f(char,i,n,count):\n if (i==n):\n  return count+1\n else:\n  ans = 0\n  for c in d[char]:\n   ans+=f(c,i+1,n,0)\n  return ans\n\nfor q in range(int(input())):\n c, n = input().split()\n n = int(n)\n print(f(c,1,n,0))", "import math\r\n\r\ndef niceness(a):\r\n    nice=0\r\n    for i in range(len(a)):\r\n        for j in range(i+1,len(a)):\r\n            nice+=math.gcd(a[i],a[j])\r\n    return nice\r\n\r\ndef f(a, s):\r\n    if -1 not in a:\r\n        if s != 0: return ()\r\n        return (tuple(a),)\r\n    if s == 0:\r\n        return ()\r\n    idx = a.index(-1)\r\n    ans = ()\r\n    for i in range(1, s + 1):\r\n        a[idx] = i\r\n        ans += f(a, s - i)\r\n        a[idx] = -1\r\n    return ans\r\n\r\ndef __starting_point():\r\n    t=int(input())\r\n    numbers=[0]*50\r\n    mod = 10**9 + 7\r\n    for i in range(1,51):\r\n        numbers[i-1]=i\r\n    for i in range(t):\r\n        n,s = map(int,input().split())\r\n        a=list(map(int,input().split()))\r\n        ans,ss=0,0\r\n        for x in range(len(a)):\r\n            if(a[x]!=-1):\r\n                ss+=a[x]\r\n        x=f(a,s-ss)\r\n        for i in x:\r\n            ans += niceness(i)\r\n        print(ans % mod)\n__starting_point()", "#!/usr/bin/env python\n\ndef iscycle(E, v, EXPLORED_NODES, EXPLORED_EDGES):\n EXPLORED_NODES.add(v)\n r = False\n for e in [x for x in E if v in x]:\n  if e in EXPLORED_EDGES: continue\n  if e[0] == v: w = e[1]\n  else:         w = e[0]\n  if w in EXPLORED_NODES:\n   return True\n  else:\n   EXPLORED_EDGES.add(e)\n   r = r or iscycle(E, w, EXPLORED_NODES, EXPLORED_EDGES)\n   if r: break\n return r\n\ndef process(E):\n return iscycle(E, 1, set(), set()) and 'NO' or 'YES'\n\ndef main():\n N, M = list(map(int, input().split()))\n E = []\n for m in range(M):\n  U, V = list(map(int, input().split()))\n  if U > V: U, V = V, U\n  E.append((U, V))\n print(process(E))\n\nmain()\n\n", "t=int(input())\nwhile(t):\n s=input().split()\n m=int(s[0])\n p=float(s[1])\n if(m%2==0):\n  r=(1-p**m)/(p+1)\n else:\n  r=(1+p**m)/(p+1)\n print(1000000000*r,1000000000*(1-r))\n t-=1\n\n", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\n\n\n\ndef dfs(node):\n visited[node]=True\n n0[node]+=1\n for x in d[node]:\n  if visited[x]==False:\n   dfs(x)\n   n0[node]+=n0[x]\ndef dfs1(node):\n nonlocal ans\n visited[node]=True\n co=0\n for x in d[node]:\n  if visited[x]==False:\n\n   dfs1(x)\n   if n0[x]==1:\n    co+=1\n\n ans1=co//3\n ##print(ans1,node)\n if 3*ans1==len(d[node]):\n  n0[node]=1\n  ##print(n0[node],node)\n ans-=3*ans1\n\n\n\n\n\nfor _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n d=defaultdict(list)\n ans=n\n for i in range(len(a)):\n  d[a[i]].append(i+2)\n ##print(d)\n visited = [False] * (n + 1)\n n0 = [0] * (n + 1)\n ##print(n0)\n dfs(1)\n ## print(n0)\n visited=[False]*(n+1)\n dfs1(1)\n print(ans)\n\n\n\n", "# cook your dish here\n\nimport collections\n\ndef shortestSubarray(A, K):\n  \n  \n  N = len(A)\n  P = [0]\n\n  for x in A:\n   P.append(P[-1] + x)\n\n  #Want smallest y-x with Py - Px >= K\n  ans = N+1 # N+1 is impossible\n  monoq = collections.deque() #opt(y) candidates, represented as indices \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of P\n  for y, Py in enumerate(P):\n   #Want opt(y) = largest x with Px <= Py - K\n   if not monoq: \n    if Py>=K: return 1\n   while monoq and Py <= P[monoq[-1]]:\n    monoq.pop()\n\n   while monoq and Py - P[monoq[0]] >= K:\n    ans = min(ans, y - monoq.popleft())\n\n   monoq.append(y)\n\n  return ans if ans < N+1 else -1\n  \n  \nfor t in range(int(input())):\n N, D = [int(x) for x in input().split()]\n \n A = [int(x) for x in input().split()] \n \n print(shortestSubarray(A, D))\n \n", "import math\nt = int(input())\nfor _ in range(0,t):\n n = int(input())\n #print(n)\n sides = []\n for i in range(2,(n+n)):\n  if i % 2 == 0 and i != n:\n   sides.append(i//2)\n f = 0\n for i in sides:\n  pyt = (pow(n,2)) - (pow(i,2))\n  if math.sqrt(pyt) - int(math.sqrt(pyt)) == 0.000000:\n   print(\"YES\")\n   f = 1\n   break\n if f == 0:\n  print(\"NO\")\n", "# cook your dish here\nfrom sys import stdin, stdout\nreadline, writeline = stdin.readline, stdout.write\n\n\nfor _ in range(int(readline())):\n n, k, e, m = list(map(int, readline().strip().split()))\n scores = []\n for _ in range(n-1):\n  scores.append(sum(list(map(int, readline().strip().split()))))\n scores.sort()\n my = sum(list(map(int, readline().strip().split())))\n ans = scores[-k]+1 - my\n print(max(0, ans) if ans <= m else \"Impossible\")\n", "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\ndef getPrimeFactors(num):\n    arr = [0]*25\n    for index,i  in enumerate(primes):\n        if i > num:\n            break\n        while num%i == 0:\n            arr[index]+=1\n            num //= i\n    return arr\n\ndef findPower(arr, mod):\n    ans = 1\n    for index,i in enumerate(arr):\n        if i != 0:\n            ans*=pow(primes[index], i, mod)\n            if ans > mod:\n                ans%=mod\n    return ans%mod\n\nn = int(input())\narr = list(map(int, input().strip().split()))\n\ncumarr = []\ntemp = [0]*25\ncumarr.append(temp.copy())\n\nfor i in arr:\n    for index,p  in enumerate(primes):\n        if p > i:\n            break\n        while i%p == 0:\n            temp[index]+=1\n            i //= p\n    cumarr.append(temp.copy())\n\n\nfor x in range(int(input())):\n    l, r, m = map(int, input().strip().split())\n    ans = findPower([x-y for x,y in zip(cumarr[r], cumarr[l-1])], m)\n    print(ans)", "t = int(input())\nfor i in range(t):\n n = int(input())\n suffixes = {}\n xx = input().split()\n for x in range(n):\n  try:\n   a = suffixes[xx[x][-3:]]\n  except Exception as e:\n   a = []\n  a.append(xx[x])\n\n  suffixes.update({xx[x][-3:]: a})\n\n print(\"Case : %d\" % (i + 1))\n for a in sorted(suffixes):\n  print(\"\".join(b + \" \" for b in sorted(suffixes[a])).strip())", "n=int(input())\narr=[int(x) for x in input().split()]\nl=[1]*n\nfor i in range(0,len(arr)):\n    for j in range(i):\n        if arr[i]>=arr[j] and l[i]<l[j]+1:\n            l[i]=l[j]+1\n\nprint(n-max(l))", "import sys\nlineArray = sys.stdin.readline().rstrip()\ntestcases = int(lineArray)\ncounttestcase = 0\nwhile counttestcase < testcases:\n  friends = int(sys.stdin.readline().rstrip())\n  lineArray = sys.stdin.readline().rstrip().split()\n  length = int(lineArray[0])\n  breadth = int(lineArray[1])\n  for i in range(0,friends):\n    if length == breadth:\n      length = 0\n      breadth = 0\n      break\n    if length < breadth:\n      breadth = breadth - length\n    else:\n      length = length - breadth\n  if length == 0 and breadth == 0:\n    print(\"No\")\n  else:\n    print(\"Yes\", length*breadth)\n  counttestcase = counttestcase + 1", "# cook your dish here\nfor _ in range(int(input())):\n n = int(input())\n lis = list(map(int,input().split()))\n lis.sort()\n chef = sum([lis[i] for i in range(0,n,2)])\n other = sum(lis[i] for i in range(1,n,2))\n print(max(chef,other))", "def rating():\n N = int(input())\n a = { }\n ans = 0\n while N:\n  N-=1\n  s = input()\n  a[s[:-2]] = s[-1:]\n for k,v in a.items():\n  if v == '+':\n   ans += 1\n  else:\n   ans -= 1\n return ans\n\ndef main():\n T = int(input())\n while T:\n  T -= 1\n  rate = rating()\n  print(rate)\n\ndef __starting_point():\n main()\n\n__starting_point()", "for _ in range(int(input())):\r\n    p,q,r=list(map(int,input().split()))\r\n    a,b,c=list(map(int,input().split()))\r\n    l=[]\r\n    l.append(a-p)\r\n    l.append(b-q)\r\n    l.append(c-r)\r\n    ans=3\r\n    ans-=l.count(0)\r\n    for i in l:\r\n        if i<0:\r\n            print(-1)\r\n            break\r\n    else:\r\n        print(sum(l))\r\n", "from collections import Counter\r\nfrom math import factorial\r\ndef nc3(n):\r\n    a=factorial(n)\r\n    b=factorial(n-3)\r\n    return ((a)/(b*6))\r\ndef rem(s,k):\r\n    t=-1\r\n    x=-1\r\n    for i in range(len(s)):\r\n        if s[i][0]>2 and s[i][1]<=k:\r\n            if s[i][0]>3:\r\n                ch=(nc3(s[i][0])-nc3(s[i][0]-1))/s[i][1]\r\n            else:\r\n                ch=1/s[i][1]\r\n            if t<ch:\r\n                t=ch\r\n                x=i\r\n    return x\r\nt=int(input())\r\nfor x in range(t):\r\n    n,c,k=map(int,input().split())\r\n    l={}\r\n    for i in range(n):\r\n        a,b,e=map(int,input().split())\r\n        if e in l:\r\n            l[e].append(a)\r\n        else:\r\n            l[e]=[]\r\n            l[e].append(a)\r\n    v=list(map(int,input().split()))\r\n    s=[]\r\n    for i in range(1,c+1):\r\n        if i in l:\r\n            s+=[[len(l[i]),v[i-1]]]\r\n    while True:\r\n        ma=rem(s,k)\r\n        if ma<=-1:\r\n            break\r\n        else:\r\n            s[ma][0]-=1\r\n            k=k-s[ma][1]\r\n    re=0\r\n    for i in s:\r\n        if i[0]>2:\r\n            re=re+nc3(i[0])\r\n    print(int(re))\r\n", "import sys\nimport math\nr=int(input())\nfor v in range (0,r):\n n = int(input())\n x=1\n arr=list(map(int,input().strip().split(\" \")))\n for i in range (0,n):\n  x=x*arr[i]\n  \n  \n for i in range (2,20000000):\n  if(x%(math.pow(i,2))==0):\n   ans1=i\n   break\n \n \n print(ans1) \n", "# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n lst=list(map(int,input().split()))\n lst.sort()\n if n==1:\n  print(lst[0])\n elif n==2:\n  print(lst[1])\n elif n==3:\n  print(lst[0]+lst[2])\n elif n==4:\n  print(max((lst[0]+lst[3]),(lst[1]+lst[2])))\n", "def len(n):\r\n    x=0\r\n    while n>0:\r\n        x+=1\r\n        n=n//10\r\n    return x\r\ne=10**9+7\r\nt=int(input())\r\n#l=[0]\r\n#for i in range(1,10**7):\r\n    #l.append((l[-1]+i*len(i))%e)\r\n\r\nf=[0]\r\na=9\r\nb=1\r\nfor i in range(10):\r\n    x=(2*b+a-1)%e\r\n    x=(x*a)%e\r\n    y=pow(2,e-2,e)\r\n    x=(x*y)%e\r\n    x=(x*(i+1))%e\r\n    x=(x+f[-1])%e\r\n    b*=10\r\n    a*=10\r\n    \r\n    f.append(x)\r\n#print(f)\r\ndef ans(n):\r\n    if n==0:\r\n        return 0\r\n    x=len(n)\r\n    y = f[x-1]\r\n    a=pow(10,x-1,e)\r\n    b=((n+a)*(n-a+1))%e\r\n    b =(b*pow(2,e-2,e))%e\r\n    b=(b*x)%e\r\n    #print(y,b,n)\r\n    return (b+y)%e\r\n    \r\n    \r\nfor _ in range(t):\r\n    a,b=map(int,input().split())\r\n    #print(l[b]-l[a-1])\r\n    b = ans(b)\r\n    a=ans(a-1)\r\n    print((b-a)%e)\r\n    \r\n", "a,b,c=map(int,input().split())\nn=0\nfor i in range(a):\n t=list(map(int,input().split()))\n d=t[-1]\n t.pop(-1)\n if d<=10 and sum(t)>=b:\n  n+=1\nprint(n)", "def divisors(n):\n count=2 # accounts for 'n' and '1'\n i=2\n while(i**2 < n):\n  if(n%i==0):\n   count+=2\n  i+=1\n count+=(1 if i**2==n else 0)\n return count \nT = int(input())\nfor t in range(T):\n n = int(input())\n d = divisors(n)\n if d%2!=0:\n  print(\"YES\")\n else:\n  print(\"NO\")", "for _ in range(int(input())):\n    n=int(input())\n    li=list(map(int,input().split()))\n    li.sort()\n    dli=dict()\n    modi=0\n    #2*n optimiztion \n    for i in li:\n     if i not in dli:\n      dli[i]=li.count(i)\n    if(len(dli)!=0):\n     while 1:\n      tmp=[]\n      for i in dli:\n       if dli[i]==0:\n        continue\n       tmp.append(i)\n       dli[i]-=1\n      l=len(tmp)\n      mn=l\n      for i in range(l):\n       mn=min(mn,tmp[i]-1-i+l-1-i)\n      modi+=mn\n      if(l==0):\n       break\n    print(modi)", "# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    m = n\n    x= 1\n    for i in range(n):\n        for j in range(m):\n            print(x, end = '')\n            x += 1\n        print()\n        m -= 1", "cases = int(input())\nfor case in range(cases):\n    n = int(input())\n    freq = [0]*10001\n    a = list(map(int,input().split()))\n    \n    largest = 1\n    for i in range(n):\n        freq[a[i]] += 1\n        largest = max(largest,a[i])\n    most = 0\n    for num in range(largest+1):\n        if freq[num] > freq[most]:\n            most = num\n    print(most,freq[most])", "# cook your dish here\nt = int(input())\n\nwhile t:\n N = int(input())\n A = list(map(int, input().split()))\n l = []\n\n for i in range(N):\n  for j in range(i+1, N):\n   l.append(A[i]+A[j])\n\n c = l.count(max(l))\n\n print(c/len(l))\n\n t = t-1\n", "# cook your dish here\ndef countsumzero(lst):\n prefixsums = [0]\n for x in lst:\n  prefixsums.append(prefixsums[-1] + x)\n freq = {}\n for y in prefixsums:\n  if y in freq:\n   freq[y] += 1\n  else:\n   freq[y] = 1\n return sum(v*(v-1) // 2 for v in list(freq.values())) \n\n# Driver code \nn=int(input())\na = list(map(int, input().split()))\nprint(countsumzero(a)) \n\n\n\n", "import io, sys, os\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\nfrom itertools import combinations\n\n\ndef li():\n return list(map(int, sys.stdin.readline().split()))\n\n\ndef num():\n return list(map(int, sys.stdin.readline().split()))\n\n\ndef nu():\n return int(input())\n\n\ndef find_gcd(x, y):\n while (y):\n  x, y = y, x % y\n return x\n\n\ndef lcm(x, y):\n gg = find_gcd(x, y)\n return (x * y // gg)\n\n\nmm = 1000000007\n\n\ndef solve():\n t = nu()\n for tt in range(t):\n  n=nu()\n  s=input()\n  x=\"\"\n  y=\"\"\n  for i in range(len(s)):\n   if(i%2==0):\n    x+=\"0\"\n    y+=\"1\"\n   else:\n    x+=\"1\"\n    y+=\"0\"\n  cc=0\n  pp=0\n  for i in range(len(s)):\n   if(s[i]!=x[i]):\n    cc+=1\n   if(s[i]!=y[i]):\n    pp+=1\n  print(min(cc,pp))\n\n\n\ndef __starting_point():\n solve()\n\n__starting_point()", "\nfor _ in range(int(input())):\n l=input().split(\":\")\n hr=int(l[0])%12\n mi=int(l[1])\n hour_angle = (hr % 12) * 30 + mi * 0.5\n minute_angle = mi * 6\n ans = abs(hour_angle - minute_angle)\n if ans%1==0:\n  print(min(int(ans), 360 - int(ans)), \"degree\")\n else:\n  print(min(ans,360-ans),\" degree\")\n\n", "# cook your dish here\nwhile True:\n\ttry:\n\t\tm=int(input())\n\t\t\n\t\tn=int(m/2)\n\t\t\n\t\ta=m-n\n\t\n\t\tsum_even= int(2*(2*n*(n+1)*(2*n+1))/3)\n\t\t\n\t\tsum_odd= int(((4*a*a*a)-a)/3)\n\t\t\n\t\tresult=sum_odd+sum_even\n\t\t\n\t\tif result%2==0:\n\t\t\tprint('Ravi')\n\t\telse:\n\t\t\tprint('Jhon')\n\texcept:\n\t\tbreak;", "# cook your dish here\nfrom sys import stdin, stdout\nfrom math import ceil\n\n\ndef solve():\n    for _ in range(int(input())):\n        n, m = map(int, stdin.readline().split())\n        par = [i for i in range(n)]\n        for i in range(m):\n            ta, tb = map(int, stdin.readline().strip().split())\n            a, b = min(ta, tb), max(ta, tb)\n            for j in range(n):\n                if par[j] == par[b] and j != b:\n                    par[j] = par[a]\n            par[b] = par[a]\n\n        q = int(input())\n        while q:\n            q -= 1\n            x, y = map(int, stdin.readline().split())\n            if par[x] == par[y]:\n                print(\"YO\")\n            else:\n                print(\"NO\")\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "# cook your dish here\n# cook your dish here\nt=int(input())\nfor _ in range(t):\n n,p,q=list(map(int,input().split(\" \")))\n l=list(map(int,input().split(\" \")))\n l.sort()\n s=sum(l)\n a=p+2*q\n b=0\n for i in l:\n  if(p==0):\n   if(i%2==0 and a>=i):\n    a=a-i\n    b=b+1\n  elif(q==0):\n   if(a>=i):\n    a=a-i\n    b=b+1\n  else:\n   if(i%2==0 and a>=i):\n    a=a-i\n    b=b+1\n   elif(i%2!=0 and p!=0 and a>=i):\n    a=a-i\n    b=b+1\n    p=p-1\n\n print(b) \n    \n   \n", "''' PROBLEM A  '''\r\n\r\n\r\n    \r\n\r\n'''   PROBLEM B   '''\r\n\r\n\r\n\r\n'''   PROBLEM C   '''\r\n\r\n\r\n\r\n\r\n'''   PROBLEM D    '''\r\n\r\n\r\nn=int(input())\r\nfor i in range(0,n):\r\n    p=input().rstrip().split(' ')\r\n    print(int(p[0]) * int(p[1]))", "for _ in range(int(input())):\n    n=int(input())\n    print((2*(pow(n,2)))-n+1)\n\n", "# cook your dish here\nx= int(input())\nfor i in range(x):\n    y = list(map(str, input().split()))\n    j= 0\n    while j<len(y)-1:\n        print((y[j][0]).capitalize()+\".\", end=' ')\n        j+= 1\n    print(y[len(y)-1].capitalize())", "t=eval(input())\nfor i in range(t):\n n=eval(input())\n a=list(map(int,input().split()))\n f=0\n for i in range(1,n-1):\n  c=0\n  for j in range(0,i):\n   c=c+a[j]\n  if c+c==sum(a)-a[i]:\n   f=i\n   break\n if sum(a[1:])==0:\n  print(0)\n elif sum(a[0:n-1])==0:\n  print(n-1)\n elif f==0:\n  print(-1)\n else:\n  print(f)\n", "mod = 10**9 + 7\n\ndef solve(n, m):\n ans = n*(n-1) % mod\n if m==1:\n  print(ans)\n  return\n else:\n  ans = (ans * pow(n-1, m-1, mod)) % mod\n\n print(ans)\n \nfor case in range(int(input())):\n n,m = list(map(int, input().split()))\n\n solve(n, m)\n", "for _ in range(int(input())):\n f,d=list(map(int,input().split()))\n arr=list(map(int,input().split()))\n risk=0\n days_risk=0\n days_norm=0\n if d==1:\n  print(f)\n else:\n  for a in arr:\n   if a>=80 or a<=9:\n    risk+=1\n  norm=f-risk\n  if risk%d==0:\n   days_risk=risk//d\n  else:\n   days_risk=(risk//d)+1\n  if norm%d==0:\n   days_norm=norm//d\n  else:\n   days_norm=(norm//d)+1\n  print(days_risk+days_norm)\n    \n    \n", "t = int(input())\nfor _ in range(t):\n    n,k = map(int,input().split())\n    l = list(map(int,input().split()))\n    l.sort()\n    count = 1\n    a = []\n    for i in range(n-1):\n        if l[i]==l[i+1]:\n            count += 1\n        else:\n            if count > k:\n                a.append(l[i])\n                count = 1\n    if count >k:\n        a.append(l[-1])\n    print(*a)", "fac = 1\nfacts = [1]\nfor i in range(1,100000):\n    fac = (fac*(2*i+1)*(i+1))%1000000007\n    facts.append(fac)\n\nT = int(input())\n\nfor _ in range(T):\n    N = int(input())\n    print(facts[N-1])", "import math\nfor _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n gc=a[0]\n for i in a :\n  gc=math.gcd(gc,i)\n print(gc,sum(a)//gc)\n\n", "t=eval(input())\nmn=[]\narmy=[]\nfor i in range(0,t):\n temp=input()\n a,b=temp.split()\n a=int(a)\n b=int(b)\n mn.append((a,b))\n temp=input()\n new=[int(i) for i in temp.split()]\n army.append(new)\n\nfor i in range(0,t):\n n=mn[i][0]\n m=mn[i][1]\n li=army[i]\n s=0\n for j in range(0,len(li)):\n  if(j<m):\n   s+=li[j]\n  else:\n   s-=(li[j]/2)\n if(s>=0):\n  print(\"VICTORY\")\n else:\n  print(\"DEFEAT\")", "\n\n\nfor i in range(int(input())):\n n,k = list(map(int,input().split()))\n\n t=[]\n\n\n for j in range(n,n-k-1,-1):\n  t.append(j)\n t=t[::-1]\n\n p=[]\n for i in range(1,n-k):\n  p.append(i)\n\n print(*(t[:2]+p+t[2:]))\n  \n", "# cook your dish here\nt=int(input())\n\nwhile t:\n    t-=1\n    \n    n,k= list(map(int,input().split()))\n    \n    \n    if n%2==0:\n        \n        print((n//2)*k)\n    else:\n        print(((n//2)+1)*k)\n", "# cook your dish here\nt=int(input())\n\nfor i in range(t):\n n=int(input())\n lst=list(map(int,input().split()))\n flag=0\n lst.sort()\n for j in range(len(lst)):\n  for k in range(j+1,len(lst)):\n   if lst[j]+lst[k]==2000:\n    print(\"Accepted\")\n    flag=1\n    break\n  if flag==1:\n   break\n if flag==0:\n  print(\"Rejected\")\n \n  \n", "a=eval(input())\nwhile(a):\n\n x=eval(input())\n b=list(map(int,input().split()))\n z=[0]*100\n k=1\n j=0\n c=0\n for i in b:\n  \n  if i==0:\n   \n   z.insert(i,k)\n   \n  else:\n   \n   if z[z.index(i)+1]==0:\n    \n    z.insert(j,k)\n   else:\n    m=z.index(i)\n    n=m+1\n    p=(len(z)-z.count(0))-n\n    c=c+min(n,p)\n    \n    z.insert(m+1,k)\n    \n    \n  k+=1\n  j+=1\n  m=0\n  n=0\n  p=0\n  \n print(c)\n \n    \n    \n    \n   \n  \n  \n \n \n  \n\n\n a-=1\n", "t = int(input())\nwhile t>0:\n s = input().strip()\n if not s:\n  print('NO')\n\n dp = [0 for x in range(len(s) + 1)]\n dp[0] = 1\n dp[1] = 1 if 0 < int(s[0]) <= 9 else 0\n\n for i in range(2, len(s) + 1):\n  if 0 < int(s[i-1:i]) <= 9:\n   dp[i] += dp[i - 1]\n  if s[i-2:i][0] != '0' and int(s[i-2:i]) <= 26:\n   dp[i] += dp[i - 2]\n \n if dp[len(s)]%2 == 0:\n  print('YES')\n else:\n  print('NO')\n t -= 1", "try:\n t,m=input().split()\n t=int(t)\n m=list(m)\n letters=list(\"abcdefghijklmnopqrstuvwxyz\")\n trans={}\n for i in range(len(letters)):\n  trans[letters[i]]=m[i]\n for i in range(t):\n  x=list(input())\n  y=\"\"\n  for j in x:\n   if(j.isalpha()==True):\n    if(j.isupper()==True):\n     y+=trans[j.lower()].upper()\n    else:\n     y+=trans[j]\n   else:\n    if(j=='_'):\n     y+=\" \"\n    else:\n     y+=j\n  print(y)\n  \nexcept:pass", "# cook your dish here\ndef isPrime(n) : \n  \n    # Corner cases \n    if (n <= 1) : \n        return False\n    if (n <= 3) : \n        return True\n  \n    # This is checked so that we can skip  \n    # middle five numbers in below loop \n    if (n % 2 == 0 or n % 3 == 0) : \n        return False\n  \n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n  \n    return True\nt=int(input())\nfor i in range(0,t):\n    n=int(input())\n    if n==1:\n        print(\"2\")\n        continue\n    if isPrime(n):\n        print(n+1)\n        continue\n    if n%2==0:\n        k=n//2\n        min=2+k\n    else:\n        min=n+1\n    for j in range(2,(n//2)+1):\n        if n%j==0:\n            k=n//j\n            if k!=j:\n                l=j+k\n                if l<min:\n                    min=l\n    print(min)\n", "t=int(input())\nwhile t:\n x=int(input())\n ans=''\n if(x &1):\n  cc=['2' if x =='1' else '1' for x in list(bin(x)[2:-1])]\n  for x in cc:\n   ans = ans + str(x)\n  print(ans)\n else:\n  print('0')\n t = t-1", "N,D=map(int,input().split())\nl=[]\nfor i in range(N):\n l.append(int(input()))\nl.sort()\nc=0\nwhile len(l)!=0:\n if len(l)==1:\n  break\n if l[1]-l[0]<=D:\n  l.pop(0)\n  l.pop(0)\n  c+=1\n else:\n  l.pop(0)\nprint(c)", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nfor _ in range(int(inp())):\n    n = int(inp())\n    s = inp()\n    md = {}\n    for i in s:\n        if i in md: md[i]+=1\n        else: md[i]=1\n    o, e = 0, 0\n    for i in md.values():\n        if i%2: o+=1\n        else: e+=1\n    print(max(o-1, 0))", "t=int(input())\nfor i in range(t):\n list1=[]\n for i in range(3):                                  \n  list1.append(list(map(int,input().split())))\n min1=min(list1[0][0],list1[1][0],list1[2][0])\n min2=min(list1[0][1],list1[1][1],list1[2][1])\n min3=min(list1[0][2],list1[1][2],list1[2][2])\n max1=max(list1[0][0],list1[1][0],list1[2][0])\n max2=max(list1[0][1],list1[1][1],list1[2][1])\n max3=max(list1[0][2],list1[1][2],list1[2][2])\n list2=[]\n list3=[]\n list2=[min1,min2,min3]\n list3=[max1,max2,max3] \n if((list2 not in list1) or (list3 not in list1)):\n  print(\"no\")\n elif((list2 in list1) and (list3 in list1)):\n  list1.remove(list2)\n  list1.remove(list3)\n  if(list1[0]!=list2 and list1[0]!=list3):\n   print(\"yes\")\n  else:\n   print(\"no\")", "def solve():\n s=input()\n n=len(s)\n c=1\n for i in range(((n-1)//2)+1):\n  if s[i] == '?' and s[n-i-1] == \"?\":\n   c=(c*26) % 10000009\n  elif s[i] == '?' or s[n-i-1] == \"?\":\n   c=c*1\n  elif s[i] != s[n-i-1]:\n   c=0\n   break\n\n print(c)\n \n\ndef __starting_point():\n t=int(input())\n while t>0:\n  solve()\n  t=t-1\n__starting_point()", "# cook your dish here\nimport math\nt=int(input())\nfor _ in range(t):\n a=int(input())\n x1=math.floor(math.sqrt(a))\n x2=a-(x1*x1)\n c=0\n while(1):\n  c=c+1\n  if x2==0:\n   print(c)\n   break\n  x1=math.floor(math.sqrt(x2))\n  x2=x2-(x1*x1)\n", "# cook your dish here\ndef dfs(s):\n\tif v[s]==1:\n\t\treturn\n\tv[s] = 1\n\tfor k in adj[s]:\n\t\tdfs(k)\ntest = int(input())\nfor t in range(test):\n\tn,m = map(int, input().split())\n\tv = [0 for i in range(n)]\n\tadj = [[] for i in range(n)]\n\tfor i in range(m):\n\t\ta,b = map(int, input().split())\n\t\tadj[a].append(b)\n\t\tadj[b].append(a)\n\tcount = 0\n\twhile(0 in v):\n\t\tnode = v.index(0)\n\t\tdfs(node)\n\t\tcount += 1\n\tprint(count)", "res=[]\nfor _ in range(int(input())):\n a,b=list(map(str,input().split()))\n res.append([a,int(b)])\nres.sort(key=lambda x:x[-1])\n#print(res)\nfor _ in range(int(input())):\n check=input().strip()\n f=1\n for i in range(len(res)-1,-1,-1):\n  if res[i][0][:len(check)]==check:\n   f=0\n   ans=res[i][0]\n   break\n if f==1:\n  print(\"NO\")\n elif f==0:\n  print(ans)\n", "def mod(a,b,c):\n x = 1\n y = a\n while(b>0):\n  if(b%2==1):\n   x = (x*y)%c\n  y = (y*y)%c\n  b /=2\n return x%c\nt = int(input())\nnum = 10**9+7\nfor i in range(t):\n n,m,q,k = list(map(int,input().split()))\n if m<=q:\n  print(0)\n else:\n  a1 = m-q\n  a2 = mod(q+1,n,num)\n  a3 = mod(q-1,n,num)\n  a4 = mod(q,n,num)\n  a5 = a2-2*a4+a3\n  ans = a1*a5\n  print(ans%num)\n", "try:\r\n    x=int(input())\r\n    a=[*map(int, input().split())]\r\n    b=[*map(int, input().split())]\r\n    for i in b:\r\n        y=a.count(i)-b.count(i)\r\n        if y!=0:\r\n            print(i)\r\n            break\r\nexcept: pass", "print", "# cook your dish here\nfor _ in range(int(input())):\n    if int(input()) < 10:\n        print(\"Thanks for helping Chef!\")\n    else:\n        print(\"-1\")\n", "import math\r\nfor _ in range(int(input())):\r\n     n,m,k = map(int,input().split())\r\n     a = list(map(int,input().split()))\r\n     total = 0\r\n     for v in a:\r\n          if(v%m == 0):\r\n               y = m\r\n          else:\r\n               y = v%m\r\n          x = math.ceil(v/m)\r\n          total += x*(n+1-x)*y*(m+1-y)\r\n     ans = total / (n * (n+1) * m * (m+1) // 4)\r\n     print(\"%.11f\"%(ans))", "n = int(input());\n\ncount = 0;\n\nwhile n > 0:\n\n n -= 1;\n\n inp = input().split(' ')[-1:][0];\n\n#   if len(inp) > 6:\n#\n#       raise ValueError;\n\n#   print inp;\n\n eight, five, three, others = 0, 0, 0, False;\n \n for each in inp:\n\n  if each >= '0' and each <= '9':\n \n   if each == '8':\n \n    eight += 1;\n\n   elif each == '5':\n\n    five += 1;\n\n   elif each == '3':\n\n    three += 1;\n\n   else:\n    others = True;\n \n    break;\n\n if not others and eight >= five and five >= three:\n\n  count += 1;\n\nprint(count);\n", "t = int(input())\n\nfor e in range(t):\n\n str = input()\n\n dict = {}\n\n for x in range(len(str)):\n  if str[x] in dict:\n   dict[str[x]] = -1\n  else:\n   dict[str[x]] = x\n\n shankyIndex = len(str)\n ankuIndex = -1\n for x in dict:\n  if dict[x] != -1:\n   if dict[x] < shankyIndex:\n    shankyIndex = dict[x]\n   if dict[x] > ankuIndex:\n    ankuIndex = dict[x]\n\n ankuLetter = 0\n shankyLetter = 0\n\n if ankuIndex != -1:\n  ankuLetter = str[ankuIndex]\n else:\n  print('PANDEY')\n  continue\n\n if shankyIndex != len(str):\n  shankyLetter = str[shankyIndex]\n else:\n  print('PANDEY')\n  continue\n\n if shankyLetter > ankuLetter:\n  print('SHANKY')\n elif ankuLetter > shankyLetter:\n  print('ANKU')\n else:\n  print('PANDEY')", "def is_zig_zag(h):\n if len(h) < 2:\n  return True\n if h[0] == h[1]:\n  return False\n fs = (lambda x, y: x < y, lambda x, y: x > y)\n f = 0 if h[0] < h[1] else 1\n for i in range(1, len(h)-1):\n  if not fs[(i+f)%2](h[i], h[i+1]):\n   return False\n return True\ndef no_more_changes(h, m):\n for i in range(len(h)-1):\n  h_diff, m_diff = h[i]-h[i+1], m[i]-m[i+1]\n  if h_diff == m_diff or m_diff == 0:\n   continue\n  if h_diff == 0 or (h_diff < 0) != (m_diff < 0):\n   return False\n return True\nfor _ in range(eval(input())):\n n = eval(input())\n h, m = list(map(list, list(zip(*[list(map(int, input().split())) for _ in range(n)]))))\n t = 0\n zig_zags = []\n zig_zag_start = None\n while True:\n  if is_zig_zag(h):\n   if zig_zag_start is None:\n    zig_zag_start = t\n  elif zig_zag_start is not None:\n   zig_zags.append((zig_zag_start, t-1))\n   zig_zag_start = None\n  if no_more_changes(h, m):\n   if zig_zag_start is not None:\n    zig_zags.append((zig_zag_start, 'Inf'))\n    zig_zag_start = None\n   break\n  h = list(map(lambda x, y: x+y, h, m))\n  t += 1\n print(len(zig_zags))\n for s, e in zig_zags:\n  print(s, e)", "# cook your dish here\nfor h in range(int(input())):\n s=input()\n mc=s.count('m')\n l=list(s)\n k=0\n for i in range(len(l)):\n  if(l[i]=='m'):\n   if l[i-1]=='s' and i>0:\n     l[i-1]='0'\n     \n   elif(i<(len(s)-1))and l[i+1]=='s': \n    l[i+1]='0'\n  \n sc=l.count('s')\n\n if mc>sc:\n  print('mongooses')\n elif sc>mc:\n  print('snakes')\n else:\n  print('tie')\n", "def solve(D):\n    c4 = D\n    while c4>=0:\n        if c4%7==0 : \n            c7 = D-c4\n            if c7%4==0 :\n                return c4\n\n        c4 -= 4\n\n    return -1\n\nfor _t in range(int(input())):\n   print(solve(int(input())))\n\n", "from collections import *\nP,S=input().split()\nP=int(P)\nS=int(S)\nlist_of_dictionaries=[]\nfor _ in range(P):\n scores=input().split()\n number_of_contestants=input().split()\n scores=map(int,scores)\n number_of_contestants=map(int,number_of_contestants)\n dictionary=dict(zip(scores,number_of_contestants))\n dictionary = OrderedDict(sorted(dictionary.items()))\n list_of_dictionaries.append(dictionary)\nlist_of_difficulty_tuples=[]\nfor alpha in range(P):\n current_dictionary = list_of_dictionaries[alpha]\n old=-1\n n=0\n for v in current_dictionary.values():\n  if(old==-1):\n   old=v\n  else:\n   if(v<old):\n    n=n+1\n    old=v\n   else:\n    old=v\n list_of_difficulty_tuples.append((n,alpha+1))\nlist_of_difficulty_tuples = (sorted(list_of_difficulty_tuples))\nfor result in range(len(list_of_difficulty_tuples)):\n print(list_of_difficulty_tuples[result][1])", "from collections import defaultdict\ndef solve(date,m):\n\n arr = [31,29,31,30,31,30,31,31,30,31,30,31]\n copied = arr.copy()\n \n d = {\n \"january\": 0,\n \"february\": 1,\n \"march\": 2,\n \"april\": 3,\n \"may\": 4,\n \"june\": 5,\n \"july\": 6,\n \"august\":7,\n \"september\": 8,\n \"october\": 9,\n \"november\":10,\n \"december\": 11\n }\n\n month = d[m]\n\n total = 366//2\n i = month\n total += date\n\n while(total > 0):\n  \n  while(arr[i]>0 ):\n   if(total<= arr[i]):\n    return give(total, i,d)\n   else:\n    total = total - arr[i]\n    i = (i+1) %12\n    break\n\n\ndef give(day, month, d):\n temp = None \n\n for x in d:\n  if(d[x] == month):\n   temp = x\n\n print(\"{} {}\".format(day,temp))\n\nt = int(input())\nfor _ in range(t):\n d,m = map(str, input().split())\n\n solve(int(d), m)", "N=int(input())\nA=[int(x) for x in input().split()]\nfor _ in range(int(input())):\n    K=int(input())\n    total=0\n    for i in range(N):\n        a=0\n        count=0\n        forward=0\n        backward=1\n        if(A[i]==K):\n            if(i!=A.index(K)):\n                a=1\n            for j in range(i,N):\n                if(A[j]>=K):\n                    forward+=1\n                else:\n                    break\n            \n            for j in range(i-1,-1,-1):\n                if(a==1):\n                    if(A[j]>K):\n                        backward+=1\n                        \n                    else:\n                        break\n                elif(a==0):\n                    if(A[j]>=K):\n                        backward+=1\n                        \n                    else:\n                        break\n            \n            count+=forward*backward\n            total+=count\n                    \n    print(total)\n        \n                \n                \n            \n            \n            ", "s = input().lower()\r\nvow = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\r\nans = \"\"\r\nfor ch in s:\r\n    if ch in vow:\r\n        continue\r\n    if ch.isalpha():\r\n        ans += \".\" + ch\r\nprint(ans)\r\n", "import sys\n\ndef joseph(k, n=6):\n\tif k==0:\n\t\tk = 1\n\tx = 0\n\tfor i in range(2,n+1):\n\t\tx = (x+k)%i\n\treturn x\n\nFLAMES = ['FRIENDS', 'LOVE', 'ADORE', 'MARRIAGE', 'ENEMIES', 'SISTER']\n\nnCase = int(sys.stdin.readline())\nfor _ in range(nCase):\n\ta = ''.join(sys.stdin.readline().split())\n\tb = ''.join(sys.stdin.readline().split())\n\tn = 0\n\tfor ch in set(a+b):\n\t\tn += abs(a.count(ch)-b.count(ch))\n\tprint(FLAMES[joseph(n)])\n", "for t in range(int(input())):\n n,k=map(int,input().split())\n l=list(map(int,input().split()))\n for i in l:\n  if i%k==0:\n   print(\"1\",end=\"\")\n  else:\n   print(\"0\",end=\"\")\n print()\n ", "import numpy as np\r\nfrom numba import njit\r\ni8 = np.int64\r\n\r\n\r\n@njit\r\ndef solve(a, b, t, K, N):\r\n    t1 = t // K\r\n    d = t % K * 2\r\n    # b \u304c a \u304b\u3089 a + d \u306e\u4f4d\u7f6e\u306b\u3042\u308c\u3070\u885d\u7a81\u3059\u308b\r\n    x = 0\r\n    y = 0\r\n    ans = 0\r\n    for c in a:\r\n        while b[x] < c:\r\n            x += 1\r\n        while b[y] <= c + d:\r\n            y += 1\r\n        ans += y - x\r\n    ans += t1 * len(a) * (N - len(a)) * 2\r\n    return ans\r\n\r\n\r\ndef set_ini(DX, K):\r\n    a = DX[1][DX[0] == 1]\r\n    a = np.sort(a)\r\n    b = DX[1][DX[0] == 2]\r\n    b = np.sort(b)\r\n    b = np.hstack((b, b + K, b + 2 * K, [3 * K]))\r\n    return a, b\r\n\r\n\r\ndef main():\r\n    f = open('/dev/stdin', 'rb')\r\n    vin = np.fromstring(f.read(), i8, sep=' ')\r\n    N, Q, K = vin[0:3]\r\n    head = 3\r\n    DX = vin[head:head + 2*N].reshape(-1, 2).T\r\n    a, b = set_ini(DX, K)\r\n    head += 2 * N\r\n    T = vin[head: head + Q]\r\n    for t in T:\r\n        print(solve(a, b, t, K, N))\r\n\r\n\r\ndef __starting_point():\r\n    main()\n__starting_point()", "from math import factorial\ndef Ncr(n,r):\n    if r<0:return 0\n    return factorial(n)/(factorial(n-r)*factorial(r))\ndef solve(m,n):\n    modulo=10**9+7\n    if m==n:\n        return (Ncr(2*n-1,n-1)+Ncr(2*n-2,n-2))%modulo\n    elif m>n:\n        return (Ncr(m+n,n)-Ncr(m+n-2,n-1))%modulo\n    else:\n        return (Ncr(m+n,m)-Ncr(m+n-2,m-1))%modulo\n        \nt=int(input())\nfor i in range(t):\n    inp=list(map(int,input()))\n    m=inp.count(4)\n    n=inp.count(7)\n    print(solve(m,n))\n", "# cook your dish here\n# cook your dish here\nt=int(input())\nwhile t>0:\n n=int(input())\n inp=[int(i) for i in input().split()]\n #print(inp)\n t=t-1\n xorarr=[0]*n\n xorarr[0]=inp[0]\n mydict=dict()\n mydict[xorarr[0]]=1\n for i in range(1,n):\n  xorarr[i]=xorarr[i-1]^inp[i]\n  if xorarr[i] not in mydict:\n   mydict[xorarr[i]]=1\n  else:\n   mydict[xorarr[i]]=mydict[xorarr[i]]+1\n #print(xorarr)\n #print(mydict)\n mydicts=dict()\n sums=0\n for i in range(n):\n  if xorarr[i]==0:\n   sums=sums+i\n   \n  if xorarr[i] not in mydicts:\n   val=0-i*(mydict[xorarr[i]]-1)\n   mydicts[xorarr[i]]=[1,val]\n   \n  else:\n   val=(2*mydicts[xorarr[i]][0]-mydict[xorarr[i]]+1)*i\n   mydicts[xorarr[i]][0]+=1\n   mydicts[xorarr[i]][1]+=val \n #print(mydicts)\n \n for i in list(mydicts.keys()):\n  sums=sums+mydicts[i][1]-(mydict[i]*(mydict[i]-1)/2)\n  \n print(int(sums))\n #print(mydicts)\n", "import math\n\ndef lcm(a, b):\n    return (a*b)//gcd(a, b)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a%b)    \n    \nfor _ in range(int(input())):\n    n = int(input())\n\n    na = math.ceil((2*n)/math.acos(-1))\n    nb = ((n+1)//2)**2\n\n    nlcm = lcm(na, nb)\n\n    oa = math.ceil(n/2)\n    ob = (n//2)*(n//2+1)\n\n    olcm = lcm(oa, ob)\n\n    if olcm > nlcm:\n        print(\"Nova's gonna kill me\")\n    else:\n        print(\"YESS(sunglass emo)\")\n\n# cook your dish here\n", "t=int(input())\nfor i in range(t):\n s=input()\n if(len(s)<4):\n  print(\"NO\")\n elif(s[-4:]!=\"1000\"):\n  print(\"NO\")\n else:\n  print(\"YES\")\n \n", "t=int(input())\nfor i in range(t):\n l=input().split()\n n=int(l[0])\n k=int(l[1])\n if n==0:\n  if k==0:\n   print(1)\n  else:\n   print(0)\n else:\n  if k>n:\n   print(0)\n  else:\n   if n-k<k:\n    k=n-k\n   ans=1\n   for i in range(n-k+1, n+1):\n    ans*=i\n   for i in range(1, k+1):\n    ans/=i\n   print(ans)\n\n    \n    \n", "for _ in range(int(input())):\n n=int(input())\n ar=[int(x) for x in input().split()]\n ar.sort()\n s=0\n an=0\n for i in range(n):\n  if ar[i]<=s:\n   s+=1\n   an+=1\n  else:\n   break\n print(an)\n   \n", "from math import floor,sqrt\n\nn=int(input())\nfor i in range(n):\n  m=int(input())\n  if m%4==1 or m%4==2:\n   print(0)\n  else:\n   s=m*(m+1)//2\n   res=0\n   sm=s//2\n   p1=floor((sqrt(4*s+1)-1)/2)\n   s1=p1*(p1+1)//2\n   p=[p1-1,p1,p1+1]\n   s=[s1-p1,s1,s1+p[2]]\n   l=[sm-s[0],sm-s1,sm-s[2]]\n   for j in range(len(l)):\n    if l[j]==0:\n     res+=(p[j]*(p[j]-1)+(m-p[j]-1)*(m-p[j]))//2\n    elif l[j]>0 and l[j]<m:\n     res+=min([l[j],m-l[j],p[j],m-p[j]])\n     \n   print(res)\n   \n", "def f(n):\r\n    sod = 0\r\n    for char in str(n):\r\n        sod += int(char)\r\n    if n%sod == 0:\r\n        return \"Yes\"\r\n    else:\r\n        return \"No\"\r\n\r\nt = int(input())\r\nanswers = list()\r\nfor _ in range(t):\r\n    n = int(input())\r\n    answers.append(f(n))\r\n\r\nfor answer in answers:\r\n    print(answer)", "# cook your dish here\nfor i in range(int(input())):\n m=int(input())\n l=[]\n p=m**2 \n ans=0\n for i in range(1,m+1):\n  if(p%i==0):\n   ans+=1 \n   l.append(i+m)\n print(ans)\n for i in l:\n  print(i)", "def maximizing(array):\n cpy = array[:]\n final_list = []\n for i in range(len(array)):\n  new_list = [array[i]]\n  for t in range(len(cpy)):\n   for j in range(len(new_list)):\n    if cpy[t][0] == new_list[j][0] or cpy[t][1] == new_list[j][1]:\n     break\n   else:\n    new_list.append(cpy[t])\n  \n  cpy.remove(array[i])\n  final_list.append(new_list)\n\n costing = []\n for i in final_list:\n  cost = 0\n  count_array = []\n  if len(i) < 4:\n   cost -= (4 - len(i))*100\n  for j in i:\n   count_array.append(arrays.count(j))\n\n  count_array.sort(reverse=True)\n\n  threshold = 100\n\n  for k in count_array:\n   cost += k*threshold\n   threshold -= 25\n\n  costing.append(cost)\n\n return max(costing)\n\n\ntest_cases = int(input())\noutput_list = []\n\nfor _ in range(test_cases):\n n = int(input())\n arrays = []\n if n != 0:\n  for _ in range(n):\n   arrays.append(list(input().split()))\n\n  output_list.append(maximizing(arrays))\n else:\n  output_list.append(-400)\n\nfor output in output_list:\n print(output)\n\nprint(sum(output_list))\n", "import sys\n\nrl=sys.stdin.readline\nT=int(rl())\nfor t in range(T):\n P=int(rl())\n T=(P+1)//2\n F=list(map(int,rl().split()))[1:]\n numtorn=int(rl())\n t=sum(range(1,P+1))-sum(F)\n K=T-numtorn\n print('%.4f' % (t*K/float(T)))\n \n", "import math\nn = int(input())\na = sorted(map(int,input().split()))\nl = [0]*n\nfor i in range(n):\n l[i] = a[i] + l[i-1]\nfor q in range(int(input())):\n print(l[int(math.ceil(float(n)/(int(input())+1)))-1])", "ts = int(input())\nfor _ in range(ts):\n n, m = map(int, input().split())\n t, tt, res, cnt = 1, [], 0, 1\n while t <= n:\n  t *= m\n  v = n // t\n  v -= v // m\n  if tt:tt[-1] -= v\n  tt.append(v)\n for i, v in enumerate(tt):\n  res += ((i + 2) // 2) * v\n  if i & 1 == 0:\n   cnt = cnt * pow((i + 2) // 2 + 1, v, 998244353) % 998244353\n print(n - res, cnt)", "n = int(input())\nq = [0] * (n + 1)\nt = list(map(int, input().split(\" \")));\nfor i in t : q[i] = 1\ns = \"\"\nfor i in range(1, n + 1) :\n if q[i] == 0 : s += str(i) + \" \"\nprint(s)", "from collections import defaultdict\nt = int(input())\nqueries = []\nwhile t:\n t-=1\n n = int(input())\n queries.append(list(map(int,input().split())))\ndef solve(a,n):\n su = sum(a)\n mp = defaultdict(int)\n s = 0\n ans = 0\n for i in range(n):\n  if((su-a[i])%2==0):\n   ans+=mp[(su-a[i])//2]\n  s+=a[i]\n  mp[s]+=1\n mp.clear()\n s = 0\n for i in range(n-1,-1,-1):\n  if((su-a[i])%2==0):\n   ans+=mp[(su-a[i])//2]\n  s+=a[i]\n  mp[s]+=1\n return ans\nfor i in queries:\n print(solve(i,len(i)))", "# cook your dish here\nt=int(input())\nl=[2048,1024,512,256,128,64,32,16,8,4,2,1]\nfor i in range(t):\n    n=int(input())\n    r=0\n    while(n>0):\n        for j in l:\n            if(n>=j):\n                r+=n//j\n                n%=j\n    print(r)", "# cook your dish here\nimport math\ndef solveit(A,n):\n N=n\n G=[]\n for i in range(n):\n  v=(math.gcd(A[i],A[(i+1)%N]))\n  if (v==1):\n   G.append(1)\n  else:\n   G.append(0)\n # print(G)\n pos=-1\n for i in range(n):\n  if (G[i]==1):\n   pos=i\n   break\n\n V=[]\n ans=[0 for i in range(N-1)]\n if (pos==-1):\n  for i in range(N-1):\n   ans[i]=math.ceil(N/(i+1))\n else:\n  c=0\n  for i in range(1,N+1):\n   if (G[(pos+i)%N]==0):\n    c=c+1\n\n   else:\n    if (c!=0):\n     V.append(c)\n    c=0\n\n \n  for val in V:\n   for i in range(min(val,N-1)):\n    ans[i]=ans[i]+(val//(i+1))\n\n print(*ans)\n   \n\n \nfor _ in range(int(input())):\n n=int(input())\n A=list(map(int,input().split()))\n solveit(A,n)\n\n", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n n, a, b, c, d, p, q, y = list(map(int,input().split()))\n x = list(map(int,input().split()))\n \n time1=p*abs(x[a-1]-x[b-1])\n l=p*abs(x[a-1]-x[c-1])\n if l<=y:\n  time2=(q*abs(x[c-1]-x[d-1]))+(p*abs(x[d-1]-x[b-1]))+y\n  print(min(time1, time2))\n else:\n  print(time1)\n \n \n   \n   \n  \n", "for t in range(int(input())):\r\n    n,m,k=list(map(int,input().split(' ')))\r\n    a=[]\r\n    for i in range(n):\r\n        a.append(list(map(int,input().split(' '))))\r\n    max=0\r\n    b=[0 for i in range(n)]\r\n    c=[0 for i in range(m)]\r\n    for i in range(n):\r\n        b[i]=sum(a[i][:k])\r\n        if b[i]>max:\r\n            max=b[i]\r\n    for i in range(m):\r\n        g=0\r\n        for x in range(k):\r\n            g=g+a[x][i]\r\n        c[i]=g\r\n        if g>max:\r\n            max=g\r\n    #print(b,c)\r\n    for i in range(n):\r\n        for j in range(1,m-k+1):\r\n            b[i]=b[i]+a[i][j+k-1]-a[i][j-1]\r\n            #print(b[i])\r\n            if b[i]>max:\r\n                max=b[i]\r\n    for i in range(m):\r\n        for j in range(1,n-k+1):\r\n            c[i]=c[i]+a[j+k-1][i]-a[j-1][i]\r\n            if c[i]>max:\r\n                max=c[i]\r\n\r\n    print(max)\r\n    \r\n", "import math\nfrom collections import defaultdict\nn=int(input())\na=[int(i) for i in input().split()]\nop=defaultdict(int)\ngcd=defaultdict(int)\nfor i in a:\n gcd[i]=1\nwhile(len(a)!=0):\n newa=[]\n x=a[0]\n for i in a[1:]:\n  z=math.gcd(x,i)\n  gcd[z]+=1\n  newa.append(z)\n  x=i\n a=newa\nfor i in gcd:\n j=i\n while(j<10**6+1):\n  op[j]+=gcd[i]\n  j+=i\nq=int(input())\nfor _ in range(q):\n print(op[int(input())])\n", "for i in range(int(input())):\n n,k=map(int,input().split())\n t=0\n if n%2!=0:\n  n-=1\n  t+=1\n t+=(n//k)\n if n%k!=0:\n  t+=1\n print(t)", "'''\n  Problem : Id and Ship\n  Author @ Rakesh Kumar\n  cpp.rakesh@gmail.com\n  Date : 04/02/2021\n'''\n\ndef solve():\n for _ in range(int(input())):\n  s = str(input())\n  r = 'yes'\n  for i in range(0, len(s), 2):\n   if s[i] == s[i + 1]:\n    r = 'no'\n    break\n  print(r)\n\ndef __starting_point():\n solve()\n\n__starting_point()", "# cook your dish here\n\nd = { 'D': 238, 'T': 244, 'M': 138, 'B': 279, 'C': 186 }\n\ns = list(input())\ntotalCal = 0\n\nfor i in range(len(s)):\n    if s[i] == 'D':\n        totalCal += d['D']\n    if s[i] == 'T':\n        totalCal += d['T']\n    if s[i] == 'M':\n        totalCal += d['M']\n    if s[i] == 'B':\n        totalCal += d['B']\n    if s[i] == 'C':\n        totalCal += d['C']\n\nR = totalCal // 50\nRm = totalCal % 50\nC = Rm // 5\nCm = Rm % 5\nx = totalCal - (R * 50 + C * 5)\n# print(totalCal - R * 50 + C * 5)\nW = int(x * 4 * 0.5)\n# print(R * 50 + C * 5 + W * 0.5)\nprint(R)\nprint(C)\nprint(W)", "def nCr(n,r):\n  if n < r :  \n    return 0\n  M = 10**9 + 7\n  ret = fact[n] * pow( fact[r], M-2, M ) * pow( fact[n-r], M-2, M )\n  return ret % M\n\nMOD = 10**9 + 7\n\nfact = [1] * 4001\nfor i in range(1,4001):\n  fact[i] = ( fact[i-1] * i ) % MOD\n\n\nfor t in range(eval(input())):\n  \n  n,q = list(map( int, input().split() ))\n    \n  for qq in range(q):\n    \n    i,k = list(map( int, input().split() ))\n    \n    print(( nCr( i-1, k-1 ) * pow( 2, n-i , MOD ) ) % MOD)", "for i in range(int(input())):\n s=input()\n r=input()\n n=len(r)\n gap=[]\n t=0\n l=0\n for i in range(0,n):\n  if s[i]==r[i]:\n   t+=1\n  else:\n   gap.append(t)\n   l+=1 \n   t=0\n\n gap.append(t) \n gp=len(gap)-1\n gap=gap[1:-1]\n gap.sort()\n x=l*gp\n for i in range(len(gap)):\n  gp-=1\n  l+=gap[i]\n  y=gp*l\n  if y<x:\n   x=y\n print(min(x,n)) \n \n", "# cook your dish here\n# the evilprofessor\nt = int(input())\nwhile t>0:\n s = input()\n length = len(s)\n ans = 0\n for l in range(length):\n  for r in range(l, length):\n   temp = s\n   x = temp[:l]\n   for i in range(l , r+1):\n    if temp[i] == '0':\n     x +='1'\n    else:\n     x +='0'\n   x +=temp[r+1:]\n   for k in range(len(x)-1):\n    if x[k] == x[k+1]:\n     ans +=1\n   #print(x , ans)\n print(ans)\n    \n  \n    \n \n t-=1\n", "# cook your dish here\nt=int(input())\n\ndef kingship(p,n):\n \n s=0\n m=min(p)\n \n for i in range(0,n):\n  s+=p[i]*m\n return s-m*m\nfor _ in range(t):\n n=int(input())\n p=list(map(int,input().split()))\n \n r=kingship(p,n)\n print(r)", "from math import factorial\nfrom functools import reduce \n\nlst=[1]*(10**6+1)\n\nfor j in range(1,10**6+1):\n lst[j]=(lst[j-1]*j)%(10**9+7)\nfor j in range(1,10**6+1):\n lst[j]=(lst[j-1]*lst[j])%(10**9+7)\nfor i in range(int(input())):\n n=int(input())\n x=lst[n]\n print(x%(10**9 +7))", "from sys import stdin,stdout\n\ndef lin(): return int(stdin.readline())\ndef mlin(): return map(int,stdin.readline().rstrip().split())\ndef llin(): return list(mlin())\ndef res():\n for i in range(lin()):\n  v1,t1,v2,t2,v3,t3=mlin()\n  if v1+v2<v3:\n   print(\"NO\")\n  else:\n   x=(v3*(t3-t2))/(t1-t2)\n   y=(v3*(t3-t1))/(t2-t1)\n   if x<=v1 and y<=v2 and x>=0 and y>=0:\n    print(\"YES\")\n   else:\n    print(\"NO\")\nres()", "# cook your dish here\nfor u in range(int(input())):\n    s=input()\n    a=s\n    for i in range(len(s)//2):\n        a=a.replace(\"abc\",\"\")\n    print(a)    ", "for t in range(int(input())):\n s = input()\n l = sorted([char for char in s])\n i = 0; x =[] \n cnt = 1\n while(i<len(l)-1):\n  if(l[i]!=l[i+1]):\n   x.append(cnt)\n   cnt = 0\n  cnt = cnt+1\n  i = i+1\n x.append(cnt) \n #print(l,\"\\n\",x)\n \n k = len(x)\n while(sum(x)%k!=0):\n  k = k+1 \n m = sum(x)//k\n z = [max(0,a - m) for a in x]\n   \n for i in range(len(x),0,-1):\n  #print(sum(x),i)\n  if(sum(x)%i==0):\n   m = sum(x)//i\n   #print(m,i)\n   break\n y = [max(0,m - a) for a in x]\n print(min(sum(sorted(z)),sum(sorted(y)[0:i])))\n \n \n  \n \n  \n", "# cook your dish here\nfor _ in range(int(input())):\n x1,x2,x3,v1,v2=map(int,input().split())\n t1=abs(x3-x1)/v1\n t2=abs(x3-x2)/v2\n if(t1<t2):\n  print(\"Chef\")\n elif(t1>t2):\n  print(\"Kefa\")\n else:\n  print(\"Draw\")", "t=int(input())\nfor j in range(0,t):\n m,n=map(int,input().split(\" \"))\n u,v=map(int,input().split(\" \"))\n k=int(input())\n s=input()\n p=0\n q=0\n for i in range(0,len(s)):\n  if s[i]=='L':\n   p-=1\n  elif s[i]=='R':\n   p+=1\n  elif s[i]=='U':\n   q+=1\n  elif s[i]=='D':\n   q-=1\n if p<0 or p>m or q<0 or q>n:\n  print(\"Case \"+str(j+1)+\": \"+\"DANGER\")\n elif p==u and q==v:\n  print(\"Case \"+str(j+1)+\": \"+\"REACHED\")\n else:\n  print(\"Case \"+str(j+1)+\": \"+\"SOMEWHERE\")", "def isSolvable( W, R):\r\n        LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}\r\n        if LR < ML: return False\r\n        def dfs(d,i,c):\r\n            if d == ML: return c == 0\r\n            if i == len(W) + 1:\r\n                s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c\r\n                return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False\r\n            if i < LW and d >= len(W[i]): return dfs(d,i+1,c)\r\n            ch = AW[i][-d-1]\r\n            if ch in LMap: return dfs(d,i+1,c)\r\n            for x in range((ch in F), 10):\r\n                if x not in V:\r\n                    LMap[ch], _ = x, V.add(x)\r\n                    if dfs(d,i+1,c): return True\r\n                    V.remove(LMap.pop(ch))\r\n        return dfs(0,0,0)\r\nn=int(input())\r\nW=[]\r\nfor i in range(n):\r\n    W.append(str(input()))\r\nR=input()    \r\na=(isSolvable(W,R))\r\nif a==True:\r\n    print(\"true\")\r\nelse:\r\n    print(\"false\")", "t=int(input())\nfor i in range(t):\n n,k=map(int,input().split())\n m=list(map(int,input().split()))\n a=0\n for i in m:\n  if i>=k:\n   a=1\n   break\n if a==1:\n  print('YES')\n else:\n  print('NO')", "def fun(a,cur,n,cnt):\n    if cur>=n-1:\n        return\n    for i in range(cur,n-1):\n        if i<n-2:\n            if a[i]>0 and a[i+1]>0:\n                a[i]-=1\n                a[i+1]-=1\n                a[i+2]+=1\n                cnt[0]=(cnt[0]+1)%1000000007\n                fun(a,i,n,cnt)\n                a[i]+=1\n                a[i+1]+=1\n                a[i+2]-=1\n        else:\n            if a[i]>0 and a[i+1]>0:\n                a[i]-=1\n                a[i+1]-=1\n                a.append(1)\n                cnt[0]=(cnt[0]+1)%1000000007\n                fun(a,i,n+1,cnt)\n                a[i]+=1\n                a[i+1]+=1\n                a.pop()\ntc=int(input())\nfor case in range(tc):\n    n=int(input())\n    a=list(map(int,input().split()))\n    cnt=[1]\n    fun(a,0,n,cnt)\n    print(cnt[0]%1000000007)\n    \n", "t=int(input())\r\nfor _ in range(t):\r\n    ans=0\r\n    x,n=map(int,input().split())\r\n    for i in range(x,n,x):\r\n        ans=ans+i\r\n    print(ans)", "# cook your dish here\nmod=10**9+7\nfor _ in range (int(input())):\n    n,m=map(int,input().split())\n    num=n//2\n    tot=(num*(2+2*num))//2\n    print(pow(m,tot,mod))", "# cook your dish here\nimport math\nt = int(input())\nwhile(t):\n n = int(input())\n res = 0\n x = 0\n y = 0\n while(x <= n):\n  tmp = int(math.sqrt(y))\n  tmp += 1\n  y += tmp * tmp\n  x = tmp\n  res += 1\n \n print(res - 1)\n \n t -= 1", "def sort_str(s):\n    o = []\n    for c in s:\n        o.append(c)\n    o.sort()\n    return \"\".join(o)\ndef find_ana(s):\n    if len(s) <= 1:\n        return 0\n    h = {}\n    c = 0\n    for i in range(len(s)):\n       for j in range(i+1, len(s)+1):\n          t = sort_str(s[i:j])\n          if t in h:\n            c += h[t]\n            h[t] += 1\n          else:\n            h[t] = 1\n    return c\nt = int(input())\nfor _ in range(t):\n    print(find_ana(input()))", "t=int(input())\n \ndef vsense(val,a,l):\n sense=0\n ctr=a\n for c in range(n):\n  if val[c]<=ctr:\n   sense+=-1\n  else:\n   sense+=1\n  ctr+=l\n return sense\n \nwhile t:\n n,l,a,b=list(map(int,input().split()))\n val=list(map(int,input().split()))\n val.sort()\n sense=0\n if b==a+n*l or vsense(val,a,l)<=0:\n  loc=a\n else:\n  st=a\n  end=b-n*l\n  while st<=end:\n   m=(st+end)/2\n   chk=vsense(val,m,l)\n   if chk==0:\n    loc=m\n    break\n   elif chk<0:\n    end=m-1\n   else:\n    loc=m\n    st=m+1\n ans=0\n st=loc\n for c in range(n):\n  ans+=abs(st-val[c])\n  st+=l\n print(ans)\n \n t-=1\n", "def findRemainigSum(start,digitSum,upTo):\n    sum=0\n    currSum=findSumOfDigits(start)\n    for i in range(0,upTo):\n        sum+=findSumOfDigits(currSum)\n        currSum=findSumOfDigits(currSum+digitSum)\n    return sum\ndef findSumOfDigits(num):\n    if(num%9 == 0)and(num != 0):\n        return 9\n    else:\n        return num%9\nt=int(input())\nwhile(t):\n    inputString=input()\n    inputList=inputString.split()\n    a=int(inputList[0])\n    d=int(inputList[1])\n    l=int(inputList[2])\n    r=int(inputList[3])\n    sum=0\n    diff=r-l+1\n    lDigitSum=findSumOfDigits(a+(l-1)*d)\n    dDigitSum=findSumOfDigits(d)\n    if(dDigitSum==9):\n        sum=lDigitSum*diff\n    else:\n        if(dDigitSum==3 or dDigitSum==6):\n            n1=lDigitSum\n            n2=findSumOfDigits(lDigitSum+dDigitSum)\n            n3=findSumOfDigits(n2+dDigitSum)\n            sum=(int(diff/3))*(n1+n2+n3)+findRemainigSum(lDigitSum,dDigitSum,diff%3)\n        else:\n            sum=(int(diff/9))*45+findRemainigSum(lDigitSum,dDigitSum,diff%9)\n    print(sum)\n    t-=1 ", "t=eval(input())\ndef func(k,n,x,dist,graph):\n if k==n:\n  x+=[dist[n]]\n  return\n for i in range(1,n+1):\n  if graph[k][i]!=0 and dist[i]==-1:\n   dist[i]=dist[k]+graph[k][i]\n   func(i,n,x,dist,graph)\n   dist[i]=-1\n   \nwhile t:\n graph=[[0 for i in range(11)]for j in range(11)]\n v,e=list(map(int,input().split()))\n for i in range(e):\n  x,y,w=list(map(int,input().split()))\n  graph[x][y]=w\n  graph[y][x]=w\n x=[]\n dist=[-1]*(v+1)\n dist[1]=0\n func(1,v,x,dist,graph)\n x.sort()\n val=x[0]\n ans=0\n for i in range(len(x)):\n  if val==x[i]:\n   ans+=1\n print(ans)\n t-=1\n", "# cook your dish here\nt=int(input())\nfor z in range(t):\n d=list(input().split())\n front, back, left, right, top, bottom=d[0],d[1],d[2],d[3],d[4],d[5] \n if (front==left or front==right) and (front==top or front==bottom):\n  print('YES')\n elif (back==left or back==right) and (back==top or back==bottom):\n  print('YES')\n else:\n  print('NO')", "# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n x=[]\n y=[]\n k=4*n-1\n for i in range(k):\n  a,b=input().split()\n  if a in x:\n   x.remove(a)\n  else:\n   x.append(a) \n  \n  if b in y:\n   y.remove(b)\n  else:\n   y.append(b)\n print(x[0],y[0])", "# cook your dish here\nimport math\nt=int(input())\nfor i in range (t):\n n,k=map(int,input().strip().split(\" \"))\n a=[int(x) for x in input().split()]\n od_a=[]\n ev_a=[]\n for j in range(n):\n  if(j%2==0):\n   ev_a.append(a[j])\n  else:\n   od_a.append(a[j])\n ev_a.sort()\n od_a.sort()\n n1=len(ev_a)\n n2=len(od_a)\n s1=sum(ev_a)\n s2=sum(od_a)\n if(s2>s1):\n  print(\"YES\")\n  continue\n elif(k==0):\n  print(\"NO\")\n  continue\n for j in range(k):\n  if(j==n2):\n   break\n  if(ev_a[n1-1-j]>od_a[j]):\n   temp=ev_a[n1-1-j]\n   ev_a[n1-1-j]=od_a[j]\n   od_a[j]=temp\n  s1-=(od_a[j]-ev_a[n1-1-j])\n  s2+=(od_a[j]-ev_a[n1-1-j]) \n  if(s2>s1):\n   print(\"YES\")\n   break\n if(s1>=s2):\n  print(\"NO\")", "def digit(x):\n ans = None\n for i in range(64):\n  if x&(1<<i): \n   return i\n  \n#data = open(\"P7.txt\")\nn = int(input())\n#n = int(data.readline())\nif n<4:\n print(\"No\")\n \nelse:\n count = [0]*65\n nums = {}\n vals = list(map(int,input().split()))\n #vals = map(long,data.readline().split())\n nums[vals[0]] = 1\n prebit = 999999999\n \n for i in range(1,n):\n  bit = digit(vals[i]^vals[i-1])\n  if bit!=prebit:\n   count[bit] += 1\n   prebit = bit\n  try:\n   nums[vals[i]] += 1\n  except:\n   nums[vals[i]] = 1\n  \n m1 = max(count)\n m2 = max(nums.values())\n if m1>=2 or m2>=4: print(\"Yes\")\n else: \n  num_doubles = 0\n  for val in list(nums.values()):\n   if val >= 2:\n    num_doubles += 1\n  if num_doubles >= 2:\n   print(\"Yes\")\n  else:\n   print(\"No\")", "from operator import add\nfrom functools import reduce\n\nchoices=[]\n\nfor x in range(1800):\n num_str = list(map (int, str (2**x)))\n suma = reduce (add, num_str)\n choices.append(suma)\nN=int(input())\n\nfor x in range(N):\n t=int(input())\n print(choices[t])\n", "# cook your dish here\nclass node:\n\tdef __init__(self,a,b=0,c=0):\n\t\tself.val=a\n\t\tself.a=b\n\t\tself.b=c\n\narr=[]\n\ndef finder(node,val):\n\tif(arr[node].val==0):\n\t\treturn val\n\telse:\n\t\ta=finder(arr[node].a,val)\n\t\tb=finder(arr[node].b,val)\n\t\tif(arr[node].val==1):\n\t\t\treturn a+b-a*b\n\t\telse:\n\t\t\treturn a*b\n\nt=int(input())\nwhile(t>0):\n\tx=input()\n\tn=int(input())\n\tarr.append(node(0))\n\tfor i in range(0,n):\n\t\tvals=input().split()\n\t\tsz=len(vals)\n\t\tfor i in range(0,sz):\n\t\t\tvals[i]=int(vals[i])\n\t\tif(vals[0]==0):\n\t\t\tnext=node(0)\n\t\t\tarr.append(next)\n\t\telse:\n\t\t\tnext=node(vals[0],vals[1],vals[2])\n\t\t\tarr.append(next)\n\tlower=0.0\n\thigher=1.0\n\teps=1e-9\n\twhile((higher-lower)>eps):\n\t\tmid=(higher+lower)/2.0 \n\t\tif(finder(n,mid)>0.5):\n\t\t\thigher=mid\n\t\telse:\n\t\t\tlower=mid\n\tprint(\"%.5f\" %(higher))\n\tarr=[]\n\t# print(higher)\n\tt-=1", "a=int(input())\nprint(\"25\")\n", "t=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    s=input()\r\n    i=1\r\n    c=0\r\n    while i<n:\r\n        if s[i]==s[i-1]:\r\n            c+=1\r\n        i+=1\r\n    print(c)\r\n            \r\n    \r\n", "# cook your dish here\ntest=int(input())\nfor _ in range(test):\n  a,b,c=[int(x) for x in input().split()]\n  t=s=0\n  m=100*a+b\n  while a*100+b>c and t<=10000:\n    if b<c:\n      a-=1\n      b+=100\n    b-=c\n    temp=b\n    b=a\n    a=temp\n    t+=1\n    if a*100+b>m:\n      m=a*100+b\n      s=t\n  print(s)", "test=int(input())\nfor i in range(test):\n N=input()\n X=[]\n for x in N:\n  X.append(x)\n Y=[]\n list1=[]\n output=''\n for y in X:\n  if int(y)>=6 and int(y) not in Y:\n   Y.append(y)\n for x in Y:\n  for y in X:\n   if int(x)==6:\n    if int(y)>=5:\n     n=int(x)*10+int(y)\n     list1.append(n) \n   else:\n    n=int(x)*10+int(y)\n    list1.append(n)\n for j in Y:\n  m=int(j)*10+int(j)\n  list1.remove(m)\n list1.sort()\n if len(list1)==0:\n  print(\" \")\n else:\n  list1.sort()\n  for k in list1:\n   if chr(k) not in output and k<91:\n    output+=chr(k)\n  print(output)\n   \n   \n   \n", "# cook your dish here\nfor i in range(int(input())):\n  n = int(input())\n  for j in range(n,-1,-1):\n    temp = j\n    for k in range(temp,0,-1):\n      print(\" \",end=\"\")\n      temp-=1\n    temp2 = j\n    for l in range(n,temp2-1,-1):\n      print(l,end=\"\")\n    print()\n  for m in range(1,n+1):\n      for i in range(m):\n        print(\" \",end=\"\")\n      for o in range(n,m-1,-1):\n        print(o,end=\"\")\n      print(\"\")", "# cook your dish here\nt = int(input())\nwhile t:\n    x = int(input())\n    arr = [int(i) for i in input().split()]\n    total = 0\n    for i in arr:\n        if i % 6 == 0:\n            total += 6\n        else:\n            total += (i % 6)\n    print(total)\n    t -= 1", "# cook your dish here\n\nT=int(input())\n\nfor _ in range(T):\n  \n n=int(input())\n x=list(map(int,input().split()))\n  \n print(min(x)*(n-1))\n  \n", "def f(n):\r\n    string = str(n)\r\n    for char in string:\r\n        if char in '05':\r\n            return 1\r\n    return 0\r\n\r\nt = int(input())\r\nanswers = list()\r\nfor _ in range(t):\r\n    n = int(input())\r\n    answers.append(f(n))\r\n\r\nfor answer in answers:\r\n    print(answer)", "# cook your dish here\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr 28 22:53:59 2020\n\n@author: srira\n\"\"\"\ncount = 0\nfor N in range(int(input())):\n    b, d = map(int, input().split())\n    if b >= 0:\n        count += d - b + 1\n    else:\n        count += d + abs(b) + 1\nprint(count % (10**9 + 7))", "# cook your dish here\nfor _ in range(int(input())):\n    k = int(input())\n    x = 1\n    for i in range(k):\n        for j in range(k):\n            print(x,end = '')\n            x = x + 2\n        print()", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n \n inv_count = 0\n m={}\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  inv_count += mergesort(m,0,k-1)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(m[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n", "t = int(input())\r\nfor i in range(0, t):\r\n    n = int(input())\r\n    c = 1\r\n    if n == 0:\r\n        print(0)\r\n    elif n == 1:\r\n        print(\"INFINITY\")\r\n    else:\r\n        for j in range(3, n+1):\r\n            a = n\r\n            while a >= j:\r\n                a = int(a/j)\r\n            if a == 1:\r\n                c = c+1\r\n        print(c)\r\n        ", "# cook your dish here\nfor i in range(int(input())):\n    n,k=[int(i) for i in input().split()]\n    if(n%2==0):\n     if(k<(n*(n+1))//2 - 1  or  k>3*((n//2)**2) - 1):print(-1)\n     elif(k==(n*(n+1))//2 - 1):\n      for i in range(1,n+1):print(i,'',end='')\n      print()\n     else:\n      k,count,p,l,x = k-(n*(n+1))//2 + 1,0,0,[0 for i in range(n)],1\n      while(k>0):p+=2 ;k,count = k-n+p ,count+1\n      for i in range(n,n-count+1,-1):l[x]=i ;x+=2\n      k=-k ;l[2*count - 1 +k],p = n-count+1 ,1\n      for i in range(n):\n       if(l[i]==0):l[i]=p ;   p+=1 \n      for i in l:print(i,'',end='')\n      print()\n    else:\n     if(n==1):print(1) if(k==0) else print(-1)                \n     elif(k<(n*(n+1))//2 - 1  or k>3*(n//2)*(n//2 + 1)):print(-1)\n     elif(k==(n*(n+1))//2 - 1):\n      for i in range(1,n+1):print(i,'',end='')\n      print()\n     else:\n      k,count,p,l,x = k-(n*(n+1))//2 + 1,0,0,[0 for i in range(n)],1\n      while(k>0):  p+=2 ;  k,count = k-n+p ,count+1", "MOD = int(1e9 + 7)\r\nfor _ in range(int(input())):\r\n    n = int(input()) + 1\r\n    res = (((3*pow(3, n, MOD) - 3) % MOD) * 500000004)% MOD\r\n    res = (res - (2*(pow(2, n, MOD) - 1)) % MOD) % MOD\r\n    print(res)", "def main():\n n = eval(input())\n city = input().split()\n m = eval(input())\n mapp = {}\n for c in city:\n  mapp[c] = [0]*n\n while m:\n  m -= 1\n  road = input().split()\n  temp = mapp[road[0]]\n  temp[city.index(road[1])] = int(road[-1])\n  mapp[road[0]] = temp\n t = eval(input())\n while t:\n  t -= 1\n  dist = 0\n  v = [0]*n #visited\n  route = input().split()\n  if route[0] == '1':\n   if route[-1] in city:\n    print(dist)\n   else:\n    print('ERROR')\n  else:\n   for r in range(1, int(route[0])+1):\n    if (route[r] not in city) or v[city.index(route[r])]:\n     dist = 'ERROR'\n     break\n    elif r>1:\n     if mapp[route[r-1]][city.index(route[r])]:\n      dist += mapp[route[r-1]][city.index(route[r])]\n     else:\n      dist = 'ERROR'\n      break\n    v[city.index(route[r])] = 1\n   print(dist)\nmain() ", "# cook your dish here\ndef main(): \n      \n    # Create a boolean array \"prime[0..n]\" and initialize \n    # all entries it as true. A value in prime[i] will \n    # finally be false if i is Not a prime, else true. \n    n=1000000\n    prime = [True for i in range(n + 1)] \n    p = 2\n    while (p * p <= n): \n          \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n              \n            # Update all multiples of p \n            for i in range(p * 2, n + 1, p): \n                prime[i] = False\n        p += 1\n    prime[0]= False\n    prime[1]= False\n    # Print all prime numbers \n    s=[]\n    s.append(0)\n    for p in range(1,n + 1): \n        if prime[p]: \n            s.append(s[p-1]+(p))\n        else:\n            s.append(s[p-1])\n    # print(s)\n    t=int(input())\n    for _ in range(t):\n        num=int(input())\n        print(s[num]%10)\nmain()", "t = int(input())\nfor i in range(t):\n  n,p = list(map(int, input().split(' ')))\n  \n  z= list(map(int, input().split()))\n  e = 0\n  d = 0\n  for j in z:\n   if j >= int(p/2):\n    e = e+1 \n   elif j <= int(p/10):\n    d = d+1\n  if e == 1 and d == 2:\n   print('yes')\n  else:\n   print('no')\n", "T=int(input())\nfor i in range(0,T):\n a,b=input().split()\n b=int(b)\n n=len(a)\n a=list(set(a))\n r=[]\n for c in range(97,123):\n  if(len(r)==n):\n   break\n  else:\n   if chr(c) not in a:\n    r.append(chr(c))\n   else:\n    if(b>0):\n     r.append(chr(c))\n     b=b-1\n if(len(r)!=n):\n  print(\"NOPE\")\n else:\n  print(''.join(r))\n", "T = int(input())\nans = []\n\nfor _ in range(T):\n N = int(input())\n A = [int(i) for i in input().split()]\n\n C2 = 0\n C = 0\n for i in range(N):\n  if(A[i]==2):\n   C2 += 1\n  if(A[i]>2):\n   C += 1\n ans.append(C2*C + (C*(C - 1))//2)\nfor i in ans:\n print(i)\n", "#!/usr/bin/env python\n\ndef fact(N):\n P = 1\n for n in range(2, N + 1):\n  P *= n\n return P\n\nT = int(input())\nfor t in range(T):\n N = int(input())\n print(fact(N))\n\n", "for _ in range(int(input())):\n s=input()\n rem=int(s)%9\n n=sum(map(int,s))\n if n<5 and len(s)>1:\n  print(9-n)\n else:\n  if rem >= 5:\n   rem=9-rem\n  print(rem)", "# cook your dish here\nn = int(input())\nfor _ in range(n):\n arr = list(map(int, input().split()))\n a = [2,3,9]\n count=0\n for i in range(arr[0], arr[-1]+1):\n  if i%10 in a:\n   count+=1\n print(count)", "# EXNETWRK.py\n\nt = int(input())\nfor _ in range(t):\n n,m = list(map(int, input().split()))\n if n == m :\n  for i in range(1,n+1):\n   print(i,i%n+1)\n else:\n  print(-1,-1)\n", "for _ in range(int(input())):\n    x,n = map(int,input().split())\n    reach = [0]*(x+1)\n    reach[0] = 1\n    i=1\n    while i**n<=x:\n        j = 1\n        while j+i**n<=x:\n            j+=1\n        j-=1\n        while j>=0:\n            if reach[j]>0:\n                reach[j+i**n]+=reach[j]\n            j-=1\n        i+=1\n    #print(reach)\n    print(reach[-1])", "read = lambda: list(map(int, input().split()))\nread_s = lambda: list(map(str, input().split()))\n\nn, m = read()\nans = 0\nif n == m:\n print(n)\n return\nwhile n > 0:\n if n > m:\n  ans += m\n  n -= 2*m\n else:\n  ans += 1\n  n -= 2\nprint(ans)", "def dfs(ind,m,n):\n if(ind == m):\n  return [\"\"]\n else:\n  temp = dfs(ind+1,m,n)\n  ans = []\n  for i in temp:\n   for j in range(97,97+n):\n    ans += [chr(j)+i]\n return ans\nn,m,k = list(map(int,input().split()))\np = []\nfor _ in range(m):\n inp = [int(x) for x in input().split()]\n p += [inp]\nans = dfs(0,m,n)\nw = []\nfor i in ans:\n cst = 0\n for j in range(m):\n  cst += p[j][ord(i[j])-97]\n w += [(-cst,i)]\nw.sort()\nprint(w[k-1][1])\n", "def gcd(a,b):\n if b==0:return a\n return gcd(b,a%b)\ndef abc(n, a, d):\n return n*(2*a + (n-1) * d)//2\nwhile 1:\n n, m, x = map(int, input().split())\n if m==n==x==0:break\n c = gcd(n, m)\n l = m//c\n ans = (abc(m, x, n)-c*abc(l, x % c, c))//m\n print(ans)", "# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n n = int(input())\n \n a = [int(x) for x in input().split()]\n b = [int(x) for x in input().split()]\n \n a.sort()\n b.sort()\n \n ans = 0\n for i in range(n):\n  ans += min(a[i],b[i])\n  \n print(ans)", "tc = int(input())\nwhile tc!= 0:\n count=0\n n,k= map(int, input().split())\n h = sorted(map(int,input().split()))\n h.reverse()\n queue = [h[0]]\n sum2 = h[0]\n res = -1\n for i in range(1,len(h)):\n  queue2=[]\n  s=set()\n  sum2+= h[i]\n  for x in queue:\n   if x not in s:\n    queue2.append(x)\n    s.add(x)\n   if h[i] not in s:\n    queue2.append(h[i])\n    s.add(h[i])\n   if x+h[i] not in s:\n    queue2.append(x+h[i])\n    s.add(x+h[i])\n   if(x+h[i])>=k and (sum2-x-h[i])>=k:\n    res= i+1\n    break\n   if (h[i]>=k) and (sum2-h[i])>=k:\n    res= i+1\n    break\n  if res!= -1:\n   break\n  queue = queue2\n print(res)\n tc-= 1", "from collections import Counter\n\n\na= int(input())\nwhile a!=0:\n b = int(input())\n original = list()\n original.append(0)\n ev,od=0,0\n\n for i in range(b):\n\n  c = int(input())\n  if c in original:\n   print(ev,od)\n   continue\n  else:\n   for j in range(len(original)):\n    p = c^original[j]\n    if Counter(bin(p))['1']%2 == 0:\n     ev+=1\n    else:\n     od+=1\n    original.append(p)\n   print(ev,od)\n  \n\n a-=1\n", "# cook your dish here\nn=int(input())\nfor _ in range(n):\n a=int(input())\n if(a%2==0):\n  f=(a//2)-1\n  s=a-f\n else:\n  f=(a//2)\n  s=a-f\n print(f,s)", "import math\n\n\nt = int(input().strip())\n\nfor _ in range(t):\n n, m = list(map(int, input().strip().split()))\n a = []\n v = [-1] * 4\n\n for i in range(n):\n  a.append(input().strip())\n\n for i, ai in enumerate(a):\n  if ai.find('*') > -1:\n   v[2] = i\n   break\n\n if v[2] == -1:\n  print(0)\n else:\n\n  for i, ai in reversed(list(enumerate(a))):\n   if ai.find('*') > -1:\n    v[3] = i\n    break\n\n  for i in range(m):\n   x = [ai[i] for ai in a]\n   if '*' in x:\n    v[0] = i\n    break\n\n  for i in reversed(range(m)):\n   x = [ai[i] for ai in a]\n   if '*' in x:\n    v[1] = i\n    break\n\n  if v.count(v[0]) == len(v):\n   print(1)\n  else:\n   print(int(math.ceil(max(v[3] - v[2], v[1] - v[0]) / 2.0)) + 1)", "T = int(input())\r\n\r\nfor t in range(T):\r\n    N = int(input())\r\n    \r\n    for i in range(N):\r\n        sol = \"1\"\r\n        for j in range(2,N+1):\r\n            sol+=str(i+1)+str(j)\r\n        print(sol+str(i+1))", "test = int(input())\nfor _ in range(test):\n n, m = map(int, input().split())\n indexArray = list(map(int, input().split()))\n mini = min(indexArray)\n maxi = max(indexArray)\n result = n*[0]\n for i in range(n):\n  result[i] = max(maxi - i, i - mini)\n  print(result[i], end=\" \")\n print()", "t=input()\nt=int(t)\nwhile t!=0 :\n n=input()\n n=int(n)\n f=0\n while n!=0 :\n  inp=input().split(\" \")\n  inp=[int(x) for x in inp]\n  np=(inp[0]*inp[2]*0.01)+inp[0]\n  f+=(inp[0]-(np-(np*inp[2]*0.01)))*inp[1]\n  n-=1\n print(f)\n t-=1", "# cook your dish here\nmod = 1000000007\nt = int(input())\nfor _ in range(t):\n    m, n = list(map(int, input().split()))\n    x = min(m, n)\n    f1 = m * n % mod\n    s1 = x * (x - 1) // 2 % mod\n    f2 = (m + n) % mod\n    s2 = x * (x - 1) * (2*x - 1) // 6 % mod\n    s3 = s1 * s1 % mod\n    ans = (f1 * s1 % mod - f2 * s2 % mod + s3) % mod\n    print(ans)\n\n\n", "from collections import defaultdict\nfrom operator import itemgetter\nfor _ in range(int(input())):\n n=int(input())\n d=defaultdict(list)\n for i in range(n):\n  x,y=list(map(int,input().split( )))\n  if not d[x]:\n   d[x].append(y)\n  else:\n   d[x][0]=max(d[x][0],y)\n y=[]\n for v in d:\n  y.extend(d[v])\n #print(y)\n if len(y)>=3:\n  v1=max(y)\n  y.remove(v1)\n  v2=max(y)\n  y.remove(v2)\n  v3=max(y)\n  y.remove(v3)\n  print(v1+v2+v3)\n else:\n  print(0)\n", "\nn=int(input())\nfor i in range(n):\n   s=input().strip()\n   c=0 \n   I=0 \n   J=len(s)-1 \n   while I<J:\n       c+=abs(ord(s[I])-ord(s[J]))\n       I+=1 \n       J-=1\n   print(c)", "for i in range(int(input())):\n r = [1, 2, 3, 4, 5, 6, 7]\n N = int(input())\n li = list(map(int, input().split()))\n x = []\n \n for j in li:\n  if j not in x:\n   x.append(j)\n \n if li == li[::-1] and x == r:\n  print('yes')\n else:\n  print('no')", "modulo = int(1e9) + 7\nfor t in range(int(input())):\n l,r = map(int,input().split())\n curr = 1\n ans = 0\n for i in range(61):\n  q = (l)//curr\n  if q&1:\n   end = min(r,(q+1)*curr-1)\n   ans = (ans + (curr*(end-l+1)%modulo)%modulo)%modulo\n   #print(i,end,q,curr,ans)\n  curr *= 2\n print(ans)", "# cook your dish here\ndef primefun(n):\n    seive=[1 for i in range(n+1)]\n    i=2\n    while(i*i<=n+1):\n        if seive[i]==1:\n            for j in range(i*i,n+1,i):\n                seive[j]=0\n        i=i+1\n    seive[0]=0\n    seive[1]=0\n    return seive\ndef divide(n,seive):\n    #print('divide n is',n)\n    for i in range(2,n,1):\n        if(n%i==0):\n            #print('n%i is',i)\n            if(seive[i]==1 and seive[n//i]==1):\n                if i!=n//i:\n                    return True\ncount=int(input())\nfor g in range(count):\n    n=int(input())\n    flag=0\n    seive=primefun(n)\n    for i in range(6,n):\n        if(i+(n-i)==n):\n            #print(i,n-i)\n            k=n-i\n            if divide(i,seive)==True  and  divide(k,seive)==True:\n                flag=1\n                print('YES')\n                break\n    if flag==0:\n        print('NO')\n        \n                \n           \n", "# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n arr=[int(ele) for ele in input().split()]\n arr.sort()\n x=n//4\n y=2*x\n z=3*x\n if arr[x]==arr[x-1] or arr[y]==arr[y-1] or arr[z]==arr[z-1] :\n  print(\"-1\")\n else:\n  print(arr[x],arr[y],arr[z])\n \n", "# cook your dish here\nfor i in range(int(input())):\n h = int(input())\n f = []\n su = []\n for j in range(0,h):\n  f.append(list(map(int,input().split())))\n for k in range(0,h):\n  s = 0\n  s1 = 0\n  for l in range(0,k+1):\n   s += f[l][h+l-k-1]\n   s1 += f[h+l-k-1][l]\n  su.append(s)\n  su.append(s1)\n print(max(su))", "# cook your dish here\nn=int(input())\nm=pow(10,9)+7\nfor i in range(n):\n s=list(input())\n c=[None]*len(s)\n for j in range(len(s)):\n  c[j]=-1\n  \n for j in range(len(s)):\n  if(s[j]=='a' or s[j]=='i' or s[j]=='e' or s[j]=='o' or s[j]=='u'):\n   c[j]=1 \n  else:\n   c[j]=0\n d=len(s)-1\n a=0\n for j in range(0,len(s)):\n  k=pow(2,d)\n  a+=(k*c[j])\n  d-=1\n print(a%m) \n", "t=int(input())\nfor _ in range(t):\n    n,m=map(int,input().split())\n    mat=[0 for i in range(n)]\n    #mat=[[0 for i in range(n)] for j in range(n)]\n    for i in range(m):\n     u,v=map(int,input().split())\n     u,v=(u-1),(v-1)\n     mat[u]|=(1<<v)\n     mat[v]|=(1<<u)\n    for i in range(n):\n     mat[i]|=(1<<i)    \n \n    goal=(2**n)-1\n    ans=n\n\n    for i in range(1,goal+1):\n     mvs=0\n     loc=0\n     for j in range(n):\n      if(i&(1<<j)):\n       loc|=mat[j]\n       mvs+=1\n     if(loc==goal):\n      ans=min(mvs,ans)\n    print(ans)", "t = eval(input())\ni=1\nwhile(i<=t):\n  j=eval(input())\n  j=(2*j)-1\n  k=1\n  p=1\n  while(k<=j):\n    p=p*k\n    k=k+2 \n  print(p)\n  print(\"\\n\")\n  i=i+1", "N = int(input())\nif N < 10:\n print(1)\nelif N < 100:\n print(2)\nelif N < 1000:\n print(3)\nelse:\n print(\"More than 3 digits\")\n\n", "# codechef - easy - collide\n\ndirTable = {}\ndirTable[\"R\"] = (1,0)\ndirTable[\"L\"] = (-1,0)\ndirTable[\"D\"] = (0,-1)\ndirTable[\"U\"] = (0,1)\n\ndef readCoordinates():\n strX, strY, strDir = input().split()\n x = int(strX)\n y = int(strY)\n dx,dy = dirTable[strDir]\n return x,y, dx,dy\n\n\nt = int(input())\nfor test in range(t):\n xe, ye, dxe, dye = readCoordinates()\n n = int(input())\n shortest = 1000\n for i in range(n):\n  xa, ya, dxa, dya = readCoordinates()\n  xa -= xe\n  ya -= ye\n  dxa -= dxe \n  dya -= dye\n\n  if dxa==0 and dya==0:\n   #print \"Same direction, pass\"\n   continue\n  elif dxa==0:\n   if xa!=0:\n    #print \"parallel, pass\"\n    continue\n   else:\n    time = -ya*1.0/dya\n    #print time\n    if 0<time<shortest:\n     shortest = time\n  elif dya==0:\n   if ya!=0:\n    #print \"parallel Y\"\n    continue\n   else:\n    time = -xa*1.0/dxa\n    #print time\n    if time>0 and time<shortest:\n     shortest = time\n  else:\n   # dx,dy both !=0\n   tx = -xa*1.0/dxa\n   ty = -ya*1.0/dya\n   #print tx,ty\n   if tx==ty and 0<tx<shortest:\n    shortest = tx\n if shortest<1000:\n  print(\"%.1f\" % shortest)\n else:\n  print(\"SAFE\")\n\n \n  \n  \n  \n", "def update_B(B, query):\n p, R = query\n for i in range(len(R)):\n  B[p][i] = R[i]\n  B[i][p] = R[i]\n\ndef get_A(B):\n N = len(B)\n A = [0] * N\n i = 0\n for j in range(N):\n  if B[0][j] != 0:\n   i = j\n   A[i] = -B[0][i]\n   break\n\n for j in range(i + 1, N):\n  if abs(A[i] - B[0][j]) == B[i][j]:\n   A[j] = B[0][j]\n  else:\n   A[j] = -B[0][j]\n\n return A\n\ndef print_list(A):\n print(' '.join([str(a) for a in get_A(B)]))\n\n\nN, Q = [int(x) for x in input().rstrip().split()]\nB = []\nfor i in range(N):\n B += [[int(x) for x in input().rstrip().split()]]\nqueries = []\nfor i in range(Q):\n p = int(input()) - 1\n arr = input().rstrip().split()\n queries += [(p, [int(x) for x in arr])]\n\nprint_list(get_A(B))\nfor q in queries:\n update_B(B, q)\n print_list(' '.join([str(a) for a in get_A(B)]))\n", "mod=10**9+7\ndef fibonacci(n):\n if n < 0:\n  raise ValueError(\"Negative arguments not implemented\")\n return (_fib(n)[0]%mod + mod)%mod;\ndef _fib(n):\n if n == 0:\n  return (0, 1)\n else:\n  a, b = _fib(n // 2)\n  c = (a * (b * 2 - a))%mod\n  d = (a * a + b * b)%mod\n  if n % 2 == 0:\n   return (c, d)\n  else:\n   return (d, c + d)\ndef inv(n):\n return pow(n,mod-2,mod)\ndef brute(n,k):\n ret = 0\n for i in range(0,n+1):\n  ret+=fibonacci(i)*pow(k,i,mod)\n return ret%mod\ndef ans(n,k):\n k%=mod\n a = pow(k,n+1,mod)\n b=(a*k)%mod\n x = a*(fibonacci(n+1))+b*fibonacci(n)-k\n y = inv((k*k+k-1)%mod)\n return ((x*y)%mod+mod)%mod\nfor t in range(0,eval(input())):\n n,k = list(map(int,input().split()))\n print(ans(n,k))", "import sys\nsys.setrecursionlimit(10**8)\n\nMOD = 10**9+7\n\nfac = [0]*(10**5+1)\ndef pre() :\n fac[0] = 1\n for i in range(1,10**5+1) :\n  fac[i] = fac[i-1]*i\n  fac[i] = fac[i]%MOD\n\ndef dfs(gp , vertex , visited , deg , ans) :\n visited[vertex] = 1\n stack = []\n stack.append(vertex)\n while len(stack)>0 :\n  vertex = stack.pop()\n  ans = ans%MOD * fac[deg[vertex]]%MOD\n  ans %= MOD\n  for i in gp[vertex] :\n   if not visited[i] :\n    visited[i] = 1\n    if vertex in gp[i] :\n     deg[i] -= 1\n    stack.append(i)\n return ans%MOD\n\npre()\nfor __ in range(eval(input())) :\n n = eval(input())\n deg = [0]*(n+1)\n st = [[]]*(n+1)\n for _ in range(n-1) :\n  a , b = list(map(int,sys.stdin.readline().split()))\n  st[a].append(b)\n  st[b].append(a)\n  deg[a] += 1\n  deg[b] += 1\n k = eval(input())\n ans = 1\n visited = [0]*(n+1)\n print(dfs(st ,k,visited,deg , 1)%MOD)\n  \n", "# cook your dish here\ntry:\n    t=int(input())\n    for i in range(0,t):\n        a,b=map(int,input().split())\n        if(a>b):\n            print('>')\n        elif(a<b):\n            print('<')\n        else:\n            print('=')\nexcept:pass", "for _ in range(eval(input())):\n noc = eval(input())\n power = list(map(int, input().split()))\n spower = power[0]\n ppowers= power[1:]\n ans = sum([1 for x in ppowers if x > spower])\n print(ans)", "from sys import stdin,stdout\r\nfrom math import gcd\r\nfor _ in range(int(stdin.readline())):\r\n    # n=int(stdin.readline()) k-pieces\r\n    n,k=list(map(int,stdin.readline().split()))\r\n    a=list(map(int,stdin.readline().split()))\r\n    gr=[[0 for _ in range(n)]for _ in range(n)];ans=0;k-=1\r\n    for sz in range(n):\r\n        for i in range(n-sz):\r\n            j=i+sz\r\n            if sz==0:gr[i][j]=a[i]\r\n            else:\r\n                gr[i][j]=gcd(gr[i+1][j],gr[i][j-1])\r\n    # print(*gr,sep='\\n')\r\n    dp=[[0 for _ in range(n)]for _ in range(k+1)]\r\n    for i in range(n):\r\n        dp[0][i]=gr[0][i]\r\n    for i in range(1,k+1):\r\n        for j in range(i,n):\r\n            for par in range(j-1,-1,-1):\r\n                dp[i][j]=max(dp[i][j],gr[par+1][j]+dp[i-1][par])\r\n    # print(*dp,sep='\\n')\r\n    print(dp[k][n-1])\r\n\r\n", "# cook your dish here\nn=int(input())\nl=[]\nfor i in range(n):\n    a=int(input())\n    l.append(a)\nfor i in l:\n    b = list(map(int, str(i)))\n    b.sort(reverse=True)\n    s = [str(i) for i in b]\n    r = int(\"\".join(s))\n    print(r)", "import math\nt=int(input())\nfor _ in range(t):\n\tn=int(input())\n\tz=2*int(math.sqrt(n/2))\n\tprint(int(z))", "n, k=map(int, input().split())\r\nfor i in range(k):\r\n    arr=list(map(int, input().split()))\r\n    res=[]\r\n    \r\n    for i in range(len(arr)-1, 0, -1):\r\n        if(arr[i]>arr[i-1]):\r\n            res.append(arr[i-1])\r\n            res.append(arr[i])\r\n            temp=arr[i-1]\r\n            break\r\n        else:\r\n            res.append(arr[i])\r\n        \r\n    res.sort()\r\n    for j in range(len(res)):\r\n        if(res[j]>temp):\r\n            arr[i-1]=res[j]\r\n            res.remove(res[j])\r\n            break\r\n    \r\n    for j in range(len(res)):\r\n        arr[i]=res[j]\r\n        i+=1\r\n        \r\n    print(*arr)", "res = []\nfor _ in range(int(input())):\n lst = []\n flag = 0\n n = int(input())\n for i in range(n):\n  lst.append(list(map(int, input().split())))\n for i in lst:\n  for j in range(n-1):\n   if i[j] == i[j+1] == 1:\n    res.append(\"UNSAFE\")\n    flag = 1\n    break\n  if flag != 0:\n   break\n for i in range(n-1):\n  for j in range(n):\n   if lst[i][j] == lst[i+1] == 1:\n    res.append(\"UNSAFE\")\n    flag = 1\n    break\n  if flag != 0:\n   break\n if flag == 0:\n  res.append(\"SAFE\")\nfor i in res:\n print(i)\n", "# cook your dish here\nt=int(input())\nwhile t:\n s=input()\n f=1\n for i in 'MITL':\n  if s.count(i)<2:\n   f=0\n   break\n if f:\n  if len(s)==9:\n   if s.count('E'):\n    print(\"YES\")\n   else:\n    print(\"NO\")\n  else:\n   if s.count('E')>1:\n    print(\"YES\")\n   else:\n    print(\"NO\")\n else:\n  print(\"NO\")\n t-=1", "# cook your dish here\nt=int(input())\nfor i in range(t):\n n,k=list(map(int,input().split(\" \")))\n sum=0\n z=0\n while(n>1):\n  sum+=(k**(n-1))*((-1)**z)\n  n-=1\n  z+=1\n print(sum%1000000007)\n\n", "f = False\nwhile f == False:\n s = input().strip()\n d = dict()\n f = True\n for i in s:\n  if i in list(d.keys()):\n   f = False\n  else:\n   d[i] = 1\n if not f : print(\"Invalid\")\n else : print(\"Valid\")", "# cook your dish here\nfor a0 in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(1,n+1):\n        l.append(str(i))\n    l = l[::-1]\n    s = \"\"\n    for i in l:\n        s+=i\n    print(s)\n    i = 0\n    while len(set(l))>2 or \"2\" in l:\n        l[i] = \"*\"\n        s = \"\"\n        for j in l:\n            s+=j\n        print(s)\n        \n        i+=1\n        \n        \n", "t = eval(input())\nwhile t>0 :\n p = input()\n count = 0\n cost = 0\n i=0\n while i<len(p):\n  if count == 6:\n   count = 0\n   i = i +1\n   continue\n  if p[i] == 'M':\n   cost = cost + 3\n  else:\n   cost = cost + 4\n  count = count +1\n  i = i+1\n print(cost)\n t = t-1", "# cook your dish here\nimport math\ntry:\n t=int(input())\n for _ in range (t):\n  n,k=list(map(int,input().split()))\n  seq=[]\n  for i in range(1,n+1):\n   if i%2!=0:\n    seq.append(i)\n   else:\n    seq.append(-i)\n  positive=math.ceil(n/2)\n  if(positive>k):\n   i=n-1\n   req=positive-k\n   while (req>0):\n    if seq[i]>0:\n     seq[i] *=-1\n     req -=1\n    i -=1\n  if(positive<k):\n   i=n-1\n   req=k-positive\n   while (req>0):\n    if seq[i]<0:\n     seq[i] *=-1\n     req -=1\n    i -=1\n  print(*seq)\nexcept EOFError as t : pass\n  \n", "import string\n\nt=0\ntry:\n t=int(input().strip())\nexcept:\n pass\nfor _ in range(0,t):\n r,c=[int(j) for j in input().split()]\n a=[]\n flag=False\n m=\"\"\n for q in range(0,r):\n  ll=input().lower()\n  a.append(ll)\n  m=m+ll\n  \n for q in a:\n  if q.find(\"spoon\")!=-1:\n   flag = True\n   break\n if not flag:\n  q=0\n  bb=(r-4)*c\n  while q<bb:\n   if m[q]==\"s\":\n    ja=m[q]+m[q+c]+m[q+2*c]+m[q+3*c]+m[q+4*c]\n    if ja==\"spoon\":\n     flag=True\n     break\n   q+=1\n if flag:\n  print(\"There is a spoon!\")\n else:\n  print(\"There is indeed no spoon!\")\n", "# cook your dish here\nimport math\nfor _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    s=l[0]\n    for i in range(1,n):\n        s=math.gcd(s,l[i])\n    if s==1:\n        print(-1)\n    elif s%2==0:\n        print(2)\n    else:\n        ans=0\n        for i in range(3,int(s**0.5)+1):\n            if s%i==0:\n                ans=i \n                break \n        if ans==0:\n            print(s)\n        else:\n            print(ans)\n    ", "# cook your dish here\nn=int(input())\ndct=dict()\nc=0\nfor i in range(n):\n    x=input()\n    for j in x:\n        if j.isdigit():\n            if j in list(dct.keys()):\n                dct[j]+=1\n            else:\n                dct[j]=1\nfor k in dct:\n    if dct[k]==1:\n        c+=1\nprint(c)\n", "for _ in range(int(input())):\n n,k=map(int,input().split())\n sum=0\n maxim=n-k+1\n if k>n:\n  sum=0\n else:\n  for i in range(1,n+1):\n   sum+=i\n   if i==maxim:\n    break\n print('Case'+' '+str(_+1)+':',sum)", "\nfor _ in range(int(input())):\n    n=int(input())\n    if(n<3):\n        print(\"B\")\n    else:\n        if(n==3):\n            print(\"A\")\n        elif(n%2):\n            print(\"B\")\n        else:\n            print(\"B\")\n\n\n\n\n\n\n\n\n", "from sys import*\r\ninput=stdin.readline\r\nt=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    print(((n-1)*(n)*((2*(n-1))+1))//6)\r\n", "t=int(input())\nwhile t>0:\n  t-=1\n  n,p=map(int,input().split())\n  l=list(map(int,input().split()))\n  l.sort()\n  l.reverse()\n  count=0\n  k=l[p-1]\n  for i in range(n):\n   if l[i]<k:\n    break\n   else:\n    count+=1\n  print(count)", "def factors(x):\n result = []\n i = 1\n while i*i <= x:\n  if x % i == 0:\n   result.append(i)\n   if x//i != i:\n    result.append(x//i)\n  i += 1\n return result\n\nt = int(input())\nfor _ in range(t):\n n, k = map(int, input().split())\n a = factors(n)\n an = -1\n for i in a:\n  c = ((i*k*(k+1))//2)\n  if (c%i==0 and c<=n):\n   an=max(an,i)\n print(an)", "t=int(input())\nfor _ in range(t):\n a,b,c,d=map(int,input().split())\n print(int((a+b+c)/2 -b),end=\" \")\n print(int((a+b+c)/2 -c),end=\" \")\n print(int((a+b+c)/2 -a))\n print()\n ", "for _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n res = 0\n gas = a[0]\n for i in range(1, len(a)):\n  if gas <= 0:\n   break\n  else:\n   gas -= 1\n   res += 1\n   gas += a[i]\n print(res + gas)", "t = int(input())\nfor i in range(t):\n n, q = input().split()\n cities = [int(x) for x in input().split()]\n cities_sort = cities.copy()\n cities_sort.sort()\n for j in range(int(q)):\n  q1, q2 = [int(x) for x in input().split()]\n  a = cities[q1 - 1]\n  b = cities[q2 - 1]\n  if (a > b):\n   c = a\n   a = b\n   b = c\n  pos_a = cities_sort[::1].index(a)\n  pos_b = len(cities_sort) - 1 - cities_sort[::-1].index(b)\n  print(q2 - q1 + b - a, pos_b - pos_a + 1)", "# cook your dish here\ntests = int(input())\nfor test in range(tests):\n    n = input().strip()\n    length = len(n)\n    steps = length - (n.count('4') + n.count('7'))\n    print(steps)", "author=\"himanshu malhotra\"\naa,bb=0,0\nfor _ in range(eval(input())):\n n,m=list(map(int,input().split()))\n li=list(map(int,input().split()))\n dp=[float(\"inf\")]*((1<<n)+1)\n for i in range(n):\n  dp[1<<i]=li[i]\n dp[1<<(n-1)]=min(dp[1<<(n-1)],sum(li))\n for i in range(m):\n  q=list(map(int,input().split()))\n  cost,no,items=q[0],q[1],q[2:]\n  mask=0\n  for j in items:\n   mask |= (1<<(j-1))\n  dp[mask]=min(dp[mask],cost)\n for i in range((1<<n)-1,-1,-1):\n  for j in range(n):\n   if i&(1<<j):\n    dp[i^(1<<j)]=min(dp[i^(1<<j)],dp[i])\n ans=[float(\"inf\")]*((1<<n)+1)\n ans[0]=0\n for i in range(1<<n):\n  submask=i\n  while submask>0:\n   ans[i]=min(ans[i],dp[submask]+ans[i-submask])\n   submask=(submask-1)&i\n print(ans[(1<<n)-1])\n   \n", "T = int(input())\nfor _ in range(T):\n X, K = [int(x) for x in input().split()]\n \n k, x, y = 1, 2, 1\n while x <= K:\n  k, x, y = k + 1, x * 2, x\n \n print((X/ x) + (K - y) * X/ y)", "n = int(input())\nfor _ in range(n):\n x, y = list(map(int, input().split()))\n bx = bin(x)[2:]\n by = bin(y)[2:]\n i = 0\n while i < min(len(bx), len(by)) and bx[i] == by[i]:\n  i += 1\n print(len(bx)+len(by) - 2*i)\n", "M=1000000007\nT=int(input())\nfor _ in range(T):\n n=int(input())\n l=[int(i) for i in input().split()]\n count1=0\n for i in range(1,n):\n  if((l[i-1]&l[i])!=l[i-1]):\n   count1=0\n   break\n  else:\n   count1+=(bin(l[i-1]&l[i]).count(\"1\"))\n \n if(count1==0):\n  print(count1)\n else:\n  print((2**count1)%M)", "# cook your dish here\nn=int(input())\narray=list(map(int, input().split()))\nfor i in range(3,n):\n    array[i]+=min([array[i-1],array[i-2],array[i-3]])\nprint(min([array[-1],array[-2],array[-3]]))", "n = int(input())\na = list(map(int,input().split()))\n\na.sort()\ncount = 0\ni = 0\nwhile(len(a)!=0 and len(a)!=1):\n if a[i] == a[i+1]:\n  a.pop(0)\n  a.pop(0)\n else:\n  a.pop(0)\n count += 1\nif len(a) == 1:\n count += 1\nprint(count)", "import sys\ndef main():\n    case=1\n    while True:\n        try:\n            m, n = list(map(int, sys.stdin.readline().split()))\n            if m>n:\n                m,n=n,m\n            r=[str(num) for num in range(m, n+1)]\n            s=''.join(r)\n            d={}\n            for number in s:\n                if number not in d:\n                    d[number]=1\n                else: d[number]+=1\n            for q in range(10):\n                if str(q) not in d:\n                        d[str(q)]=0\n            print(\"Case \"+str(case)+\": \"+\"0:\"+str(d['0'])+\" \"+\"1:\"+str(d['1'])+\" \"+\"2:\"+str(d['2'])+\" \"+\"3:\"+str(d['3'])+\" \"+\"4:\"+str(d['4'])+\" \"+\"5:\"+str(d['5'])+\" \"+\"6:\"+str(d['6'])+\" \"+\"7:\"+str(d['7'])+\" \"+\"8:\"+str(d['8'])+\" \"+\"9:\"+str(d['9']))\n            case+=1\n        except:\n            break\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    p = list(map(int,input().split()))\n    r = int(input())\n    lcm = p[0]\n    for i in p[1:]:\n      lcm = int(lcm*i/gcd(lcm, i))\n    print(int(lcm+r))", "# 4 4.296 3 3.8 -2 1.8 2 2.8678 1\r\narr = [x for x in input().split()]\r\nfor i in range(int(arr[0])):\r\n    ans = float(arr[1])*1.0*(10**int(arr[2]))\r\n    print(\"{:.2f}\".format(round(ans, 2)))\r\n    del arr[1]\r\n    del arr[1]\r\n", "for _ in range(int(input())):\n n = int(input())\n a = list(map(int,input().split()))\n ans = 0\n count = 0\n for i in a:\n  if i>0:\n   ans+=i\n   count+=1\n res = []\n for i in range(count):\n  if a[i]<=0:\n   res.append(i+1)\n for i in range(count,n):\n  if a[i]>0:\n   res.append(i+1)\n print(ans)\n print(len(res),end = \" \")\n print(*res)", "t = int(input())\nfor _ in range(t):\n n = int(input())\n data = list(map(int,input().strip().split()))\n \n prefix = [False]*n\n suffix = [False]*n\n \n prefix[0] = True\n for i in range(1,n):\n  if data[i]>data[i-1]:\n   prefix[i] = True\n  else:\n   break\n \n suffix[n-1] = True\n for i in range(n-2,-1,-1):\n  if data[i]<data[i+1]:\n   suffix[i] = True\n  else:\n   break\n   \n \n ans = 0\n if prefix.count(True) == n:\n  ans = (n*(n-1))/2 + (n-1)\n else:\n  for i in range(n):\n   if prefix[i]:\n    low =i\n    high =n\n    while(high-low>1):\n     mid = (low+high)//2\n     if suffix[mid] and data[i]<data[mid]:\n      high = mid\n     else:\n      low = mid\n    \n    ans += n-high\n   else:\n    break\n    \n  ans += suffix.count(True)\n  ans += prefix.count(True)\n  \n print(int(ans))\n", "for _ in range(int(input())):\n n,x=map(int,input().split())\n a=list(map(int,input().split()))\n a.sort()\n count=0\n for i in range(n):\n  # count+=1\n  if a[i]>=x/2:\n   # count-=1\n   break\n p=i\n  \n while 1:\n  if a[i]<=x:\n   count+=1\n   x=2*a[i]\n   \n  else:\n   while a[i]>x:\n    x=2*x\n    count+=1\n   x=2*a[i]\n   count+=1\n  i+=1\n  if i==n:\n   break\n print(count+p)", "for _ in range(int(input())):\n s = input()\n s = list(s)\n s1 = s\n f = 0\n l = len(s)\n if l >= 2:\n  for i in range(l):\n   if l % 2 == 0:\n    ln = l\n    tp1 = s1[:(ln//2)]\n    tp2 = s1[(ln//2):]\n    if str(tp1) == str(tp2):\n     f = 1\n     break\n   else:    \n    if i == 0:\n     tmp = s1[i+1:]\n     ln = l - 1\n     tp1 = tmp[:(ln//2)]\n     tp2 = tmp[(ln//2):]\n     if str(tp1) == str(tp2):\n      f = 1\n      break\n    else:\n     tmp = s1[:i]\n     tmp2 = s1[i+1:]\n     temp = tmp + tmp2\n     ln = l - 1\n     tp1 = temp[:(ln//2)]\n     tp2 = temp[(ln//2):]\n     if str(tp1) == str(tp2):\n      f = 1\n      break\n  if f == 1:\n   print(\"YES\")\n  else:\n   print(\"NO\")\n elif l == 1:\n  print(\"NO\")\n  \n", "# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n l=list(map(int,input().split()))\n l.sort()\n print(l[0]+l[1])", "for _ in range(int(input())):\n code=input().strip()+'0'\n message=''\n asc=int(code[0])\n \n for i in range(len(code)-1):\n  \n  if int(str(asc)+code[i+1])>256:\n   message+=chr(asc)\n   asc=int(code[i+1])\n  else:    \n   asc=int(str(asc)+code[i+1])\n   \n print(message)\n", "m = 10**9 + 7\ndef findNumbers(n, w): \n x = 0; \n s = 0; \n if (w >= 0 and w <= 8): \n  x = 9 - w; \n elif (w >= -9 and w <= -1): \n  x = 10 + w;     \n s = pow(10, n - 2,m); \n s *= (x%m);     \n return s%m; \nfor _ in range(int(input())):\n n,w = map(int,input().split())\n print(findNumbers(n,w))", "n,m=list(map(int,input().split()))\nl=list(map(int,input().split()))\nl.sort()\nl2=[]\nl4=[]\nl5=[]\nl6=[]\nl7=[]\nfor i in range(m):\n l3=input().split()\n l3[0]=int(l3[0])\n l3[1]=int(l3[1])\n l2.append(l3)\n\nfor k in range(len(l2)):\n if l2[k][0] in l:\n  l4.append(k)\n  l6.append(l2[k][1])\n else:\n  l5.append(k)\n  l7.append(l2[k][1])\n\nwhile True:\n max=0\n c=0\n for i in range(len(l6)):\n  if l6[i]>max:\n   max=l6[i]\n   c=i\n if max==0:\n  break\n y=int(l4[c])\n print(l2[y][2])\n l6[c]=0\n \nwhile True:\n max=0\n c=0\n for i in range(len(l7)):\n  if l7[i]>max:\n   max=l7[i]\n   c=i\n if max==0:\n  break\n y=int(l5[c])\n print(l2[y][2])\n l7[c]=0\n\n\n", "from collections import defaultdict\nimport copy\n#def dfs(l,r,dct):\ndef dfs(l,r,dct):\n visit=[0 for i in range(n+1)]\n arr=[l]\n while(arr):\n  node=arr.pop()\n  if node==r:return True\n  visit[node]=1\n  for lnk in dct[node]:\n   if not visit[lnk]:\n    arr.append(lnk)\n return False\n \ndef ok(mid,cst):\n for i,j in edges:\n  cst[i][j]-=mid\n \n d=[10**9]*(n+1)\n d[l]=0\n for _ in range(n-1):\n  for i,j in edges:\n   d[j]=min(d[j],d[i]+cst[i][j])\n   \n if d[r]<=0:return 1\n for i,j in edges:\n  if d[j]>d[i]+cst[i][j] and dfs(l,i,dct) and dfs(j,r,dct):\n   return 1\n return 0\n \nfor _ in range(int(input())):\n n,m=map(int,input().split())\n dct=defaultdict(list)\n \n cost=[[1000 for i in range(n+1)] for j in range(n+1)]\n edges=[]\n for i in range(m):\n  a,b,w=map(int,input().split())\n  edges.append([a,b])\n  dct[a].append(b)\n  cost[a][b]=min(cost[a][b],w)\n \n l,r=map(int,input().split())\n if not dfs(l,r,dct):\n  print(-1)\n  continue\n #print(cost)\n lo=1\n hi=101\n for i in range(100):\n  cst=copy.deepcopy(cost)\n  mid=(lo+hi)/2\n  if ok(mid,cst):hi=mid-1\n  else:lo=mid+1\n print(\"%.7f\"%mid)", "from sys import *\ninput=stdin.readline\nfor u in range(int(input())):\n    s=int(input())\n    if(s%3==0):\n        print(1)\n    else:\n        print(0)\n", "m= 1000000007\ndef mul(a,b):\n return [(a[0]*b[0]+a[1]*b[2])%m,\n   (a[0]*b[1]+a[1]*b[3])%m,\n   (a[2]*b[0]+a[3]*b[2])%m,\n   (a[2]*b[1]+a[3]*b[3])%m] \ndef f(n):\n if n==0:\n  return 0\n v1, v2, v3 = 1, 1, 0 \n for rec in bin(n)[3:]:\n  v2=v2%m\n  v1=v1%m\n  v3=v3%m\n  calc = (v2*v2)\n  v1, v2, v3 = (v1*v1+calc), ((v1+v3)*v2), (calc+v3*v3)\n  if rec=='1': v1, v2, v3 = v1+v2, v1, v2\n return [v1+1,v2,v2,v3+1]\n\ndef q(X,Y):\n nonlocal A\n s = [1,0,0,1]\n for v in A[X-1:Y]:\n  s = mul(s,f(v))\n return s[1]%m\n\nN,M = list(map(int,input().split()))\nA=list(map(int,input().split()))\nfor _ in range(M):\n [T,X,Y] = input().split()\n X,Y = int(X),int(Y)\n if T=='Q':\n  print(q(X,Y))\n else:\n  A[X-1]=Y", "for _ in range(int(input())):\r\n    lens = int(input())\r\n    has  = set([int(x) for x in input().split()])\r\n    rets = [0] * lens\r\n    for i in range(lens):\r\n        if i in has:\r\n            rets[i] = i\r\n\r\n    print(*rets)\r\n", "n = int(input())\nfrom collections import Counter\nfor c in range(n):\n t = int(input())\n s = list(map(int, input().strip().split()))\n count = dict(Counter(s))\n for k in sorted(count.keys()):\n  answer = str(k) + ': ' + str(count[k])\n  print(answer)", "def time(x1,y1,x2,y2):\n if x1==x2:\n  return y2-y1\n return y2-y1+1\n\nans=['no','yes'] \nfor _ in range(int(input())):\n t, fx, fy, sx, sy, f=0, 1, 1, 2, 1, 1\n for _ in range (int(input())):\n  a=[int(x) for x in input().split()]\n  if f:\n   if a[1]==a[3] and a[2]==a[4]:\n    f=0\n    continue\n   if fy>a[2] or sy>a[4]:\n    f=0\n    continue\n   t1=time(fx,fy,a[1],a[2])\n   t2=time(sx,sy,a[3],a[4])\n   _t=a[0]-t\n   if t1>_t or t2>_t:\n    f=0\n  t, fx, fy, sx, sy=a\n print(ans[f])\n \n\n", "MOD = 10**9 + 7\n\nfact = [1 for i in range(101)]\nfor i in range(2, 100):\n fact[i] = (fact[i - 1] * i) % MOD\n\ninv = [1 for i in range(101)]\nfor i in range(0, 100):\n inv[i] = pow(fact[i], MOD - 2, MOD)\n\ndef C(n, r):\n return (((fact[n] * inv[r]) % MOD) * inv[n - r]) % MOD\n\nt = int(input())\nfor qq in range(t):\n n, k = list(map(int, input().split()))\n for kk in range(n - 1):\n  a, b = list(map(int, input().split()))\n\n ans = 0\n for i in range(1, k + 1):\n  if (i-1) > (n-1):\n   break\n  cur = C(n - 1, i - 1) * C(k, i)\n  cur %= MOD\n  cur *= fact[i]\n  cur %= MOD\n  ans += cur\n  ans %= MOD\n\n print(ans % MOD)\n", "bell_nums = [1]\nt = [[1]]\n\ndef generate_num():\n nonlocal bell_nums\n nonlocal t\n for i in range(1,1001):\n  t.append([])\n  t[i].append(t[i-1][i-1])\n  for j in range(1,i+1):\n   t[i].append((t[i][j-1] + t[i-1][j-1]) % 1000000007)\n  bell_nums.append(t[i][i])\n\ngenerate_num()\ntc = int(input())\nwhile tc:\n n = int(input())\n print(bell_nums[n-1])\n tc -= 1\n", "for _ in range(int(input())):\r\n    n = int(input())\r\n    arr = list(map(int, input().split()))\r\n    total = 0\r\n\r\n    for i in arr:\r\n        if i == 5:  total += i\r\n        else:\r\n            if total == 0:\r\n                print(\"NO\")\r\n                break\r\n            else:\r\n                to_return = i - 5\r\n                if total < to_return:\r\n                    print(\"NO\")\r\n                    break\r\n                else:\r\n                    total += (5 - to_return)\r\n    else:\r\n        print(\"YES\")", "##//author : 'Amit Singh Sansoya @amit3200'\n##//it was all meant to happen as i was all talk!\nimport string\nfor _ in range(int(input())):\n s,k=list(map(str,input().split()))\n k=int(k)\n lower=[i for i in string.ascii_lowercase]\n l={}\n for i in lower:\n  l[i]=0\n for i in s:\n  l[i]+=1\n ans=len(s)\n for i in lower:\n  c=0\n  for j in lower:\n   if l[j]<l[i]:\n    c+=l[j]\n   elif (l[j]-l[i])>k:\n    c+=l[j]-l[i]-k\n  ans=min(ans,c)\n print(ans)\n\n", "for _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n ev=[]\n od=[]\n\n for i in a:\n  if i%2==0:\n   ev.append(i)\n  else:\n   od.append(i)\n c=0\n c1=0\n cc=0\n cc1=0\n if od:\n  mo=max(od)\n  for i in a:\n   if i!=mo and i%2!=mo%2:\n    c+=1\n   elif i!=mo and i%2==mo%2:\n    c+=2\n  mo+=1\n  for i in a:\n   if i%2==mo%2:\n    cc+=2\n   else:\n    cc+=1\n  \n if ev:\n  me=max(ev)\n  for i in a:\n   if i!=me and i%2==me%2:\n    c1+=2\n   elif i!=me and i%2!=me%2:\n    c1+=1\n  me+=1 #odd now\n  for i in a:\n   if i%2==me%2:  #odd odd 2\n    cc1+=2\n   else:\n    cc1+=1 #odd even 1\n if ev and od:\n  print(min(c,c1,cc,cc1))\n elif not ev:\n  print(min(cc,c))\n elif not od:\n  print(min(cc1,c1))", "for _ in range(eval(input())):\n    S1=input()\n    m1=len(S1)/2\n\n    S2=input()\n    m2=len(S2)/2\n    d1={}\n    d2={}\n    for i in range(len(S1)):\n        c=S1[i]\n        v=abs(m1-i)\n        if c in d1:\n            if v<d1[c][0]:\n                d1[c]=[v,i]\n        else:\n            d1[c]=[v,i]\n    for i in range(len(S2)):\n        c=S2[i]\n        v=abs(m2-i)\n        if c in d2:\n            if v<d2[c][0]:\n                d2[c]=[v,i]\n        else:\n            d2[c]=[v,i]\n\n    mini=999999999999999999999999999999999\n    for i in d1:\n        if i in d2:\n            L1=d1[i][1]\n            L3=len(S1)-L1-1\n            L2=d2[i][1]\n            L4=len(S2)-L2-1\n            v=abs(L1-L2)+abs(L2-L3)+abs(L3-L4)+abs(L4-L1)\n            if v<mini:\n                mini=v\n    print(mini)", "def main():\n mod=(10**9+7)\n for i in range(eval(input())):\n  printk =0\n  c=0\n  A,D= list(map(int,input().split()))\n  aks=int(str(D)*A)\n  s=(aks*aks)\n  hey=str(s)\n  for ii in hey:\n   printk= printk+int(ii)*23**c\n   __=int(ii)*printk\n   c+=1\n   #print __\n   #print c\n  ok_=printk % mod \n  print(ok_)\nmain() \n", "for _ in range(int(input())):\n n,c=list(map(int,input().split()))\n numpoints=0\n moves=0\n d=dict()\n for f in range(n):\n  a,b= list(map(int, input().split()))\n  dif = a-b\n  mod = a % c\n  if dif not in d:\n   d[dif] = {}\n  if mod not in d[dif]:\n   d[dif][mod] = []\n  d[dif][mod].append(a)\n for i in d:\n  for j in d[i]:\n   numpoints += 1\n   num = len(d[i][j])\n   d[i][j].sort()\n   if num % 2:\n    mid = d[i][j][int(num / 2)]\n    for k in d[i][j]:\n     moves += abs(int((k - mid) / c))\n   else:\n    choice1 = 0\n    mid = d[i][j][int(num / 2)]\n    for k in d[i][j]:\n     choice1 += abs(int((k - mid) / c))\n    choice2 = 0\n    mid = d[i][j][int(num / 2) - 1]\n    for k in d[i][j]:\n     choice2 += abs(int((k - mid) / c))\n    moves += min(choice1, choice2)\n print(numpoints, moves)\n", "mod=10**9+7\nfib=[1,1]\nfor i in range(10**5+4):\n fib.append((fib[-1]+fib[-2])%mod)\ns=input()\nif 'c' in s or 'k' in s:\n print(0)\n return\nn=len(s)\nl=[]\ni=0\nwhile i<n:\n if s[i]=='f':\n  c=0\n  while i<n and s[i]=='f':\n   c+=1\n   i+=1\n  l.append(fib[c])\n elif s[i]=='g':\n  c=0\n  while i<n and s[i]=='g':\n   c+=1\n   i+=1\n  l.append(fib[c])\n else:\n  i+=1\nif len(l)==0:\n print(1)\n return\nans=l[0]\nfor i in range(1,len(l)):\n ans=(ans*l[i])%mod\nprint(ans)", "# cook your dish here\nimport math\n\ndef solve():\n    n = int(input())\n    l = list(map(int,input().split()))\n    \n    pos = n\n    for i in range(n):\n        if l[i]!=0:\n            pos = i\n            break\n    c = 0\n    for j in l[::-1]:\n        if j==0:\n            c+=1\n        else:\n            break\n    if (n-c-pos)>0:\n        print(n-c-pos)\n    else:\n        print(1)\n\nt = input()\nt = int(t)\nwhile t!=0:\n    t = t-1\n    solve()", "from sys import stdin,stdout\n\n\n\n\ntotal_cost=0\ndef find(a):\n if par[a]==a:\n  return a\n else:\n  par[a]=find(par[a])\n  return par[a]\ndef union(a,b,c):\n a,b=find(a),find(b)\n nonlocal total_cost\n total_cost+=(rank[a]*rank[b]*c)\n if a!=b:\n  if rank[a]>rank[b]:\n   par[b]=a\n   rank[a]+=rank[b]\n  elif rank[b]>rank[a]:\n   par[a]=b\n   rank[b]+=rank[a]\n  else:\n   par[a]=b;\n   rank[b]+=rank[a]\n\nn=int(stdin.readline().strip())\npar=[i for i in range(n)]\nrank=[1 for i in range(n)]\nedges=[]\nfor i in range(n-1):\n u,v,c=stdin.readline().strip().split(' ')\n u,v,c=int(u)-1,int(v)-1,int(c)\n edges.append((c,u,v))\nedges.sort()\ntw=0\nfor i in edges:\n union(i[1],i[2],i[0])\n tw+=i[0]\n\nstdout.write(str(tw-(total_cost/((n*(n-1))/2))))", "t=int(input())\r\nfor i in range(t):\r\n    n,m=[int(x) for x in input().split()]\r\n    if n>=m:\r\n        print(\"Yes\")\r\n    else:\r\n        print(\"No\")", "from math import sqrt \n\ntest = int(input())\nfor i in range(test):\n sum = 0\n max = int(input())\n if max==1:\n  sum = 0\n elif max==2:\n  sum += 2\n else:    \n  sum = sum + 2\n  for x in range(3,max+1):\n   half = int(sqrt(x)) + 1\n   if all(x%y!=0 for y in range(2,half)):\n    sum = sum + x\n print(sum) ", "for _ in range(int(input())):\n k, n = input().split()\n\n while int(n) >= 5:\n  print(len(set(k)) ** 3)\n  break", "for _ in range(int(input())):\n n,k = map(int,input().split())\n ans = 0\n for x in map(int, input().split()):\n  if (x+k)%7 == 0: ans += 1\n print(ans)", "# cook your dish here\nt=int(input())\nfor i in range(0,t):\n x1,x2,x3,x4=list(map(int,input().split()))\n z=(x1*x1)+(x2*x2)\n z1=(x3*x3)+(x4*x4)\n if(z>z1):\n  print(\"B IS CLOSER\")\n else:\n  print(\"A IS CLOSER\")\n", "# cook your dish here\nfor _ in range(int(input())):\n n,k=list(map(int, input().split()))\n l=list(map(int, input().split()))\n ans, temp = 0, 0\n \n if k==2:\n  l1=[0, 0]\n  for i in l:\n   l1[i-1]=1 \n   temp+=1 \n   if l1==[1, 1]:\n    ans=max(ans, (temp-1))\n    l1=[0, 0]\n    l1[i-1]=1 \n    temp=1 \n  \n else:\n  l1=[]\n  for i in range(n):\n   l1.append(l[i])\n   temp=1 \n   for j in range(i+1, n):\n    if l[j] in l1:\n     temp+=1 \n     \n    else:\n     if len(l1)==k-1:\n      l1=[]\n      ans=max(ans, temp)\n      break\n     \n     else:\n      l1.append(l[j])\n      temp+=1\n      \n   ans=max(ans, temp)\n     \n     \n print(max(ans, temp))", "t=int(input())\nfor i in range(0,t):\n f1,f2,r1,r2,r3,r4=list(map(int,input().split()))\n p1,p2,p3,p4=list(map(float,input().split()))\n a1=p1*(r1*p2+r2*(1-p2))-f1\n a2=p3*r3+p3*r4*p4-f2\n if(a1>a2):\n  print(\"FIRST\")\n elif(a1<a2):\n  print(\"SECOND\")\n else:\n  print(\"BOTH\") ", "for t in range(int(input())):\n print(int(input()[::-1]))", "# cook your dish here\nt = int(input())\nfor z in range(t):\n    th,tl,nh,nl = list(map(int,input().split()))\n    diff = (th+tl-nh-nl)/2\n    if(diff>=0):\n        print(str(1.0*diff)+\" DEGREE(S) ABOVE NORMAL\")\n    else:\n        diff = -1.0*diff\n        print(str(1.0*diff)+\" DEGREE(S) BELOW NORMAL\")\n", "a,n,k=list(map(int,input().split()))\ns=[]\n\nwhile k:\n s.append(a%(n+1))\n a=a//(n+1)\n k-=1\n\nprint(*s)\n \n", "import sys\ndef main():\n s = sys.stdin.readline\n string = s().strip()\n save = {}\n for i in string:\n  if i in save:\n   save[i]+=1\n  else:\n   save[i]=1\n output = ''\n x = set()\n for i in string:\n  if i not in x:\n   output += i\n   output += str(save[i])\n   x.add(i)\n print(output)\n\ndef __starting_point():\n main()\n\n__starting_point()", "# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    sum = int((n*(n-1) )/ 2)\n    print(sum)", "# cook your dish here\nt = int(input())\nfor _ in range(t):\n    n, k, d = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    lane = 3 - l[0]\n    switched = -float('inf')\n    ans = k\n    for i in range(n):\n     if l[i] == lane:\n      if switched + d < x[i] and x[i - 1] + 1 < x[i]:\n       lane = 3 - lane\n       switched = max(x[i - 1] + 1, switched + d)\n      else:\n       ans = x[i]\n       break\n    print(ans)\n", "n = int(input())\na = [int(x) for x in input().split()]\nx = int(input())\nl = []\nc = 0\n\nfor i in range(n):\n if a[i] < 0:\n  l.append(-a[i])\nl.sort()\nll = len(l)\nnum = ll - x\n\nans = 0\nfor i in range(len(l)):\n l[i] = c - l[i]\n if ll > x:\n  ans += abs(l[i] * x)\n  c += abs(l[i])\n else:\n  ans += abs(l[i] * ll)\n  c += abs(l[i])\n ll -= 1\n \nprint(ans)\n", "for _ in range(int(input())):\n a,k=map(int,input().split())\n inp=[int(i) for i in input()]\n conright=list(inp)\n prev=conright[0]\n for i in range(1,a):\n  if conright[i]==1:\n   if prev==1:\n    conright[i]=conright[i-1]+1\n   else:\n    prev=conright[i]\n  else:\n   prev=conright[i]\n #print(conright)\n conleft=list(inp)\n prev=conleft[a-1]\n for i in range(a-2,-1,-1):\n  if conleft[i]==1:\n   if prev==1:\n    conleft[i]=conleft[i+1]+1\n   else:\n    prev=conleft[i]\n  else:\n   prev=conleft[i]\n #print(conleft)\n conright.insert(0,0)\n conleft.append(0)\n m=-1\n for i in range(a-k+1):\n  insr=conright[i-1]\n  insl=conleft[i+k]\n  m=max(m,k+conright[i]+conleft[i+k])\n print(m)", "for _ in range(int(input())):\n n, p = map(int,input().split())\n s = list(input())\n a=s.count('a'); b=s.count('b'); swap = 0\n arr = [i for i in s]\n for i in range(a):\n  if s[i] == 'b':\n   swap += 1\n if p <= swap:\n  i=0; tmp=p\n  while p>0 and i<n:\n   if arr[i]=='b':\n    arr[i]='a'\n    p -= 1\n   i += 1\n  p = tmp; i = n-1\n  while p>0 and i>0:\n   if arr[i] == 'a':\n    arr[i] = 'b'\n    p -= 1\n   i -= 1\n  print(''.join(arr))\n else:\n  for j in range(n):\n   if j < a:\n    arr[j] = 'a'\n   else:\n    arr[j] = 'b'\n  p -= swap\n  for k in range(n):\n   if arr[k] == 'b':\n    if s[k] == 'b' and p >= 2:\n     p -= 2\n     arr[k] = 'a'\n    if s[k] == 'a' and p >= 1:\n     p -= 1\n     arr[k] = 'a'\n  print(''.join(arr))", "for i in range(int(input())):\n a,b = list(map(int, input().split()))\n print(a+b-1)\n   \n", "for _ in range(int(input())):\n n=int(input())\n tax=0\n if n<=250000:\n  tax = n*0\n elif n>250000 and n<=500000:\n  tax = (n-250000)*0.05\n elif n>500000 and n<=750000:\n  tax = ((n-500000)*0.10)+12500\n elif n>750000 and n<=1000000:\n  tax = ((n-750000)*0.15)+37500\n elif n>1000000 and n<=1250000:\n  tax = ((n-1000000)*0.20)+75000\n elif n>1250000 and n<=1500000:\n  tax = ((n-1250000)*0.25)+125000\n elif n>1500000:\n  tax = ((n-1500000)*0.30)+187500\n print(int(n-tax))", "n=int(input())\r\nans=[]\r\nfor x in range(n):\r\n    a=input()\r\n    a=(' '.join(a.split()[::-1]))\r\n    # print(a)\r\n    punctuation=\".,:;'\"\r\n    b=\"\"\r\n    for i in a:\r\n         if i not in punctuation:\r\n            b+=i\r\n    ans.append(b)\r\nn=(ans[::-1])\r\nfor i in n:\r\n    print(i)", "# cook your dish here\nfor a0 in range(int(input())):\n n,q=list(map(int, input().split()))\n print(q*(n+q+1)/(q+1))", "t=int(input())\nfor _ in range (t):\n n,k=map(int,input().split())\n d={}\n for i in range(n):\n  s,f,p=map(int,input().split())\n  try:\n   d[p].append((f,s))\n  except:\n   d[p]=[(f,s)]\n ans=0\n for i in d:\n  d[i].sort()\n  start=-1\n  for j in d[i]:\n   if j[1]>=start:\n    ans+=1\n    start=j[0]\n print(ans)", "# cook your dish here\nX ,Y = map(int, input().split())\noutput = X + Y\nprint(output)", "for _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n ans = 1\n l1 = l[0]\n for i in range(1,n):\n  if l[i] <= l1:\n   l1 = l[i]\n   ans = ans + 1\n print(ans)", "import math\nMod=1000000007\n\nfor _ in range(int(input())):\n  v=int(input())\n  i=0\n  s=0\n  for i in range(1,math.floor(math.sqrt(v))+1):\n    s+=i*((math.floor(v/i))*(math.floor(v/i)+1)-(i*(i-1)))\n    s-=(i*i)\n  print(s%Mod) \n", "# cook your dish here\nfor test in range(0,int(input())):\n A,B = map(int,input().split())\n diff = abs(A-B)\n count=0\n if not(A^B):\n  print(-1)\n else:\n  for i in range(1,int(diff**(1/2))+1):\n   if diff%i==0:\n    if diff/i==i:\n     count+=1 \n    else:\n     count+=2\n  print(count)", "# cook your dish here\nt = int(input())\nwhile t>0:\n t-=1\n n,m,x,y = [int(x) for x in input().split()]\n f=0\n if m==1 and n==1:\n  f=1\n elif n==2 and m==2:\n  f=1\n elif (n-1)%x==0 and (m-1)%y==0 and n>=1 and m>=1: f=1\n elif n>=2 and m>=2:\n  if (n-2)%x==0 and (m-2)%y==0: f=1\n if f==1: print('Chefirnemo')\n else: print('Pofik')\n", "def mForMaxSeq(arr, n):\r\n    eim = dict()\r\n    for i in range(n):\r\n        if arr[i] in eim:\r\n            eim[arr[i]].append(i)\r\n        else:\r\n            eim[arr[i]] = [i]\r\n    \r\n    keys = sorted(eim.keys())\r\n    \r\n    # print(eim, keys)\r\n\r\n    connected = False\r\n    count = 0\r\n    pI = -1\r\n\r\n    nKeys = len(keys)\r\n    for i in range(nKeys-1):\r\n        \r\n        if not connected:\r\n            pI = eim[keys[i]][0]\r\n            \r\n            for idx in eim[keys[i+1]]:\r\n                if idx >pI:\r\n                    connected = True\r\n                    count += 1\r\n                    pI = idx\r\n                    break\r\n        else:\r\n            connected = False\r\n\r\n            for idx in eim[keys[i+1]]:\r\n                if idx > pI:\r\n                    connected = True\r\n                    count += 1\r\n                    pI = idx\r\n                    break\r\n\r\n    \r\n    return (nKeys - count)\r\n\r\n\r\ndef __starting_point():\r\n    for _ in range(int(input())):\r\n        n = int(input())\r\n        arr = list(map(int, input().split()))\r\n        \r\n        print(mForMaxSeq(arr, n))\r\n        \r\n        \r\n\n__starting_point()", "from collections import Counter\nt=int(input())\nfor i in range(t):\n a=input()\n print(len(set(a)))\n \n", "# cook your dish here\nimport sys\nimport math\nfrom collections import Counter\nfrom heapq import heapify, heappop, heappush\nimport numpy as np\n\n# sys.setrecursionlimit(10**6)\n# input = sys.stdin.buffer.readline\n\nMAX_INT = 2**62-1\nMOD = 10**9 + 7\n\n\ndef __starting_point():\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        nums = np.array([int(s) for s in input().split()], dtype=np.int)\n        ranges = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            ranges.append((l-1, r-1))\n\n        mat = np.zeros((n, n), dtype='u1')\n\n        for i, (l, r) in enumerate(ranges):\n            mat[i, l:r+1] = 1\n\n        trans = np.eye(n, dtype='u1')\n        k -= 1\n        while k:\n            if k & 1:\n                trans = trans @ mat\n                trans &= 1\n            k >>= 1\n            mat = mat @ mat\n            mat &= 1\n            # print(k, trans)\n        # print(trans)\n\n        ans = np.zeros((n,), dtype=np.int)\n        for i in range(60)[::-1]:\n            c = (nums >> i) & 1\n            ans <<= 1\n            ans += (trans @ c & 1)\n        print(*ans, sep=' ')\n\n\n\n\n\n__starting_point()", "# cook your dish here\nnum=[]\nfor i in range(20):\n  num.append(2**i)\nfor _ in range(int(input())):\n  n,l,r=list(map(int,input().split()))\n  minset=num[:l]\n  maxset=num[:r]\n  ans1=0\n  ans2=0\n  ml=len(minset)\n  mal=len(maxset)\n  ans1=sum(minset)+(n-ml)*minset[0]\n  ans2=sum(maxset)+(n-mal)*maxset[-1]\n  \n  print(ans1,ans2)\n", "t,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\narr.sort()\nc=0\nsum1=0\nfor i in arr:\n sum1+=i\n if sum1>k:\n  break\n elif sum1==k:\n  c+=1\n  break\n c+=1\nprint(c) ", "def add(A, B):\n cnt = 0\n while B > 0:\n  cnt += 1\n  U = A ^ B\n  V = A & B\n  A = U\n  B = V * 2\n return cnt\n\nfor _ in range(int(input().strip())):\n print(add(int(input().strip(), 2), int(input().strip(), 2)))", "for _ in range(int(input())):\n s = input()\n n = len(s)\n decode = [0]*(n+1)\n if s[0]=='0':\n  print(0)\n  continue\n \n decode[0] = 1\n decode[1] = 1\n modul = 1000000007\n for i in range(2, n+1):\n  if s[i-1]>'0': \n   decode[i] = (decode[i]%modul+decode[i-1]%modul)%modul\n   \n  if s[i-2]=='1' or (s[i-2]=='2' and s[i-1]<'7'):\n   decode[i] = (decode[i]%modul+decode[i-2]%modul)%modul\n \n print(decode[n])\n \n", "import sys\ntest_cases = int(input())\nfor i in range(0,test_cases):\n count = input().split()\n count_r = int(count[0])\n count_g = int(count[1])\n count_b = int(count[2])\n k = int(input())\n if k is 1:\n  print(1)\n else:   \n  total = 0\n  for i in range (1,k):\n   if count_r is not 0:\n    count_r = count_r -1 \n    total =total+1 \n   if count_g is not 0:\n    count_g = count_g -1 \n    total =total+1 \n   if count_b is not 0:\n    count_b = count_b -1 \n    total =total+1 \n  total =total + 1\n  print(total)\n", "import sys\r\nimport math\r\nfrom collections import defaultdict,Counter\r\nimport bisect\r\ninput=sys.stdin.readline\r\ndef print(x):\r\n    sys.stdout.write(str(x)+\"\\n\")\r\n\r\n# sys.stdout=open(\"CP1/output.txt\",'w')\r\n# sys.stdin=open(\"CP1/input.txt\",'r')\r\n\r\ndef Sieve(n):\r\n    prime = [True for i in range(n + 1)]\r\n    p = 2\r\n    while (p * p <= n):\r\n\t    if (prime[p] == True):\r\n\t\t    for i in range(p * p, n + 1, p):\r\n\t\t\t    prime[i] = False\r\n\t    p += 1\r\n    prime[0]= False\r\n    prime[1]= False\r\n\r\n    p1=[]\r\n    for p in range(n + 1):\r\n\t    if prime[p]:\r\n\t\t    p1.append(pow(p,4))\r\n    return p1\r\n\r\np=Sieve(10**5)\r\n# mod=pow(10,9)+7\r\nt=int(input())\r\nfor i in range(t):\r\n\tn=int(input())\r\n\tans=bisect.bisect_right(p,n)\r\n\tprint(ans)", "# cook your dish here\nt=int(input())\nfor i in range(t):\n n,q=list(map(int,input().split()))\n a=list(map(int, input().split()))\n even,odd=0,0\n for j in range(n):\n  count=(bin(a[j]).count(\"1\"))\n  if count%2==0: \n   even = even + 1\n  else:   \n   odd = odd + 1\n\n for j in range(q):\n  m=int(input())\n  g=bin(m).count(\"1\")\n  a,b=even,odd\n  if g%2==0:\n   a,b=even,odd\n  else: \n   a,b=odd,even\n  print(a,b)\n", "for _ in range(int(input())):\n n, m = list(map(int, input().split()))\n ans = [[0 for i in range(m)] for i in range(n)]\n k = 0\n if n == 1:\n  for i in range(m):\n   if i%4 == 0 or i%4 == 1:\n    t = 1\n   else:\n    t = 2\n   ans[0][i] = t\n   k = max(k, ans[0][i])\n elif m == 1:\n  for i in range(n):\n   if i%4 == 0 or i%4 == 1:\n    t = 1\n   else:\n    t = 2\n   ans[i][0] = t\n   k = max(k, ans[i][0])\n elif n == 2:\n  t = 1\n  for i in range(m):\n   ans[0][i] = t\n   ans[1][i] = t\n   t = (t)%3 + 1\n   k = max(k, ans[0][i])\n elif m == 2:\n  t = 1\n  for i in range(n):\n   ans[i][0] = t\n   ans[i][1] = t\n   t = t%3 + 1\n   k = max(k, ans[i][0])\n else:\n  for i in range(n):\n   if i%4 == 0 or i%4 == 1:\n    t = 0\n   else:\n    t = 2\n   for j in range(m):\n    ans[i][j] = (t%4) + 1\n    t += 1\n    k = max(k, ans[i][j])\n      \n\n print(k)\n for i in range(n):\n  print(*ans[i])\n", "mod = 10 ** 9 + 7\nfrom collections import Counter\nchoice = {'1' : ['11', '21', '22'], '2' : ['11', '12', '21']}\ndef solve(a,b):\n n = len(a)\n if n == 1:\n  return 2\n dp = Counter([('11', '11')])\n for i in range(n-1):\n  new = Counter()\n  for x,y in (a[i], b[i]), (b[i], a[i]):\n   for p in choice[x]:\n    for q in choice[y]:\n     m = p[-1] + x \n     n = q[-1] + y\n     new[m,n] += dp[p,q]\n     new[m,n] %= mod\n  dp = new\n ans = 0 \n for i in '11', '21', :\n  for j in '11', '21':\n   ans += dp[i,j]\n return (ans * 2) % mod\n\n \nt = int(input())\nfor _ in range(t):\n a = input()\n b = input()\n print(solve(a,b))", "# cook your dish here\nimport sys\n#from sys import stdin,stdout\ninput=sys.stdin.readline\n#sys.setrecursionlimit(10**7)\n#import math\n#import random\n#import heapq\n#from collections import Counter\n#from queue import PriorityQueue\n#from functools import lru_cache,cmp_to_key\n#@lru_cache(maxsize=None) #for optimizing the execution time of callable objects/functions(placed above callable functions)\n\ntry:\n    for _ in range(int(input())):\n        n=int(input())\n        ans=0\n        while n:\n            if n&1:\n                ans+=1\n            n=n//2\n        print(ans)\n        \n\n\n        \nexcept EOFError as e:\n    print(e)\n", "nCr = [[0 for x in range(1001)] for x in range(1001)]\n\nfor i in range (0,1001):\n nCr[i][0]=1\n nCr[i][i]=1\nfor i in range (1,1001):\n for j in range (1,1001):\n  if i!=j:\n   nCr[i][j] = nCr[i-1][j] + nCr[i-1][j-1]\n\n#print(nCr[4][2])\n\nt=eval(input())\nfor __ in range(0,t):\n s=input().split()\n s,n,m,k=int(s[0]),int(s[1]),int(s[2]),int(s[3])\n if (s==n):\n  print(\"1.000000\")\n  continue\n \n foo=float(0.0000000)\n s=s-1\n n=n-1\n m=m-1\n bar=float(nCr[s][n])\n x=k-1\n if(k>n):\n  print(\"0.000000\")\n  continue\n for i in range(0,x+1):\n  foo=foo+(nCr[m][i]*nCr[s-m][n-i])\n \n ans= float(1- (foo/bar))\n print(ans)\n \n", "# cook your dish here\ntry:\n t=int(input())\n for _ in range(t):\n  x,r,A,B=map(int,input().split())\n  if(A<B):\n   A,B=B,A\n  q=2*(22/7)*r\n  t=(q/abs(A-B))*A\n  d=x*q\n  ans=d/t\n  if(ans==int(ans)):\n   print(int(ans)-1)\n  else:\n   print(int(ans))\nexcept:\n pass", "for _ in range(int(input())):\r\n    d={}\r\n    for __ in range(int(input())):\r\n        c,p=map(str,input().split())\r\n        d[c]=p\r\n    s=input()\r\n    k=\"\"\r\n    for i in range(0,len(s)):\r\n        if(s[i] in d.keys()):\r\n            k=k+d[s[i]]\r\n        else:\r\n            k=k+s[i]\r\n     \r\n    if '.' in k:\r\n        k = k.strip('0').rstrip('.') \r\n    else:\r\n        k = k.lstrip('0') \r\n    print(k or '0')\r\n", "def chk():\n for r in range(i+1, i+k):\n  if m[r][ix:ix+k] != ss:\n   return False\n return True \nl, r, q = list(map(int, input().split()))\nm = [input().replace(\" \", \"\") for _ in range(l)]\nfor _ in range(q):\n k, s = input().split()\n k = int(k)\n ss = k * s\n ans = \"no\"\n for i in range(l-k+1):\n  st = 0\n  while ss in m[i][st:]:\n   ix = m[i].index(ss, st)\n   if chk():\n    ans = \"yes\"\n    break\n   st = ix + 1\n  if ans == \"yes\":break \n print(ans)", "def is_pal(s):\n if len(s)==1:\n  return 1\n else:\n  count=0\n  for i in range(int(len(s)/2)):\n   if s[i]==s[len(s)-1-i]:\n    count+=1\n  if count==int(len(s)/2):\n   return 1\n  else:\n   return 0\nt = int(input())\nfor i in range(t):\n count=0\n s = input()\n c = list()\n d = list()\n for j in range(len(s)):\n  c.append(s[j])\n  d.append(s[j])\n#     print(c)\n#     print(d)\n for j in range(len(s)):\n  c.pop(j)\n  x = is_pal(c)\n  if x==1:\n   print('YES')\n   break\n  else:\n#             print(c)\n   count+=1\n   c.clear()\n   for i in range(len(d)):\n    c.append(d[i])\n#             print(c)\n if count==len(s):\n  print('NO')", "s,n,s1,lis,new1=[],[],[],[],[]\nimport itertools\nq = int(input())\ns.append(input().split(' '))\ns1 = list([list(map(int,x)) for x in s])\nsum1 = sum(s1[0])\nif len(s1[0])%2!=0 :\n z = (len(s1[0])+1)//2\n n = list(itertools.combinations(s1[0],z))\n for j in range(len(n)) :\n   x = sum(n[j])\n   if x==sum1//2 :\n    lis = n[j]\n    break\n new1 = list(lis)\n sum2 = sum(new1)\n for j in range(len(lis)) :\n    y = lis[j]\n    s1[0].remove(y)\n sum3=sum(s1[0])\n if sum3>sum2 :\n  print(' '.join(map(str,s1[0])))\n  print(' '.join(map(str,new1)))\n else :\n  print(' '.join(map(str,new1)))\n  print(' '.join(map(str,s1[0])))\nelse :\n z = len(s1[0])//2\n n = list(itertools.combinations(s1[0],z))\n print(n)\n for j in range(len(n)) :\n   x = sum(n[j])\n   if x==sum1//2 :\n    lis = n[j]\n    break\n   #print lis,len(lis)\n new1 = list(lis)\n sum2 = sum(new1)\n for j in range(len(lis)) :\n    y = lis[j]\n    s1[0].remove(y)\n sum3 = sum(s1[0])\n if sum3>sum2  :\n  print(' '.join(map(str,s1[0])))\n  print(' '.join(map(str,new1)))\n else :\n  print(' '.join(map(str,new1)))\n  print(' '.join(map(str,s1[0])))\n\n  \n", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dic = {}\n    for i in range(1,9):\n        dic[i] = a.count(i)\n    ans = min(dic.values())\n    print(ans)\n        \n        \n        ", "for t in range(int(input())):\n n = int(input())\n a = list(map(int,input().split(\" \")))\n k = n + 1\n dp = [0]*k\n dp[1] = a[0]\n \n for i in range(2,n+1):\n  dp[i] = max( dp[i-1] + a[i-1]*i , dp[i-2] + a[i-2]*i + a[i-1]*(i-1) )\n  \n print(dp[n])", "\n\n\nt = int(input())\n\ndef gcd (a, b):\n if (b == 0): return a\n return gcd (b, a % b)\n\ndp = {}\n\ndef solve (p, k, g, s, m, x, y, n):\n if ((p, k, g) in dp): return dp[(p, k, g)];\n \n ans = 0\n\n if (p == n): \n  if k >= x and k <= y:\n   ans = g\n  else:\n   ans = 0 \n else:   \n  for i in range (p, n):\n   \n   if (i - p + 1 > m): break\n   \n   temp = solve (i + 1, k + 1, gcd(g, int(s[p:i + 1])), s, m, x, y, n)\n   if (temp > ans):\n    ans = temp\n    \n dp[(p, k, g)] = ans\n return ans\n \n\nwhile t != 0:\n dp = {}\n t -= 1\n n = int(input())\n s = input()\n m, x, y = list(map (int, input().split()))\n x += 1\n y += 1\n \n print(solve (0, 0, 0, s, m, x, y, n))\n \n", "def getsum(N):\n\tif N==1:\n\t\treturn 9\n\tif N==2:\n\t\treturn 99\n\ts = \"\"\n\tfor i in range(0,N):\n\t\ts = s+'5'\n\ts = int(s)\n\tif N%2==0:\n\t\ts = s*pow(9,N//2-1)\n\telse:\n\t\ts = s*pow(9,N//2)\n\treturn s%(pow(10,9)+7)\n\ndef main():\n\tt = int(input())\n\tfor _ in range(0,t):\n\t\tN = int(input())\n\t\tresult = getsum(N)\n\t\tprint(result)\ndef __starting_point():\n\tmain()\n\n__starting_point()", "t = int(input())\nfor i in range(0, t):\n n = int(input())\n a = input()\n b = [1]*n\n for i in range(0, n):\n  if a[i] == '1':\n   b[i] = 0\n   if i > 0:\n    b[i - 1] = 0\n   if i < n - 1:\n    b[i + 1] = 0\n ans = 0\n for i in range(0, n):\n  if b[i] == 1:\n   ans += 1\n print(ans)", "t=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    k=int(input())\n    c=a[k-1]\n    a.sort()\n    for i in range(n):\n        if a[i]==c:\n            print(i+1)\n            break\n", "# cook your dish here\na,b=map(int,input().split())\nfor i in range(b):\n r=a%10\n n=a//10\n if(r==0):\n  a=n\n else:\n  a=a-1\nprint(a)", "t=int(input())\ncount=[]\n\nfor i in range(t) :\n s = input()\n a,b,c,n = s.split()\n n=int(n)\n d = int(a+b*n+c,2)\n count.append(0)\n while(d>0) :\n  d=(d&(d+1))-1\n  count[i]+=1\n\n\nfor i in range(t) :\n print(count[i])\n", "# cook your dish here\nfor _ in range(int(input())):\n n,m=list(map(int, input().split()))\n c=list(map(int, input().split()))\n l = []\n l1=[0]*n \n total=0\n \n for i in range(n):\n  d,f,b=list(map(int, input().split()))\n  if c[d-1]>0:\n   c[d-1]-=1 \n   total+=f \n   l1[i]=d \n   \n  else:\n   total+=b \n   l.append(b)\n \n t=m-1 \n print(total) \n for i in l1:\n  if i>0:\n   print(i, end=' ')\n   \n  else:\n   while True:\n    if c[t]>0:\n     print(t+1, end=' ')\n     c[t]-=1\n     if c[t]==0:\n      t-=1 \n     break\n    \n    else:\n     t-=1 \n   \n print('') ", "# cook your dish here\nfrom sys import stdin,stdout\na,b=list(map(int,stdin.readline().split()))\nleft=[]\ntop=[]\nfor i in range(a):\n c,d=list(map(int,stdin.readline().split()))\n left.append(c)\n top.append(d)\nleft.sort()\ntop.sort()\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nrow=0\ncol=0\ntotal=0\ncons_x=0\ncons_y=0\nfor i in range(len(left)):\n cons_x+=(abs(left[i]))\n cons_y+=(abs(top[i]))\ntotal=cons_x+cons_y\ncc=stdin.readline().rstrip()\nfor i in cc:\n if i==\"R\":\n  kk=br(left,col)\n  cons_x=(cons_x+kk-(a-kk))\n  col+=1\n if i==\"L\":\n  kk=bl(left,col)\n  cons_x=(cons_x+(a-kk)-kk)\n  col-=1\n if i==\"U\":\n  kk=br(top,row)\n  cons_y=(cons_y+kk-(a-kk))\n  row+=1\n if i==\"D\":\n  kk=bl(top,row)\n  cons_y=(cons_y+(a-kk)-kk)\n  row-=1\n stdout.write(str(cons_x+cons_y))\n stdout.write(\"\\n\")\n  \n\n", "# cook your dish here\nimport heapq\nimport math\nfor i in range(int(input())):\n n,a,b,x,y,z = list(map(int,input().split()))\n cntrbtns= list(map(int,input().split()))\n t=math.ceil((z-b)/y)\n sumy= a+ x*(t-1) \n if (sum(cntrbtns)*2 +sumy) < z:\n  print(\"RIP\")\n  continue\n c=0\n for i in range(n):\n  cntrbtns[i]= - cntrbtns[i]\n heapq.heapify(cntrbtns)\n ele=0\n while True:\n  if sumy>=z:\n   print(c)\n   break\n  ele=heapq.heappushpop(cntrbtns,math.ceil(ele/2))\n  if ele==0:\n   print(\"RIP\")\n   break\n  sumy -=ele \n  c+=1 \n  \n\n", "for _ in range(int(input())):\n n = int(input())\n xl = [int(x) for x in input().split()]\n pl = [float(x) for x in input().split()]\n tl = [0]*30\n for x,p in zip(xl,pl):\n  bs = bin(x)[2:][::-1]\n  for i in range(len(bs)):\n   if bs[i]=='1':\n    tl[i] = (1-tl[i])*p + (1-p)*tl[i]\n ans = 0\n for i in range(30):\n  ans += (2**i)*tl[i]\n print(ans)", "# cook your dish here\nfor _ in range(int(input())):\n    n,k = [int(v) for v in input().split()]\n    ans = (n//2)*(k+2)\n    if n%2 == 0:\n        ans = ans\n    else:\n        ans += 1 + 2*k\n    \n    print(ans)", "for t in range(int(input())):\r\n    n = int(input())\r\n    matrix = []\r\n    count1 = 0\r\n    for i in range(n):\r\n        matrix.append(list(map(int, input().split())))\r\n        count1 += matrix[-1].count(1)\r\n    bandwidth = 0\r\n    count1 -= n\r\n    for i in range(n-1,0, -1):\r\n        if count1 > 0:\r\n            count1 -= 2 * i\r\n            bandwidth += 1\r\n    print(bandwidth)\r\n", "#!/usr/bin/python\n#http://www.codechef.com/OCT12/problems/LUCKY10\n\nimport sys\n\ndef solve():\n\ta=sys.stdin.readline()\n\tb=sys.stdin.readline()\n\n\tdef arrange(a,A):\n\t\tfor i in a:\n\t\t\tif '0'<=i<='3':A[0]+=1\n\t\t\telif i=='4':\n\t\t\t\tA[1]+=1\n\t\t\telif i=='7':\n\t\t\t\tA[2]+=1\n\t\t\telif '5'<=i<='6':A[3]+=1\n\tA,B=[0]*5,[0]*5\n\tarrange(a,A)\n\tarrange(b,B)\n\n\tret=''\n\tret=(min(A[2],B[3])+min(B[2],A[3]))*'7'\n\n\tA[2],B[2]=max(0,A[2]-B[3]),max(0,B[2]-A[3])\n\tt=min(A[1]+B[1],A[1]+A[0],B[1]+B[0])\n\tA[0]=A[1]+A[0]-t\n\tB[0]=B[1]+B[0]-t\n\tret=ret+(min(A[2],B[0])+min(B[2],A[0]))*'7'\n\tA[2],B[2]=max(0,A[2]-B[0]),max(0,B[2]-A[0])\n\tret=ret+(min(t,A[2])+min(t,B[2]))*'7'\n\tk=min(max(0,t-A[2]),max(0,t-B[2]))\n\n\tA[2],B[2]=max(0,A[2]-t),max(0,B[2]-t)\n\tret=ret+min(A[2],B[2])*'7'+k*'4'\n\n\tprint(ret)\n\treturn \n\n\nt=int(input())\nfor i in range(t):\n\tsolve()\n\n", "n = int(input())\r\na = list(map(int, input().split()))\r\nb = list(map(int, input().split()))\r\nbb = b[:]\r\nfor i in range(n):\r\n    b[i] -= 1000\r\nans = []\r\ndp = []\r\nfor i in range(n+1):\r\n    dp.append([0] * (n+1))\r\nfor offset in range(2001):\r\n    for i in range(n+1):\r\n        dp[i][0] = 0\r\n        dp[i][0] = 0\r\n    for i in range(1, n+1):\r\n        for j in range(1, n+1):\r\n            if(a[i-1] == b[j-1]):\r\n                dp[i][j] = 1 + dp[i-1][j-1]\r\n            else:\r\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\r\n    if(dp[n][n] > len(ans)):\r\n        ans = []\r\n        j = n\r\n        i = n\r\n        while(i > 0 and j > 0):\r\n            if(dp[i][j] > dp[i][j-1] and dp[i][j] > dp[i-1][j]):\r\n                ans.append([i-1, j-1])\r\n                i -= 1\r\n                j -= 1\r\n            elif(dp[i][j] > dp[i][j-1]):\r\n                i -= 1\r\n            else:\r\n                j -= 1\r\n    for i in range(n):\r\n        b[i] += 1\r\nprint(len(ans))\r\nprintable = [[], []]\r\nfor i, j in ans[::-1]:\r\n    printable[0].append(a[i])\r\n    printable[1].append(bb[j])\r\nprint(*printable[0])\r\nprint(*printable[1])", "# cook your dish here\nfor _ in range(int(input())):\n    g=input()\n    h=g[::-1]\n    if h==g :\n        print(1)\n    else:\n        print(2)\n    ", "import math\ndef findnumber(l,n):\n    l.sort()\n    x = l[0] * l[-1]\n    vec = []\n    i = 2\n    while (i*i)<=x:\n        if x%i==0:\n            vec.append(i)\n            if x//i !=i:\n                vec.append(x//i)\n        i = i + 1\n    vec.sort()    \n    if len(vec)!=n:\n        return -1\n    else:\n        j = 0\n        for it in range(n):\n            if(l[j] != vec[it]):\n                return -1\n            else:\n                j += 1\n    return x\ndef __starting_point():\n    t = int(input())\n    while t:\n        n = int(input())\n        arr = list(map(int,input().split()))\n        n = len(arr)\n        print(findnumber(arr,n))\n        print()\n        t=t-1\n__starting_point()", "import bisect\nimport sys\nimport math\n\nt = int(input())\n\nM = 2000001\n\ns = [0 for x in range(M)]\n\nfor i in range(2,M):\n if (s[i] == 0):\n  s[i] = i;\n  for j in range(i*2,M,i):\n   s[j] += i\n\nwhile (t):\n\n n = int(input())\n a = [int(x) for x in input().split()]\n\n dict = {}\n m = 0\n for x in a:\n  m = max(x,m)\n  if (x in dict):\n   dict[x] += 1\n  else:\n   dict[x] = 1\n\n count = 0\n \n for k in dict.keys():\n  d = dict[k] * (dict[k] - 1)\n  count += d\n  for i in range(2,math.ceil(m/k)+1):\n   if (i*k in dict and s[i*k] % s[k] == 0):\n    d = dict[k] * dict[i*k] \n    count += d\n\n sys.stdout.write(str(count)+\"\\n\")\n \n \n t -= 1", "import math\r\n\r\ndp = []\r\ndp.append(0)\r\nfor i in range(1,1000005):\r\n\tdp.append(math.log(i) + dp[i-1])\r\n\r\nt = int(input())\r\nfor i in range(t):\r\n\tn,m,p,k = input().split()\r\n\tn = int(n)\r\n\tm = int(m)\r\n\tp = int(p)\r\n\tk = int(k)\r\n\r\n\tif n%2==0 and m%2==0:\r\n\t\tans = 1.0\r\n\t\tprint(ans)\r\n\telif n%2==1 and m%2==1:\r\n\t\tans=0.0\r\n\t\tprint(ans)\r\n\telse:\r\n\t\tans = 0\r\n\t\tfor j in range(p,k+1):\r\n\t\t\ttotal = math.exp(dp[k] - dp[j] - dp[k-j] - k*math.log(2))\r\n\t\t\tans = ans + total\r\n\t\tprint(ans)\r\n\r\n", "for i in range(int(input())):\n n=int(input())\n l=list(map(int,input().split()))\n print(sorted(l)[0])", "# cook your dish here\nfor _ in range(int(input())):\n    a=int(input())\n    print(a//2+2)", "for _ in range(int(input())):\n n,m=map(int,input().split())\n matrix = []\n for i in range(n):\n  row = []\n  s = input()\n  for ele in s:\n   row.append(ele)\n  matrix.append(row)\n ans = 0\n for i in range(m):\n  cnt = 0\n  for j in range(n):\n   if(matrix[j][i]=='1'):\n    cnt+=1\n  ans +=(cnt*(cnt-1)//2)\n print(ans)", "try:\r\n\tfor _ in range(int(input())):\r\n\t\tnum=int(input())\r\n\t\tarr=list(map(int,input().split()))\r\n\t\tdp=[0]*num\r\n\t\tdpr=[0]*num\r\n\t\tdpt=[0]*num\r\n\t\tdp[0]=1\r\n\t\tdpr[0]=0\r\n\t\tans=1\r\n\t\tfor i in range(1,num):\r\n\t\t\tj=i+1\r\n\t\t\tcount=1\r\n\t\t\tdp[i]=dp[i-1]\r\n\t\t\tif i-2>=0 and arr[i-2]==2:\r\n\t\t\t\tdp[i]+=dp[i-2]\r\n\t\t\t\tif i-3>=0 and arr[i-3]==2:\r\n\t\t\t\t\tdp[i]+=dp[i-3]\r\n\t\t\tif arr[i-1]==2 and i<num-1:\r\n\t\t\t\twhile j<num and arr[j]==2:\r\n\t\t\t\t\tj+=1\r\n\t\t\t\t\tcount+=1\r\n\t\t\t\tif j==num:\r\n\t\t\t\t\tdpr[i]=dp[i-1]*(count-1)\r\n\t\t\t\telif count%2!=0:\r\n\t\t\t\t\tif j<num-1 and arr[j+1]==2:\r\n\t\t\t\t\t\tdpr[i]=dp[i-1]*(count+1)\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tdpr[i]=dp[i-1]*(count)\r\n\t\t\t\telif count%2==0:\r\n\t\t\t\t\tdpr[i]=dp[i-1]*(count-1)\r\n\t\t\tans+=dpr[i]+dp[i]\r\n\t\tprint(ans)\r\nexcept:\r\n\tpass\r\n\r\n\r\n\r\n\t\t\t", "t=int(input())\n\nans=[]\nwhile(t):\n X=[];\n Y=[];\n XY=[]\n \n t-=1;\n n=int(input());\n st='';\n for i in range(1,n+1):\n  xi,yi=list(map(int,input().split()));\n  X.append(xi);\n  Y.append(yi);\n  XY.append((xi,yi));\n lborder=X.index(min(X));\n rborder=X.index(max(X));\n tborder=Y.index(max(Y));\n bborder=Y.index(min(Y));\n if((X[lborder],Y[tborder])in XY):\n  st='1\\n'+str(XY.index((X[lborder],Y[tborder]))+1)+' SE';\n elif((X[lborder],Y[bborder])in XY):\n  st='1\\n'+str(XY.index((X[lborder],Y[bborder]))+1)+' NE';\n elif((X[rborder],Y[tborder])in XY):\n   st='1\\n'+str(XY.index((X[rborder],Y[tborder]))+1)+' SW';\n elif((X[rborder],Y[bborder])in XY):\n   st='1\\n'+str(XY.index((X[rborder],Y[bborder]))+1)+' NW';\n elif((rborder==lborder)):\n   st='1\\n'+str(tborder+1)+' SE';\n elif(tborder==bborder):\n   st='1\\n'+str(lborder+1)+' NE';\n else:\n   if(Y[lborder]>=Y[rborder]):\n    st='2\\n'+str(lborder+1)+' SE\\n'+str(rborder+1)+' NW';\n   else:\n    st='2\\n'+str(lborder+1)+' NE\\n'+str(rborder+1)+' SW';\n\n\n ans.append(st);\nfor x in ans:\n print(x)\n", "for i in range(int(input())):\n n=int(input())\n t=-1\n for j in range(30):\n  if n==2**j-1:\n   t=j\n   break\n if t==1:\n  print(2)\n elif t==-1:\n  print(-1)\n else:\n  print(2**(t-1)-1)\n", "# cook your dish here\nt=int(input())\nwhile t:\n n=int(input())\n arr=list(map(int,input().split()))\n con=[]\n count=1\n c=[]\n i=0\n while i<n:\n  while (i<n-1) and (arr[i]==arr[i+1]):\n   i+=1\n   count+=1\n  if arr[i] in con or count in c:\n   break\n  con.append(arr[i])\n  c.append(count)\n  i+=1\n  count=1\n \n if i==n :\n  print(\"YES\")\n else:\n  print(\"NO\")\n #print(*con)\n #print(*c)\n t-=1", "# cook your dish here\nfor _ in range(int(input())):\n    a, d, k, n, inc = map(int, input().split())\n    sum = a\n    for i in range(1, n):\n        if i % k == 0:\n            d = d + inc\n        sum = sum + d\n    print(sum)", "x=eval(input())\nfor x in range(0,x):\n\tans=0\n\td=input()\n\ta=0\n\tcont=0\n\tfor i in range(0,len(d)):\n\t\ta+=len(d)-i\n\t\tif d[i]=='7':\n\t\t\tans+=1+cont\n\t\t\tcont+=1\n\t\telse:\n\t\t\tcont=0\n\tans=a-ans\n\tprint(ans)\n", "# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    i=1\n    while(i<n):\n        a[i-1],a[i] = a[i],a[i-1]\n        i+=2\n    print(*a)\n", "for _ in range(int(input())):\r\n    l=[]\r\n    mp={}\r\n    cr={}\r\n    ans=[]\r\n    n,m=map(int,input().split())\r\n    for i in range(1,n+1):\r\n        mp[i]=0\r\n        cr[i]=False\r\n    for _ in range(m):\r\n        f,t=map(int,input().split())\r\n        l.append((f,t))\r\n        mp[f]+=1\r\n        mp[t]+=1\r\n    if m%2>0:\r\n        print(-1)\r\n        continue\r\n    else:\r\n        for _ in range(m):\r\n            cr[l[_][1]]=not cr[l[_][1]]\r\n            ans.append(0)\r\n        for _ in range(m-1,-1,-1):\r\n            if cr[l[_][1]]==True:\r\n                cr[l[_][1]]=not True\r\n                ans[_]=1\r\n                if cr[l[_][0]]:\r\n                    cr[l[_][0]]=False\r\n                else:\r\n                    cr[l[_][0]]=True\r\n        for i in range(len(ans)):\r\n            print(ans[i],end=' ')\r\n        print()\r\n    ", "def idat(pos,M,N):\n return (pos+M)%N\n\nT = eval(input())\nfor _ in range(T):\n N,M = list(map(int,input().split(\" \")))\n robots = [0]*N\n#     print range(1,N+1)[M:]+range(1,N+1)[:M]\n Id = idat(0,M,N)\n while robots[Id]!=1:\n  robots[Id]=1\n  newpos = Id\n  Id = idat(newpos,M,N)\n#         print robots[M:]+robots[:M]\n if robots.count(1)==N:\n  print(\"Yes\")\n else:\n  print(\"No\",robots.count(1))", "n,q,k = map(int, input().split())\na = [int(x) for x in input().split()]\ns = input()\nm = 0\nl = 0\nfor i in a:\n if i==1:\n  m += 1\n else:\n  m = 0\n if m>=k:\n  l = k\n  break\n elif m>l:\n  l = m\nfor i in s:\n if i == '?':\n  print(l)\n else:\n  a.insert(0,a[n-1])\n  a.pop()\n  if a[0]!=0:\n   m = 0\n   l = 0\n   for j in a:\n    if j==1:\n     m += 1\n    else:\n     m = 0\n    if m>=k:\n     l = k\n     break\n    elif m>l:\n     l = m", "import numpy as np\n\nN=10**6+1\nt=eval(input())\ninp = ()\n\nt1=ord('z')\n#bag=[[0  for _ in xrange(t1)] for _ in xrange(N+1)]\nbag=np.zeros((N+1,t1),dtype=np.int)\n#print bag\nwhile t:\n t-=1\n inp=input().split()\n t2=ord(inp[3]) - ord('a')\n t3=int(inp[1])\n t4=int(inp[2]) + 1\n if inp[0]==\"1\":\n  #print \"enter\"\n  bag[t3][t2]+=int(inp[2])\n\n\n if inp[0]==\"2\":\n  sum=0\n  for i in range(t3,t4):\n   sum+=bag[i][t2]\n  print(sum)\n\n#\n# for j in range(ord('z')-ord('a')):\n#     for i in range(N+1):\n#         if bag[i][j]!=0:\n#             print bag[i][j] ,i,j\n\n\n\n", "n=eval(input())\na=input().split()\nfor i in range(n):\n a[i]=int(a[i])\nm=eval(input())\nfor i in range(m):\n l,r=input().split()\n l=int(l)-1\n r=int(r)\n s=a[l:r]\n s.sort()\n sum=0\n for i in range(1,r-l):\n  sum+=(s[i]-s[i-1])**2\n  \n print(sum)\n", "def fun(m):\n sumi=(m*(m+1))//2\n f=1\n while(f<=m):\n  x=(m//f)+1\n  sumi-=1+f*((x//2))\n  f*=2\n return sumi \n \nt=int(input())\nfor _ in range(t):\n l,r=map(int,input().split())\n print(fun(r)-fun(l-1))", "#Note that it's python3 Code. Here, we are using input() instead of raw_input().\n#You can check on your local machine the version of python by typing \"python --version\" in the terminal.\n\n(n, k) = list(map(int, input().split(' ')))\n\nans = 0\n\nfor i in range(n):\n\tx = int(input())\n\tif x % k == 0:\n\t\tans += 1\n\nprint(ans)\t", "t=int(input())\nfor i in range (t):\n a=0\n n=int(input())\n while(n>0):\n  a += n*n\n  n=n-2\n print(a)\n", "import math\r\n\r\n\r\nn,m = map(int, input().split())\r\nhyp = math.sqrt(1+m*m)\r\ncosx = 1/hyp\r\nsinx = m/hyp\r\n\r\nfor i in range(n):\r\n    px, py = list(map(int, input().strip().split()))\r\n    px_temp = cosx*px+sinx*py\r\n    py_temp = cosx*py-sinx*px\r\n\r\n    if i == 0:\r\n        px_max = px_temp\r\n        px_min = px_temp\r\n        py_max = py_temp\r\n        py_min = py_temp\r\n\r\n    if px_temp > px_max:\r\n        px_max = px_temp\r\n    elif px_temp < px_min:\r\n        px_min = px_temp\r\n\r\n    if py_temp > py_max:\r\n        py_max = py_temp\r\n    elif py_temp < py_min:\r\n        py_min = py_temp\r\n\r\nw = px_max-px_min\r\nl = py_max-py_min\r\n\r\nprint(2*l+2*w)\r\n", "# cook your dish here\nd,x,y=list(map(float,input().split()))\nl=list(map(int,input().split()))\nsum1=d*x\nft=y\nst=y-(y*2)/100\ntt=y-(y*4)/100\nftt=y-(y*6)/100\nfifth=y-(y*8)/100\nsixth=y-(y*10)/100\nsum2=0\nfor i in range(len(l)):\n    if(l[i]==6):\n        sum2=sum2+sixth\n    elif(l[i]==5):\n         sum2=sum2+fifth\n    elif(l[i]==4):\n        sum2=sum2+ftt\n    elif(l[i]==3):\n        sum2=sum2+tt\n    elif(l[i]==2):\n        sum2=sum2+st\n    elif(l[i]==1):\n        sum2=sum2+ft\nif((sum1+sum2)>=300):\n    print('YES')\nelse:\n    print('NO')\n", "# Python code to demonstrate naive \n# method to compute gcd ( recursion ) \n\ndef gcd(a,b): \n\tif(b==0): \n\t\treturn a \n\telse: \n\t\treturn gcd(b,a%b) \n\nT=int(input())\nwhile T:\n    a,b,N=map(int,input().split())\n    c=set()\n    ls=[]\n    for i in range(1,N+1):\n        for j in range(1,i):\n            k=gcd(i,j)\n            if(j/i not in c):\n                c.add(j/i)\n                ls.append([j/i,j//k,i//k])\n    ls.sort()\n    for i in range(len(ls)):\n        if(ls[i][1]==a and ls[i][2]==b):\n            break\n    print(ls[i-1][1],ls[i-1][2])\n    T-=1", "for _ in range(int(input())):\r\n    s = input()\r\n    check1 = 'berhampore'\r\n    check2 = 'serampore'\r\n    if check1 in s.casefold() and check2 in s.casefold():\r\n        print(\"Both\")\r\n    else:\r\n        if check1 in s.casefold():\r\n            print(\"GCETTB\")\r\n        elif check2 in s.casefold():\r\n            print(\"GCETTS\")\r\n        else:\r\n            print(\"Others\")", "t = int(input())\r\nwhile(t):\r\n    t-=1\r\n    n = int(input())\r\n    if n>1:\r\n        print(n//2)\r\n    else:\r\n        print(\"1\")\r\n    if n<3:\r\n        print(n,end = \" \")\r\n        for i in range(1,n+1):\r\n            print(i,end = \" \")\r\n    if n==3:\r\n        print(\"3\",end = \" \")\r\n        print(\"1\",end = \" \")\r\n        print(\"2\",end = \" \")\r\n        print(\"3\")\r\n    if n>3:\r\n        print(\"3\",end = \" \")\r\n        print(\"1\",end = \" \")\r\n        print(\"2\",end = \" \")\r\n        print(\"3\")\r\n        for i in range(4,n,2):\r\n            print(\"2\",end = \" \")\r\n            print(i,end = ' ')\r\n            print(i+1)\r\n        if(n%2 == 0):\r\n            print(\"1\",end = \" \")\r\n            print(n)", "# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n s = input()\n a = s.split(\":\")\n year = int(a[0])\n m = int(a[1])\n d = int(a[2])\n\n if m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12:\n  count = (31 - d) // 2 + 1\n elif m == 4 or m == 6 or m == 9 or m == 11:\n  count = (30 + 31 - d) // 2 + 1\n else:\n  if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n   count = (29 - d) // 2 + 1\n  else:\n   count = (28 + 31 - d) // 2 + 1\n\n print(count)\n \n", "T=eval(input());\nans=[0]*T;\nfor j in range(T):\n\t[N,Q]=[int(x) for x in (input()).split()];\n\tfor i in range(N-1):\n\t\tinput();\n\tcomp=list(range(N+1));\n\trevcomp=[];\n\tfor i in range(N+1):\n\t\trevcomp.append([i]);\t\n\tsumcomp=[0]*(N+1);\n\tflag=True;\n\trank=0;\n\tfor i in range(Q):\n\t\tif(not(flag)):\n\t\t\tinput();\n\t\telse:\t\n\t\t\t[u,v,x]=[int(x) for x in (input()).split()];\n\t\t\tif(comp[u]==comp[v]):\n\t\t\t\tif(not((sumcomp[u]+sumcomp[v])%2==(x%2))):\n\t\t\t\t\tflag=False;\n\t\t\telse:\n\t\t\t\trank=rank+1;\n\t\t\t\tn1=len(revcomp[comp[u]]);\n\t\t\t\tn2=len(revcomp[comp[v]]);\n\t\t\t\tif(n1<n2):\n\t\t\t\t\toldsu=sumcomp[u];\n\t\t\t\t\tl=revcomp[comp[v]];\n\t\t\t\t\tfor w in revcomp[u]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[v];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[v]+x+oldsu)%2;\n\t\t\t\telse:\n\t\t\t\t\toldsv=sumcomp[v];\n\t\t\t\t\tl=revcomp[comp[u]];\n\t\t\t\t\tfor w in revcomp[v]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[u];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[u]+x+oldsv)%2;\n\tif(not(flag)):\n\t\tans[j]=0;\n\telse:\n\t\tans[j]=2**(N-rank-1);\n\nfor j in range(T):\n\tprint((ans[j]));\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\n\n", "# cook your dish here\nl=input().split()\nn=int(l[0])\nq=int(l[1])\nl=input().split()\nli=[int(i) for i in l]\nxori=0\nsi=[0 for i in range(n)]\nfor i in range(n):\n si[i]=xori\n xori=xori^li[i]\nsi.append(xori)\nfi=list(li)\nfi.append(xori)\nfor you in range(q):\n q1=int(input())\n print(si[q1%(n+1)])", "# cook your dish here\ndef guessingGame (l):\n a = []\n m = 1000000001\n for i in range (len(l)):\n  k=int(l[i][1])\n  if (l[i][0]=='<' and l[i][2]=='Yes'):\n   a.append((1,1))\n   a.append((k,-1))\n   \n  if (l[i][0]=='<' and l[i][2]=='No'):\n   a.append((k,1))\n   a.append((m,-1))\n   \n  if (l[i][0]=='=' and l[i][2]=='Yes'):\n   a.append((k,1))\n   a.append((k+1,-1))\n\n  if (l[i][0]=='=' and l[i][2]=='No'):\n   a.append((1,1))\n   a.append((k,-1))\n   a.append((k+1,1))\n   a.append((m,-1))\n\n  if (l[i][0]=='>' and l[i][2]=='Yes'):\n   a.append((k+1,1))\n   a.append((m,-1))\n\n  if (l[i][0]=='>' and l[i][2]=='No'):\n   a.append((1,1))\n   a.append((k+1,-1))\n\n a.sort()\n w=0\n r=0\n\n for i in range (len(a)):\n  w+=a[i][1]\n  r=max(w,r)\n\n return len(l)-r\n  \n \ndef __starting_point():\n\n T = int(input())\n answer = []\n\n for _ in range (T):\n  e = int(input())\n  temp = []\n  for q_t in range (e):\n   q = list(map(str,input().rstrip().split()))\n   temp.append(q)\n  result = guessingGame(temp)\n  print(result)\n__starting_point()", "# cook your dish here\nfor _ in range(int(input())):\n    s=input()\n    print(int(s,16))", "try:\n    for i in range(int(input())):\n        n=int(input())\n        \n        for j in range(1,n+1):\n            s=j+1\n            for k in range(1,n+1):\n                \n                print(s,end=\"\")\n                s+=1\n            print(\"\\r\")\nexcept Exception:\n    pass\n\n", "# cook your dish here\nfor _ in range(int(input())):\n s=input()\n count=0\n i=0\n while i<len(s)-1:\n  ch=s[i]\n  j=i+1 \n  while j<len(s) and s[j]==ch:\n   j+=1 \n  l=j-i\n  if i!=0 and j!=len(s) and s[i-1]==s[j] :\n   count+=1\n  count+=l*(l-1)//2\n  #print(s[i:j],count)\n  i=j\n print(count) \n", "x=[0, 0, 1, 1, 2, 1, 3, 1, 4, 2, 2, 0, 7, 0, 2, 2, 7, 0, 7, 0, 5, 2, 0, 0, 17, 1, 0, 3, 5, 0, 8, 0, 13, 0, 0, 2, 21, 0, 0, 0, 12, 0, 8, 0, 0, 5, 0, 0, 38, 1, 3, 0, 0, 0, 15, 0, 12, 0, 0, 0, 24, 0, 0, 5, 24, 0, 0, 0, 0, 0, 6, 0, 58, 0, 0, 3, 0, 0, 0, 0, 26, 5, 0, 0, 24, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 82, 0, 3, 0, 9]\ny=[0, 6, 20, 20, 54, 20, 88, 20, 122, 54, 68, 0, 238, 0, 68, 68, 224, 0, 238, 0, 170, 68, 0, 0, 522, 34, 0, 102, 170, 0, 272, 0, 358, 0, 0, 68, 630, 0, 0, 0, 352, 0, 272, 0, 0, 170, 0, 0, 928, 34, 102, 0, 0, 0, 454, 0, 352, 0, 0, 0, 648, 0, 0, 170, 502, 0, 0, 0, 0, 0, 204, 0, 1300, 0, 0, 102, 0, 0, 0, 0, 576, 156, 0, 0, 648, 0, 0, 0, 0, 0, 648, 0, 0, 0, 0, 0, 1380, 0, 102, 0, 222]\nn= int(input())\nprint(x[n],y[n])", "t = int (eval(input()))\n\nwhile t > 0:\n t -= 1\n r, c, m, j, k = list(map (int, input().split()))\n area = r * c\n if m + j + k != area:\n  print(\"No\")\n  continue\n l = r\n b = c\n if m % l == 0:\n  b -= m/l\n  if b > 0 and (j % l == 0 or j % b == 0 or k %l == 0 or k % b == 0):\n   print(\"Yes\")\n   continue\n l = r\n b = c\n if m % b == 0:\n  l -= m/b\n  if l > 0 and (j % l == 0 or j % b == 0 or k %l == 0 or k % b == 0):\n   print(\"Yes\")\n   continue\n \n l = r\n b = c\n if j % l == 0:\n  b -= j/l\n  if b > 0 and (m % l == 0 or m % b == 0 or k %l == 0 or k % b == 0):\n   print(\"Yes\")\n   continue\n l = r\n b = c\n if j % b == 0:\n  l -= j/b\n  if l > 0 and (m % l == 0 or m % b == 0 or k %l == 0 or k % b == 0):\n   print(\"Yes\")\n   continue\n \n l = r\n b = c\n if k % l == 0:\n  b -= k/l\n  if b > 0 and (j % l == 0 or j % b == 0 or m %l == 0 or m % b == 0):\n   print(\"Yes\")\n   continue\n l = r\n b = c\n if k % b == 0:\n  l -= k/b\n  if l > 0 and (j % l == 0 or j % b == 0 or m % l == 0 or m % b == 0):\n   print(\"Yes\")\n   continue\n \n print(\"No\")\n", "T = int(input())\n\ndef call_me(N,A,X):\n max = 0\n ans = ''\n for i in A:\n  if i.count(X) > max:\n   max = i.count(X)\n   ans = i\n return ans\n\n\n\nfor i in range(T):\n N = int(input())\n A = list(map(str,input().split()))\n X = input()\n print(call_me(N,A,X))\n", "from collections import Counter\n\ndef is_anagram(str1, str2):\n return Counter(str1) == Counter(str2)\n\n\ns=input()\nst=input()\ns=s.split(\" \")\ni=0\nc=\"\"\nfor sr in s:\n i+=1\n if sr!=st and is_anagram(sr, st):\n  c=c+str(i)\n\nprint(\"The antidote is found in \" + c+ '.')", "import math\nt=int(input())\n#print(math.factorial(5))\nfor i in range(t):\n s=input()\n l=list(s)\n seti=set(l)\n deno=1\n for i in seti:\n  deno*=(math.factorial(l.count(i)))\n leng=len(l)\n ans=((math.factorial(leng))//deno)%1000000007\n print(int(ans))", "def modify(s,i,j):\n k = s[i]\n del(s[i])\n s.insert(j,k)\n return(str(s))\n \nfor _ in range(int(input())):\n n = int(input())\n s = list(input())\n\n ans = str(s)\n for i in range(n):\n  for j in range(n):\n   if i != j:\n    ans = min(ans,modify(s,i,j))\n   k = s[j]\n   del(s[j])\n   s.insert(i,k)\n \n for i in ans:\n  if ord(i) >= 65 and ord(i) <=90:\n   print(i,end=\"\")\n print()", "# cook your dish here\nfrom math import gcd\nfor _ in range(int(input())):\n    n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1   \n    for j in range(n):\n     if(a[j] != -1):break            \n    for i in range(j,n):\n     if min_k==0:min_k,e = a[i],a[i]+1 \n     else:\n      if min_k < a[i]:min_k = a[i]                \n      if(a[i] == -1):pass\n      else:\n       if(a[i] == e):pass\n       else:\n        if( k == 0):k = e-a[i]\n        else:\n         new_k = e-a[i]\n         if(new_k < 0):k = -1\n         else:k = gcd(k,new_k)\n        if(k<min_k or k<0): k = -1; break\n      if k != 0 and a[i]!=-1: e = a[i]%k+1\n      else:e += 1             \n    if(k == -1):print(\"impossible\")\n    elif k == 0 :print(\"inf\")\n    else:print(k)  ", "n=int(input())\nwhile n>0:\n t=int(input())\n a=[]\n for i in range(8):\n  a.append(0)\n for i in range(t):\n  b,c=[int(x) for x in input().split()]\n  if b<=8 and c>a[b-1]:\n   a[b-1]=c\n print(sum(a))\n n=n-1\n", "# cook your dish here\nfor _ in range(int(input())):\n s = input()\n lisS = list(s)\n \n if(len(set(lisS))==1 or len(s) % 2 != 0):\n  print(-1)\n else:\n  mid = len(s) // 2\n  numZeros = 0\n  for i in range(len(s)):\n   if(s[i] == \"0\"):\n    numZeros += 1\n  \n  print(abs(mid - numZeros))", "# cook your dish here\nimport math\ntt=int(input())\nfor i in range(tt):\n n=int(input())\n a=n-math.ceil(n/2)\n print(1,10**a)", "for _ in range(int(input())):\n s = list(input().strip())\n\n i = 0\n\n while i < len(s) - 1:\n  if s[i].isalpha() or s[i] == ')':\n   if s[i + 1].isdigit():\n    if i + 2 >= len(s) or s[i + 2] == ')':\n     s = s[:i+1] + ['*', s[i+1]] + s[i+2:]\n    else:\n     s = s[:i+1] + ['*', s[i+1], '+'] + s[i+2:]\n    i += 1\n   elif s[i + 1].isalpha() or s[i + 1] == '(':\n    s = s[:i+1] + ['+'] + s[i+1:]\n\n  i += 1\n\n s = ''.join(s)\n\n s = s.strip('+')\n\n x = 2\n y = 4\n z = 10\n\n print(eval(s))\n", "# cook your dish here\nT = int(input())\nfor _ in range(T):\n N = int(input())\n mini = 10000000\n count1,count2=0,0\n u = []\n save = []\n for i in range(N):\n  a = input()\n  u.append(a)\n  x = a[:N//2].count('1')\n  y = a[N//2:].count('1')\n  count1+=x\n  count2+=y\n  save.append(x-y)\n if(count1==count2):\n  print(0)\n  continue\n for i in save:\n  mini = min(abs(count1-2*i-count2),mini)\n print(mini)\n \n", "for j in range(int(input())):\n input()\n a = list(map(int,input().split()))\n marks = 0\n backlok = 0\n top_marks = max(a)\n topper = []\n for i in range(len(a)):\n  if(a[i] >= 31):\n   marks+=a[i]\n  if(a[i]<31):\n   backlok+=1\n  if(a[i] == top_marks):\n   topper.append(i)\n print(backlok, \"{:0.2f}\".format(marks/len(a),2))\n topper.sort(reverse=True)\n for i in topper:\n  print(i,\" \")\n for i in a:\n  print(top_marks-i)\n\n", "from itertools import permutations\nk=[]\nd=[]\ndef abc(l):\n ans=0\n for i in range(1,len(l)):\n  if l[i]>l[i-1]:\n   ans+=1\n return ans\n\nfor i in range(8):\n k.append(i+1)\n x=list(permutations(k))\n c=[]\n for j in range(8):\n  c.append([])\n d.append(c)\n for j in x:\n  d[i][abc(j)].append(j)\n\nt=int(input())\nfor _ in range(t):\n n,k=list(map(int,input().split()))\n l=list(map(int,input().split()))\n ans=0\n c=d[n-1][k]\n for i in c:\n  flag=1\n  for j in range(n):\n   if l[j]!=0 and l[j]!=i[j]:\n    flag=0\n    break\n  if flag:\n   ans+=1\n print(ans)\n \n", "num,k=input().split()\r\nk=int(k)\r\n# print(num)\r\n# print(num[0])\r\nl=[]\r\nold=''\r\nfor x in range(len(num)):\r\n    if num[x]!='9' and k>0:\r\n        old='9'\r\n        l.append(old)\r\n        k=k-1\r\n    else:\r\n        l.append(num[x])\r\n    \r\n\r\nfor x in l:\r\n    print(x,end='')\r\n", "from math import ceil\r\nt=int(input())\r\nfor i in range(t):\r\n       p=int(input())\r\n       l=list(map(int,input().split()))\r\n       maxx=1\r\n       for i in range(len(l)):\r\n           maxx=max(maxx,l.count(l[i]))\r\n       if(maxx*2>p):\r\n           print(maxx)\r\n       else:\r\n           q=p-maxx*2\r\n           maxx+=ceil(q/2)\r\n           print(maxx)\r\n           \r\n       \r\n              \r\n\r\n", "import itertools\na,b,c,d = list(map(float , input().split()))\nli = list(itertools.permutations([a,b,c,d]))\nflag = False\nfor i in li:\n if i[0]/i[1] == i[2]/i[3]:\n  flag = True\n  break\nif flag == True :\n print('Possible')\nelse :\n print('Impossible')", "for x in range(0,int(input())):\n k=int(input())\n ctra,ctrb=[None]*k,[None]*k\n for y in range(0,k):\n  s=input()\n  ctra[y],ctrb[y]=s.count('a'),s.count('b')\n print(min(min(ctra),min(ctrb)))\n", "def compute(s,c):\n bcount = s.count('B')\n gcount = s.count('G')\n if(abs(bcount-gcount)>1):\n  return -1\n stack = [(0,s[0])]\n bans = 0\n gans = 0\n for i in range(1,len(s)):\n  if(len(stack)>0 and stack[len(stack)-1][1]!=s[i]):\n   idx,char = stack[len(stack)-1]\n   if((idx%2 and s[i]=='B') or (i%2 and char=='B')):\n    bans += abs(i-idx)**c\n   elif((idx%2 and s[i]=='G') or (i%2 and char=='G')):\n    gans += abs(i-idx)**c\n   stack.pop(len(stack)-1)\n  else:\n   stack.append((i,s[i]))\n \n if(gcount==bcount):\n  return min(bans,gans)\n elif(gcount>bcount):\n  return bans\n return gans\nfor t in range(int(input())):\n c = int(input())\n print(compute(input(),c))\n", "#!/usr/bin/env python\r\nimport sys\r\n\r\nboxes_number = int(sys.stdin.readline().rstrip())\r\nboxes_sizes = list(map(int, sys.stdin.readlines()))\r\n\r\nboxes_sizes.sort()\r\n\r\nlower_bound, upper_bound = 0, boxes_number // 2 + 1\r\n\r\nwhile lower_bound + 1 < upper_bound:\r\n  middle = (lower_bound + upper_bound) >> 1\r\n\r\n  possible = not middle or all(\r\n    2 * boxes_sizes[i] <= boxes_sizes[boxes_number - middle + i]\r\n    for i in range(middle)\r\n  )\r\n\r\n  if not possible:\r\n    upper_bound = middle\r\n  else:\r\n    lower_bound = middle\r\n\r\nprint(boxes_number - lower_bound)\r\n", "def mul3(ip):   \n q0=[]\n q1=[]\n q2=[]\n ip.sort()\n sums=sum(ip)\n for i in ip:\n  if (i % 3) == 0:\n   q0.insert(0,i)\n  if (i % 3) == 1:\n   q1.insert(0,i)\n  if (i % 3) == 2:\n   q2.insert(0,i)\n if(sums%3==1):\n  if(len(q1)):\n   q1.pop()\n  elif(len(q2)>=2):\n   q2.pop()\n   q2.pop()\n  else:\n   return -1\n elif(sums%3==2):\n  if(len(q2)):\n   q2.pop()\n  elif(len(q1)>=2):\n   q1.pop()\n   q1.pop()\n  else:\n   return -1\n \n q0.extend(q1)\n q0.extend(q2)\n if(len(q0)<=0):\n  return -1\n q0.sort()\n q0.reverse()\n return q0\n\nt = int(input())\nfor z in range(t):\n n = int(input())\n a = list(map(int, input().split()))\n if 0 not in a or mul3(a)==-1:\n  print(-1)\n else:\n  out=''\n  temp = mul3(a)\n  for p in temp:\n   out+=str(p)\n  print(out)", "# cook your dish here\nMOD=10**9+7\nfor _ in range(int(input())):\n    s=input()\n    ind=1\n    level=1\n    for i in range(len(s)):\n        if s[i]=='l':\n            if level%2==1:\n                ind=ind*2\n            else:\n                ind=ind*2-1\n        if s[i]=='r':\n            if level%2==1:\n                ind=ind*2+2\n            else:\n                ind=ind*2+1\n        level+=1\n        ind%=MOD\n    print(ind)\n", "# your code goes here\nfrom sys import stdin, stdout\nt = int(stdin.readline())\nwhile t:\n t -= 1\n n = int(stdin.readline())\n maxi = -1\n index = 0\n for i in range(n):\n  hh,mm,ss = list(map(int, stdin.readline().strip().split(':')))\n  ssa = ss * 360.0 / 60.0\n  mma = (mm + (ss / 60.0)) * 360.0 / 60.0\n  hha = (hh + (mm + (ss / 60.0)) / 60.0) * 360.0 / 12.0\n  avg = (abs(ssa-hha) + abs(mma-ssa) + abs(mma-hha)) / 3\n  # print hha, mma, ssa\n  if avg > maxi:\n   maxi = avg\n   index = i\n stdout.write(str(index+1)+'\\n')\n", "# cook your dish here\nfor _ in range(int(input())):\n n, m = map(int, input().split())\n\n ml = []\n for i in range(n):\n  ml.append(list(map(int, input().split())))\n s = input()\n p, q = map(int, input().split())\n nl = [0]*(n+m-1)\n pl = [0]*(n+m-1)\n for i in range(n):\n  for j in range(m):\n   if ml[i][j] != int(s[i+j]):\n    nl[i+j] += 1\n   else:\n    pl[i+j] += 1\n c = 0\n for i in range(len(nl)):\n  c += min(nl[i]*p, pl[i]*p + q)\n print(c)", "# cook your dish here\nfor s in range(int(input())):\n    A=input()\n    balance=0\n    max_balance=0\n    for i in range(len(A)):\n        if(A[i]=='('):\n            balance+=1\n        if(A[i]==')'):\n            balance-=1\n        max_balance=max(max_balance,balance)\n    for i in range(max_balance):\n        print(\"(\",end='')\n    for i in range(max_balance):\n        print(\")\",end='')\n    print()", "mod=1000000007\nn,q=map(int,input().split())\nl=n+1%mod\nr=n+1%mod\nt=1%mod\nb=pow(2,n)%mod\ne=(pow(2,n+1)-2)%mod\nfor _ in range(q):\n lst=list(map(int,input().split()))\n if (len(lst)!=1) :\n  if(lst[1]==1):\n   e=(2*e+l)%mod\n   l=l\n   r=r\n   t=(2*t)%mod\n   b=(2*b)%mod\n  if lst[1]==2:\n   e=(2*e+r)%mod\n   l=l\n   r=r\n   t=(2*t)%mod\n   b=(2*b)%mod\n  if lst[1]==3:\n   e=((2*e)+t)%mod\n   t=b%mod\n   l=2*l%mod\n   r=2*r%mod\n   b=b%mod\n  if lst[1]==4:\n   e=((2*e)+b)%mod\n   b=t%mod\n   l=2*l%mod\n   r=2*r%mod\n   b=b%mod\n else:\n  print(e)", "for _ in range(int(input())):\r\n    s = input().strip()\r\n    input()\r\n    a = set(input().split())\r\n\r\n    d = set(s)\r\n\r\n    print(int(all(i in a for i in d)))\r\n", "# cook your dish here\nimport math\nt = int(input())\nfor i in range(t):\n l,b = map(int, input().split())\n area = l*b\n gcd = math.gcd(l,b)\n gcd=gcd**2\n print(area//gcd)", "t = int(input())\nwhile t>0:\n    t-=1\n    n = int(input())\n    s = input().strip()\n    previ = s[0]\n    num = 0\n    _s = []\n    dic = {}\n    for i in s:\n     if previ == i:\n      num+=1\n      continue\n     _s.append((previ, num))\n     if previ not in dic or dic[previ]<num:\n      dic[previ] = num\n     #l.append(previ)\n     previ = i\n     num  = 1\n    _s.append((previ, num))\n    if previ not in dic or dic[previ]<num:\n      dic[previ] = num\n\n    ##print(_s)\n    sum1 = sum(dic.values())\n    del dic, s", "# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    if n==1:\n        print(\"0\")\n    else:\n        s=[]\n        for i in range(n):\n            s.append(str(i))\n        print(''.join(s))\n        p=1\n        for i in range(n-1):\n            s.pop(n-1)\n            s=[str(p)]+s\n            print(''.join(s))\n            p+=1\n", "# cook your dish here\ntry:\n for _ in range(int(input())):\n  q = input()\n  print(10)\nexcept:\n pass", "t=int(input()) #TESTCASES\n\nfor y in range(t):\n inptstr=input().split()\n\n n=int(inptstr[0]) #N TOTAL ELEMENTS\n\n K=int(inptstr[1]) #K CONSTaNT IN Pij\n\n s=input() #STRING SEQUENCE OF CELLS ELEMENTS\n\n \n noblock=s.split('X')\n cnt=[]\n cntiron=0\n for ele in noblock: #PARSING ELEMENTS WITHOUT BLOCK\n  d={}\n  d1={}\n  iron=[]\n  magnet=[]\n  for x in range(len(ele)):#TRACKING LOCATION OF ELEMENTS IN NOBLOCK\n   if ele[x]=='I':\n    iron.append(x)\n   elif ele[x]=='M':\n    magnet.append(x)\n  #print('part',ele)\n  for i in iron:\n\n   #print('IRON - ',i)\n   for j in magnet:\n    #print('MAGNET - ',j)\n    \n    if i in d or j in d1:\n     continue\n    if i<j:\n     Sij=(ele[i:j]).count(':')\n\n    if j<i:\n     Sij=(ele[j:i]).count(':')\n    Pij=(K+1)-(abs(j-i))-Sij\n    if Pij > 0:\n     cntiron=cntiron+1\n     #print('CONNECTION DONE')\n     d[i]=j\n     d1[j]=i\n     break\n \n print(cntiron)\n\n    \n    \n    \n  \n  \n\n\n\n\n \n \n\n", "cases = int(input())\nfor _ in range(cases):\n rows, cols = map(int, input().split())\n if (cols - 1) % 3 == 0 and (rows - 1) % 4 == 0: print('Vanya')\n elif (cols - 1) % 3 != 0 and (rows - 1) % 4 == 0: print('Tuzik')\n elif (cols - 1) % 3 == 0 and (rows - 1) % 4 != 0: print('Tuzik')\n else:\n  if (cols - 1) % 3 == 1 and (rows - 1) % 4 == 1: print('Vanya')\n  elif (cols - 1) % 3 == 2 and (rows - 1) % 4 == 2: print('Vanya')\n  else: print('Tuzik')", "# cook your dish here\n\nfrom collections import defaultdict\nd = defaultdict(int)\nfor i in range(97,123):\n    d[chr(i)] = 100 * (i - 96)\n    \nt = int(input())\nfor _ in range(t):\n    s = input()\n    val = defaultdict(int)\n    ini = d[s[0].lower()]\n    for i in range(97,123):\n        val[chr(i)] = ini + (i - 97)\n    mod = (10**9) + 7\n    ans = 0\n    for i in s:\n        ans += val[i.lower()]\n        ans = ans%mod\n    print(ans)", "__author__ = 'Prateek'\n\nMOD = int(10**9+7)\n\ndef test():\n n,k=list(map(int,input().split()))\n l = k\n d =n-1\n ans = l-1\n ans = ans%MOD\n a = k-n\n term = (d+a)//d\n ll = (a%MOD - (((term-1)%MOD)*(d%MOD))%MOD)%MOD\n if ll < 0:\n  ll = (ll +MOD)%MOD\n m = ((term%MOD)*((a%MOD+ll%MOD)%MOD))%MOD\n m = (m*pow(2,MOD-2,MOD))%MOD\n ans += m\n ans = ans%MOD\n print(ans)\n\n\nif __author__ == 'Prateek':\n t = int(input())\n for _ in range(t):\n  test()\n", "for _i in range(int(input())):\n x,k = list(map(int,input().split()))\n a = list(map(int,input().split()))\n b = list(map(int,input().split()))\n l = []\n l.append(x)\n for i in range(k):\n  x = x+(x*(float(a[i])/b[i]))\n w = l[0]\n perc = 100*(float(w)/x)\n ans = 100-perc\n print(int(ans))\n\n\n\n", "from math import sqrt\n\ndef isprime(n):\n    if (n % 2 == 0 and n > 2) or n == 1: return 0\n    else:\n        s = int(sqrt(n)) + 1\n        for i in range(3, s, 2):\n            if n % i == 0:\n                return 0\n        return 1\n\ndef find(N, K): \n    if (N < 2 * K): \n        return 0\n    if (K == 1): \n        return isprime(N) \n    if (K == 2): \n        if (N % 2 == 0): \n            return 1\n        return isprime(N - 2); \n    return 1\n\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    print(find(n, k))\n\n\n", "\r\nimport math\r\n\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n\r\n    r=math.log2(n)\r\n\r\n    if(r!=int(r)):\r\n        r=int(r)\r\n        r=pow(2,r+1)\r\n    else:\r\n        r=int(r)\r\n        r=pow(2,r)\r\n        \r\n    print(r)\r\n", "n=int(input())\nl=list(map(int,input().split()))\na=[]\nfor i in range(0,n):\n    for j in range(i+1,n):\n     a.append((l[i]^l[j],(i,j)))\n\na.sort()\ndp=[0]*n\nfor i in range(0,len(a)):\n    x=a[i][0]\n    left,right=a[i][1][0],a[i][1][1]\n    dp[right]=max(dp[left]+1,dp[right])\n\nprint(max(dp)+1)", "# cook your dish here\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    lower =[]\n    upper =[]\n    points =[]\n    for j in range(N):\n        inputs = list(map(int,input().split()))\n        lower.append(inputs[0])\n        upper.append(inputs[1])\n        points.append(0)\n    for p in range(N):\n        for m in range(p+1,N):\n            if (lower[p]<lower[m] and upper[p]>=upper[m]) or (lower[p]<=lower[m] and upper[p]>upper[m]):\n                points[p] += 2\n            elif (lower[p]>lower[m] and upper[p]<=upper[m]) or (lower[p]>=lower[m] and upper[p]<upper[m]):\n                points[m] += 2\n            else:\n                points[p] +=1\n                points[m] +=1\n    for n in range(N):\n        print(points[n],end=\" \")\n    print()", "# cook your dish here\nn=int(input())\narr=list(map(int,input().split()))\ndp=[0]*(n+1)\ndp[0]=0\ndp[1]=arr[0]\ndp[2]=arr[0]+arr[1]\ndp[3]=max(arr[2]+arr[0],arr[1]+arr[2],dp[-1])\n\nfor i in range(4,n+1):\n    dp[i]=max(dp[i-1],arr[i-1]+dp[i-2],arr[i-1]+arr[i-2]+dp[i-3])\n# print(dp)/\nprint(dp[-1])\n# if N > 0:\n#     sum[0] = Ps[0]\n# if N > 1:\n#     sum[1] = Ps[0] + Ps[1]\n# if N > 2:\n#     sum[2] = max(Ps[0] + Ps[2], max(sum[1], Ps[1] + Ps[2]))\n\n\n# for i in range(3, N):\n#     sum[i] = max(sum[i-2] + Ps[i], max(sum[i-1], sum[i-3] + Ps[i-1] + Ps[i]))\n", "M=1000000007\ndef expmod_iter(a,b,c):\n x = 1\n while(b>0):\n  if(b&1==1): x = (x*a)%c\n  a=(a*a)%c\n  b >>= 1\n return x%c\n\nt=eval(input())\nwhile t>0:\n t-=1\n n,k=list(map(int,input().split()))\n if n>=2 and k<=1:\n  print(0)\n else:\n  print((k*expmod_iter(k-1,n-1,M))%M)", "import math\ndef score(df):\n res,fx,li2,x = {} ,1,{},1\n for val in df:\n  for key in val:\n   if key not in res:res[key]=1\n   else:res[key]+=1\n for val in res.values():fx=fx*val \n for val in res:\n  li2[val]=0\n  for i in df:\n   if val in i:li2[val]+=1 \n for val in li2: x *= li2[val]\n return [x,fx]\ndef prog(li,al,bo):\n for cur in li:\n  prev,f = -1,0\n  for j in range(len(cur)):\n   if cur[j] not in ['a','e','i','o','u']:\n    if prev==-1:prev = j\n    else:\n     if abs(prev-j)==2 or abs(prev-j)==1:\n      f = 1\n      break\n     else:prev = j\n  if f==1:bo.append(cur)\n  else:al.append(cur) \n sca,scb = score(al),score(bo)\n ans1 = math.log10(sca[0])+len(bo)*math.log10(scb[1])\n ans2 = math.log10(scb[0])+len(al)*(math.log10(sca[1]))\n return (ans1-ans2 ) \nfor i in range(int(input())):\n li,x =[],int(input())\n for i in range(x):li.append(input())\n final =prog(li,[],[])\n print(\"Infinity\") if final >7.0 else print(pow(10,final))", "# cook your dish here\n\nt = int(input())\nwhile t:\n A = input()\n B = input()\n mp1 = 0\n p1 = 0\n mp0 = 0\n p0 = 0\n for i in range(len(B)):\n  if A[i]==B[i] and B[i]=='1':\n   p1 += 1\n  elif A[i]==B[i] and B[i]=='0':\n   p0 += 1\n  elif A[i]!=B[i] and B[i]=='1':\n   mp0 += 1\n  else:\n   mp1 += 1\n #if A==B:\n  #   con = True\n  #  op = 0\n if mp0+p0==len(A) or mp1+p1==len(A):\n  con = False\n elif mp1+p0>=mp0+p0:\n  con = True\n  op = mp1-mp0\n  mp1 -= op\n  op += mp1\n else:\n  con = True\n  op = mp0-mp1\n  mp0 -= op\n  op += mp0\n if con:\n  print('Lucky Chef')\n  print(op)\n else:\n  print('Unlucky Chef')\n t -= 1\n", "for _ in range(int(input())):\n # n = int(input())\n # s = input()\n n,k = list(map(int,input().split()))\n f = input().split()\n leftovers = f[:n-k]\n removed = f[n-k:]\n seekin = 'H'\n flip = {'H':'T' , 'T':'H'}\n for coin in removed[::-1] :\n  if coin == seekin :\n   seekin = flip[seekin]\n print(leftovers.count(seekin))\n", "from math import factorial as fact\ndef _sum(arr, n): \n    f = fact(n)\n    ds = 0\n    for i in range(n):\n        ds += arr[i]\n    ds *= (f // n)\n    res, i, k = 0, 1, 1\n    while i <= n :\n        res += (k * ds)\n        k = k * 10\n        i += 1\n    return res\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(_sum(arr, n))\n", "\r\nt=int(input())\r\nwhile t>0:\r\n    t-=1\r\n    n=int(input())\r\n    a=[]\r\n    s=n*(n+1)//2\r\n    for i in range(1,n+1):\r\n        s=i*(i+1)//2\r\n        for j in range(i):\r\n            \r\n            print(s,end=\"\")\r\n            s-=1\r\n        print()\r\n", "t = eval(input())\n\nfor i in range(t):\n n=eval(input())\n a = list(map(int, input().split()))\n a.sort()\n \n cnt=1\n for ind,x in enumerate(a):\n  cnt*=(x-ind) \n  if x-ind<=0:\n   cnt=0\n   break\n print(cnt%(10**9+7)) \n", "n,m,lk = list(map(int,input().split()))\nsp = [int(i)-1 for i in input().split()]\ndp = []\nfor i in range(n):\n dp += [[0]*n]\nfor i in range(n):\n for j in range(n):\n  if(i!=j):\n   dp[i][j]=10**18\nfor _ in range(m):\n x,y,z = list(map(int,input().split()))\n dp[x-1][y-1]=z\n dp[y-1][x-1]=z\nfor k in range(n):\n for i in range(n):\n  for j in range(n):\n   if(dp[i][j]>dp[i][k]+dp[k][j]):\n    dp[i][j]=dp[i][k]+dp[k][j]\ndist = 10**18\nfor i in range(lk):\n for j in range(i+1,lk):\n  dist = min(dist,dp[sp[i]][sp[j]])\nprint(dist)\n", "t=int(input())\nwhile t>0 :\n\ta=int(input())\n\tb=int(input())\n\tl=int(input())\n\tx=0\n\ty=0\n\tz=0\n\ta1=0\n\tb1=0\n\tc1=0\n\twhile(a//10!=0 or a%10!=0):\n\t\ta1+=(a%10+((a//10)%10)*7+((a//100)%10)*49+((a//1000)%10)*343+((a//10000)%10)*2401+((a//100000)%10)*16807+((a//1000000)%10)*117649+((a//10000000)%10)*823543+((a//100000000)%10)*5764801+((a//1000000000)%10)*40353607)*(282475249**x)\n\t\tx+=1\n\t\ta//=10000000000\n \n\twhile (b//10!=0 or b%10!=0):\n\t\tb1+=(b%10+((b//10)%10)*7+((b//100)%10)*49+((b//1000)%10)*343+((b//10000)%10)*2401+((b//100000)%10)*16807+((b//1000000)%10)*117649+((b//10000000)%10)*823543+((b//100000000)%10)*5764801+((b//1000000000)%10)*40353607)*(282475249**y)\n\t\ty+=1\n\t\tb//=10000000000\n\tc=(a1//b1)%(7**l)\n\twhile z<l:\n\t\tc1+=(c%7+((c//7)%7)*10+((c//49)%7)*100+((c//343)%7)*1000+((c//2401)%7)*10000+((c//16807)%7)*100000+((c//117649)%7)*1000000+((c//823543)%7)*10000000+((c//5764801)%7)*100000000+((c//40353607)%7)*1000000000)*(10000000000**(z//10))\n\t\tc//=282475249\n\t\tz+=10\n\tprint(c1)\n\tt-=1", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat May 16 22:03:29 2020\n\n@author: shailesh\n\"\"\"\n\n\ndef findD_and_start(A):\n first = A[1] - A[0]\n second = A[2] - A[1]\n third = A[3] - A[2]\n if first == second:\n  return second,A[0]\n elif third == second:\n  return third,A[3] - 3*third\n else:\n  return (A[3] - A[0])//3,A[0]\nT = int(input())\n\nfor t in range(T):\n N = int(input())\n A = [int(i) for i in input().split()]\n d,start = findD_and_start(A)\n \n s = ''\n if d ==0:\n  for i in range(N):\n   s+=str(start) + ' '\n else:\n  for i in range(start,start + N*d,d):\n   s+= str(i) + ' '\n print(s.strip())", "primes = []\r\n\r\ndef rwh_primes1(n):\r\n    \r\n    \"\"\" Returns  a list of primes < n \"\"\"\r\n    sieve = [True] * (n//2)\r\n    for i in range(3,int(n**0.5)+1,2):\r\n        if sieve[i//2]:\r\n            sieve[i*i//2::i] = [False] * ((n-i*i-1)//(2*i)+1)\r\n    return [2] + [2*i+1 for i in range(1,n//2) if sieve[i]]\r\n\r\nprimes = rwh_primes1(1000000)\r\n#print(primes)\r\nplookup = set(primes)    \r\nS = []\r\n#print(len(primes))\r\nprime = 10**9+7\r\nfor i in range(2,10000):\r\n  if i in plookup:\r\n    S.append(primes[i-1])\r\n#print(len(S))\r\ndef __starting_point():\r\n  T = int(input())\r\n  while T>0:\r\n    T-=1\r\n    N = int(input())\r\n    s = 0\r\n    for i in range(N):\r\n      s+=S[i]\r\n    print(s%prime)\n__starting_point()", "# cook your dish here\nimport math\ndef find():\n    x,y = map(int,input().split())\n    a = math.gcd(x,y)\n    lcm = (x*y)//a\n    print(a,lcm)\n \n\nfor i in range(int(input())):\n    find()", "from sys import *\nt=eval(input())\nfor i in range(t):\n j=input()\n s=input()\n ans=0\n for k in range(len(s)):\n  if s[k] in j:\n   ans+=1\n print(ans)\nreturn", "# cook your dish here\nfor i in range(int(input())):\n    n=int(input())\n    k=int(input())\n    if(k%n==0):\n        print(\"YES\")\n    else: print(\"NO\")\n", "# cook your dish here\n# cook your dish here\nfor _ in range(int(input())):\n n,m=list(map(int,input().split()))\n atomlist = ['']*n\n for k in range(m):\n  s=[]\n  s.extend(input().split()[1:])\n  #print(s)\n  for w in range(n):\n   if str(w) in s:\n    atomlist[w]+=\"1\"\n   else:\n    atomlist[w]+=\"0\"\n  #print(atomlist)\n print(len(set(atomlist)))\n", "try:\r\n    t = int(input())\r\n    for a in range(t):\r\n        k = int(input())\r\n        for i in range(k):\r\n            # for j in range(k):\r\n            if (i==0 or i==k-1):\r\n                print(\"*\"*(i+1))\r\n            else:\r\n                print(\"*\"+(\" \"*(i-1))+\"*\")\r\nexcept EOFError:\r\n    pass", "for i in range(eval(input())):\n n,k=input().strip().split()\n n=int(n)\n k=int(k)\n print(int( ((n-k)&(int((k-1)/2)))==0))", "# cook your dish here\nT=int(input())\nfor _ in range(T):\n    A,B,C=map(int,input().split())\n    if A**2+(B**2)==C**2 :\n        if A+B>C:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif B**2+(C**2)==A**2 :\n        if C+B>A:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif A**2+(C**2)==B**2 :\n        if A+C>B:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")", "try:\n a=list(map(int,input().split()))\n d1=a[0]\n v1=a[1]\n d2=a[2]\n v2=a[3]\n p=a[4]\n vacc=0\n day=0\n for i in range(1,1000):\n  if i>=d1:\n   vacc=vacc+v1\n  if i>=d2:\n   vacc=vacc+v2\n  day=day+1\n  if vacc>=p:\n   break\n print(day)\nexcept:\n pass", "# cook your dish here\nfor _ in range(int(input())):\n\tn = int(input())\n\tflag = False\n\ts = n\n\tfor i in range(2*n+1):\n\t\tif s>=0:\n\t\t\tfor j in range(s):\n\t\t\t\tprint(\" \",end=\"\")\n\t\t\tfor j in range(n+1-s):\n\t\t\t\tprint(j+s,end=\"\")\n\t\telse:\t\t\t\n\t\t\tfor j in range(abs(s)):\n\t\t\t\tprint(\" \",end=\"\")\n\t\t\tfor j in range(n+1-abs(s)):\n\t\t\t\tprint(j+abs(s),end=\"\")\t\t\n\t\tprint()\t\n\t\ts-=1", "# Python3 program to find XNOR\n# of two numbers\nimport math\n\n\ndef swap(a, b):\n temp = a\n a = b\n b = temp\n\n\n# log(n) solution\ndef xnor(a, b):\n # Make sure a is larger\n if (a < b):\n  swap(a, b)\n\n if (a == 0 and b == 0):\n  return 1;\n\n # for last bit of a\n a_rem = 0\n\n # for last bit of b\n b_rem = 0\n\n # counter for count bit and\n # set bit in xnor num\n count = 0\n\n # for make new xnor number\n xnornum = 0\n\n # for set bits in new xnor\n # number\n while (a != 0):\n\n  # get last bit of a\n  a_rem = a & 1\n\n  # get last bit of b\n  b_rem = b & 1\n\n  # Check if current two\n  # bits are same\n  if (a_rem == b_rem):\n   xnornum |= (1 << count)\n\n  # counter for count bit\n  count = count + 1\n\n  a = a >> 1\n  b = b >> 1\n\n return xnornum;\n\n\nt= int(input())\nfor o in range(t):\n a,b,n=map(int,input().split())\n c=a^b\n x=bin(c)\n x=x.split(\"b\")\n x=x[1]\n x=len(x)\n d=xnor(a,b)\n p=[a,b,c];r=[a,b,d]\n k=n%3-1\n if p[k]>r[k]:\n  print(p[k])\n else :\n  print(r[k])", "t=int(input())\nfor i in range(t):\n s=input().split()\n if('not' in s):\n  print(\"Real Fancy\")\n else:\n  print(\"regularly fancy\")", "def find_min(m,W):\n i=1\n while i <= m :\n  if i not in W:\n   break\n  i+=1\n return i\n \ndef find_max(M,W,m):\n i=min(M,m)\n while i > 0 :\n  if i not in W:\n   break\n  i-=1\n return i\ncache = {}\ndef knap(M,W,m):\n if len(W)==m or M < find_min(m,W) or M==0 :\n  return 0\n if (M,tuple(W),m) in cache:\n  return cache[(M,tuple(W),m)]\n if m*(m+1)/2<M:\n  cache[(M,tuple(W),m)]=m*(m+1)/2\n  return cache[(M,tuple(W),m)]\n #if (M,W,m) in cache:\n #    return cache[(M,W,m)] \n val = find_max(M,W,m)\n W.add(val)\n #if val == M:\n #    return val\n #print val,M\n #cache[(M,W,m)] = \n cache[(M,tuple(W),m)] = val+knap(M-val,W,m)\n return cache[(M,tuple(W),m)]\n\n #return cache[(M,W,m)] \n \ntests = int(input())\nfor i in range(tests):\n n1,n2,m = ([int(x) for x in input().split(\" \")])\n W = set()\n M = min(n1,n2)\n print(max(n1,n2)-M + 2*(M-knap(M,W,m))) ", "def power(x, y, p) : \n res = 1\n x = x % p \n  \n if (x == 0) : \n  return 0\n \n while (y > 0) :\n  \n  if ((y & 1) == 1) : \n   res = (res * x) % p \n   \n  y = y >> 1 \n  x = (x * x) % p \n   \n return res \n \nt = int(input())\nmod = 1000000007\nfor _ in range(t):\n n = int(input())\n ans = power(n-1,2,mod) + power(n,3,mod)\n print(ans%mod)", "from sys import*\r\ninput=stdin.readline\r\nt=int(input())\r\nfor _ in range(t):\r\n    k=int(input())\r\n    l=[1 for _ in range(k)]\r\n    for i in range(1,k):\r\n        if l[i-1]==0:\r\n            l[i]=1\r\n        else:\r\n            l[i]=0\r\n    ans=\"\".join([str(x) for x in l])\r\n    for i in range(k):\r\n        print(ans)\r\n", "# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n s=input()\n r=input()\n if s.count('1')==r.count('1'):\n  print('YES')\n else:\n  print(\"NO\")\n", "for x in range(int(input())):\n n,m=map(int,input().split())\n y=n*m\n l=[(1,1)]\n for x in range(n*m):\n  l=[(1,1)]\n  a=1\n  b=1\n  while(True):\n   b=b+x+1\n   if(b>m):\n    u=b-m\n    if(u%m==0):\n     a=a+u//m\n     b=m\n    else:\n     a=a+(u//m)+1\n     b=u%m\n   if a>n:\n    break\n   else:\n    l.append((a,b))\n  a=1\n  b=1\n  while(True):\n   a=a+x+1\n   if(a>n):\n    u=a-n\n    if(u%n==0):\n     b=b+u//n\n     a=n\n    else:\n     b=b+(u//n)+1\n     a=u%n\n   if b>m:\n    break\n   else:\n    l.append((a,b))\n  print(len(set(l)),end=\" \")\n print(\"\")\n  \n   \n", "\n\nMOD = 1000000007\n\ndef powmod(base,exp):\n if exp == 0:\n  return 1\n elif exp & 1:\n  return (base * powmod(base,exp-1)) % MOD\n else:\n  return powmod((base*base) % MOD,exp//2) % MOD\n\n\n\nt = eval(input())\nfor i in range (0, int(t)):\n n = eval(input())\n k = int(n)//2\n if (int(n) & 1):\n  result = 3 * (powmod(9,k)-1)\n else:\n  result = powmod(9,k)+3\n print(result % MOD)\n", "import math\nimport sys\n\ndef fun(n,x):\n res = 1\n for i in range(n, x,-1):\n  res = (res*i)%1000000007\n return res\n\ndef degree(a,k):\n res = 1\n cur = a\n while(k):\n  if (k % 2):\n   res = (res * cur) % 1000000007\n  k /= 2\n  cur = (cur * cur) % 1000000007\n return res\n \ndef inv_fun(k):\n denom = 1\n for x in range(1, k+1, 1):\n  denom = (denom*x) % 1000000007\n denom = degree(denom, 1000000005) % 1000000007\n return denom\n  \ndef nCr(n,r):\n return fun(n,n-r)*inv_fun(r)\n \nT = int(input())\nfor x in range(T):\n N, K = [int(y) for y in input().split(\" \")]\n array = [int(t) for t in input().split(\" \")]\n count = 0\n for i in range(len(array)):\n  if(array[i] == 0):\n   count += 1\n K = min(N,K)\n if count != 0:\n  sum = 0\n  for j in range(0,min(N-count,K)+1):\n   sum += nCr(N-count,j)\n   \n elif K%2 == 0:\n  sum = 0\n  for j in range(0,K+1,2):\n   sum += nCr(N,j)\n else:\n  sum = 0\n  for j in range(1,K+1,2):\n   sum += nCr(N,j)\n print(sum%1000000007)", "import sys\n\nt = int(sys.stdin.readline().strip())\n\nwhile t:\n n = int(sys.stdin.readline().strip())\n\n if n == 1:\n  st = 1\n elif n == 2:\n  st = \"1 2\"\n elif n == 3:\n  st = \"1 2 3\"\n else:\n  \n  \n  j = n//2 +1\n  add = []\n  for i in range(n):\n   add.append(str(n-i+j-1))\n\n  st = \" \".join(add)\n print(st)\n \n t-=1\n\n\n\n\n", "t = int(input(\"\"));\nfor i in range(t):\n s1,s2 = (input(\"\").split());\n s1=str(int(s1))\n s2=str(int(s2))\n s1 = s1[::-1];\n s2 = s2[::-1];\n sum = int(s1) + int(s2) ;\n sum = str(sum)\n sum = sum[::-1];\n print(int(sum))", "t = eval(input())\nfor _ in range(t):\n\ts = input()\n\td = []\n\tl = len(s)\n\tfor a in range(l-1):\n\t\td.append(s[a:a+2])\n\td = set(d)\n\tprint(len(d))", "# Problem: http://www.codechef.com/JULY09/submit/CUBESUM/ \n# Author: Susam Pal\n\ndef computeA():\n X, Y, Z = [int(x) for x in input().split()]\n B = []\n for x in range(X):\n  B.append([])\n  for y in range(Y):\n   B[-1].append([int(t) for t in input().split()])\n   for z in range(Z):\n    result = B[x][y][z]\n    if x:\n     result -= B[x - 1][y][z]\n     if y:\n      result += B[x - 1][y - 1][z]\n      if z:\n       result -= B[x - 1][y - 1][z - 1]\n       \n    if y:\n     result -= B[x][y - 1][z]\n     if z:\n      result += B[x][y - 1][z - 1]\n    if z:\n     result -= B[x][y][z - 1]\n     if x:\n      result += B[x - 1][y][z - 1]\n    print(result, end=' ')\n   print()\n\ntest_cases = int(input())\nfor i in range(test_cases):\n computeA()\n", "import sys\nsys.setrecursionlimit(1000000)\n\nmod = 10**9 + 7\nts = int(input())\nwhile ts > 0:\n n,q = list(map(int,input().split()))\n ncc = n-1\n par = [i for i in range(n)]\n rank = [1]*n\n xor = [0]*n\n flag = 1\n\n def find(a):\n  if par[a] == a:\n   return a\n  else:\n   temp = find(par[a])\n   xor[a]^=xor[par[a]]\n   par[a] = temp\n   return temp\n\n def union(a,b): \n  a,b = find(a),find(b)\n  if a ==b:\n   return \n  if rank[a] > rank[b]:\n   par[b] = a\n\n   rank[a]+=rank[b]\n  elif rank[a] < rank[b]:\n   par[a] = b\n   rank[b]+=rank[a]\n  else:\n   par[b] = a\n   rank[a]+=rank[b]\n  par[b] =a\n\n for _ in range(q):\n  \n  a,b,x = list(map(int,input().split()))\n  a-=1\n  b-=1\n  if flag == -1:\n   continue\n  para = find(a)\n  parb = find(b)\n\n  if para == parb and xor[a] ^ xor[b] != x:\n   flag = -1 \n   continue\n   # print(\"no\")\n\n  if para != parb:\n   if rank[para] < rank[parb]:\n    xor[para] = xor[a] ^ xor[b] ^ x\n    par[para] = parb\n    rank[parb]+=rank[para]\n   else:\n    xor[parb] = xor[a] ^ xor[b] ^ x\n    par[parb] = para\n    rank[para]+=rank[parb]\n   ncc-=1\n   \n if flag != -1:\n  print(\"yes\")\n else:\n  print(\"no\")\n  \n ts-=1", "for t in range(int(input())):\n n = int(input()) // 2\n s = input()\n d = {}\n for i in s:\n  if (i not in d):\n   d[i] = 0\n  d[i] += 1\n res = 0\n for i in d:\n  if (d[i] % 2):\n   res += 1\n if (n % 2):\n  if (res == 0 or res == 2):\n   print(\"YES\")\n  else:\n   print(\"NO\")\n else:\n  if (res == 0):\n   print(\"YES\")\n  else:\n   print(\"NO\")", "def test():\r\n    N=int(input())\r\n    ls=list(map(int,input().split()))\r\n    ans=0\r\n    n=N/2\r\n    for each in ls:\r\n        if each>=n:\r\n            ans+=1\r\n    print(ans)\r\n\r\nT=int(input())\r\nfor i in range(T):\r\n    test()\r\n", "# cook your dish here\nimport math\nfor _ in range(int(input())):\n n = int(input())\n print(n*(n+1)*(2*n+1)//6)\n", "# cook your dish here\nimport math\nT = int(input())\nfor _ in range(T):\n N, A, K = list(map(int, input().split(\" \")))\n total = (N-2) * 180\n \n # 360 = 60 + (1+2+3)*diff + 3*60\n # 360 = 240 + 6*diff\n # 120 = 6*diff\n # 120 / 6 = diff\n \n # K: 60 + (K-1) * diffT / diffN = (60*diffN+(K-1)*diffT) / diffN\n \n diffT = total - N*A\n diffN = sum(range(1,N))\n r = (A*diffN+(K-1)*diffT)\n \n d = math.gcd(r, diffN)\n while d > 1:\n  r//=d\n  diffN//=d\n  d = math.gcd(r, diffN)\n print(r, diffN)\n", "t=int(input())\nfor i in range(t):\n N=int(input())\n L=[0]*N\n if N%2==1:\n  print(\"YES\")\n  for i in range(0,N):\n   for k in range(1,int((N+1)/2)):\n    L[(i+k)%N]=1\n   for m in L:\n    print(m,sep=\"\",end=\"\")\n   print(\"\")\n   L=[0]*N\n else:\n  print(\"NO\")\n\n\n\n\n", "def f(n):\n\n s = list(map(int, input().split()))\n low = []\n high = []\n\n for i in range(n - 1):\n  low.append(min(s[i], s[i+1]))\n  high.append(max(s[i], s[i+1]))\n low.sort()\n high.sort()\n curr = mx = 0\n i = j = 0\n n -= 1\n while i < n and j < n:\n  if low[i] < high[j]:\n   i += 1\n   curr += 1\n  else:\n   j += 1\n   curr -= 1\n  mx = max(mx, curr)\n\n return mx \n \nn = int(input())\nprint(f(n))", "for t in range(int(input())):\n m=int(input())\n n=int(input())\n o=int(input())\n if m==1 and (n==1 and o==1):\n  print(0)\n else:\n  print((m+n+o-6)*4)", "#Pattern E\r\nT = int(input())\r\n\r\nfor t in range(T):\r\n    N = int(input())\r\n    \r\n    for i in range(N):\r\n        sol = \"\"\r\n        for j in range(1,N+1):\r\n            if((j+i)%N == 0):\r\n                sol+=str(N)\r\n            else:\r\n                sol+=str((j+i)%N)\r\n        print(sol)", "t=eval(input())\nfor x in range(0,t):\n arr=list(input())\n sum=0\n for i in arr:\n  if(i.isdigit()):\n   sum+=int(i)\n print(sum)", "try:\n t=int(input())\n if 1<=t<=300:\n  for T in range(t):\n   n=int(input())\n   a=list(map(int,input().split()))\n   a.sort(reverse=True)\n   to_add=a[0]\n   f=0\n   for i in range(1,n):\n    to_add=to_add|a[i]\n    if to_add in a:\n     f=1\n     break\n    a.append(to_add)\n   if f==1:\n    print(\"NO\")\n   else:\n    print(\"YES\")\nexcept:\n pass\n\n", "n= int(input())\ns1=''\nfor _ in range(n):\n    s=input()\n    s1=s1+s\ns1=s1.lower()\ns1=s1.replace('.','').replace(',','').replace(\"'\",\"\").replace(':','').replace(';','')\na=set(s1.split())\nb=list(a)\nb.sort()\nprint(len(b))\nfor i in b:\n    print(i)\n", "# cook your dish here\nt=int(input())\nMOD=1000000007\ndef mod(n, m=MOD):\n n%=m\n while n<0: n+=m\n return n\n\ndef power(n, p):\n res=1\n while p:\n  if p%2: res=mod(res*n)\n  p//=2\n  n=mod(n*n)\n return res\n\nwhile t:\n ma=input().split()\n x=int(ma[0])\n y=int(ma[1])\n s=int(ma[2])\n ma=input().split()\n u=int(ma[0])\n v=int(ma[1])\n if s%x==0 and ((s // x) & ((s // x) - 1) == 0):\n  inv=power(u, MOD-2)\n  print(mod(mod(mod(s//x)*v)*inv))\n else:\n  inv=power(v-u, MOD-2)\n  print(mod(mod(mod(s//y)*v)*inv))\n t-=1\n", "test=int(input())\n#def solve():\n    \n'''hile test:\n    solve()\n    test-=1 '''\ncount=0\ns=input()\nfor i in range(test-1):\n    if s[i+1]==s[i]:\n        count+=1 \nprint(count)\n", "for cas in range(eval(input())):\n n, sx, sy, ex, ey, bx, by = list(map(int, input().strip().split()))\n print(abs(sx - ex) + abs(sy - ey) + 2 * ((sx == ex or sy == ey)\n  and min(sx, ex) <= bx <= max(sx, ex)\n  and min(sy, ey) <= by <= max(sy, ey)\n ))", "#\n\n#for _ in range(int(input())):\nn,m,x = list(map(int,input().split()))\narr = [[0 for i in range(m)] for j in range(n)]\ndpr = [0]*n \ndpc = [0]*m\nfor i in range(x):\n    a,b=list(map(int,input().split()))\n    arr[a][b]=1\n    dpr[a]+=1 \n    dpc[b]+=1\n#print(dpr,dpc)\nmax=-1\nfor i in range(n):\n    for j in range(m):\n        sum=dpr[i]+dpc[j]\n        #print(i,j,sum)\n        if arr[i][j]==1:\n            sum-=1\n        if sum>max:\n            max=sum\n        if max==x:\n            break\nprint(max)\n\n        \n", "# cook your dish here\nt=int(input())\nfor i in range (0,t):\n    a=list(map(int,input().split()))\n    print(max(a),sum(a))\n", "from math import sqrt\nr = int(input())\ncnt=0\nrt=[]\nfor i in range(1,16*r):\n for j in range(i, 460):\n  for k in range(j+1, j+i):\n   #print i,j,k\n   s = float((i+j+k))/2\n   #print s,i,j,k,s*(s-i)*(s-j)*(s-k)\n   area = sqrt(abs(s*(s-i)*(s-j)*(s-k)))\n   #print(float(2*area))/(i+j+k)\n   if (r==(float(2*area))/(i+j+k)):\n    cnt+=1\n    #print i,j,k,area\n    rt.append([i,j,k])\n    \nprint(cnt)\n\nfor i in rt:\n for j in i:\n  print(j, end=' ')\n print()\n", "from collections import Counter\r\nT=int(input())\r\nfor i in range(T):\r\n    NM=[]\r\n    A=[]\r\n    z=0\r\n    N=int(input())\r\n    for j in range(N):\r\n        nm,a=input().split()\r\n        NM.append(nm)\r\n        A.append(int(a))\r\n    D=Counter(A)\r\n    K=sorted(D.keys())\r\n    for k in K:\r\n        if D[k]==1:\r\n            z=k\r\n            break\r\n        else:\r\n            pass\r\n    if z==0:\r\n        print(\"Nobody wins.\")\r\n    else:\r\n        print(NM[A.index(z)])", "t=int(input())\nfor _ in range(t):\n    l=list(map(int,input().strip().split()))\n    l.insert(0,0)\n    c,n,a=0,0,0\n    for i in range(1,len(l)):\n        if l[i]>=30:\n            c+=1\n        if l[i]%2==0:\n            a+=l[i]*i\n            n+=i\n    x=a/n        \n    print(c,\"{:.2f}\".format(x))        \n\n", "# cook your dish here\nfrom sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nimport bisect\nimport heapq as hq\n\n\ndef L():\n return list(map(int, stdin.readline().split()))\n\n\ndef In():\n return list(map(int, stdin.readline().split()))\n\n\ndef I():\n return int(stdin.readline())\n\n\nP = 1000000007\n\n\ndef main():\n try:\n  for _ in range(I()):\n   # code here ALL THE BEST\n   l=L()\n   l.sort()\n   if (l[0]+l[1]>=l[2]):\n    print('Yes')\n   else:\n    print('No')\n\n\n except:\n  pass\n\n\ndef __starting_point():\n main()\n\n__starting_point()", "t = eval(input())\nli =[0] * 100001\nli[1] = 1\nfor j in range(2,100001):\n li[j] = (li[j-1]*j)%1589540031\nfor x in range(t):\n n = eval(input())\n print(li[n])\n", "# cook your dish here\n\nT = int(input())\n\nfor _ in range(T):\n n = int(input())\n s = 0\n temp = []\n for _ in range(n):\n  l = list(map(int, input().split()))\n  if l[0]%2 == 0:\n   s += sum(l[1:len(l)//2+1])\n  else:\n   s += sum(l[1:len(l)//2])\n   temp.append(l[len(l)//2])\n temp.sort(reverse= True)\n s += sum(temp[::2])\n  \n print(s)\n", "# cook your dish here\ndef notes(a):\n  Q = [ 100, 50, 10,5,2,1]\n  x ,b= 0,0\n  for i in Q:\n    b=a//i\n    x += b\n    a = a-i*b\n  return x\nn=int(input())\nfor i in range(n):\n    m=int(input())\n    print(notes(m))", "def evaluate(a, b):\n\tans = ''\n\tfor i in range(0, len(a)):\n\t\tif a[i] == b[i]:\n\t\t\tans += '-'\n\t\telse:\n\t\t\tans += '+'\n\treturn ans\n\ndef dp(p_bar, n, s):\n\tmod = 10**7 + 9\n\tif n == 0:\n\t\treturn 0\n\telif n == 1:\n\t\tk = 0\n\t\tif p_bar == s[0]:\n\t\t\tk += 1\n\t\tif p_bar == \"----------\":\n\t\t\tk += 1\n\t\treturn k\n\telse:\n\t\treturn (dp(p_bar, n-1, s)%mod + dp(evaluate(p_bar, s[n-1]), n-1, s))%mod\n\n\nt = int(input())\n\nfor i in range(0, t):\n\tp = input()\n\tn = int(input())\n\ts = []\n\tfor j in range(0, n):\n\t\ttemp = input()\n\t\ts.append(temp)\n\tp_bar = ''\n\tfor j in p:\n\t\tif j == 'w':\n\t\t\tp_bar += '+'\n\t\telse:\n\t\t\tp_bar += '-'\n\tprint(dp(p_bar, n, s))", "import math\nd=10**8\ne=[0]\np=1\nwhile p<d:\n  p*=2\n  e.append(p-1)\ne=e[::-1]\nfor _ in range(int(input())):\n  li=list(map(int,input().split()))\n  ans1=0\n  n1=li[0]+1\n  ans2=0\n  n2=li[1]+1\n  for i in e:\n    if (n1-i-1)>=0:\n      n1-=i\n      n1-=1\n      ans1+=1\n  ans1+=n1\n  for i in e:\n    if (n2-i-1)>=0:\n      n2-=i\n      n2-=1\n      ans2+=1\n  ans2+=n1\n  if(ans1==ans2):\n    print(0,0)\n  elif ans1>ans2:\n    print(2,ans1-ans2)\n  else:\n    print(1,ans2-ans1)\n  \n\n  \n", "T = int(input())\nimport math\nfor i in range(T):\n list = []\n A,M = input().split()\n A = int(A)\n M = int(M)\n L1 = M//A\n L2 = math.ceil(M/(A+1))\n while L2 <= L1 :\n  N = L2\n  if M - N*A !=0 and N%(M - N*A) == 0 :\n   list.append(L2)\n  L2 += 1\n\n print(len(list))\n if len(list) > 0:\n  for j in range(len(list)-1):\n   print(list[j],end=\" \")\n  print(list[len(list)-1])\n else:\n  print(\" \")\n", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n n=int(input())\n d={}\n for j in range(n):\n  x,p,m=map(str,input().split())\n  if((x,p) not in d):\n   d[(x,p)]=int(m)\n lst=d.values()\n s=sum(lst)\n avg=s/n\n count=0\n \n d=sorted(d.items())\n for i in range(n):\n  if(d[i][1]<avg):\n   count=1\n   print(d[i][0][0],d[i][0][1],d[i][1])\n if(count==0):\n  print('\\n')", "'''input\n1\n3\n1 2\n1 3\n1 2 3\n'''\nimport sys\nsys.setrecursionlimit(1000000)\nfor _ in range(eval(input())):\n C=[]\n n=eval(input())\n for i in range(n):\n  C.append([])\n for i in range(n-1):\n  a,b=[int(x)-1 for x in input().split()]\n  C[a].append(b)\n  C[b].append(a)\n cnt=0\n Co=[bin(int(x)).count(\"1\") for x in input().split()]\n Q=[0]*(n+100)\n cur=0\n done=[0]*n\n done[0]=1\n H=[0]*n\n for i in range(n):\n  r=Q[i]\n  if H[r]&1 == Co[r]&1:\n   cnt+=1\n  for i in C[r]:\n   if done[i]==0:\n    done[i]=1\n    Q[cur+1]=i\n    cur+=1\n    H[i]=H[r]+1\n #dfs(0,-1)\n print(cnt*(n-cnt))\n\n", "t=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    arr=list(map(int,input().split()))\r\n    d={}\r\n    for i in range(n):\r\n        if arr[i] in d:\r\n            d[arr[i]].append(i)\r\n        else:\r\n            d[arr[i]]=[i]\r\n    q=int(input())\r\n    for i in range(q):\r\n        m=int(input())\r\n        if len(d[m])==1:\r\n            print(n)\r\n        elif len(d[m])==2:\r\n            print(min((d[m][1]-d[m][0]),((n-d[m][1])+d[m][0])))\r\n        else:\r\n            k=100000\r\n            for j in range(len(d[m])-1):\r\n                if (d[m][j+1]-d[m][j])<k:\r\n                    k=d[m][j+1]-d[m][j]\r\n                else:\r\n                    pass\r\n            print(min(k,((n-d[m][len(d[m])-1])+d[m][0])))\r\n            \r\n                \r\n", "# cook your dish here\nts=int(input())\nwhile ts>0:\n num,p=list(map(int,input().split()))\n aa=(num//2)+1\n if(num==1 or num==2):\n  print(p*p*p)\n else:\n  aa=num%aa\n  b=(p-aa)**2\n  c=(p-num)*(p-aa)\n  a=(p-num)*(p-num)\n  print(b+c+a)\n ts=ts-1\n\n", "n=int(input())\n\nd={}; D={}; ans=[]\n\nfor _ in range(n): s=input()+'/'; t=s.find('/',7); d.setdefault(s[:t],set()).add(s[t:])\n\nfor k in d: D.setdefault(frozenset(d[k]),[]).append(k)\n\n{ans.append(D[k]) for k in D if len(D[k])>1}\n\nprint(len(ans))\n\nprint('\\n'.join(map(' '.join,ans)))\n\n\n\n# Made By Mostafa_Khaled\n", "'''\nCreated on Oct 12, 2014\n\n@author: Ismael\n'''\n\n#import time\n\nMOD = 10**9+7\ndef sumTermsArith1(firstTerm,r,nbTerms):\n    return (nbTerms*(2*firstTerm+(nbTerms-1)*r))//2\n\ndef solve(a,b):\n    s = 0\n    for rem in range(1,b):\n        reason = rem*b\n        s = (s+sumTermsArith1(reason+rem,reason,a))%MOD\n    return s\n\ndef solve2(a,b):\n    reason = a*(b*(a+1)+2)//2\n    return sumTermsArith1(reason,reason,b-1)%MOD\n\n#t = time.clock()\na,b = list(map(int,input().split()))\n#sol1 = solve(a,b)\nsol2 = solve2(a,b)\nprint(sol2)\n#print(sol1 == sol2)\n#print(time.clock()-t)\n", "l,r  = map(int, input().split(\" \"))\nif l == r:\n    print (l)\nelse:\n    print (2)", "str1 = input()\nans = 0\nfor i,char1 in enumerate(str1):\n\tif char1 == 'A':\n\t\tcount1 = 0\n\t\tcount2 = 0\n\t\tfor j in range(i):\n\t\t\tif (str1[j] == 'Q'):\n\t\t\t\tcount1+= 1\n\t\tfor j in range(i+1, len(str1)):\n\t\t\tif (str1[j] == 'Q'):\n\t\t\t\tcount2+= 1\n\t\tans += count1*count2\nprint(ans)", "import numpy as np\n\n\ndef determinant(matrix):\n    return np.linalg.det(matrix).round()\n", "def sum_of_intervals(intervals):\n    s, top = 0, float(\"-inf\")\n    for a,b in sorted(intervals):\n        if top < a: top    = a\n        if top < b: s, top = s+b-top, b\n    return s", "subsets_parity=lambda n,k:~n&k and\"EVEN\"or\"ODD\"", "def solution(string,markers):\n    lst = string.split('\\n')\n    ans = []\n    for line in lst:\n        for m in markers:\n            if m in line:\n                line = line[: line.find(m)].strip()\n        ans.append(line) \n    return '\\n'.join(ans)", "def who_is_winner(moves):\n    G = {(c, r):' ' for r in range(6) for c in range(7)}\n\n    for col, colour in [(ord(m[0]) - ord('A'), m[2]) for m in moves]:\n        for row in range(6):\n            if G[(col, row)] == ' ':\n                G[(col,row)] = colour\n                break\n        if colour*4 in ' '.join([''.join(G[(col, k)] for k in range(6)),\n                                 ''.join(G[(k, row)] for k in range(7)),\n                                 ''.join(G.get((k, row - col + k), ' ') for k in range(7)),\n                                 ''.join(G.get((k, row + col - k), ' ') for k in range(7))]): return {'Y':'Yellow', 'R':'Red'}[colour]\n    return 'Draw'        ", "def longest_slide_down(pyr):\n    for row in range(len(pyr)-1, 0, -1):\n        for col in range(0, row):\n            pyr[row-1][col] += max(pyr[row][col], pyr[row][col+1])\n    return pyr[0][0]", "def parse_int(string):\n    \n    print(string)\n    \n    setDigit = {\"zero\"      :0,\n                \"one\"       :1,\n                \"two\"       :2,\n                \"three\"     :3,\n                \"four\"      :4,\n                \"five\"      :5,\n                \"six\"       :6,\n                \"seven\"     :7,\n                \"eight\"     :8,\n                \"nine\"      :9,\n                \"ten\"       :10,\n                \"eleven\"    :11,\n                \"twelve\"    :12,\n                \"thirteen\"  :13,\n                \"fourteen\"  :14,\n                \"fifteen\"   :15,\n                \"sixteen\"   :16,\n                \"seventeen\" :17,\n                \"eighteen\"  :18,\n                \"nineteen\"  :19,\n                \"twenty\"    :20,\n                \"thirty\"    :30,\n                \"forty\"     :40,\n                \"fifty\"     :50,\n                \"sixty\"     :60,\n                \"seventy\"   :70,\n                \"eighty\"    :80,\n                \"ninety\"    :90,\n                }\n     \n     \n    millionNumber, thousandNumber, hundredNumber, number = (0,) * 4\n       \n    for word in string.split():\n        for newWord in word.split('-'):     \n            \n            try:\n                digit = setDigit[newWord]\n                number += digit\n            except:\n                \n                if newWord == \"hundred\":\n                    hundredNumber = number\n                    number = 0\n                    \n                if newWord == \"thousand\":\n                    thousandNumber = 100 * hundredNumber + number\n                    hundredNumber = 0\n                    number = 0\n                    \n                if newWord == \"million\":\n                    millionNumber = number\n                    number = 0\n          \n    return(millionNumber * 1000000 + thousandNumber * 1000 + hundredNumber * 100 + number)\n        \n", "def differentiate(eq, point):\n    eq = eq.replace('-', ' -').strip()\n    eq = eq.replace('+', ' +').strip()\n    eq = eq.replace('-x', '-1x')\n    eq = eq.replace('+x', '+1x')\n    eq = eq.split(' ')\n\n    eq = [i if i[0].isalpha() == False else \"1\"+i for i in eq]\n    \n    if \"x\" not in eq[-1]: eq.pop(-1)\n    for i in range(len(eq)):\n        if eq[i][-1] == \"x\":\n            eq[i] = eq[i][:-1] + \"x^1\"\n        j = int(eq[i][-1])\n        eq[i] = int(eq[i][:-3]) * j * (point ** (j-1))\n\n    return sum(eq)", "def n_linear(m,n):\n    arr = [1]\n    indices = [0] * len(m)\n    r = range(len(m))\n    count = 0\n    while count < n:\n        x = min([arr[indices[i]] * m[i] for i in r])\n        for i in r:\n            if x == arr[indices[i]] * m[i]:\n                indices[i] += 1\n        arr.append(x + 1)\n        count += 1\n        \n    return arr[-1]", "def count_change(money, coins):\n    if money<0:\n        return 0\n    if money == 0:\n        return 1\n    if money>0 and not coins:\n        return 0\n    return count_change(money-coins[-1],coins) + count_change(money,coins[:-1])", "r,p=lambda n:int(str(n)[::-1]),lambda n:pow(2,n,n)==2\nsq_cub_rev_prime=([0]+[n for n in range(2,10**5)if p(r(n**2))*p(r(n**3))]).__getitem__", "def solve(k): \n    k -= 1\n    i, d, p, n, s = 0, 1, 0, 9, 45\n    while i + s <= k:\n        i += s\n        p += n * d\n        d += 1\n        n = 10 ** d - 10 ** (d - 1)\n        s = n * p + n * d * (n + 1) // 2\n    k -= i\n    i = int((((2 * p + d) ** 2 + 8 * k * d) ** 0.5 - (2 * p + d)) / (2 * d))\n    k -= i * p + i * d * (i + 1) // 2\n    i, d, s = 0, 1, 9\n    while i + s <= k:\n        i += s\n        d += 1\n        n = 10 ** d - 10 ** (d - 1)\n        s = n * d\n    q, r = divmod(k - i, d)\n    return int(str(10 ** (d - 1) + q)[r])", "def proper_fractions(n):\n    phi = n > 1 and n\n    for p in range(2, int(n ** 0.5) + 1):\n        if not n % p:\n            phi -= phi // p\n            while not n % p:\n                n //= p\n    if n > 1: phi -= phi // n\n    return phi", "from collections import Counter\n\ndef exchange_sort(sequence):\n    \"\"\"Greedy algorithm based on permutation cycle decomposition:\n    1. Search for transposition placing TWO elements correctly.\n    2. Search iteratively for transposition placing ONE elements correctly.\"\"\"\n    swaps, cnt = 0, Counter()\n    for a, b in zip(sequence, sorted(sequence)):\n        if cnt[b,a] > 0:\n            cnt[b,a] -= 1\n            swaps += 1\n        elif a != b:\n            cnt[a,b] += 1\n    # Special case: as there are only three keys at most,\n    # all remaining cycles will be 3-length cycles that\n    # need 2 transpositions to place 3 elements correctly.\n    return swaps + sum(cnt.values()) // 3 * 2", "import math\ndef survivor(zombies):\n    size = len(zombies)\n    if size == 0:\n        return -1\n    if (1 in zombies):\n        return 0\n\n    gcd = zombies[0]\n    for i in range(len(zombies) - 1):\n        gcd = math.gcd(gcd, zombies[1 + i])\n    if gcd != 1:\n        return -1\n\n    maxSize = (zombies[0] * zombies[1]) - zombies[0] - zombies[1]\n    posible = [False for _ in range(maxSize + 1)]\n    posible[0] = True\n\n\n    for zombie in zombies:\n        if zombie <= maxSize:\n            for i in range(zombie, maxSize + 1):\n                if not posible[i]:\n                    posible[i] = posible[i - zombie]\n    largest = 0\n    for i in range(maxSize + 1):\n        if not posible[i]:\n            largest = i\n    return largest", "def snail(array):\n    ret = []\n    if array and array[0]:\n        size = len(array)\n        for n in range((size + 1) // 2):\n            for x in range(n, size - n):\n                ret.append(array[n][x])\n            for y in range(1 + n, size - n):\n                ret.append(array[y][-1 - n])\n            for x in range(2 + n, size - n + 1):\n                ret.append(array[-1 - n][-x])\n            for y in range(2 + n, size - n):\n                ret.append(array[-y][n])\n    return ret\n", "def countOnes(left, right):\n    def f(n):\n        c = 0\n        a = list(reversed(list(bin(n))))\n        for i, d in enumerate(a):\n            if d == '1':\n                c += 1 + 2**i*i/2 + 2**i*a[i+1:].count('1')\n        return c\n    return f(right) - f(left-1)\n", "def middle_permutation(s):\n    s = ''.join(sorted(s))\n    return s[len(s)//2-1:(len(s)+1)//2][::-1] + s[(len(s)+1)//2:][::-1] + s[:len(s)//2-1][::-1]", "def productsum(n):\n    if n < 12:\n        kmax = n+1\n    else:\n        kmax = n\n    \n    def prodsum(p, s, nf, start):\n        k = p - s + nf     #product - sum + number of factors\n        if k < kmax:\n            if p < n[k]:\n                n[k] = p\n            for i in range(start, kmax//p*2 + 1):\n                prodsum(p*i, s+i, nf+1, i)\n    if kmax > 12: kmax +=1\n    n = [2*kmax] * kmax\n    \n    prodsum(1, 1, 1, 2)\n    \n    return sum(set(n[2:]))", "def modi(s):\n    return ''.join(['#'+i for i in s]) + '#'\n\ndef demodi(s):\n    return ''.join(([i for i in s if i != '#']))\n\ndef longest_palindrome(s):\n    s = modi(s)\n    lenth, c, r, maxl, p = len(s), 0, 0, 0, [0]*len(s)\n\n    for i in range(lenth):\n        mir = (2*c) - i\n\n        if i<r: \n            p[i] = min(r-i, p[mir])\n\n        a, b = i + (1+p[i]), i - (1+p[i])\n        while a < lenth and b >= 0 and s[a] == s[b]:\n            p[i] += 1\n            a += 1\n            b -= 1\n\n        if (i + p[i]) > r: \n            c = i\n            r = i + p[i]\n\n            if p[i] > maxl: \n                maxl = p[i]\n    mai = p.index(maxl)\n    return demodi(s[mai-maxl: mai+maxl+1])", "from scipy.special import comb\nfrom collections import Counter\n\ndef factorize_exponents(n):\n    result = Counter()\n    while n % 2 == 0:\n        result[2] += 1\n        n //= 2\n    k = 3\n    m = int(n ** 0.5)\n    while k <= m:\n        if n % k == 0:\n            result[k] += 1\n            n //= k\n            m = int(n ** 0.5)\n        else:\n            k += 2\n    if n > 1:\n        result[n] += 1\n    return list(result.values())\n\ndef multiply(n, k):\n    factorized = factorize_exponents(n)\n    total = 1\n    for exp in factorized:\n        total *= comb(exp + k - 1, k - 1, exact=True)\n    return total\n", "R = lambda a,b: range(a,b)\n\ndef almost_everywhere_zero(S, k):\n    S = [int(c) for c in str(S)]\n    D,n = {},len(S)\n  \n    def F(i, k, L):\n        if i==n: return k==0\n        if k==0: return F(i+1,k,L)\n        if (i,k,L) in D: return D[(i,k,L)]\n\n        if i==0 or L: D[(i,k,L)] = sum(F(i+1, k-(j>0), j==S[i]) for j in R(0,S[i]+1))\n        else: D[(i,k,L)] = sum(F(i+1, k-(j>0), 0) for j in R(0,10))\n\n        return D[(i,k,L)]\n    return F(0, k, 0)", "# yet another rewrite of Joachim Henke's C# implementation\n\nENCODE = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\\\"\")\nDECODE = dict(map(reversed, enumerate(ENCODE)))\n\ndef b91encode(s):\n    b, i = 0, 0\n    r = \"\"\n\n    for c in s:\n        b |= ord(c) << i\n        i += 8\n        if i > 13:\n            v = b & 0x1FFF\n            k = 13\n            if v < 89:\n                v = b & 0x3FFF\n                k += 1\n            b >>= k\n            i -= k\n            r += ENCODE[v % 91] + ENCODE[v // 91]\n    if i:\n        r += ENCODE[b % 91]\n        if i > 7 or b > 90: r += ENCODE[b // 91]\n\n    return r\n\ndef b91decode(s):\n    v, b, i = -1, 0, 0\n    r = \"\"\n\n    for c in s:\n        c = DECODE[c]\n        if ~v:\n            v += c * 91\n            b |= v << i\n            i += 13 + (v & 0x1FFF < 89)\n            while 1:\n                r += chr(b & 0xFF)\n                b >>= 8\n                i -= 8\n                if i < 8: break\n            v = -1\n        else: v = c\n    if ~v: r += chr((b | v << i) & 0xFF)\n\n    return r", "def sum_of_squares(n):\n    # three-square theorem\n    if n**0.5 == int(n**0.5):\n        return 1\n    while n % 4 == 0:\n        n >>= 2\n    if (n -7) % 8 ==0:\n        return 4\n    for s in range(1,int(n**0.5)+1):\n        if (n - s*s)**0.5 == int((n - s*s)**0.5):\n            return 2\n    return 3", "def green(n):\n    vec = [1, 5, 6]\n    m1 = 5\n    m2 = 6\n    tot = 3\n    h = 0\n    while tot < n:\n        s1 = str(m1)\n        s2 = str(m2)\n        m1 = morph(m1)\n        m2 = morph(m2)\n        (tot, vec, h) = recover(str(m1), s1, str(m2), s2, vec, tot, h)\n    vec.sort()\n    return vec[n - 1]\n\n\ndef recover(p, s, r, q, vec, tot, h):\n    d = len(p) - len(s)\n    d2 = len(r) - len(q)\n    for i in range(0, d):\n        if p[d - 1 - i] != '0':\n            vec.append(int(p[d - 1 - i: d] + s))\n            tot += 1\n        if r[d2 - 1 - i + h] != '0':\n            vec.append(int(r[d2 - 1 - i + h: d2 + h] + q[h:]))\n            tot += 1\n    return tot, vec, len(r) - len(p)\n\n\ndef morph(m):\n    return (3 * m * m - 2 * m * m * m) % 10 ** (2 * len(str(m)))", "def next_bigger(n):\n    if str(n) == ''.join(sorted(str(n))[::-1]):\n        return -1\n    a = n\n    while True:\n        a += 1\n        if sorted(str(a)) == sorted(str(n)):\n            return a", "def spinning_rings(inner_max, outer_max):\n    \n    i = inner_max+1\n    j = outer_max+1\n    \n    x = 1\n    while x < i*j:\n        a = -x % i\n        b = x % j\n        if a == b:\n            return x\n        elif a > b: \n            if a > j:\n                x += a-j\n            else:                \n                x+= max((a-b)//2,1)\n        elif b > a:\n            if b > i:\n                x+= j-b\n            else:\n                x+= max(min(j-b,a),1)", "def ways(t, n, d):\n    return [e for l in [[int(str(i)+str(e)) for e in ways(t-i, n-1, [k for k in d if k>= i])] for i in d] for e in l] if n > 1 else [t] if t in d else []\n\ndef find_all(target, n):\n    r = ways(target, n, [1,2,3,4,5,6,7,8,9])\n    return [len(r), min(r), max(r)] if r else []", "def solution(args):\n    result = \"\"\n    i = 0\n    while i<len(args):\n        val = args[i]\n        while i+1<len(args) and args[i]+1==args[i+1]:\n            i+=1\n        if val == args[i]:\n            result += \",%s\"%val\n        elif val+1 == args[i]:\n            result += \",%s,%s\"%(val, args[i])\n        else:\n            result += \",%s-%s\"%(val, args[i])\n        i+=1\n    return result.lstrip(\",\")", "times = [(\"year\", 365 * 24 * 60 * 60), \n         (\"day\", 24 * 60 * 60),\n         (\"hour\", 60 * 60),\n         (\"minute\", 60),\n         (\"second\", 1)]\n\ndef format_duration(seconds):\n\n    if not seconds:\n        return \"now\"\n\n    chunks = []\n    for name, secs in times:\n        qty = seconds // secs\n        if qty:\n            if qty > 1:\n                name += \"s\"\n            chunks.append(str(qty) + \" \" + name)\n\n        seconds = seconds % secs\n\n    return ', '.join(chunks[:-1]) + ' and ' + chunks[-1] if len(chunks) > 1 else chunks[0]\n", "def fibfusc(n, num_digits=None):\n    m = 10 ** num_digits if num_digits is not None else None\n    x, y = 1, 0\n    for i in reversed(range(n.bit_length())):\n        if n & 1 << i == 0:\n            x, y = ((x + y) * (x - y), y * (2*x + 3*y))\n        else:\n            x, y = (-y * (2*x + 3*y), (x + 2*y) * (x + 4*y))\n        if m is not None:\n            x %= m\n            y %= m\n    if m is not None and n >= 2:\n        x -= m\n    return x, y", "import re\n\n\ndef solve_runes(runes):\n    runes = runes.replace('=', '==')\n    s = bool(re.search(r'\\b0\\d', runes.replace('?', '0')))\n    for d in map(str, range(s, 10)):\n        if d not in runes and eval(runes.replace('?', d)):\n            return int(d)\n    return -1", "def count_subsequences(needle, haystack):\n    count = [1] + [0] * len(needle)\n    for a in haystack:\n        count = [1] + [count[i] + count[i-1] * (a == b)\n                       for i, b in enumerate(needle, 1)]\n    return count[-1] % 10 ** 8", "def string_func(s, n):\n    l, s = [s], list(s)\n    while True:\n        s[::2], s[1::2] = s[:len(s)//2-1:-1], s[:len(s)//2]\n        l.append(''.join(s))\n        if l[0] == l[-1]: del l[-1]; break\n    return l[n % len(l)]", "from fractions import Fraction, gcd\nfrom math import floor\ndef float_to_rat(x):\n    def is_int(x):\n        return x == floor(x)\n    d = 1\n    while not is_int(x):\n        x *= 10\n        d *= 10\n    x = int(x);\n    g = gcd(x, d)\n    return [x // g, d // g]\ndef expand(x, digit):\n    [a, b] = float_to_rat(x)\n    x = Fraction(a, b)\n    res = Fraction(1)\n    new = Fraction(1)\n    exponent = 0\n    while len(str(res.numerator)) < digit:\n        exponent += 1\n        new *= x / exponent\n        res += new\n    return [res.numerator, res.denominator]", "limit = 300\np = [1]+[0]*limit\nfor i in range(1,limit+1):\n  for k,l in enumerate(range(i,limit+1)):\n    p[l]+=p[k]\nexp_sum=lambda n:p[n]", "from collections import defaultdict\nimport re\ndef simplify(poly):\n    terms = defaultdict(lambda: 0)\n    for a, b, c in re.findall(r'([+-]?)(\\d*?)([a-z]+)', poly):\n        terms[''.join(sorted(c))] += eval(a + (b or '1'))\n    return (\n        re.sub\n        (\n            r'((?<=[-+])|\\b)1(?=[a-z])|((?:[-+])|\\b)0(?:[a-z]+)|\\+(?=-)',\n            '',\n            '+'.join([f'{terms[x]}{x}' for x in sorted(list(terms.keys()), key = lambda x: (len(x), x))])\n        )\n    )\n", "from collections import deque\n\n\ndef tree_by_levels(node):\n    q, result = deque(), []\n    if node is not None:\n        q.append(node)\n    while len(q):\n        node = q.popleft()\n        result.append(node.value)\n        q.extend(i for i in (node.left, node.right) if i is not None)\n    return result\n", "def count_divisors(n):\n    return 2 * sum(n//k for k in range(int(n ** 0.5), 0, -1)) - int(n ** 0.5) ** 2", "def make_hash(nest):\n    if isinstance(nest, list):\n        elems = ''\n        for elem in nest:\n            elems += make_hash(elem)\n        return '[' + elems + ']'\n    else:\n        return '*'\n\ndef same_structure_as(original,other):\n    if make_hash(original) == make_hash(other):\n        return True\n    else:\n        return False", "def gcd(x, y):\n    if x < y:\n        x, y = y, x\n    while y:\n        x, y = y, x % y\n    return x\n\ndef solution(arr):\n    uniques = list(set(arr))\n    N = len(arr)\n    if N < 2 or len(uniques) == 1:\n        return arr[0] * N\n        \n    min_gcd = gcd(uniques[0], uniques[1])\n    for i in range(2, len(uniques)):\n        if min_gcd == 1:\n            return N\n        cur = gcd(min_gcd, uniques[i])\n        min_gcd = min(cur, min_gcd)\n            \n    return min_gcd * N", "#\u5148\u786e\u5b9a\u8981\u6539\u53d8\u7684\u8303\u56f4\uff0c\u7136\u540e\u5728\u5bf9\u6307\u5b9a\u8303\u56f4\u8fdb\u884c\u6539\u52a8\n#itertools\u662f\u5f88\u597d\u7528\u7684\u5305\uff0c\u6ce8\u610f\u5b66\u4e60\nimport itertools\ndef next_smaller(n):\n    print(n)\n    a=list(str(n))\n    b=len(a)\n    if b==1:\n        return -1\n    for j in range(b-2,-1,-1):\n        if a[j] > a[j+1]:         \n            t=a[j:]\n            m=max([x for x in t if x<t[0]])\n            t.remove(m)\n            c=[]\n            while len(t)>0:\n                d=max(t)\n                c.append(d)\n                t.remove(d)\n            a[j:]=[m]+c\n            if a[0]=='0':\n                return -1\n            return int(''.join(a))\n    return -1\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = Counter(hand)\n        while c:\n            i = min(c)\n            for j in range(i, i + W):\n                if not c[j]:\n                    return False\n                c[j] -= 1\n                if not c[j]:\n                    del c[j]\n        return True", "t = int(input())\nwhile t:\n    n = int(input())\n    print(*[1] * n)\n    t -= 1\n", "lip = ['0.00', '6.00', '-3642.00', '-2557.17', '-1712.35', '-1077.55', '-622.76', '-318.00', '-133.27', '-38.59', 'MAGNA NIMIS!']\ns = []\nfor i in range(11):\n    s.append(int(input()))\ns.reverse()\n#print(s)\nfor i in range(0, 11):\n    a = s[i]**3*5\n    b = abs(s[i])**0.5\n    ans = a + b\n    print ('f(' + str(s[i]) + \") = \", end='')\n\n    if (ans < 400):\n        print('{:.2f}'.format(ans))\n    else:\n        print(' MAGNA NIMIS!')\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        N = len(arr)\n        \n        dp = [[0] * N for _ in range(N)]\n        \n        for i in range(N):\n            dp[N-1][i] = arr[N-1][i]\n        \n        for r in range(N-2, -1, -1):\n            for c in range(N):\n                min_c = float('inf')\n                for n_c in range(N):\n                    if n_c == c:\n                        continue\n                    min_c = min(min_c, arr[r+1][n_c])\n                dp[r][c] = min_c + arr[r][c]\n                arr[r][c] = dp[r][c]\n        \n        res = float('inf')\n        for i in range(N):\n            res = min(res, dp[0][i])\n        \n        return res", "import functools\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        for i in range(n-2, -1, -1):\n            piles[i] += piles[i+1] # suffix sum\n        \n        # \u5728\u4f4d\u7f6ei\uff0cM=m\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u524d\u9009\u624b\u83b7\u5f97\u7684\u6700\u5927\u5206\u6570\n        @lru_cache(None)\n        def dp(i, m):\n            if i+2*m >= n: return piles[i]\n            #                      \u5728\u5f53\u524dplayer\u9009\u62e9x\u4e0b\uff0c\u5bf9\u624b\u80fd\u5f97\u5230\u7684\u6700\u5927\u5206\u6570\n            # \u9009\u62e9\u4e86x\uff0c\u5c31\u662f\u7ed9\u5bf9\u65b9\u8bbe\u7f6e\u4e86M\n            # return piles[i] - min([dp(i+x, max(m,x)) for x in range(1, 2*m+1)])\n            # \u5199\u6210\u8fd9\u6837\u66f4\u6e05\u6670\n            res = 0\n            for x in range(1, 2*m+1):\n                res = max(res, piles[i] - dp(i+x, max(m,x)))\n            return res\n        return dp(0, 1)", "from bisect import *\r\nfrom collections import *\r\nfrom sys import stdin,stdout\r\nfrom queue import *\r\nfrom itertools import *\r\nfrom heapq import *\r\nfrom random import *\r\nfrom statistics import *\r\nfrom math import *\r\nimport operator\r\ninn=stdin.readline\r\nout=stdout.write\r\ndef fun(p1,p2):\r\n    return ((p2[0]-p1[0])**2+(p2[1]-p1[1])**2)**0.5\r\nfor i in range(int(input())):\r\n    input()\r\n    n=int(input())\r\n    a=[]\r\n    for i in range(n):\r\n        k,v=map(int,input().split())\r\n        a.append((k,v))\r\n    d=list(sorted(a,key=lambda x: [x[0],-x[1]]))\r\n    dis=0\r\n    for i in range(n-1):\r\n        dis+=fun(d[i],d[i+1])\r\n        t=d[i]\r\n    print(\"%.2f\"%(dis))\r\n            \r\n        ", "# -*- coding: utf-8 -*-\n\n\nxyz = [\n\t[-1, -1],\n\t[1, 1],\n\t[2, 9],\n\t[1, 2],\n\t[3, 10],\n\t[1, 4],\n\t[6, 9],\n\t[2, 1],\n\t[8, 10],\n\t[3, 1],\n\t[2, 7],\n\t[5, 6],\n\t[6, 1],\n\t[8, 6],\n\t[7, 1],\n\t[8, 5],\n\t[10, 1],\n\t[10, 3],\n\t[10, 5],\n\t[10, 7]\n]\n\ndim = [\n\t[-1, -1],\n\t[0, 0],\n\t[1, 0],\n\t[0, 0],\n\t[2, 0],\n\t[0, 0],\n\t[3, 0],\n\t[0, 0],\n\t[4, 0],\n\t[0, 0],\n\t[1, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[1, 0],\n\t[1, 0],\n\t[1, 0],\n\t[1, 0]\n]\n\nA, B, C = list(map(int, input().split()))\nprint('1', dim[A][0]+1, dim[A][1]+1, '2', 5+dim[B][0], 5+dim[B][1], '-1 '*3)\n# print '2', xyz[C][0], xyz[C][1], '3', xyz[B][0], xyz[B][1], '-1 '*3 \n", "# cook your dish here\ntry:\n    n,m = map(int,input().split())\n\n    l1 = list(map(int,input().split()))\n    l2 = list(map(int,input().split()))\n    \n    a = l1.index(min(l1))\n    b = l2.index(max(l2))\n     \n    for i in range(m):\n        print(a,i)\n        \n    for i in range(n):\n        if a!=i:\n            print(i,b)\n                    \nexcept:\n    pass", "\n#include<stdio.h>\nint reverse(int n)\n{\nint rev = 0, remainder;\nwhile (n != 0) {\nremainder = n % 10;\nrev = rev * 10 + remainder;\nn /= 10;\n}\nreturn rev;\n}\nint main()\n{\nint t;\nscanf(\"%d\",&t);\n \nwhile(t--)\n \n{\n \nint a,b,sum=0;\n \nscanf(\"%d %d\",&a,&b);\n \nsum=reverse(reverse(a)+reverse(b));\n \nprintf(\"%d\\n\",sum);\n \n}\n \n}", "for _ in range(int(input())):\n    x,y=map(int,input().split())\n    if(x==y):\n        if(x==1):\n            print(1)\n        else:\n            n=0\n            for i in range(x-1):\n                n=i\n                for _ in range(y):\n                    print(n,end=' ')\n                    n=(n+1)%x\n                print()  \n            for i in range(x):\n                print(i,end=' ')\n            print( )\n    else:\n        l=[]\n        n=min(x,y)\n        m=max(x,y)\n        for _ in range(n):\n            l.append([])\n        v=n+1\n        for i in range(n):\n            u=i\n            for j in range(m):\n                if(j<=n):\n                    l[i].append(u)\n                    u=(u+1)%(n+1)\n                else:\n                    if(j>=v):\n                        l[i].append(j+1)\n                    else:\n                        l[i].append(j)\n            v=v+1\n        if(x>y):\n            for i in range(x):\n                for j in l:\n                    print(j[i],end=' ')\n                print( )\n        else:\n            for i in l:\n                for j in i:\n                    print(j,end=' ')\n                print( )", "l=list(map(int,input()))\nt=-1\nx=-1\ny=-1\nfor i in range(len(l)):\n    s=l[i]\n    a=i+1\n    b=i+1\n    for j in range(i+1,len(l)):\n        if l[i]<l[j]:\n            s=s+l[j]\n            b=j+1\n        else:\n            break\n    if s>t:\n        t=s\n        x=a\n        y=b\nprint(t,end=\":\")\nprint(x,y,sep=\"-\")", "try:\n    for _ in range(int(input())):\n        n=int(input())\n        for i in range(1,n+1):\n            print(i,end=\" \")\n        print()\nexcept:\n    pass", "# cook your dish here\nimport math\n\nT = int(input())\n\ndef nb_bits(i, N):\n    nb = 0\n    for j in range(N):\n        mask = 1 << j\n        if i & mask == mask:\n            nb+=1\n    return nb\n            \n\nfor t in range(T):\n    N, K = map(int, input().strip().split(\" \"))\n    d = {}\n    for i in range(1, N+1):\n        d[i] = set()\n    for i in range(2**N):\n        nb = nb_bits(i, N)\n        if nb != 0:\n            d[nb].add(i)\n    \n    last = d[1].pop()\n    print(0, last)\n    should_not_be = 0\n    for i in range(K-2):\n        for j in range(1, N+1):\n            if len(d[j]) > 0 and j!=should_not_be:\n                n = d[j].pop()\n                break\n        print(last, n)\n        should_not_be = nb_bits(last, N)\n        last = n\n    print(last, 0)\n    ", "m=int(input())\nwhile m:\n    m-=1\n    n=int(input())\n    t=[i for i in input().split()]\n    print(''.join(t))", "import sys\nn,m,c=list(map(int,input().split()))\nli=[]\nmax=0\nfor i in range(1,51):\n       print(1,1,n,1,m,i,i)\n       sys.stdout.flush()\n       ans=int(input())\n       if ans>max:\n              max=ans\n              deal=i\n\nprint(3)          \nfor i in range(n):\n       print(\" \".join([str(deal)]*m))\n\n       \n       \n\n       \n\n\n       \n\n       \n", "n = 402\nprint (n)\nprint (0, 1000000)\nfor i in range(1, n-1):\n    print (i * 1000, n-i)\nprint (1000000, 1000000)", "def sampleVariance(V):\n    X = sum(V) / len(V)\n    S = 0.0\n    for x in V:\n        S += (X-x)**2\n\n    S /= (len(V)-1)\n    return (X, S)\n\n#That awkward moment when you realized that variance is sigma^2 but you just took the stat course this semester\nfor i in range(int(input())):\n    V = list(map(int, input().split()))\n    X, S = sampleVariance(V)\n    v1 = X\n    v2 = (2*X) ** 2 / 12\n\n    print(\"{}\".format(\"poisson\" if abs(v1-S) < abs(v2-S) else \"uniform\"))", "def sampleVariance(V):\n    X = sum(V) / len(V)\n    S = 0.0\n    for x in V:\n        S += (X-x)**2\n\n    S /= (len(V)-1)\n    return (X, S)\n\n#That awkward moment when you realized that variance is sigma^2 but you just took the stat course this semester\nfor i in range(int(input())):\n    V = list(map(int, input().split()))\n    X, S = sampleVariance(V)\n    v1 = X\n    v2 = (2*X) ** 2 / 12\n\n    if abs(v1-S) < abs(v2-S):\n        print(int(X))\n    else:\n        print(max(V)+min(V) // 2)", "print(2000)\nn = 1000\nfor i in range(1, n + 1):\n    print(i, 1, i, 2)\nfor i in range(n, 0, -1):\n    print(i, 1, i, 2)\n", "for i in range(int(input())):\n  a=list(map(int,input().split()))\n  mx=max(list(map(abs,a)))\n  std=(sum(list([x*x for x in a]))/len(a))**0.5\n  print('poisson'if mx/std>2 else'uniform')\n", "def dbl_linear(n):\n    x = 1\n    ys = []\n    zs = []\n\n    for i in range(n):\n        ys.append(2*x + 1)\n        zs.append(3*x + 1)\n        miny = ys[0]\n        minz = zs[0]\n        x = miny if miny < minz else minz\n        if x == miny: ys.pop(0)\n        if x == minz: zs.pop(0)\n\n    return x\n", "def doubles(k, n):\n    s = 0\n    for iK in range(1,min(k+1, 24)):\n        for iN in range(2, n+2):\n            s += 1/(iK*iN**(2*iK))\n    return s", "from itertools import chain\nimport math\n\nclass Sudoku(object):\n\n    def __init__(self, data):\n        self.grip = data\n        self.len = len(data)\n        self.valid = (self.len == 1 and data != [[1]]) or not all(( len(e) == self.len for e in data )) or all(type(x)!=int for e in data for x in e )\n        self.box = int(math.sqrt(self.len))\n    \n    def resp(self):\n        self.grip = list( zip( *[ list( zip( *[iter(e)]*self.box)) for e in self.grip][::-1] ))\n        return [list(chain(*list( zip( *[iter(e)]*self.box))[i]))  for e in self.grip for i in range(len(self.grip)//self.box)]\n                 \n    def is_valid(self): \n        return not self.valid and all(( len(set(e)) == self.len  for e in self.resp() ))", "class PokerHand(object):\n    CARD = \"23456789TJQKA\"\n    RESULT = [\"Loss\", \"Tie\", \"Win\"]\n\n    def __init__(self, hand):\n        values = ''.join(sorted(hand[::3], key=self.CARD.index))\n        suits = set(hand[1::3])\n        is_straight = values in self.CARD\n        is_flush = len(suits) == 1\n        self.score = (2 * sum(values.count(card) for card in values)\n                      + 13 * is_straight + 15 * is_flush,\n                      [self.CARD.index(card) for card in values[::-1]])\n        \n    def compare_with(self, other):\n        return self.RESULT[(self.score > other.score) - (self.score < other.score) + 1]", "def rectangle_rotation(a, b):\n    n1, n2 = map(lambda x: int((x/2) / 2**.5), [a,b])\n    m1, m2 = map(lambda x: int((x-2**.5)/2 / 2**.5 + 1), [a,b])\n    return (2*n1+1)*(2*n2+1) + 4*m1*m2", "class MemoryManager:\n    def __init__(self, memory):\n        self.memory = [None] * len(memory)\n        self.disk = memory\n\n    def allocate(self, size):\n      previous = 0\n      for i in range(len(self.memory)):\n        if self.memory[i] == None:\n          previous += 1\n        else:\n          previous = 0\n        if previous == size:\n          start_index = i +1 - size \n          for x in range(start_index, i + 1):\n            self.memory[x] = start_index\n          return start_index\n      raise Exception('No space available')\n\n    \n    def release(self, pointer):\n      if pointer not in self.memory:\n        raise Exception('pointer not in memory')\n      for i in range(len(self.memory)):\n        if self.memory[i] == pointer:\n           self.memory[i] = None\n\n    def read(self, pointer):\n        if self.memory[pointer] == None:\n          raise Exception('No space alocated')\n        return self.disk[pointer]\n    def write(self, pointer, value):\n      if self.memory[pointer] == None:\n        raise Exception('No space alocated')\n      self.disk[pointer] = value", "\ndef factors(n):\n    gaps = [1,2,2,4,2,4,2,4,6,2,6]\n    length, cycle = 11, 3\n    f, fs, nxt = 2, [], 0\n    while f * f <= n:\n        while n % f == 0:\n            fs.append(f)\n            n /= f\n        f += gaps[nxt]\n        nxt += 1\n        if nxt == length:\n            nxt = cycle\n    if n > 1: fs.append(n)\n    return fs\n\ndef sum_for_list(lst):\n    d={}\n    fList=[]\n    \n    for i in lst:\n        f=factors(abs(i))\n        f=list(set(f))\n        if(i<0):\n            print((i,f))\n        for n in f:\n            if n in d:\n                d[n].append(i)\n            else:\n                d[n]=[i]\n    r=[]\n    for i in sorted(d):\n        r.append([int(i),sum(d[i])])\n    \n    return r\n", "import sys\n\ndef count_calls(func, *args, **kwargs):\n    \"\"\"Count calls in function func\"\"\"\n\n    calls = [ -1 ]\n    def tracer(frame, event, arg):\n        if event == 'call':\n            calls[0] += 1\n        return tracer\n    sys.settrace(tracer)\n  \n    rv = func(*args, **kwargs)\n  \n    return calls[0], rv\n", "def hull_method(points):\n    \"\"\"Computes the convex hull of a set of 2D points.\n\n    Input: an iterable sequence of (x, y) pairs representing the points.\n    Output: a list of vertices of the convex hull in counter-clockwise order,\n      starting from the vertex with the lexicographically smallest coordinates.\n    Implements Andrew's monotone chain algorithm. O(n log n) complexity.\n    \"\"\"\n\n    # Sort the points lexicographically (tuples are compared lexicographically).\n    # Remove duplicates to detect the case we have just one unique point.\n    points =  sorted(points)\n#     points = sorted(set(points))\n    \n\n    # Boring case: no points or a single point, possibly repeated multiple times.\n    if len(points) <= 1:\n        return points\n\n    # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\n    # Returns a positive value, if OAB makes a counter-clockwise turn,\n    # negative for clockwise turn, and zero if the points are collinear.\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    # Build lower hull \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    # Build upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    # Concatenation of the lower and upper hulls gives the convex hull.\n    # Last point of each list is omitted because it is repeated at the beginning of the other list. \n    return lower[:-1] + upper[:-1]\n\n# def hull_method(pointlist):\n\n#     pass\n", "import itertools as it\nimport copy\n\noperator=['+','-','*','/']\n\ndef gnrt_exp(a,b):\n    return [\n    '({0})*({1})'.format(a,b),\n    '({0})/({1})'.format(a,b),\n    '({0})/({1})'.format(b,a),\n    '({0})+({1})'.format(a,b),\n    '({0})-({1})'.format(a,b),\n    '({0})-({1})'.format(b,a)\n    ]\n\ndef equal_to_24(a,b,c,d):\n    List=[a,b,c,d]\n    for fst,scnd in it.combinations(List,2):\n        temp=copy.deepcopy(List)\n        temp.remove(fst)\n        temp.remove(scnd)\n        for exp1 in gnrt_exp(fst,scnd):\n            for thrd in it.combinations(temp,1):\n                temp1=copy.deepcopy(temp)\n                temp1.remove(thrd[0])\n                for exp2 in gnrt_exp(exp1,thrd[0]):\n#                    print(\"exp2=\",exp2)\n                    for exp3 in gnrt_exp(exp2,temp1[0]):\n#                        print(exp3)\n                        try:\n                            rst_final=eval(exp3)\n                        except:\n                            rst_final=0\n                        if rst_final==24:\n                            return exp3\n    for fst,scnd in it.combinations(List,2):\n        temp=copy.deepcopy(List)\n        temp.remove(fst)\n        temp.remove(scnd)\n        for exp1 in gnrt_exp(fst,scnd):\n            for exp2 in gnrt_exp(*temp):\n                for exp in gnrt_exp(exp1,exp2):\n                    print(exp)\n                    try:\n                        rst_final=eval(exp)\n                    except:\n                        rst_final=0\n                    if rst_final==24:\n                        return exp\n    return \"It's not possible!\"\n", "from collections import Counter\nimport re\n\ndef top_3_words(text):\n    words = re.findall(r\"[a-z][a-z']*|[a-z']*[a-z]\", text, re.IGNORECASE)\n    topchart = Counter([word.lower() for word in words]).most_common(3)\n    return [top[0] for top in topchart]", "MOVES = {(0,1), (0,-1), (1,0), (-1,0)}\n\ndef has_exit(maze):\n    posSet = {(x,y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k'}\n    if len(posSet) != 1:\n        raise ValueError(\"There shouldn't be more than one kate\")\n    \n    seen = set(posSet)\n    while posSet:\n        x,y = posSet.pop()\n        if any(not (0 <= x+dx < len(maze) and 0 <= y+dy < len(maze[x+dx])) for dx,dy in MOVES):\n            return True\n        neighbors = {(x+dx, y+dy) for dx,dy in MOVES if 0 <= x+dx < len(maze) and 0 <= y+dy < len(maze[x+dx])\n                                                        and maze[x+dx][y+dy] == ' '\n                                                        and (x+dx, y+dy) not in seen}\n        posSet |= neighbors\n        seen   |= neighbors\n    return False", "def zeroes (base, number):\n    pzeros = []\n    for p in range(2, base+1):\n        e = 0\n        while base % p == 0:\n            base /= p\n            e += 1\n        if e:\n            f, m = 0, number\n            while m:\n                m /= p\n                f += m\n            pzeros.append(f / e)\n    return min(pzeros)", "from itertools import groupby, zip_longest\n\nFROM_ROMAN = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\nTO_ROMAN = ((1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'),\n            (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I'))\n\n\nclass RomanNumerals(object):\n    @staticmethod\n    def to_roman(n):\n        result = []\n        for num, char in TO_ROMAN:\n            q, n = divmod(n, num)\n            result.append(q * char)\n        return ''.join(result)\n\n    @staticmethod\n    def from_roman(roman):\n        pairs = [sum(g) for _, g in groupby(FROM_ROMAN[a] for a in roman)]\n        return sum(a + b if a > b else b - a for a, b in\n                   zip_longest(pairs[::2], pairs[1::2], fillvalue=0))\n", "def create_number_class(alphabet):\n    n = len(alphabet)\n    class C(int):\n        def __new__(cls, s):\n            return super().__new__(\n                cls, sum(alphabet.index(c) * n**i for i, c in enumerate(s[::-1]))\n            )\n        \n        def __str__(self):\n            s = \"\"\n            while self > 0:\n                self, d = divmod(self, n)\n                s = alphabet[d] + s\n            return s or alphabet[0]\n            \n        for op in ['__add__', '__sub__', '__mul__', '__floordiv__']:\n            locals()[op] = lambda self, other, op=op: int.__new__(type(self), getattr(int, op)(self, other))\n            \n        def convert_to(self, c):\n            return int.__new__(c, self)\n    return C", "class Machine:\n    def __init__(self):\n        _actions = ACTIONS()\n        self.actions ={}\n    def command(self, cmd, num):\n        self.cmd=cmd\n        self.actions[cmd] = self.actions.get(cmd,ACTIONS())\n        return self.actions[cmd][0](num)\n    def response(self,res):\n        if not res:\n            self.actions[self.cmd]=self.actions[self.cmd][1:]", "def path_finder(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack, length = [[0, 0]], len(matrix)\n    while len(stack):\n      x, y = stack.pop()\n      if matrix[x][y] == '.':\n        matrix[x][y] = 'x'\n        for x, y in (x, y-1), (x, y+1), (x-1, y), (x+1, y):\n          if 0 <= x < length and 0 <= y < length:\n            stack.append((x, y))\n    return matrix[length-1][length-1] == 'x'", "def find_word(board, word, cursor = None):\n    if not word:\n        return True\n    workboard = [row[:] for row in board]\n    sy, sx, ey, ex = 0, 0, len(board), len(board[0])\n    if cursor:\n        cx, cy = cursor\n        workboard[cy][cx] = \"-\"\n        sy = max(sy, cy - 1)\n        sx = max(sx, cx - 1)\n        ey = min(ey, cy + 2)\n        ex = min(ex, cx + 2)\n    for     y, row  in enumerate(workboard[:ey][sy:]):\n        for x, cell in enumerate(      row[:ex][sx:]):\n            if cell == word[0] and find_word(workboard, word[1:], (x + sx, y + sy)):\n                return True\n    return False", "import re\n\npos = [0, 0]    # pos-x is down, pos-y is right\ndirection = 0   # 0=up, 1=right, 2=down, 3=left\n\ndef i_am_here(path):\n    commands = list(re.findall(\"(\\d+|[lrLR])\", path))\n    nonlocal direction, pos\n    for command in commands:\n        if command.isdigit():\n            steps = int(command)\n            if direction % 2 == 0:\n                pos[0] += steps if direction == 2 else -steps\n            else:\n                pos[1] += steps if direction == 1 else -steps\n        elif command == \"r\":\n            direction = (direction + 1) % 4\n        elif command == \"l\":\n            direction = (direction - 1) % 4\n        else:\n            direction = (direction + 2) % 4\n    return pos", "def knight(p1, p2):\n    from collections import deque\n\n    mapper = {1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\", 6: \"f\", 7: \"g\", 8: \"h\"}\n    mapper_inv = {\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5, \"f\": 6, \"g\": 7, \"h\": 8}\n    visited = set()\n    que = deque()\n\n    start_pos = tuple(p1)\n    start_pos = (int(mapper_inv[start_pos[0]]), int(start_pos[1]))\n\n    que.appendleft((start_pos, 1))\n\n    def _gen_move(spos):\n        \"\"\"\n        Generate next moves\n        eg. spos = (a, 1) == (1, 1) == (x, y)\n        \"\"\"\n        dx = [-2, -1, 1, 2, 2, 1, -1, -2]  # relative directions x\n        dy = [1, 2, 2, 1, -1, -2, -2, -1]  # relative directions y\n        for d in range(8):\n            nx = spos[0] + dx[d]\n            ny = spos[1] + dy[d]\n            if not 0 < nx < 9 or not 0 < ny < 9 and (nx, ny) not in visited:\n                continue\n            npos = (nx, ny)\n            visited.add(npos)\n            yield npos\n\n    while len(que) > 0:\n\n        # generate next positions and put them in que\n        sp, step = que.pop()\n        for nm in _gen_move(sp):\n            # check if next move is last\n            nm_ = mapper[nm[0]]+str(nm[1])\n            if nm_ == p2:\n                return step\n            que.appendleft((nm, step+1))", "from heapq import *\nfrom collections import defaultdict\n\nMOVES = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))\n\ndef shallowest_path(river):\n    q = [(river[x][0], 0, (x,0)) for x in range(len(river))]\n    path = {}\n    stored_steps = defaultdict(lambda : float('inf'))\n    heapify(q)\n\n    while q:\n        cost, step, (x,y) = heappop(q)\n        if (x,y) == (x,len(river[0])-1):\n            end = (x,y)\n            break\n\n        for dx,dy in MOVES:\n            xx = dx + x\n            yy = dy + y\n\n            if 0<=xx<len(river) and 0<=yy<len(river[0]):\n                new_step = step + (abs(dx)+abs(dy))**.5\n\n                if new_step < stored_steps[(xx,yy)]:\n                    stored_steps[(xx,yy)] = new_step\n                    new_cost = max(cost, river[xx][yy])\n\n                    path[(xx,yy)] = (x,y)\n                    heappush(q, (new_cost, new_step, (xx,yy)))\n        \n    \n    coords = [end]\n\n    while coords[-1][1] != 0:\n        coords.append(path[end])\n        end = path[end]\n\n    return coords[::-1]", "def runoff(voters):\n    if len(voters[0]) < 1:\n        return None\n    votes = count_votes(voters)\n    possible_winner = get_winner(votes)\n    if votes[possible_winner] > (len(voters) / 2):\n        return possible_winner\n    else:\n        losers = get_losers(votes)\n        new_voters = [[candidate for candidate in voter if candidate not in losers] for voter in voters]\n        return runoff(new_voters)\n\ndef count_votes(voters):\n    votes = {candidate: 0 for candidate in voters[0]}\n    for voter in voters:\n        votes[voter[0]] += 1\n    return votes\n\ndef get_winner(votes):\n    return max(votes, key=lambda x: votes[x])\n\ndef get_losers(votes):\n    min_vote = min(votes.values())\n    return [candidate for candidate in votes if votes[candidate] == min_vote]", "def five_by_2n(n):\n    a1, a2, a3, a4 = 1, 8, 95, 1183\n    \n    for i in range(n):     \n        nxt = (15 * a4 - 32 * a3 + 15 * a2 - a1) % 12345787\n        a1, a2, a3, a4 = a2, a3, a4, nxt\n    \n    return a1", "\nimport itertools\nd = {1:[[1]]}\ndef combos(n):\n    if n not in d:\n        d[n] = list(i for i,_ in itertools.groupby(sorted([[n]] + [sorted(j+[i]) for i in range(1, n) for j in combos(n-i)])))\n    return d[n]", "def tokenize(expression):\n    result = []\n    curr = ''\n    for chr in expression:\n        if chr.isdigit() or chr == '.':\n            curr += chr\n        elif chr in '$*-+':\n            result.extend([float(curr), chr])\n            curr = ''\n        else:\n            raise ValueError('invalid input')\n    if curr:\n        result.append(float(curr))\n    return result\n    \ndef calculate(expression):\n    ops = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '$': lambda x, y: x / y,\n    }\n    \n    try:\n        l = tokenize(expression)\n    except ValueError:\n        return '400: Bad request'\n    \n    for op in '$*-+':\n        while op in l:\n            i = l.index(op)\n            l = l[:i-1] + [ops[op](l[i-1], l[i+1])] + l[i+2:]\n    \n    return l[0]", "from collections import defaultdict\n\ndef pf(n):\n    primes = defaultdict(lambda: 0); i=2\n    while n>1 and i*i<=n:\n        if n%i==0:\n            while n%i==0: primes[i] = primes[i]+1; n/=i;\n        i+=1\n    if n>1: primes[n]=primes[n]+1\n    return primes\n\nreduce = lambda n,p: 0 if n<p else n//p + reduce(n//p,p)\n\ndef trailing_zeros(num, base):\n    mx = float('inf'); primes = pf(base)\n    for p in primes: mx = min(mx,reduce(num,p)//primes[p])\n    return mx", "mystery=lambda n:n ^ (n >> 1)\nmystery_inv=lambda n,i=0,li=[0]:int(''.join(map(str,li)),2) if i==len(bin(n)[2:]) else mystery_inv(n,i+1,li+[int(li[-1])^int(bin(n)[2:][i])])\nname_of_mystery=lambda:'Gray code'", "from itertools import combinations\nfrom collections import Counter\n\ndef valid(schedule):\n    N, G = len((schedule)[0]), len((schedule)[0][0]) # number of groups and sife of each one\n    test1 = lambda s: all(len(set(\"\".join(groups))) == N*G for groups in s)\n    test2 = lambda s: all(len(groups) == N and all(len(g) == G for g in groups) for groups in s)\n    test3 = lambda s: Counter(c for groups in s for g in groups for c in combinations(g, 2)).most_common(1)[0][1] < 2\n    all_players = set(\"\".join((schedule)[0]))\n    test4 = lambda s: all(set(\"\".join(groups)) == all_players for groups in s)\n    return test1(schedule) and test2(schedule) and test3(schedule) and test4(schedule)", "def splitlist(lst):\n    if not lst:\n        return ([], [])\n    lst = sorted(lst, reverse=True)\n    optimum = sum(lst) // 2\n    if optimum <= lst[0]:\n        return [lst[0]], lst[1:]\n    dp = [None] * (optimum + 1)\n    dp[0] = []\n    for item in lst:\n        for pos in reversed(range(optimum - item + 1)):\n            if dp[pos] is not None and dp[pos + item] is None:\n                dp[pos + item] = dp[pos] + [item]\n    best = next(reversed([option for option in dp if option is not None]))\n    for item in best:\n        lst.remove(item)\n    return best, lst", "from typing import Tuple, Iterable, List\n\nPosition = Tuple[int, int]\nPositions = List[Position]\n\nMOVES: Tuple[Position, ...] = ((-1, -2), (1, -2), (-2, -1), (2, -1), (-2, 1), (2, 1), (-1, 2), (1, 2))\n\n\ndef knights_tour(start: Position, size: int) -> Positions:\n    board = [[False] * size for _ in range(size)]\n\n    def moves(x: int, y: int) -> Iterable[Position]:\n        for xd, yd in MOVES:\n            xx, yy = x + xd, y + yd\n\n            if 0 <= xx < size and 0 <= yy < size and not board[xx][yy]:\n                yield xx, yy\n\n    def dfs(path: Positions) -> Iterable[Positions]:\n        if len(path) == size ** 2:\n            yield path\n            return\n\n        x, y = path[-1]\n        board[x][y] = True\n\n        for vv in sorted(moves(x, y), key=lambda n: len([*moves(*n)])):\n            path.append(vv)\n            yield from dfs(path)\n            path.pop()\n\n        board[x][y] = False\n\n    return next(dfs([start]), [])", "import itertools\n\ndef permutations(s):\n    return list(set([''.join(x) for x in itertools.permutations(list(s))]))\n", "MOD = 12345787\n\ndef n_choose_k(n,k):\n    if not k or n == k: return 1\n    if k < 0 or k > n: return 0\n    if 2*k > n: k = n - k\n    ans = 1\n    for i in range(k):\n        ans = (ans*(n-i)//(i+1))\n    return ans\n    \ndef insane_inc_or_dec(x):\n    return (n_choose_k(9+x,x) + n_choose_k(10+x,x) - 10*x - 2) % MOD\n", "dic={}\ndef partitions(n,x=None, maxx=None):\n    x,maxx = (n,n) if x==None else (x,maxx)\n    return sum([dic[(x-i,i)] if (x-i,i) in dic else(0 if dic.update({(x-i,i):partitions(n,x-i,i)}) else dic[(x-i,i)])for i in range(1,min([maxx,x])+1)[::-1]]) if x else 1", "def path_finder(maze):\n    matrix = list(map(list, maze.splitlines()))\n    n = len(matrix)-1\n    lst, lst2, count = [(0,0)], [], 0\n    while lst:\n        count += 1\n        while lst:\n            a, b = lst.pop()\n            matrix[a][b] = \"X\"\n            for i, j in (a+1,b),(a-1,b),(a,b+1),(a,b-1):\n                if 0 <= i <= n and 0 <= j <= n and matrix[i][j] == '.':\n                    if i == n and j == n:\n                        return count\n                    lst2.append((i,j))\n        lst, lst2 = list(set(lst2)), []\n    return False", "def closure_gen(*s):\n    s = [*s]\n\n    if 1 in s:\n        s.remove(1)\n        yield 1\n\n    queue = [(n, n, 0) for n in s]\n    numbers = [1]\n\n    while queue:\n        prod, *_ = min(queue)\n        yield prod\n\n        numbers.append(prod)\n        for i, (p, n, d) in enumerate(queue):\n            if p <= prod:\n                d += p == prod\n                queue[i] = numbers[d] * n, n, d", "class VigenereCipher(object):\n    def __init__(self, key, alphabet):\n        self.alphabet=alphabet\n        self.key=key\n    \n    def encode(self, text):\n        cl\u00e9=self.key\n        while(len(cl\u00e9)<len(text)):\n            cl\u00e9+=cl\u00e9\n            cl\u00e9=cl\u00e9[:len(text)]\n        chiffre=''    \n        for i,(v,w) in enumerate(zip(text,cl\u00e9)):\n            if v in self.alphabet:\n                chiffre+=self.alphabet[(self.alphabet.index(v)+self.alphabet.index(w))%len(self.alphabet)]\n            else:\n                chiffre+=v\n        return chiffre        \n                \n        \n    \n    def decode(self, text):\n        cl\u00e9=self.key\n        while(len(cl\u00e9)<len(text)):\n            cl\u00e9+=cl\u00e9\n            cl\u00e9=cl\u00e9[:len(text)]\n        dechiffre=''    \n        \n        for i,(v,w) in enumerate(zip(text,cl\u00e9)):\n            if v in self.alphabet:\n                dechiffre+=self.alphabet[(self.alphabet.index(v)-self.alphabet.index(w))%len(self.alphabet)]\n            else:\n                dechiffre+=v\n                \n        return dechiffre        \n", "c = [[1]]\np = [1, 1]\nc.append(p)\nfor i in range(1, 2100):\n  a = [1]\n  for j in range(1, i+1):\n    a.append(p[j-1] + p[j])\n  a.append(1)\n  c.append(a)\n  p = a\n\ndef roll_dice (rolls, sides, threshold):\n  if threshold <= rolls: return 1\n  if threshold > rolls * sides: return 0\n  threshold -= rolls + 1;\n  sum_ = 0.0\n  i = 0\n  while (threshold >= 0):    \n    sum_ += (-1)**i * c[rolls][i] * c[threshold + rolls][threshold]\n    threshold -= sides\n    i += 1\n  return 1.0 - sum_ / (sides ** rolls)", "def get_key_length(text, max_key_length):\n    mx = s = 0 \n    for i in range(2, max_key_length + 1):\n        x = sum(index_of_coincidence(text[j::i]) for j in range(i)) / i\n        if x > s: mx, s = i, x\n    return mx\n\ndef index_of_coincidence(string):\n    N = len(string)\n    return sum(count * (count - 1) for count in map(string.count, set(string))) / (N * (N - 1))", "def balanced_parens(n):\n    return list(set([p[:i] + \"()\" + p[i:] for p in balanced_parens(n - 1) for i in range(0, len(p))])) if n > 1 else ([\"\"], [\"()\"])[n]", "from functools import total_ordering\n\n@total_ordering\nclass PokerHand(object):\n    CARDS = \"AKQJT987654321\"\n    RANKS = {card: idx for idx, card in enumerate(CARDS)}\n    \n    def score(self, hand):    \n        values, suits = zip(*hand.split())\n        idxs, ordered = zip(*sorted((self.RANKS[card], card) for card in values))\n        is_straight = ''.join(ordered) in self.CARDS\n        is_flush = len(set(suits)) == 1\n        return (-2 * sum(values.count(card) for card in values)\n                - 13 * is_straight - 15 * is_flush, idxs)\n    \n    def __init__(self, hand):\n        self.hand = hand\n        self.score = min(self.score(hand), self.score(hand.replace('A', '1')))\n    \n    def __repr__(self):  return self.hand\n    def __eq__(self, other): return self.score == other.score\n    def __lt__(self, other): return self.score < other.score", "# Monotone chain method\n\ndef cross(a,b,o):\n    return (a[0]-o[0]) * (b[1]-o[1]) - (b[0]-o[0]) * (a[1]-o[1])\n\ndef hull(pts):\n    q = []\n    for p in pts:\n        while len(q) > 1 and cross(q[-2], q[-1], p) <= 0: q.pop()\n        q.append(p)\n    q.pop()\n    return q\n\ndef convex_hull_area(points):\n    if len(points) < 3: return 0\n    points = sorted(points)\n    hl = hull(points) + hull(points[::-1])\n    hl.append(hl[0])\n    return round(sum(x1*y2 - y1*x2 for (x1,y1),(x2,y2) in zip(hl, hl[1:])) / 2, 2)", "from functools import reduce\n\nclass Datamining:\n    def __init__(self, train_set):\n        self.s = train_set[:6]\n\n    def predict(self, x):\n        f = lambda j, x, xj: [(x - xi) / (xj - xi) for (i, (xi,yi)) in enumerate(self.s) if j != i]\n        return sum(\n            reduce(lambda s, n: s * n, f (j,x,xj), yj) for (j, (xj,yj)) in enumerate(self.s))", "from operator import xor\n\ndef choose_move(game_state):\n    \"\"\"Chooses a move to play given a game state\"\"\"\n    x = reduce(xor, game_state)\n    for i, amt in enumerate(game_state):\n        if amt ^ x < amt:\n            return (i, amt - (amt ^ x))", "def nQueen(n):\n    if n==2 or n==3: return []\n    r, odds, evens = n%6, list(range(1,n,2)), list(range(0,n,2))\n    if r==2:\n        evens[:2] = evens[:2][::-1]\n        evens.append(evens.pop(2))\n    if r==3:\n        odds.append(odds.pop(0))\n        evens.extend(evens[:2])\n        del evens[:2]\n    return odds+evens", "operand = set(\"0123456789\")\noperator = {'+':1, '-':1, '*':2, '/':2, '^':3}\n\ndef to_postfix (infix):\n    stack, res = [], []\n    for c in \"({})\".format(infix):\n        if c in operand:\n            res.append(c)\n        elif c == '(':\n            stack.append(c)\n        elif c == ')':\n            while stack[-1] != '(':\n                res.append(stack.pop())\n            del stack[-1]\n        elif c in operator:\n            while operator.get(stack[-1], 0) >= operator[c]:\n                res.append(stack.pop())\n            stack.append(c)\n        else:\n            raise Exception(\"Character {} unknown\".format(c))\n    return ''.join(res)", "def hamming(n):\n    h, i, j, k = [1] * n, 0, 0, 0\n    \n    for nn in range(1, n):\n        h[nn] = min(2 * h[i], 3 * h[j], 5 * h[k])\n        i += 2 * h[i] == h[nn]\n        j += 3 * h[j] == h[nn]\n        k += 5 * h[k] == h[nn]\n    \n    return h[-1]\n", "import numpy as np\n\ndef next_gen(grid):\n    neighbours = np.array([np.roll(grid, (i, j), axis=(0, 1)) for i in [-1, 0, 1] for j in [-1, 0, 1]]).sum(axis=0) - grid\n    return (neighbours == 3) | (grid & (neighbours == 2)) \n\ndef unpad(grid):\n    if grid[0,].sum() == 0:\n        return unpad(grid[1:])\n    if grid[-1,].sum() == 0:\n        return unpad(grid[:-1])\n    if grid[:,0].sum() == 0:\n        return unpad(grid[:,1:])\n    if grid[:,-1].sum() == 0:\n        return unpad(grid[:,:-1])\n    return grid\n        \ndef get_generation(cells, generations):\n    cells = np.array(cells)\n    for _ in range(generations):\n        cells = next_gen(np.pad(cells, 1, mode='constant'))\n    return unpad(cells).tolist()", "import math\ndef min_price(coins):\n    if coins == []:\n        return -1\n    if do_gcd(coins) !=1:\n        return -1\n    if min(coins) == 1:\n        return 1\n    if len(coins) == 2:\n        return do_lcm(coins) - sum(coins) + 1\n    a = sorted(coins)\n    a1 = a[0]\n    k = len(a)\n    inf = math.inf\n    n = [0]\n    for i in range(1, a1):\n        n.append(inf)\n    for i in range(1, k):\n        d = math.gcd(a1, a[i])\n        for r in range(d):\n            nn = inf\n            for q in range(r, a1, d):\n                if (q % d) == r:\n                    nn = min(nn, n[q])\n            if nn < inf:\n                for j in range(int(a1/d) - 1):\n                    nn = nn + a[i]\n                    p = nn % a1\n                    nn = min(nn, n[p])\n                    n[p] = nn\n    return max(n) - a1 + 1\n\ndef do_gcd(array):\n    if len(array) == 1:\n        return array[0]\n    if len(array) == 2:\n        return math.gcd(array[0], array[1])\n    return math.gcd(array[0], do_gcd(array[1:]))\n\ndef do_lcm(array):\n    return int(array[0]*array[1]/math.gcd(array[0], array[1]))", "import itertools\nfrom functools import reduce\nfrom operator import mul\nimport re\n\n\ndef max_palindrome(x):\n    s = str(x)\n    left, odds = [], []\n    for c in set(s):\n        cnt = s.count(c)\n        d, d1 = cnt//2, cnt % 2\n        if d:\n            left.append(c*d)\n        if d1:\n            odds.append(c)\n    left.sort(reverse=True)\n    s1 = ''.join(left)\n    m = max(odds) if odds else ''\n    temp = s1+m+s1[::-1]\n    temp = re.sub(r'0*$', '', temp)\n    return int(temp)\n\n\ndef numeric_palindrome(*args):\n    arr = [x for x in args if x > 1]\n    if 1 in args:\n        arr.append(1)\n    if len(arr) > 1:\n        res = 0\n        for i in range(2, len(arr)+1):\n            temp = [max_palindrome(reduce(mul, x))\n                    for x in itertools.combinations(arr, i)]\n            res = max(max(temp), res)\n        return res\n    elif len(arr) == 1:\n        return max_palindrome(arr[0]) if args.count(1)>1 in args else 0\n    else:\n        return 1 if args.count(1) > 1 else 0\n", "def recoverSecret(a):\n    out = list(zip(*a)) \n    h = [j for j in (set(out[0])-set(out[1]+out[2]))]\n    for i in a:\n        if i[0] in h:\n            i[:2], i[2] = i[1:], ''\n        \n    return h[0]+recoverSecret(a) if h else str()\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        visited = set()\n        queue = deque([(id, 0)])\n        visited.add(id)\n        requiredFriends = []\n        while queue:\n            person, lev = queue.popleft()\n            if lev == level:\n                requiredFriends.append(person)\n            if lev > level:\n                break\n            for friend in friends[person]:\n                if friend not in visited:\n                    queue.append((friend, lev + 1))\n                    visited.add(friend)\n        videosFrequency = defaultdict(int)\n        for friend in requiredFriends:\n            for video in watchedVideos[friend]:\n                videosFrequency[video] += 1\n        return [video[0] for video in sorted(videosFrequency.items(), key = lambda x : (x[1], x[0]))]", "class Solution:\n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         \"\"\"\n         :type expression: str\n         :type evalvars: List[str]\n         :type evalints: List[int]\n         :rtype: List[str]\n         \"\"\"\n         class C(collections.Counter):\n             def __add__(self, other):\n                 self.update(other)\n                 return self\n             def __sub__(self, other):\n                 self.subtract(other)\n                 return self\n             def __mul__(self, other):\n                 product = C()\n                 for x in self:\n                     for y in other:\n                         xy = tuple(sorted(x + y))\n                         product[xy] += self[x] * other[y]\n                 return product\n         vals = dict(zip(evalvars, evalints))\n         def f(s):\n             s = str(vals.get(s, s))\n             return C({(s,): 1}) if s.isalpha() else C({(): int(s)})\n         c = eval(re.sub('(\\w+)', r'f(\"\\1\")', expression))\n         return ['*'.join((str(c[x]),) + x)\n                 for x in sorted(c, key=lambda x: (-len(x), x))\n                 if c[x]]", "class Solution:\n    def get_ggT(self, a, b):\n        while (a != b):\n            a_ = a - b\n            a = max(a_, b)\n            b = min(a_, b)\n            \n        return a\n        \n        \n        \n    def simplifiedFractions(self, n: int) -> List[str]:\n        ret = set()\n        \n        \n        for denominator in range(2, n + 1):\n            for numerator in range(1, denominator):\n                ggT = self.get_ggT(denominator, numerator)\n                ret.add(str(numerator // ggT) + \\\"/\\\" + str(denominator // ggT))\n                \n        return ret", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         if len(intervals) == 0:\n             return 0\n         \n         intervals = sorted(intervals, key = lambda x: (x.end, -x.start))\n         \n         end = intervals[0].end\n         \n         res = 0\n         \n         for interval in intervals[1:]:\n             \n             if end > interval.start:\n                 res += 1\n             else:\n                 end = interval.end\n         \n         for i in intervals:\n             print((i.start,i.end))\n         return res\n         \n         ", "class Solution:\n     def productExceptSelf(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[int]\n         \"\"\"\n         nums0 = nums.copy()\n         son = 1\n         if 0 in nums0:\n             nums0.remove(0)\n             for i in nums0:\n                 son *= i\n             \n             \n         pro = 1\n         for i in nums:\n             pro *= i\n         result = []\n         for i in nums:\n             if i == 0:\n                 result.append(son)\n             else:\n                 result.append(pro//i)\n         return result", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n        self.idx = 0\n        \n\n    def next(self, price: int) -> int:\n        while len(self.st) and self.st[-1][0] <= price:\n            self.st.pop()\n        ans = self.idx - (0 if not len(self.st) else self.st[-1][1])+1\n        self.st.append((price, self.idx+1))\n        self.idx += 1\n        return ans\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.loc = collections.defaultdict(list)\n        for i, n in enumerate(arr):\n            self.loc[n].append(i)    \n        self.nums = sorted(list(self.loc.keys()), key = lambda n: len(self.loc[n]), reverse=True)\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for n in self.nums:\n            if len(self.loc[n]) < threshold: return -1\n            l, r = bisect.bisect_left(self.loc[n], left), bisect.bisect_right(self.loc[n], right)\n            if r - l >= threshold: return n\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        self.shelf = defaultdict(list)\n        \n        @lru_cache(None)\n        def helper(i):\n            if i == len(books):\n                return 0\n            \n            width = 0\n            height = 0\n            out = float('inf')            \n            \n            while width < shelf_width and i < len(books):\n                w,h = books[i]                \n                width += w\n                \n                if width > shelf_width: # went over when added this new book\n                    break\n                    \n                # max height of this shelf with new book added\n                height = max(height, h) \n                \n                # see how much the total height others are if we include the new book\n                # in this shelf\n                others = helper(i+1) \n                \n                # if height of current shelf+ total height of other books is minimum\n                # save it.\n                out = min(height+others, out) \n                i+= 1\n            return out\n        \n        out = helper(0)\n        return out\n            \n            \n", "class Solution:\n     def exclusiveTime(self, n, logs):\n         \"\"\"\n         :type n: int\n         :type logs: List[str]\n         :rtype: List[int]\n         \"\"\"\n         dict={}\n         st=[]\n         ans=[]\n         for i in range(n):\n             dict[i]=0\n         #print(dict)\n         for s in logs:\n             if s.split(':')[1]=='start':\n                 if not st:\n                     st.append([int(s.split(':')[0]),int(s.split(':')[2])])\n                     #print(st)\n                 else:\n                     time=int(s.split(':')[2])-st[-1][1]\n                     dict[st[-1][0]]+=time\n                     #print(dict)\n                     st.append([int(s.split(':')[0]),int(s.split(':')[2])])\n                     #print(st)\n             else:\n                 time=int(s.split(':')[2])-st[-1][1]\n                 dict[st[-1][0]]+=time+1\n                 #print(dict)\n                 st.pop()\n                 #print(st)\n                 if st:\n                     st[-1][1]=int(s.split(':')[2])+1\n                     #print(st)\n \n         for i in range(n):\n             ans+=[dict[i]]\n \n         return ans\n", "class Solution:\n    def shiftingLetters(self, S: str, shifts: List[int]) -> str:\n        n, cumsum, res = len(S), 0, \\\"\\\"\n        for i in range(n-1, -1, -1):\n            cumsum += shifts[i]\n            res = chr(ord('a') + (ord(S[i]) - ord('a') + cumsum) % 26) + res\n        return res", "from itertools import groupby\n class Solution:\n     def reorganizeString(self, s):\n         \"\"\"\n         :type d: str\n         :rtype: str\n         \"\"\"\n         counts = sorted([s.count(x) for x in set(s)] + [0])[::-1]\n         \n         if counts[0] > sum(counts[1:]) + 1:\n             return \"\"\n         \n         gl = sorted([list(j) for i, j in groupby(sorted(list(s)))], key=lambda x: -len(x))\n         \n         res = \"\"\n         while gl:\n             \n             res += gl[0].pop()\n             if len(gl) > 1:\n                 res += gl[1].pop()\n \n             gl = list(filter(None, gl))\n             gl.sort(key=lambda x: -len(x))\n         return res\n         \n         ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        \\\"\\\"\\\"\n        8:00 AM\n        \n        \\\"\\\"\\\"\n        if root == None:\n            return \\\"\\\"\n        result  = None\n        \n        charMappings = { i: chr(i+ord(\\\"a\\\")) for i in range(0, 26)}\n        \n        def helper(node, path):\n            nonlocal result\n            if node == None:\n                return\n            \n            if node.left == None and node.right == None:\n                char = charMappings.get(node.val)\n                string = \\\"\\\".join(  ((path+[char])[::-1]) )\n                if result == None or string < result:\n                    result = string\n                \n                return\n            char = charMappings.get(node.val)\n            helper(node.left, path+[char])\n            helper(node.right, path+[char])\n            \n        helper(root, [])\n        return result\n                ", "class Solution:\n \n     def __init__(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         \"\"\"\n         self.nums = nums;\n         \n         \n \n     def pick(self, target):\n         \"\"\"\n         :type target: int\n         :rtype: int\n         \"\"\"\n         indices = [i for i, x in enumerate(self.nums) if x == target]\n         return random.choice(indices)\n \n \n # Your Solution object will be instantiated and called as such:\n # obj = Solution(nums)\n # param_1 = obj.pick(target)\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return [] \n         q = [root]\n         r = []\n         while q:\n             r.append(max([i.val for i in q]))\n             q = [i for node in q for i in [node.left, node.right] if i]\n         return r", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        length = len(nums)\n        start_node = (length-2) // 2\n        for i in range(start_node, -1, -1):\n            self.build(nums, i, length)\n        for i in range(length-1, 0, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            self.build(nums, 0, i)\n        return nums\n#     def sortArray(self, nums: List[int]) -> List[int]:\n#         length = len(nums)\n#         for i in range(length - 1, -1, -1):\n#             self.build(nums, i, length)\n        \n#         for i in range(length - 1, 0, -1):\n#             nums[0], nums[i] = nums[i], nums[0]\n#             self.build(nums, 0, i)\n#         return nums    \n    \n    \n    def build(self, nums, node, n):\n        left = node*2 + 1\n        right = node*2 + 2\n        large = node\n        \n        if left < n and nums[left] > nums[large]:\n            large = left\n        if right < n and nums[right] > nums[large]:\n            large = right\n        if large != node:\n            nums[large], nums[node] = nums[node], nums[large]\n            self.build(nums, large, n)", "import functools\n import collections\n \n class Solution(object):\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         wordCounts = collections.Counter(words)\n         candidates = list(wordCounts.keys())\n         candidates.sort(key = lambda word: (-wordCounts[word], word))\n         return candidates[:k]\n           ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reorderList(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: void Do not return anything, modify head in-place instead.\n         \"\"\"\n         if not head:\n             return \n         fast, slow = head.next, head\n         while fast and fast.next:\n             fast = fast.next.next\n             slow = slow.next\n             \n         \n         p = slow.next\n         slow.next = None\n         node = None\n         while p:\n             nxt = p.next\n             p.next = node\n             node = p\n             p = nxt\n         \n         p = head\n         while node:\n             tmp = node.next\n             node.next = p.next\n             p.next = node\n             p = p.next.next\n             node = tmp\n             \n             ", "def bs(arr, val, key=lambda x:x):\n     l, r = 0, len(arr)-1\n     if key(arr[l])>val:\n         return l\n     if key(arr[r])<=val:\n         return r+1\n     while l+1<r:\n         m = (l+r)>>1\n         v = key(arr[m])\n         if v<=val:\n             l = m\n         else:\n             r = m\n     return r\n \n def bs_left(arr, val, key=lambda x:x):\n     l, r = 0, len(arr)-1\n     if key(arr[l])>=val:\n         return l\n     if key(arr[r])<val:\n         return r+1\n     while l+1<r:\n         m = (l+r)>>1\n         v = key(arr[m])\n         if v<val:\n             l = m\n         else:\n             r = m\n     return r\n             \n \n class Solution:\n     def findNumberOfLIS(self, nums):\n         if not nums: return 0\n         N = len(nums)\n         l, dp = 0, [[] for _ in range(N)]\n         for n in nums:\n             idx1 = bs_left(dp, n, lambda _:_[-1][0] if _ else sys.maxsize)\n             if idx1==l:\n                 l += 1\n             if idx1==0:\n                 dp[0].append([n, (dp[0][-1][1] if dp[0] else 0)+1])\n             else:\n                 idx2 = bs(dp[idx1-1], -n, lambda _:-_[0])\n                 dp[idx1].append([n, (dp[idx1][-1][1] if dp[idx1] else 0)+(dp[idx1-1][-1][1] if idx2==0 else (dp[idx1-1][-1][1]-dp[idx1-1][idx2-1][1]))])\n         return dp[l-1][-1][1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def traverse(root, level):\n            if root:\n                if not root.left and not root.right:\n                    return level, root\n                else:\n                    left_level, left_lca = traverse(root.left, level + 1)\n                    right_level, right_lca = traverse(root.right, level + 1)\n                    if left_level == right_level:\n                        return left_level, root\n                    elif left_level > right_level:\n                        return left_level, left_lca\n                    else:\n                        return right_level, right_lca\n            return float('-inf'), None\n\n        deepest_level, lca = traverse(root, 0)\n        return lca", "class Solution:   \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        valid_row_indexes = range(len(mat))\n        valid_col_indexes = range(len(mat[0]))\n        answer = [[0]*len(mat[0]) for _ in range(len(mat))]\n        for r in valid_row_indexes:\n            for c in valid_col_indexes:\n                left = c-K if c-K in valid_col_indexes else None\n                right = c+K+1 if c+K in valid_col_indexes else None\n                answer[r][c] += sum([sum(mat[i][left:right]) for i in range(r-K, r+K+1) if i in valid_row_indexes])\n        return answer                ", "import math\n class Solution:\n     def smallestGoodBase(self, n):\n         n = int(n)\n         maxLength = int(math.log(n,2))\n         for m in range(maxLength, 1, -1):\n             k = int(n**m**-1)\n             if (k**(m+1) - 1)//(k - 1) == n:\n                 return str(k)\n         return str(n-1)\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         ", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        i, n = 0, len(barcodes)\n        res = [0] * n\n        for k, v in collections.Counter(barcodes).most_common():\n            for _ in range(v):\n                res[i] = k\n                i += 2\n                if i >= n: i = 1\n                # print(res)\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        return self.countGoodNodes(root, -999999)\n\n    def countGoodNodes(self, node, maxSoFar):\n        if node is None:\n            return 0\n\n        newMax = max(maxSoFar, node.val)\n        return int(node.val >= maxSoFar) + self.countGoodNodes(node.left, newMax) + self.countGoodNodes(node.right, newMax)", "class Solution:\n     def movesToChessboard(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(board)\n         for i in range(1, n):\n             for j in range(1, n):\n                 if (board[0][0] + board[0][j] + board[i][0] + board[i][j]) % 2 != 0:\n                     return -1\n         result = 0\n         x = 0\n         y = 0\n         for i in range(0, n):\n             if i % 2 == 0 and board[i][0] == 1:\n                 x += 1\n             elif i % 2 == 1 and board[i][0] == 0:\n                 y += 1\n         if n % 2 == 0:\n             if x != y:\n                 return -1\n             result += min(x, n // 2 - x)\n         else:\n             if x == y:\n                 result += x\n             elif (n + 1) // 2 - x == (n - 1) // 2 - y:\n                 result += (n + 1) // 2 - x\n             else:\n                 return -1\n         x = 0\n         y = 0\n         for i in range(0, n):\n             if i % 2 == 0 and board[0][i] == 1:\n                 x += 1\n             elif i % 2 == 1 and board[0][i] == 0:\n                 y += 1\n         if n % 2 == 0:\n             if x != y:\n                 return -1\n             result += min(x, n // 2 - x)\n         else:\n             if x == y:\n                 result += x\n             elif (n + 1) // 2 - x == (n - 1) // 2 - y:\n                 result += (n + 1) // 2 - x\n             else:\n                 return -1\n         return result\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,n in edges:\n            g[i].append((j, n))\n            g[j].append((i, n))\n            \n        q = [(-M, 0)]\n        visited = [-10001] * N\n        ans = 0\n        while q:\n            #print(list(q))\n            hp, cur = heapq.heappop(q)\n            if visited[cur] != -10001:\n                #print(cur, visited[cur])\n                continue\n            hp = -hp\n            visited[cur] = hp\n            ans += 1\n            for node, cost in g[cur]:\n                nxt_hp = hp - cost - 1\n                if nxt_hp < 0: continue\n                heapq.heappush(q, (-nxt_hp, node))                    \n        \n        for i,j,n in edges:\n            ui, uj = 0, 0\n            if visited[i] != -10001: ui = visited[i]\n            if visited[j] != -10001: uj = visited[j]\n            ans += min(ui+uj, n)\n            \n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        \n        def helper(node, depth):\n            if not node:\n                return depth, None\n            \n            ld, ln = helper(node.left, depth+1)\n            rd, rn = helper(node.right, depth+1)\n            \n            if ld == rd:\n                return ld, node\n            \n            if ld > rd:\n                return ld, ln\n            \n            if ld < rd:\n                return rd, rn\n            \n        \n        depth, res = helper(root, 0)\n        \n        return res", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        '''\n        top priority would be the first column should be all 1s\n        so toggle each row to make sure the first cell is 1\n        and examine each column from left to right\n        toggle if needed to make sure sum of each column is bigger than otherwise\n        '''\n        \n        def toggle_row(row):\n            for j in range(len(A[0])):\n                if A[row][j]==1:\n                    A[row][j]=0\n                else:\n                    A[row][j]=1\n                    \n        def toggle_col(col):\n            for i in range(len(A)):\n                if A[i][col]==1:\n                    A[i][col]=0\n                else:\n                    A[i][col]=1\n        \n        for i in range(len(A)):\n            if A[i][0]==0:\n                toggle_row(i)\n                \n        for j in range(1, len(A[0])):\n            # get col sum\n            col_sum=0\n            for i in range(len(A)):\n                col_sum += A[i][j]\n            if col_sum < len(A) /2:\n                toggle_col(j)\n                \n        # convert into binary and calculate result\n        res=0\n        for row in A:\n            row_s=''\n            for i in row:\n                row_s += str(i)\n            decimal=int(row_s, 2)\n            res += decimal\n        return res\n            \n", "class Solution:\n    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\n        queue=[]\n        ans = []\n        for i in range(1,10):\n            queue.append(str(i))\n        while len(queue)>0:\n            num = queue.pop(0)\n            #print(queue)\n            #print(num,len(num))\n            if len(num)==n and (num not in ans):\n                ans.append(num)\n\n            elif len(num)<n:\n                x=int(num[-1])\n                if x-k>=0:\n                    queue.append(num+str(x-k))\n                if x+k<=9:\n                    queue.append(num+str(x+k))\n        \n        #print(queue)\n        \n        \n        return ans\n    \n    \n", "import random\n class RandomizedSet:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.dataMap = {}\n         self.dataList = []\n         \n \n     def insert(self, val):\n         \"\"\"\n         Inserts a value to the set. Returns true if the set did not already contain the specified element.\n         :type val: int\n         :rtype: bool\n         \"\"\"\n         if val in self.dataMap:\n             return False\n         else:\n             self.dataMap[val] = len(self.dataList)\n             self.dataList.append(val)\n             return True\n         \n         \n \n     def remove(self, val):\n         \"\"\"\n         Removes a value from the set. Returns true if the set contained the specified element.\n         :type val: int\n         :rtype: bool\n         \"\"\"\n         if val in self.dataMap:\n             idx = self.dataMap[val]\n             tail = self.dataList.pop()\n             if idx < len(self.dataList):\n                 self.dataList[idx] = tail\n                 self.dataMap[tail] = idx\n             del self.dataMap[val]\n             return True\n         else:\n             return False\n \n         \n         \n \n     def getRandom(self):\n         \"\"\"\n         Get a random element from the set.\n         :rtype: int\n         \"\"\"\n         return random.choice(self.dataList)\n         \n \n \n # Your RandomizedSet object will be instantiated and called as such:\n # obj = RandomizedSet()\n # param_1 = obj.insert(val)\n # param_2 = obj.remove(val)\n # param_3 = obj.getRandom()", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         cnt = 0\n         max_curr = -1\n         for i in range(len(arr)):\n             max_curr = max(max_curr, arr[i])\n             if max_curr == i:\n                 cnt += 1\n         return cnt", "import heapq\n class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         def neighbors(n, x, y):\n             neighbors = []\n             if 0 <= x+1 < n and 0 <= y < n: neighbors.append((x+1, y))\n             if 0 <= x-1 < n and 0 <= y < n: neighbors.append((x-1, y))\n             if 0 <= x < n and 0 <= y+1 < n: neighbors.append((x, y+1))\n             if 0 <= x < n and 0 <= y-1 < n: neighbors.append((x, y-1))\n             return neighbors\n                 \n             \n         \n         n = len(grid)\n         \n         poss = set((0,0))\n         pq = [(grid[0][0],0,0)]\n         maxx = 0\n         while pq:\n             elem, x, y = heapq.heappop(pq)\n             maxx = max(maxx, elem)\n             for newx, newy in neighbors(n, x, y):\n                 if newx == n-1 and newy == n-1:\n                     return max(maxx, grid[n-1][n-1])\n                 if (newx, newy) not in poss:\n                     poss.add((newx, newy))\n                     # neighborval = grid[newx][newy]\n                     # if neighborval <= elem:\n                     heapq.heappush(pq, (grid[newx][newy], newx, newy))\n             # print(pq)\n         return maxx\n                     \n             \n             \n         ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def traverse(node,d,curr):\n            if not node:\n                res[0] = max(res[0],curr-1)\n                return\n            if d==0:\n                traverse(node.left,0,1)\n                traverse(node.right,1,curr+1)\n            else:\n                traverse(node.left,0,curr+1)\n                traverse(node.right,1,1)\n                \n        if not root:\n            return 0\n        res = [-float('inf')]\n        traverse(root.left,0,1)\n        traverse(root.right,1,1)\n        return res[0]\n    \n        \n", "def minDifference(minsA, minsB):\n     maxMins = 60 * 24\n     earlier = min(minsA, minsB)\n     later = max(minsA, minsB)\n     direct = later - earlier\n     loopAround = maxMins - later + earlier\n     return min(direct, loopAround)\n \n def toMinutes(timeString):\n     h = int(timeString.split(\":\")[0])\n     m = int(timeString.split(\":\")[1])\n     return m + h * 60\n \n class Solution:\n     def findMinDifference(self, timePoints):\n         \"\"\"\n         :type timePoints: List[str]\n         :rtype: int\n         \"\"\"\n         # timePoints.sort()\n         # currentMin = 60 * 24 + 1\n         # for i in range(-1, len(timePoints) - 1):\n         #     currentMin = min(currentMin, minDifference(toMinutes(timePoints[i]), toMinutes(timePoints[i+1])))\n         # return currentMin\n         minBuckets = [None] * (24 * 60)\n         for i in range(24 * 60):\n             minBuckets[i] = False\n             \n         for time in timePoints:\n             if minBuckets[toMinutes(time) - 1] == True:\n                 return 0\n             minBuckets[toMinutes(time) - 1] = True\n             \n         last = None\n         maxTime = 0\n         minTime = 24 * 60 + 1\n         minDistance = 24 * 60 + 1\n         for i in range(24 * 60):\n             if last == None and minBuckets[i] == True:\n                 first = i\n                 last = i\n             elif minBuckets[i] == True:\n                 minDistance = min(minDistance, i - last)\n                 last = i\n                 veryLast = i\n         minDistance = min(minDistance, 24 * 60 - veryLast + first)\n         return minDistance\n         \n         \n                 \n             ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pruneTree(self, root: TreeNode) -> TreeNode:\n        return root if self.dfs(root) else None\n    \n    def dfs(self, root):\n        if not root:\n            return False\n        l = self.dfs(root.left)\n        r = self.dfs(root.right)\n        if not l:\n            root.left = None\n        if not r:\n            root.right = None\n        return root.val == 1 or l or r", "import random\n class RandomizedCollection(object):\n     def __init__(self):\n         self.l = []\n         self.d = collections.defaultdict(set)\n \n     def insert(self, val):\n         b = val not in self.d\n         self.d[val].add(len(self.l))\n         self.l.append(val)\n         return b\n \n     def remove(self, val):\n         if val not in self.d:\n             return False\n         i, newVal = self.d[val].pop(), self.l[-1]\n         if len(self.d[val]) == 0:\n             del self.d[val]\n         self.l[i] = newVal\n         if newVal in self.d:\n             self.d[newVal].add(i)\n             self.d[newVal].discard(len(self.l)-1)\n         self.l.pop()\n         return True\n \n     def getRandom(self):\n         return random.choice(self.l)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n import queue\n \n class Solution(object):\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         \n         q = queue.Queue()\n         q.put(root)\n         ret = []\n         while not q.empty():\n             nq = queue.Queue()\n             level = []\n             while not q.empty():\n                 node = q.get()\n                 level.append(node.val)\n                 \n                 if node.left:\n                     nq.put(node.left)\n                 if node.right:\n                     nq.put(node.right)\n             ret.append(level)\n             q = nq\n         return ret\n         ", "from collections import defaultdict\n\n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        g = Graph()\n        for u, v in edges:\n            g.connect(u, v)\n            g.connect(v, u)\n            \n        t = g.tree(0)\n        \n        children = [0] * N\n        dists = [0] * N\n        \n        discovered = set()\n        stack = [0]\n        while stack:\n            u = stack.pop()\n            if u not in discovered:\n                discovered.add(u)\n                stack.append(u)\n                \n                for v in t.adj[u]:\n                    stack.append(v)\n            \n            else:\n                discovered.remove(u)\n                children[u] = sum(1 + children[v] for v in t.adj[u])\n                dists[u] = children[u] + sum(dists[v] for v in t.adj[u])\n                \n        stack = [0]\n        while stack:\n            u = stack.pop()\n            for v in t.adj[u]:\n                dists[v] = dists[u] - children[v] - 1 + N - children[v] - 1\n                stack.append(v)\n                \n        return dists\n    \n\nclass Graph:\n    def __init__(self):\n        self.adj = defaultdict(set)\n        \n    def connect(self, u, v):\n        self.adj[u].add(v)\n        \n    def tree(self, start):\n        t = Graph()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            for v in self.adj[u]:\n                if v not in t.adj:\n                    stack.append(v)\n                    t.connect(u, v)\n\n        return t", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         def helper(n, start):\n             if n < 1:\n                 return [None]\n             \n             res = []\n             for i in range(1, n+1):\n                 lefts = helper(i-1, start)\n                 rights = helper(n-i, start+i)\n                 \n                 for left in lefts:\n                     for right in rights:\n                         root = TreeNode(i+start)\n                         root.left = left\n                         root.right = right\n                         res.append(root)\n                         \n             return res\n         \n         return helper(n, 0) if n else []\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         \n         dp = {}\n         \n         def rob1(node):\n             if node.left and node.left not in dp:\n                 dp[node.left] = rob1(node.left)\n             if node.right and node.right not in dp:\n                 dp[node.right] = rob1(node.right)\n             \n             temp = node.val\n \n             if node.left and node.left.left:\n                 temp += dp[node.left.left]\n             if node.left and node.left.right:\n                 temp += dp[node.left.right]\n             if node.right and node.right.left:\n                 temp += dp[node.right.left]\n             if node.right and node.right.right:\n                 temp += dp[node.right.right]\n             \n             t = 0\n             if node.left:\n                 t += dp[node.left]\n             if node.right:\n                 t += dp[node.right]\n             \n             return max(t, temp)\n         \n         return rob1(root)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import sys\n class Solution:\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         if not root or (not root.left and not root.right):\n             return True\n         return self.isBst(root, [], [])\n     def isBst(self, root, min_nums, max_nums):\n         # if root:\n         #     print(\"root:\", root.val)\n         # else:\n         #     print(\"root:\", root)\n         # print(\"min_nums\", min_nums)\n         # print(\"max_nums\", max_nums)\n         if not root:\n             return True\n         min_value = min(min_nums) if min_nums else sys.maxsize\n         max_value = max(max_nums) if max_nums else -sys.maxsize-1\n         left = self.isBst(root.left, min_nums+[root.val], max_nums)\n         right = self.isBst(root.right, min_nums, max_nums+[root.val])\n         if root.val < min_value and root.val > max_value and left and right:\n             return True\n         else:\n             return False\n             \n             ", "from itertools import groupby\nfrom re import finditer\n\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        ans = 2*n\n        reservedSeats.sort()\n        rows = groupby(reservedSeats, key=lambda x: x[0])\n        for r, c in rows:\n            row = ['O']*10\n            for _, col in c:\n                row[col-1] = 'X'\n            row = ''.join(row)\n            idx = {f.start() for f in finditer('(?=OOOO)', row)}\n            if not idx:\n                ans -= 2\n            elif 1 in idx and 5 in idx:\n                continue\n            elif 1 in idx or 3 in idx or 5 in idx:\n                ans -= 1\n            else:\n                ans -= 2\n        return ans\n    \\\"\\\"\\\"\n    OOO OOOO OOO\n    OOO OOOO OOO\n    \\\"\\\"\\\"", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m=len(matrix)\n        n=len(matrix[0])\n        ans=0\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][j]!=0 and matrix[i-1][j]!=0 and matrix[i][j-1]!=0 and matrix[i-1][j-1]!=0:\n                    matrix[i][j]=min(matrix[i-1][j],matrix[i][j-1],matrix[i-1][j-1])+1\n        for i in matrix:\n            ans+=sum(i)\n        return ans\n", "class Solution:\n     def fallingSquares(self, positions):\n         \"\"\"\n         :type positions: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         height = [0]\n         pos = [0]\n         res = []\n         max_h = 0\n         for left, side in positions:\n             i = bisect.bisect_right(pos, left)\n             j = bisect.bisect_left(pos, left + side)\n             high = max(height[i - 1:j] or [0]) + side\n             pos[i:j] = [left, left + side]\n             height[i:j] = [high, height[j - 1]]\n             max_h = max(max_h, high)\n             res.append(max_h)\n         return res        ", "from collections import defaultdict \nclass Solution:\n    def minAreaRect(self, points):\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n         \n        A = sorted(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    ans = min(ans, area)\n        return ans if ans < float('inf') else 0", "class Solution(object):\n    def pancakeSort(self, arr):\n        p = arr.copy()\n        final = p.copy()\n        final.sort()\n        print(p)\n        k = len(final) - 1\n        ret = []\n        while k >= 0:\n            val = final[k]\n            print(\\\"value = \\\", val)\n            ind = p.index(val)\n            print(\\\"p array = \\\", p)\n            print(\\\"index for\\\", val, \\\"=\\\", ind)\n            if ind != k and ind != 0:\n                p = p[:(ind+1)][::-1] + p[(ind+1):]\n                p = p[:(k+1)][::-1] + p[(k+1):]\n                ret += [ind+1, k+1]\n            elif ind == k:\n                pass\n            elif ind == 0:\n                p = p[:(k+1)][::-1] + p[(k+1):]\n                ret.append(k+1)\n            k -= 1\n        return ret\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.dictionary = defaultdict()\n        \n        def dfs(node, x, y):\n            if not node:\n                return None\n            if x not in self.dictionary:\n                self.dictionary[x] = defaultdict(list)\n            self.dictionary[x][y].append(node.val)\n            dfs(node.left, x - 1, y - 1)\n            \n            dfs(node.right, x + 1, y - 1)\n        \n        dfs(root, 0, 0)\n        ans = []\n        for k in sorted(self.dictionary.keys()):\n            tmp = []\n            for l in sorted(self.dictionary[k].keys(), key=lambda y: -y):\n                tmp += sorted(self.dictionary[k][l])\n            \n            ans.append(tmp)\n        return ans", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if root == None:\n             return None\n         else:\n             node = root\n             visited = []\n             count = 0\n             while node or visited:\n                 if node:\n                     visited.append(node)\n                     node = node.left\n                 else:\n                     cur = visited.pop()\n                     count = count+1\n                     if count == k:\n                         return cur.val\n                     else:\n                         node = cur.right\n             return None\n         ", "class Solution:\n    def beautifulArray(self, N: int) -> List[int]:\n        r=[1]\n        while(len(r)<N):\n            o=[2*i-1 for i in r]\n            e=[2*(i) for i in r]\n            r=o+e\n        ans=[]\n        for i in range(len(r)):\n            if(r[i]<=N):\n                ans.append(r[i])\n        return ans\n        \n", "class Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        ptr = 0\n        def traverse(level: int) -> TreeNode:\n            nonlocal ptr\n            nextLevel = 0\n            while ptr < len(S) and S[ptr] == '-':\n                nextLevel += 1\n                ptr += 1\n                \n            if level == nextLevel: \n                val = ''\n                while ptr < len(S) and S[ptr] != '-':\n                    val += S[ptr]\n                    ptr += 1\n                node = TreeNode(int(val))\n                node.left = traverse(level+1)\n                node.right = traverse(level+1)\n                return node\n            else:\n                ptr -= nextLevel\n                return None\n\n        return traverse(0)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, path):\n            if node.left == None and node.right == None: \n                if len(path) >1:\n                    res[0] = max(res[0], abs(max(path) - min(path)))\n                return \n            \n            else:\n                \n                if node.left:\n                    dfs(node.left, path  + [node.left.val])\n                \n                if node.right: \n                    dfs(node.right, path + [node.right.val])\n                    \n                return \n                    \n        res = [-1*float('infinity')]\n        \n        dfs(root, [root.val])\n        \n        \n        return res[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    import collections\n    def maxLevelSum(self, root: TreeNode) -> int:\n#         bfs to do level traversal and calculate sum, update level if sum is larger\n        levelSum = float('-inf')\n        res = 0\n        queue = collections.deque()\n        queue.append((1, root))\n        while len(queue) != 0:\n            curr_sum = 0\n            for _ in range(len(queue)):\n                currl, curr = queue.popleft()\n                curr_sum += curr.val\n                if curr.left:\n                    queue.append((currl + 1, curr.left))\n                if curr.right:\n                    queue.append((currl + 1, curr.right))\n            if curr_sum > levelSum:\n                res = currl\n                levelSum = curr_sum\n        return res", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\n           return False\n         import operator\n         \n         for char, op in (('L', operator.gt), ('R', operator.lt)):\n           j = 0\n           for i, c in enumerate(start):\n             if c == char:\n               while j < len(end):\n                 if end[j] == char and op(j, i):\n                   return False\n                 elif end[j] == char:\n                   j += 1\n                   break\n                 j += 1\n \n         return True\n                 \n         \n", "class Solution:\n     def numRabbits(self, answers):\n         cnts = collections.Counter(answers)\n         return sum(-v % (k+1) + v for k, v in cnts.items())", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root == None: return []\n         m = collections.defaultdict(int)\n         self.helper(root, m)\n         max_value = max(m.values())\n         res = []\n         for v in m.keys():\n             if m.get(v) == max_value:\n                 res.append(v)\n         return res\n         \n     def helper(self, node, m):\n         if not node:\n             return 0\n         left, right = self.helper(node.left, m), self.helper(node.right, m)\n         m[node.val+left+right]+=1\n         return node.val + left + right", "class Solution:\n     def reachNumber(self, target):\n         \"\"\"\n         :type target: int\n         :rtype: int\n         \"\"\"\n         target = abs(target)\n         s = 0\n         for i in range( target+1):\n             s += i\n             if s >= target:\n                 break\n         if (s - target)&1 :\n             if (i+1)&1:\n                 return i+1\n             else:\n                 return i+2\n         else:\n             return i\n \n \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \\\"\\\"\\\"\n        return the root so that every node is a sufficient\n        Approach:\n        1. For any given node, if all of its children have a path sum < than limit, or None, delete the node\n        2. Post-order traversal, at the leaf node, if the path sum < than limit, delete node, then work your way up\n        \\\"\\\"\\\" \n        \n        leaf = True\n        # check left child alive\n        if root.left is not None:\n            root.left = self.sufficientSubset(root.left, limit - root.val)\n            leaf = False\n            \n        # check right child alive\n        if root.right is not None:\n            root.right = self.sufficientSubset(root.right, limit - root.val)   \n            leaf = False\n            \n        # if the node is not leaf and left and right are not alive -> set to null\n\\t\\t# if the node is leaf but less than limit -> set to null\n        if root.left is None and root.right is None and ( root.val < limit or not leaf):\n            root = None\n\n        return root\n                \n                \n                \n            \n                ", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         from collections import Counter\n         s = sorted(arr)\n \n         i = 0\n         a_nums = Counter()\n         b_nums = Counter()\n         total = 0\n         while i < len(arr):\n             a_nums[arr[i]] += 1\n             b_nums[s[i]] += 1\n             if a_nums == b_nums:\n                 a_nums.clear()\n                 b_nums.clear()\n                 total += 1\n             i += 1\n \n         return total", "from collections import namedtuple\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nleaf_info = namedtuple(\\\"Leaf_Info\\\", \\\"depth sum\\\")\n\n\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        def is_leaf(node: TreeNode) -> bool:\n            return node.left is None and node.right is None\n\n        def leaves(node: TreeNode, depth: int, path_sum: int) -> leaf_info:\n            if node is None:\n                yield leaf_info(0, 0)\n            elif is_leaf(node):\n                yield leaf_info(depth, node.val)\n            else:\n                yield from leaves(node.left, depth + 1, path_sum)\n                yield from leaves(node.right, depth + 1, path_sum)\n        \n        max_depth = 0\n        leaves_sum = 0\n        for leaf in leaves(root, 0, 0):\n            if leaf.depth > max_depth:\n                max_depth, leaves_sum = leaf\n            elif leaf.depth == max_depth:\n                leaves_sum += leaf.sum\n\n        return leaves_sum\n", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        def nextDay(cells):\n            ans = [0] #start\n            for i in range(1, len(cells) - 1):\n                ans.append(int(cells[i - 1] == cells[i + 1]))\n            ans.append(0)\n            return ans\n        \n        seen = {}\n        forwarded = False\n        \n        while N > 0: # when there is loop left\n            if not forwarded: # if cycle hasn't been detected\n                snapshot = tuple(cells)\n                if snapshot in seen: # detected cycle\n                    N %= seen[snapshot] - N # length of cycle\n                    forwarded = True\n                else:\n                    seen[snapshot] = N\n            if N > 0: # update snapshot to next day's\n                N -= 1\n                cells = nextDay(cells)\n        return cells\n        \n    # Given K number of cells, there could be at most 2**K possible states. If the number of steps is larger than all possible states (N > 2 ** K), we are destined to repeat ourselves sooner or later.\n", "class Solution:\n     def intersectionSizeTwo(self, intervals):\n         res = 0\n         last2 = [-float('inf')] * 2\n         intervals = sorted(intervals, key=lambda x: x[1])\n         for lo, hi in intervals:\n             n = sum(x < lo for x in last2)\n             res += n\n             if n == 2:\n                 last2 = hi - 1, hi\n             elif n == 1:\n                 last2 = last2[1], hi\n         return res\n", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def swapPairs(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         i = 1\n         node = head\n         prev = None\n         prev2 = None\n         while node is not None:\n             if i % 2 == 0 and i != 1:\n                 if prev2 is not None:\n                     prev2.next = node\n                 prev.next = node.next\n                 node.next = prev\n                 if i == 2:\n                     head = node\n                 node = prev\n             prev2 = prev\n             prev = node\n             node = node.next\n             i += 1\n         return head", "class Solution:\n     def findLadders(self, beginWord, endWord, wordList):\n         wordDict = set(wordList)\n         if endWord not in wordDict: return []\n         wordDict.discard(beginWord)\n         front, back = set([beginWord]), set([endWord])\n         length = 2\n         direction = 1\n         parents = collections.defaultdict(set)\n         \n         while front:\n             next_level = set()\n             for word in front:\n                 for index in range(len(beginWord)):\n                     p1, p2 = word[:index], word[index+1:]\n                     for ch in 'abcdefghijklmnopqrstuvwxyz':\n                         if word[index] != ch:\n                             next_word = p1 + ch + p2\n                             if next_word in wordDict:\n                                 next_level.add(next_word)\n                                 if direction == 1:\n                                     parents[next_word].add(word)\n                                 else:\n                                     parents[word].add(next_word)\n                             \n             if next_level & back:\n                 res = [[endWord]]\n                 while res and res[0][0] !=beginWord:\n                     res = [[p]+r for r in res for p in parents[r[0]]]\n                 return res\n                 \n             length += 1\n             front = next_level\n             if len(front) > len(back):\n                 direction *= -1\n                 front, back = back, front\n             wordDict -= front\n         return []\n         \n         \n         \n         \n         \n         \n         \"\"\"\n         :type beginWord: str\n         :type endWord: str\n         :type wordList: List[str]\n         :rtype: List[List[str]]\n         \"\"\"\n", "class Solution:\n     def countBits(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: List[int]\n         \"\"\"\n         ans = [0]\n         while len(ans) < num + 1:\n             ans += [1 + x for x in ans]\n         # len(ans) > num\n         return ans[:num+1]", "class NumArray:\n \n     def __init__(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         \"\"\"\n         l = len(nums)\n         self.nums = nums\n         self.bit = [0] * (l+1)\n         for i in range(1, l+1):\n             self.update_delta(i, nums[i-1])\n \n     def update(self, i, val):\n         \"\"\"\n         :type i: int\n         :type val: int\n         :rtype: void\n         \"\"\"\n         bit = self.bit\n         delta = val - self.nums[i]\n         self.nums[i] = val\n         self.update_delta(i+1, delta)\n \n     def sumRange(self, i, j):\n         \"\"\"\n         :type i: int\n         :type j: int\n         :rtype: int\n         \"\"\"\n         return self.get_sum(j+1) - self.get_sum(i)\n     \n     def get_sum(self, i):\n         bit = self.bit\n         res = 0\n         while i > 0:\n             res += bit[i]\n             i -= (i & -i)\n         \n         return res\n     \n     def update_delta(self, i, delta):\n         bit = self.bit\n         l = len(bit)\n         while i < l:\n             bit[i] += delta\n             i += (i & -i)\n             \n         \n \n \n # Your NumArray object will be instantiated and called as such:\n # obj = NumArray(nums)\n # obj.update(i,val)\n # param_2 = obj.sumRange(i,j)\n", "class Solution:\n \n     def find(self, u):\n         if self.parent[u] == u:\n             return u\n         else:\n             root_u = self.find(self.parent[u])\n             self.parent[u] = root_u\n             return self.find(self.parent[u])\n \n     def union(self, u, v):\n         parent_u = self.find(u)\n         parent_v = self.find(v)\n         self.parent[parent_u] = parent_v\n \n     def findCircleNum(self, M):\n         if len(M) == 0:\n             return 0\n         n = len(M)\n         self.parent = [i for i in range(n)]\n \n         for i in range(n):\n             for j in range(i+1, n):\n                 if M[i][j] == 1:\n                     self.union(i, j)\n         friend_set = set()\n         for i in range(n):\n             friend_set.add(self.find(i))\n \n         print(self.parent)\n         return len(friend_set)", "class Solution:\n     \n     def traverse_left(self, stack, node, node_depth, d):\n         while node_depth + 1 < d and node.left is not None:\n             stack.append((node.left, node_depth + 1))\n             node = node.left\n             node_depth += 1\n     \n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         \n         if d == 1:\n             new_root = TreeNode(v)\n             new_root.left = root\n             return new_root\n         \n         stack = [(root, 1)]\n         self.traverse_left(stack, root, 1, d)\n         \n         while not (not stack):\n             node, node_depth = stack.pop()\n             if node_depth + 1 < d and node.right is not None:\n                 stack.append((node.right, node_depth + 1))\n                 self.traverse_left(stack, node.right, node_depth + 1, d)\n               \n             if node_depth == d - 1:\n                 a = TreeNode(v)\n                 a.left = node.left\n                 node.left = a\n                 b = TreeNode(v)\n                 b.right = node.right\n                 node.right = b\n                 \n         return root\n         \n", "from functools import reduce\n class Solution:\n     def smallestRange(self, nums):\n         \"\"\"\n         :type nums: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         k = len(nums)\n         idx = [0]*k\n         \n         dic = collections.defaultdict(list)\n         \n         for i in range(k):\n             dic[nums[i][0]].append(i)\n         \n         mi, ma = min(dic.keys()), max(dic.keys())\n         \n         ret = (mi, ma)\n         while True:\n             for i in dic[mi]:\n                 idx[i] += 1\n                 if idx[i]==len(nums[i]):\n                     return ret\n                 dic[nums[i][idx[i]]].append(i)\n             dic.pop(mi)\n             mi, ma = min(dic.keys()), max(dic.keys())\n             if ma-mi<ret[1]-ret[0]:\n                 ret = (mi, ma)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         \n         leftmost = []\n         \n         def recurse(node, path):\n             nonlocal leftmost\n             \n             if node is None:\n                 return\n             \n             if len(path) > len(leftmost):\n                 leftmost = path\n                 \n             if 0 < len(path) == len(leftmost):\n                 if int(''.join(path), 2) < int(''.join(leftmost), 2):\n                     leftmost = path\n             \n             recurse(node.left, path + ['0'])\n             recurse(node.right, path + ['1'])\n \n         recurse(root, [])\n             \n         node = root\n         while leftmost:\n             if leftmost.pop(0) == '0':\n                 node = node.left\n             else:\n                 node = node.right\n                 \n         return node.val", "class Solution:\n     def solveNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[List[str]]\n         \"\"\"\n         queens = []\n         res = []\n         def backtracking(n, k, queens):\n             if k > n:\n                 return\n             elif len(queens) == n and k < n:\n                 return\n             elif len(queens) == n and k == n:\n                 temp = queens[:]                \n                 res.append(temp)\n             else:\n                 row =[0] * n\n                 temp_q = queens[:]\n                 for each in  temp_q:\n                     x, y = each[0], each[1]\n                     \n                     row[y] = 1\n                     if y + k - x < n:\n                         row[y + k - x] = 1\n                     if y - k + x >= 0:\n                         row[y - k + x] = 1\n                 \n                 for i in range(n):\n                     if row[i] == 0:\n                         temp_q.append((k,i))\n                         # print(temp_q)\n                         backtracking(n, k + 1, temp_q)\n                         temp_q.pop()\n                 \n                 \n                 \n         backtracking(n, 0, queens)\n         \n         layout = []\n         for q in res:\n             temp = []\n             for each in q:\n                 _row = \".\" * each[1] + \"Q\" + \".\" * (n - each[1] - 1)\n                 temp.append(_row)\n             layout.append(temp)\n         return layout", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         curr_path = []\n         if root == None:\n             return curr_path\n         else:\n             return self.pathSumHelper(root, sum, curr_path)\n         \n     def pathSumHelper(self, root, sum, curr_path):\n         new_path = curr_path + [root.val]\n         if root.left is None and root.right is None:\n             return [new_path] if sum == root.val else []\n         elif root.left is None:\n             return self.pathSumHelper(root.right, sum - root.val, new_path)\n         elif root.right is None:\n             return self.pathSumHelper(root.left, sum - root.val, new_path)\n         else:\n             return self.pathSumHelper(root.right, sum - root.val, new_path) + self.pathSumHelper(root.left, sum - root.val, new_path)", "# Definition for singly-linked list.\n # class ListNode(object):\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution(object):\n     def splitListToParts(self, root, k):\n         \"\"\"\n         :type root: ListNode\n         :type k: int\n         :rtype: List[ListNode]\n         \"\"\"\n         if not root: return [None for _ in range(k)]\n         length = 0;\n         i = root;\n         while i:\n             i = i.next;\n             length += 1;\n             \n         chunk_size = length//k\n         num_longer_chunks = length % k\n         \n         res = [chunk_size + 1] * num_longer_chunks + [chunk_size] * (k - num_longer_chunks)\n         \n         curr = root;\n         prev = None;\n         \n         for i,num in enumerate(res):\n             res[i] = curr;\n             for _ in range(num):\n                 prev = curr;\n                 curr = curr.next;\n             \n             prev.next = None;\n             \n         return res\n         ", "class Solution:\n     def validTicTacToe(self, board):\n         \"\"\"\n         :type board: List[str]\n         :rtype: bool\n         \"\"\"\n         valid_X,valid_O = 0,0\n         cnt_X, cnt_O = 0,0\n         # for i in range (3):\n         #     if board[i] == 'OOO' or board[i] =='XXX':\n         #         valid_row += 1\n         #     cnt_X += board[i].count('X')\n         #     cnt_O += board[i].count('O')\n         # sum_row = sum(valid_row)\n         for row in board:\n             if row == 'XXX':\n                 valid_X += 1\n             elif row == 'OOO':\n                 valid_O += 1\n             cnt_X += row.count('X')\n             cnt_O += row.count('O')\n             \n         a,b,c = board\n         for col in zip(a,b,c):\n             if col == 'XXX':\n                 valid_X += 1\n             elif col == 'OOO':\n                 valid_O += 1\n         if board[1][1] != ' ':   \n             if board[0][0] == board[2][2] == board[1][1]:\n                 if board[1][1] == 'X':\n                     valid_X += 1\n                 else:\n                     valid_O += 1\n             \n             if board[2][0] == board[0][2] == board[1][1]:\n                 if board[1][1] == 'X':\n                     valid_X += 1\n                 else:\n                     valid_O += 1\n             \n         if valid_X + valid_O > 1:\n             return False\n         if valid_X:\n             if cnt_X - cnt_O != 1:\n                 return False\n         elif valid_O:\n             if cnt_X != cnt_O:\n                 return False\n         else:\n             if not (0 <= cnt_X - cnt_O <= 1):\n                 return False\n         return True", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         q = []\n         def push(i,j):\n             if i<len(nums1) and j<len(nums2):\n                 heapq.heappush(q,[nums1[i]+nums2[j],i,j])\n         push(0,0) # pushing first sum into heap\n         res = []\n         while q and len(res) <k:\n             s,i,j = heapq.heappop(q) #pops out min till here\n             res.append([nums1[i],nums2[j]])\n             push(i,j+1)\n             if j == 0:\n                 push(i+1,0)\n         return res        ", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        px = arr[:]\n        \n        for i in range(1, len(px)):\n            px[i] ^= px[i-1]\n        \n        res = []\n        \n        for q in queries:\n            s, e = q[0], q[1]\n            r = px[e]\n\n            if s: r ^= px[s-1]\n            res.append(r)\n        \n        return res\n            \n", "class Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        final_list = []\n        def rec(node):\n            if node == None:\n                return None\n            node.left = rec(node.left)\n            node.right = rec(node.right)\n            if node.val in to_delete:\n                if node.left!= None:\n                    final_list.append(node.left)\n                if node.right!= None:\n                    final_list.append(node.right)\n                return None\n            return node\n        rec(root)\n        if root.val not in to_delete:\n            final_list.append(root)\n        return(final_list)\n", "import collections\nclass Solution:\n    def shortestBridge(self, A: List[List[int]]) -> int:\n        found = False\n        res=[]\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j]==1:\n                    self.dfs(A,i,j,res)\n                    found = True\n                    break\n            if found:\n                break\n        cnt =0       \n        while res:\n            tmp=[]\n            for x,y in res:\n                for dx,dy in ((1,0),(-1,0),(0,1),(0,-1)):\n                    if 0<=x+dx<len(A) and 0<=y+dy<len(A[0]) and A[x+dx][y+dy]!=2:\n                        if A[x+dx][y+dy]==0:\n                            A[x+dx][y+dy]=2\n                        if A[x+dx][y+dy]==1:\n                            return cnt\n                        tmp.append([x+dx,y+dy])\n            cnt+=1\n            res = tmp\n        return -1\n        \n        \n        \n        \n        \n    def dfs(self,A,i,j,res):\n        if 0<=i<len(A) and 0<=j<len(A[0]) and A[i][j]==1:\n            A[i][j]=2\n            res.append([i,j])\n            self.dfs(A,i+1,j,res)\n            self.dfs(A,i-1,j,res)\n            self.dfs(A,i,j-1,res)\n            self.dfs(A,i,j+1,res)", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         s=1\n         a=[[root,1]]\n         while 1:\n             b=[]\n             for p in a:\n                 if p[0].left:\n                     b.append([p[0].left,2*p[1]-1])\n                 if p[0].right:\n                     b.append([p[0].right,2*p[1]])\n             a=b\n             if a:\n                 s=max(s,a[-1][1]-a[0][1]+1)\n             else:\n                 break\n         return s", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        # First DFS to find the each island and the island components. Then do another DFS to find out \n        # the size of the islands if the were to join.\n        # TC = O(n^2), SC = O(n^2)\n        \n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        def dfs(i, j):\n            dic[(i, j)] = curr\n            count[curr] += 1\n            for dx, dy in directions:\n                a, b = i + dx, j + dy\n                if 0 <= a < m and 0 <= b < n and grid[a][b] == 1 and (a, b) not in dic:\n                    dfs(a, b)\n\n        def neighbours(i, j, adj):\n            for dx, dy in directions:\n                a, b = i + dx, j + dy\n                if 0 <= a < m and 0 <= b < n and grid[a][b] == 1 and dic[(a, b)] not in adj:\n                    adj.add(dic[(a, b)])\n            \n            return adj            \n        \n        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and (i, j) not in dic: \n                    curr += 1\n                    dfs(i, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1: \n                    res = max(res, count[dic[(i, j)]])\n                else:\n                    res = max(res, sum(count[r] for r in neighbours(i, j, set())) + 1)\n    \n        return res", "class Solution:\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\n        \n        res = []\n        def dfs(curr_num):\n            if curr_num>=low and curr_num<=high:\n                res.append(curr_num)\n            elif curr_num > high:\n                return\n            \n            if int(str(curr_num)[-1]) == 9:\n                return\n            dfs(curr_num*10 + int(str(curr_num)[-1])+1)\n                    \n        dfs(1)\n        dfs(2)\n        dfs(3)\n        dfs(4)\n        dfs(5)\n        dfs(6)\n        dfs(7)\n        dfs(8)\n        dfs(9)\n        return sorted(res)", "class Graph:\n    def __init__(self, v =0):\n        self.v = v\n        self.edge = []\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0]*n\n        \n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    \n    def union(self, u, v):\n        uroot, vroot = self.find(u), self.find(v)\n        if uroot == vroot:\n            return False\n        elif self.rank[uroot] < self.rank[vroot]:\n            self.parent[uroot] = vroot\n            self.rank[vroot] += 1\n        else:\n            self.parent[vroot] = uroot\n            self.rank[uroot] += 1\n        return True\n    \nclass Solution:\n    def distance(self, point1: List[int], point2: List[int]):\n        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points or len(points)<2:\n            return 0\n        n = len(points)\n        graph = Graph(n)\n        tot = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                d = self.distance(points[i], points[j])\n                graph.edge.append([i,j,d])\n\n        graph.edge = sorted(graph.edge, key=lambda item: item[2])\n        \n        uf = UnionFind(n)\n        for u,v,w in graph.edge:\n            if uf.union(u,v):\n                tot += w\n        return tot\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        # points = sorted(points, key = lambda x: x[0]**2 + x[1]**2)\n        # return points [:K]\n        \n        distance_dict = dict()\n        \n        def distance(xy):\n            xy = tuple(xy)\n            if xy in distance_dict:\n                return distance_dict[xy]\n            ans = xy[0]**2 + xy[1]**2\n            distance_dict[xy] = ans\n            return ans\n    \n        def _quicksort(points, left, right):\n                        \n            if left>right:\n                return\n            \n            pivot = right\n            lower = left\n            for i in range(left, right):\n                if distance(points[i]) <= distance(points[pivot]):\n                    points[lower], points[i] = points[i], points[lower]\n                    lower = lower + 1\n            \n            pivot = lower\n            points[pivot], points[right] = points[right], points[pivot]\n                        \n            if (K-1) <= pivot:\n                _quicksort(points, left, pivot-1)\n            else:\n                _quicksort(points, left, pivot-1)\n                _quicksort(points, pivot+1, right)\n            \n            return\n        \n        _quicksort(points, 0, len(points)-1)\n\n        return points[:K]", "from math import sqrt\n class Solution:\n     def largestDivisibleSubset(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[int]\n         \"\"\"\n         nums.sort()\n         l, prev = {}, {}  # length, previous number(largest divisor in nums)\n         max_l, end_number = 0, None\n         \n         for i in nums:\n             tmp_l, tmp_prev = 0, None\n             for j in range(1, 1 + int(sqrt(i))):\n                 if i % j == 0:\n                     tmp = i // j\n                     if tmp in prev and l[tmp] > tmp_l:\n                         tmp_l, tmp_prev = l[tmp], tmp\n                     if j in prev and l[j] > tmp_l:\n                         tmp_l, tmp_prev = l[j], j                    \n                     \n             tmp_l += 1\n             prev[i], l[i] = tmp_prev, tmp_l\n             \n             if tmp_l > max_l:\n                 max_l, end_number = tmp_l, i\n         \n         ans = []\n         while end_number is not None:\n             ans.append(end_number)\n             end_number = prev[end_number]\n         \n         return ans", "class Solution:\n     def reconstructQueue(self, people):\n         \"\"\"\n         :type people: List[List[int]]\n         :rtype: List[List[int]]\n         \"\"\"\n         people.sort(key=lambda x: (-x[0], x[1]))\n         result=[]\n         for person in people:\n             result.insert(person[1],person)\n         return result", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\n        return self.search(cloned, target)\n        \n    def search(self, head, target):\n        if head is None:\n            return None\n        if head.val == target.val:\n            return head\n        else:\n            left_node = self.search(head.left, target) \n            if left_node is None:\n                return self.search(head.right, target)\n            else:\n                return left_node", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def countNodes1(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         if root.left is None and root.right is None:\n             return 1\n         if root.left is None:\n             return 1 + self.countNodes(root.right)\n         if root.right is None:\n             return 1 + self.countNodes(root.left)\n         return 1 + self.countNodes(root.right) + self.countNodes(root.left)\n \n     def countNodes(self,root):\n         p = root \n         height = 0\n         while p:\n             height += 1\n             p = p.left\n         if height <= 1:\n             return height\n         \n         p = root\n         while p:\n             hr = 0\n             pr = p.right\n             while pr:\n                 hr += 1\n                 pr = pr.left\n             if hr == height - 1:\n                 return 2 ** (height-1) + self.countNodes(p.right)\n             return 2 ** (height-2) + self.countNodes(p.left)\n             \n         \n         ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        \n        lefts = [l[:] for l in grid]\n        ups = [l[:] for l in grid]\n        \n        for i in range(n):\n            for j in range(1,m):\n                if lefts[i][j]:\n                    lefts[i][j]+= lefts[i][j-1]\n\n        for j in range(m):\n            for i in range(1,n):\n                if ups[i][j]:\n                    ups[i][j]+= ups[i-1][j]\n        \n        rec = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    rec = max(rec,1)\n                    k = min(ups[i][j], lefts[i][j])\n                    for r in range(1,k):\n                        if lefts[i-r][j]>=r+1 and ups[i][j-r]>=r+1:\n                            rec=max(rec, (r+1)**2)\n        \n        return rec", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverse(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         counter = k\n         tail = head\n         prev = None\n         current = head\n         \n         while counter > 0 and current:\n             newCurrent = current.next\n             current.next = prev\n             prev = current\n             current = newCurrent\n             counter -= 1\n         \n         if counter > 0:\n             return self.reverse(prev, k - counter)\n         \n         head = prev\n             \n         return (head, tail, current)\n     \n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if k == 0:\n             return head\n         \n         head, tail, current = self.reverse(head, k)\n         while current:\n             joinedFragmentHead, newTail, newCurrent = self.reverse(current, k)\n             tail.next = joinedFragmentHead\n             tail = newTail\n             current = newCurrent\n             \n         return head", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def sortList(self, head):\n         l = []\n         traverse, traverse2 = head, head\n         while(traverse) != None:\n             l.append(traverse.val)\n             traverse = traverse.next\n         l.sort()\n         for num in l:\n             traverse2.val = num\n             traverse2 = traverse2.next\n         return head", "class Solution:\n     def nextGreatestLetter(self, letters, target):\n         \"\"\"\n         :type letters: List[str]\n         :type target: str\n         :rtype: str\n         \"\"\"\n         tmp = list(map(ord, letters))\n         d = [x - y for x, y in zip(tmp, [ord(target)] * len(letters))]\n        \n         for i in range(len(d)):\n             if d[i] <= 0:\n                 d[i] = 26 + d[i]\n         \n         return letters[d.index(min(d))]\n         \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if sorted(A) == A: return A\n        \n        n = len(A)\n        s = A[:]\n        for i in range(n-2, -1, -1):\n            s[i] = min(s[i], s[i+1])\n            if A[i] > s[i+1]:\n                j = n-1\n                while A[j] >= A[i]: j -= 1\n                A[i], A[j] = A[j], A[i]\n                return A\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        \n        c = []\n        asum = 0\n        for i in range(len(costs)):\n            a,b = costs[i]\n            price = b - a\n            asum += a\n            c.append(price)\n\n        refunds = sorted(c)\n        \n        for i in range(len(refunds) // 2):\n            asum += refunds[i]\n        \n        return asum", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n\\t\\t# Step - 1:\n        # we need to collect all possible stamp patters, like\n        # 'abcde'\n        # 'abcd*'\n        # '*bcde'\n        # 'abc**'\n        # '**cde'\n        # 'ab***'\n        # '*bc**'\n        # '**cd*'\n        # '***de'\n        # \u2018****e\u2019 and etc\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n\\t\\t# Step - 2\n        # '*****' is our final target\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]\n        ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import sys\n \n class Solution:\n     def __init__(self):\n         self.max = -sys.maxsize\n         \n     def maxPathSum(self, root):\n         self.mps(root)\n         return self.max\n     \n     def mps(self, root):\n         # returns max path-to-leaf from ROOT\n         if not root.left and not root.right: \n             self.max = max(self.max, root.val)\n             return root.val\n         if not root.left and root.right:\n             right = self.mps(root.right)\n             self.max = max(self.max, root.val, root.val + right)\n             return max(root.val, root.val + right)\n         if root.left and not root.right: \n             left = self.mps(root.left)\n             self.max = max(self.max, root.val, root.val + left)\n             return max(root.val, root.val + left)\n         left = self.mps(root.left)\n         right = self.mps(root.right)\n         self.max = max(self.max, root.val, left + root.val, root.val + right, left + root.val + right)\n         return max(root.val, left + root.val, right + root.val)\n", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         stack = []\n         mapping = collections.defaultdict(int)\n         s = \"\"\n         num = 0\n         i = 0\n         while i < len(formula):\n             c = formula[i]\n             if c.islower():\n                 s += c\n                 i += 1\n             elif c.isdigit():\n                 num = 10 * num + int(c)\n                 i += 1\n             else:\n                 if s != \"\":\n                     mapping[s] = mapping[s] + num if num > 0 else mapping[s] + 1\n                 s = \"\"\n                 num = 0\n                 i += 1\n                 if c.isupper():\n                     s = c\n                 elif c == '(':\n                     stack.append(mapping)\n                     mapping = collections.defaultdict(int)\n                 elif c == ')':\n                     while i < len(formula) and formula[i].isdigit():\n                         num = 10 * num + int(formula[i])\n                         i += 1\n                     prev = stack.pop()\n                     for k in mapping:\n                         prev[k] += mapping[k] * num\n                     mapping = prev\n                     num = 0\n         if s != \"\":\n             mapping[s] = mapping[s] + num if num > 0 else mapping[s] + 1\n         ans = []\n         for k, v in sorted(mapping.items()):\n             ans.append(k)\n             if v > 1:\n                 ans.append(str(v))\n         return ''.join(ans)\n", "class Solution(object):\n \n     def __init__(self):\n         self.res = []\n \n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         if tickets is None or len(tickets) == 0:\n             return []\n \n         dic = {}\n         dic_city = {}\n         for t in tickets:\n             if (t[0], t[1]) not in dic:\n                 dic[(t[0], t[1])] = 0\n             dic[(t[0], t[1])] += 1\n             if t[0] not in dic_city:\n                 dic_city[t[0]] = []\n             dic_city[t[0]].append(t[1])\n         for k in dic_city.keys():\n             dic_city[k] = set(dic_city[k])\n             dic_city[k] = list(dic_city[k])\n             dic_city[k].sort()\n         self.res = []\n         self.dfs(\"JFK\", dic, dic_city, [\"JFK\"], len(tickets)+1)\n         return self.res\n \n     def dfs(self, city, dic, dic_city, cur, tar):\n         if len(cur) == tar:\n             if not self.res:\n                 self.res = list(cur)\n             \n             return True\n         if city in dic_city:\n             citys = dic_city[city]\n             for c in citys:\n                 if (city, c) in dic and dic[(city, c)]>0:\n                     dic[(city, c)]-=1\n                     cur.append(c)\n                     if self.dfs(c, dic, dic_city, cur, tar):\n                         return True\n                     cur.pop()\n                     dic[(city, c)]+=1\n         return False", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         \n         def dfs( v, edgesOut, seen, pCounts ):\n             if seen[v] == 1:\n                 return []\n             else:\n                 if pCounts[v] > 0:\n                     return []\n                 else:\n                     seen[v] = 1\n                     order = [v]\n                     for e in edgesOut[v]:\n                         pCounts[e] -= 1\n                     for e in edgesOut[v]:\n                         order += dfs( e, edgesOut, seen, pCounts )\n                     return order\n         \n         seen = [0] * numCourses\n         pCounts = [0] * numCourses\n         edgesOut = [[] for __ in range(numCourses)]\n         for (a,b) in prerequisites:\n             edgesOut[b].append(a)\n             pCounts[a] += 1\n         \n         order = []\n         for v in range(numCourses):\n             order += dfs( v, edgesOut, seen, pCounts )\n         \n         if len(order) < numCourses:\n             return []\n         else:\n             return order\n         \n         \n         \n         \n         \n             \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        ans = 0\n        def recursive(root):\n            nonlocal ans\n            if not root.left and not root.right:\n                return 0, 0\n            left_cover = 1\n            right_cover= 1\n            left_camera = 0\n            right_camera  = 0\n            if root.left:\n                left_cover, left_camera = recursive(root.left)\n            if root.right:\n                right_cover, right_camera = recursive(root.right)\n            if not (left_cover and right_cover):\n                ans +=1\n                return 1, 1\n            elif left_camera or right_camera:\n                return 1, 0\n            else:\n                return 0, 0\n        return ans if recursive(root)[0] else ans+1\n                \n", "class Solution:\n     def countSmaller(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[int]\n         \"\"\"\n         s = sorted(nums)\n         c = []\n         for n in nums:\n             p = bisect.bisect_left(s, n)\n             c.append(p)\n             s.pop(p)\n         return c\n", "class Transaction(object):\n    def __init__(self, txn):\n        name, time, amount, city = txn.split(',')\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \n    def __str__(self):\n        return \\\"{},{},{},{}\\\".format(self.name, self.time, self.amount, self.city)\n    \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        ans = []\n        txns = list(map(Transaction, transactions))\n        for i, t in enumerate(txns):\n            d[t.name].append(i)\n        for name, tid in d.items():    \n            l = r = 0\n            for t in (tid := sorted(tid, key=lambda x:txns[x].time)):\n                if txns[t].amount > 1000:\n                    ans.append(t)\n                    continue\n                while l + 1 < len(tid) and txns[tid[l]].time + 60 < txns[t].time:\n                    l += 1\n                while r + 1 < len(tid) and txns[tid[r+1]].time <= txns[t].time + 60:\n                    r += 1\n                for j in range(l, r+1):\n                    if txns[tid[j]].city != txns[t].city:\n                        ans.append(t)\n                        break\n        return [str(transactions[i]) for i in ans]      ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        # \n        # minHeap | O(NlogN) | ----- 40 ms (50.65%) / 14.3 MB (5.13%)\n        # ------------------------------------------------------------------------------------------------\n        if not preorder:\n            return None\n        root = TreeNode(val=preorder[0])\n        parents = [(root.val, root)]\n        heapq.heapify(parents)\n        for idx in range(1, len(preorder)):\n            num = preorder[idx]\n            node = TreeNode(val=num)\n            tmp = None\n            while parents and parents[0][0] < num:\n                _, tmp = heapq.heappop(parents)\n            if tmp:\n                tmp.right = node\n            elif not tmp and parents:\n                parents[0][1].left = node\n            heapq.heappush(parents, (num, node))   \n        return root", "class Solution:\n    def solve(self,x):\n        a = max(1, int(math.sqrt(x)) )\n        while (a*(x//a))!=x:\n            a = max(1, a-1 )\n        return [a,x//a]\n    def closestDivisors(self, x):\n        a,b = self.solve(x+1)\n        if a==b:\n            return [a,b]\n        c,d = self.solve(x+2)\n        return [a,b] if (b-a)<=(d-c) else [c,d]", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         if not asteroids:\n             return asteroids\n \n         remaining = []\n         for item in asteroids:\n                             \n             itemSign, itemVal = self.getItemDetails(item)\n             shouldAppend = False\n \n             while True:\n                 if not remaining:\n                     shouldAppend = True\n                     break\n                 \n                 topSign, topVal = self.getItemDetails(remaining[-1])\n \n                 if not (topSign and not itemSign):\n                     shouldAppend = True\n                     break\n \n                 if topVal > itemVal:\n                     break\n                 elif topVal == itemVal:\n                     remaining.pop()\n                     break\n                 else:\n                     remaining.pop()\n                                                                     \n             if shouldAppend:\n                 remaining.append(item)\n \n         return remaining\n \n     def getItemDetails(self, val):\n         return val > 0, abs(val)", "# \"\"\"\n # This is the interface that allows for creating nested lists.\n # You should not implement it, or speculate about its implementation\n # \"\"\"\n #class NestedInteger:\n #    def __init__(self, value=None):\n #        \"\"\"\n #        If value is not specified, initializes an empty list.\n #        Otherwise initializes a single integer equal to value.\n #        \"\"\"\n #\n #    def isInteger(self):\n #        \"\"\"\n #        @return True if this NestedInteger holds a single integer, rather than a nested list.\n #        :rtype bool\n #        \"\"\"\n #\n #    def add(self, elem):\n #        \"\"\"\n #        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n #        :rtype void\n #        \"\"\"\n #\n #    def setInteger(self, value):\n #        \"\"\"\n #        Set this NestedInteger to hold a single integer equal to value.\n #        :rtype void\n #        \"\"\"\n #\n #    def getInteger(self):\n #        \"\"\"\n #        @return the single integer that this NestedInteger holds, if it holds a single integer\n #        Return None if this NestedInteger holds a nested list\n #        :rtype int\n #        \"\"\"\n #\n #    def getList(self):\n #        \"\"\"\n #        @return the nested list that this NestedInteger holds, if it holds a nested list\n #        Return None if this NestedInteger holds a single integer\n #        :rtype List[NestedInteger]\n #        \"\"\"\n \n class Solution:\n     def deserialize(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: NestedInteger\n         \"\"\"\n         return eval(s)\n #     def deserialize(self, s):\n #         def nestedInteger(x):\n #             if isinstance(x, int):\n #                 return NestedInteger(x)\n #             lst = NestedInteger()\n #             for y in x:\n #                 lst.add(nestedInteger(y))\n #             return lst\n #         return nestedInteger(eval(s))\n         \n         ", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # time O(h)\n        self.stream = deque([])\n        self.trie = {}\n        \n        for word in words:\n            node = self.trie\n            for char in word[::-1]:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['$'] = word\n\n    def query(self, letter: str) -> bool:\n        # time O(h)\n        self.stream.appendleft(letter)\n        node = self.trie\n        for char in self.stream:\n            if '$' in node:\n                return True\n            if char not in node:\n                return False\n            node = node[char]\n        \n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def matchPath(self, head, root):\n        if head is None:\n            return True\n        if root is None:\n            return False\n        \n        if head.val != root.val:\n            return False\n        \n        if self.matchPath(head.next, root.left):\n            return True\n        \n        if self.matchPath(head.next, root.right):\n            return True\n        \n        return False\n        \n    \n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        nexts = [root]\n        while len(nexts) > 0:\n            node = nexts.pop()\n            if node.val == head.val:\n                if self.matchPath(head, node):\n                    return True\n            if node.left:\n                nexts.append(node.left)\n            if node.right:\n                nexts.append(node.right)\n        \n        return False", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        c = [0, 0]\n        \n        def count(node):\n            if not node: return 0\n            l, r = count(node.left), count(node.right)\n            \n            if node.val == x:\n                c[0], c[1] = l, r\n                \n            return l + r + 1\n        \n        return count(root) / 2 < max(max(c), n - sum(c) - 1)\n        \n", "class Solution:\n     def complexNumberMultiply(self, a, b):\n         re_a, im_a = map(int, a.replace('i', '').split('+'))\n         re_b, im_b = map(int, b.replace('i', '').split('+'))\n         return str(re_a*re_b - im_a*im_b) + \"+\" + str(re_a*im_b+re_b*im_a) + \"i\"", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         result = []\n         current = [root]\n         clevel=1\n         while current:\n             next_level = []\n             vals = []\n             for node in current:\n                 vals.append(node.val)\n                 if node.left:\n                     next_level.append(node.left)\n                 if node.right:\n                     next_level.append(node.right)\n                     \n             if (clevel%2):\n                 result.append(vals)\n             else:\n                 result.append(vals[::-1])\n             clevel+=1\n             current = next_level\n         return result\n         ", "class Solution:\n     def isToeplitzMatrix(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         diagonals_upper = []\n         x, y = len(matrix[0]), len(matrix)\n         starters = [[0, i] for i in range(x)] + [[i, 0] for i in range(y)]\n         for starter in starters:\n             for j in range(min(x,y)):\n                 if starter[0] + j < y and starter[1] + j < x:\n                     print(starter[0] + j , starter[1] + j)\n                     if matrix[starter[0]][starter[1]] != matrix[starter[0] + j][starter[1] + j]:\n                         return False\n             print('\\n')\n         return True", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        if label==1:\n            return [1]\n        #else:\n        ans = []\n        for i in range(50):\n            if (2**i<=label)and(2**(i+1)-1>=label):\n                break\n            #print(i)\n        if i % 2 ==1:\n            label = 2**i + 2**(i+1) -1 - label\n        #print(label)\n        x=label\n        for j in range(i,-1,-1):\n            if j % 2 ==1:\n                ans.append(2**j + 2**(j+1) -1 - x)\n            else:\n                ans.append(x)\n            x = x // 2\n            \n            \n        return ans[::-1] \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        \n        def getArea(width):\n            res = 0\n            prev_low = 0\n            for low, high in intervals:\n                low = max(prev_low, low)\n                if high > low:\n                    res += (high - low)*width\n                    prev_low = high\n            return res\n\n        MOD = 10**9 + 7\n        # convert list of rectangles to events\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append((x1, 0, y1, y2)) #in\n            events.append((x2, 1, y1, y2)) #out\n        events.sort(key = lambda x : (x[0], x[1]))\n        \n        # sweep to calculate area\n        intervals = []\n        area = 0\n        prev_x = 0\n        for event in events:\n            cur_x, type, low, high = event\n            area += getArea(cur_x - prev_x)\n            if type == 1:\n                intervals.remove((low, high))\n            else:\n                intervals.append((low, high))\n                intervals.sort()   \n            prev_x = cur_x\n                \n        \n        return area % MOD", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        p=head\n        stack=[]\n        d=collections.defaultdict(deque)\n        res=[]\n        length=0\n        \n        while p:\n            while stack and stack[-1]<p.val:\n                val=stack.pop()\n                d[val].append(p.val)\n            stack.append(p.val)\n            p=p.__next__\n            length+=1\n        #print(d,[0]*length)   \n        while head:\n            #print(head.val)\n            if head.val in d:\n                if d[head.val]:\n                    res.append(d[head.val].popleft())\n                else:\n                    res.append(0)\n            else:\n                res.append(0)\n            head=head.__next__\n        return res\n            \n            \n        \n            \n            \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        #the output list\n        res = [0] * len(puzzles)\n        \n        #set up the trie using dictionary\n        dic = {}\n        for word in words:\n            cur = dic\n            for letter in sorted(set(word)):\n                if letter not in cur:\n                    cur[letter] = {}\n                cur = cur[letter]\n            # if only this word contains all the letters along the branch\n            if '*' not in cur:\n                cur['*'] = 1\n                \n            # if there exists other words that contain all the \n            # letters along the branch\n            else:\n                cur['*'] += 1\n        \n        # search the trie using depth first search;\n        # check_head checks whether the first letter of puzzle is in the word\n        def dfs(dic, i, check_head):\n            p = puzzles[i]\n            if '*' in dic and check_head:\n                # add the number of words that meet the specification to the                        \n\\t\\t\\t\\t# corresponding position of puzzle\n                res[i] += dic['*']\n            for key in dic:\n                if key in p:\n                    if p[0] == key or check_head:\n                        dfs(dic[key], i, True)\n                    else:\n                        dfs(dic[key], i, False)\n            else:\n                return\n        \n        # run dfs for all puzzles\n        for i in range(len(puzzles)):\n            dfs(dic, i, False)\n        \n        \n        # return result\n        return res ", "class Solution:\n    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:\n        dic_companies = {}\n        inx = 0\n        for companies in favoriteCompanies:\n            for company in companies:\n                if company not in dic_companies:\n                    dic_companies[company] = inx\n                    inx += 1\n\n        favorite_comp = []\n        for companies in favoriteCompanies:\n            val = 0\n            for company in companies:\n                val += 2** dic_companies[company]\n            favorite_comp.append(val)\n\n        res = []\n\n        for i in range(len(favorite_comp)):\n            flag = True\n            for j in range(len(favorite_comp)):\n                if i == j:continue\n                if favorite_comp[i] | favorite_comp[j] == favorite_comp[j]:\n                    flag = False\n                    break\n            if flag:\n                res.append(i)\n\n        return res", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        if not A or not B:\n            return []\n        m, n = len(A), len(B)\n        result = []\n        i = j = 0\n        while i<m and j<n:\n            start = max(A[i][0], B[j][0])\n            end = min(A[i][1], B[j][1])\n            \n            if start<=end:\n                result.append([start, end])\n            \n            if A[i][1]<B[j][1]:\n                i += 1\n            else:\n                j += 1\n        return result\n", "class Solution:\n     def solveEquation(self, equation):\n         \"\"\"\n         :type equation: str\n         :rtype: str\n         \"\"\"\n         left_x = right_x = 0\n         left_const = right_const = 0\n         \n         cur_left = True\n         cur_num = 0\n         cur_sign = 1\n         has_num = False\n         for c in equation:\n             if c == \"=\":\n                 left_const += cur_num * cur_sign\n                 cur_num = 0\n                 cur_sign = 1\n                 cur_left = False\n                 has_num = False\n             elif c in '+-':\n                 if cur_left:\n                     left_const += cur_num * cur_sign\n                 else:\n                     right_const += cur_num * cur_sign\n                 cur_num = 0\n                 cur_sign = 1 if c == '+' else -1\n                 has_num = False\n             elif c == 'x':\n                 if cur_left:\n                     left_x += cur_sign* (cur_num if has_num else 1)\n                 else:\n                     right_x += cur_sign* (cur_num if has_num else 1)\n                 cur_num = 0\n                 has_num = False\n             else:\n                 cur_num = cur_num * 10 + int(c)\n                 has_num = True\n             \n             # print(left_x, right_x, left_const, right_const, cur_num, cur_sign)\n         \n         right_const += cur_num*cur_sign\n         left_x -= right_x\n         right_const -= left_const\n         \n         if left_x == 0 and right_const == 0:\n             return \"Infinite solutions\"\n         elif left_x == 0 and right_const != 0:\n             return \"No solution\"\n         else:\n             return \"x=\" + str(int(right_const/left_x))", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ma = 0\n        for i in matrix:\n            c = matrix.count(i)+matrix.count([1-x for x in i])\n            if c > ma:\n                ma = c\n       \n        return ma", "class Twitter(object):\n \n     def __init__(self):\n         self.timer = itertools.count(step=-1)\n         self.tweets = collections.defaultdict(collections.deque)\n         self.followees = collections.defaultdict(set)\n \n     def postTweet(self, userId, tweetId):\n         self.tweets[userId].appendleft((next(self.timer), tweetId))\n \n     def getNewsFeed(self, userId):\n         tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\n         return [t for _, t in itertools.islice(tweets, 10)]\n \n     def follow(self, followerId, followeeId):\n         self.followees[followerId].add(followeeId)\n \n     def unfollow(self, followerId, followeeId):\n         self.followees[followerId].discard(followeeId)\n         \n \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)\n", "from collections import Counter\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        universal_words = []\n        required_counts = {}\n        for pattern in B:\n            for char in pattern:\n                char_sum = sum(1 for i in pattern if i == char)\n                if char not in required_counts or required_counts[char] < char_sum:\n                    required_counts[char] = char_sum\n        print(required_counts)\n        for word in A:\n            universal = True\n            for char in required_counts:\n                char_count = sum(1 for i in word if i == char)\n                if char_count < required_counts[char]:\n                    universal = False\n            if universal:\n                universal_words.append(word)\n        return universal_words", "import itertools\n\nclass Solution:\n  def numPoints(self, points: List[List[int]], r: int) -> int:\n    # http://www4.comp.polyu.edu.hk/~csbxiao/paper/2004/ISPAN04_cover.pdf\n    # TC: O(N^3), possible O(N^2logN), SC: O(1)\n    ans = 1\n    for (x1, y1), (x2, y2) in itertools.combinations(points, 2):\n      d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) / 4.0\n      if d <= r * r:\n        x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n        y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n        ans = max(ans, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in points))\n    return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y]):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n                    \n                \n    def recursive(self, total, x, y, grid, visited):\n        if (grid[x][y] == 0):\n            return total\n        \n        if ((x,y) in visited):\n            return total\n        \n        visited.add((x,y))\n        total = total + grid[x][y]\n        # left = (x-1,y)\n        # right = (x+1,y)\n        # top = (x,y-1)\n        # btm = (x,y+1)\n        left,right,top,btm = total,total,total,total\n        \n        if (x > 0):\n            left = self.recursive(total, x-1, y, grid, set(visited))\n        \n        if (x < len(grid)-1):\n            right = self.recursive(total, x+1, y, grid, set(visited))\n            \n        if (y > 0):\n            top =self.recursive(total, x, y-1, grid, set(visited))\n        \n        if (y < len(grid[x])-1):\n            btm = self.recursive(total, x, y+1, grid, set(visited))\n        \n        return max(left, right, top, btm, total)\n            \n        \n", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         dummy = ListNode(0)\n         new_head = dummy\n         prev = None\n         n = 0\n         while head:\n             if prev is None:\n                 prev = head\n                 n = 1\n             elif head.val != prev.val:\n                 if n < 2:\n                     new_head.next = prev\n                     new_head = prev\n                 prev = head\n                 n = 1\n             else:\n                 n += 1\n \n             head = head.next\n         if n == 1:\n             new_head.next = prev\n             new_head = new_head.next\n         new_head.next = None\n         return dummy.next\n         ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n            \n        if not root: return TreeNode(val)\n        \n        if root.val<val: \n            node = TreeNode(val)\n            node.left=root\n            return node\n        else:\n            root.right = self.insertIntoMaxTree(root.right, val)\n                    \n        return root\n    \n    \n        # if(root==None):\n        #     return TreeNode(val)       \n        # if(root.val<val):\n        #         temp = TreeNode(val)\n        #         temp.left = root\n        #         return temp\n        # else:\n        #         root.right = self.insertIntoMaxTree(root.right, val)\n        # return root    \n", "class Solution:\n     def reverseBetween(self, head, m, n):\n         \"\"\"\n         :type head: ListNode\n         :type m: int\n         :type n: int\n         :rtype: ListNode\n         \"\"\"\n         if head is None or head.__next__ is None or m == n: return head\n         h = ListNode(-1)\n         h.next = head\n         fast = slow = h\n         for _ in range(n - m + 1):\n             fast = fast.__next__\n             \n         for _ in range(m - 1):\n             fast = fast.__next__\n             slow = slow.__next__\n             \n         prev = fast.__next__\n         curr = slow.__next__\n         while prev != fast:\n             temp = curr.__next__\n             curr.next = prev\n             prev = curr\n             curr = temp\n         slow.next = prev\n         \n         return h.__next__\n", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def removeNthFromEnd(self, head, n):\n         \"\"\"\n         :type head: ListNode\n         :type n: int\n         :rtype: ListNode\n         \"\"\"\n         dummy = ListNode(0)\n         dummy.next = head\n         slow = fast = dummy\n \n         for _ in range(n):\n             fast = fast.next\n \n         while fast.next != None:\n             fast = fast.next\n             slow = slow.next\n \n         slow.next = slow.next.next\n         temp = dummy.next\n         while temp != None:\n             print(temp.val)\n             temp = temp.next\n         return dummy.next", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        res = [''] * 17\n        n = len(req_skills)\n        def dfs(idx, has, path):\n            nonlocal res\n            if idx == n:\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, has, path)\n            else:\n                if len(path) + 1 < len(res):\n                    for i, p in enumerate(people):\n                        p = set(p)\n                        if req_skills[idx] in p:\n                            union = p & has\n                            has |= p\n                            dfs(idx + 1, has, path + [i])\n                            has -= p\n                            has |= union\n        dfs(0, set(), [])\n        return res\n                        \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        S=s\n        N = len(S)\n        graph = [[] for _ in range(N)]\n        for u, v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n        ans = [None] * N\n        \n        seen = [False] * N\n        for u in range(N):\n            if not seen[u]:\n                seen[u] = True\n                stack = [u]\n                component = []\n                while stack:\n                    node = stack.pop()\n                    component.append(node)\n                    for nei in graph[node]:\n                        if not seen[nei]:\n                            seen[nei] = True\n                            stack.append(nei)\n                \n                component.sort()\n                letters = sorted(S[i] for i in component)\n                for ix, i in enumerate(component):\n                    letter = letters[ix]\n                    ans[i] = letter\n        return \\\"\\\".join(ans)\n        ", "# Solution! DFS\n class Solution:\n # @param board, a 9x9 2D array\n # Solve the Sudoku by modifying the input board in-place.\n # Do not return any value.\n     def solveSudoku(self, board):\n         res = self.dfs(board)\n         # board = copy.copy(res)\n         for n, row in enumerate(res):\n             board[n] = row #''.join(row)\n \n     def dfs(self, board):\n         stack = [board]\n         while stack:\n             s = stack.pop()\n             result = self.fill_board(s)\n             if result == 'complete':\n                 return s\n             for r in result:\n                 stack.append(r)\n             \n     def fill_board(self, board):\n         digits = set('123456789')\n         choice, best = {}, []\n         for j in range(9):\n             for i in range(9):\n                 if board[j][i] == '.':\n                     square = {board[j//3*3+y][i//3*3+x]\n                               for y in range(3) for x in range(3)}\n                     row = {board[j][x] for x in range(9)}\n                     col = {board[y][i] for y in range(9)}\n                     rest = digits.difference(square, row, col)\n                     if len(rest) == 1:\n                         board[j][i] = rest.pop()\n                         return self.fill_board(board)\n                     elif len(rest) == 0:\n                         return ''\n                     else:\n                         choice[(j, i)] = rest\n         if not choice:\n             return 'complete'\n         y, x = min(choice, key=lambda k: len(choice[k]))\n         for n in choice[(y, x)]:\n             b = copy.deepcopy(board)\n             b[y][x] = n\n             best.append(b)\n         return best", "class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        seen = set()\n        q = collections.deque()\n        q.append((0, 0, k))\n        seen.add((0, 0, k))\n        steps = 0\n        direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        if 0 == m - 1 and 0 == n - 1:\n            return 0\n        \n        while q:\n            for i in range(len(q)):\n                r, c, k = q.popleft()\n\n                for x, y in direction:\n                    R = r + x\n                    C = c + y\n\n                    if (R, C, k) in seen:\n                        continue\n\n                    if R >= 0 and R < m and C >= 0 and C < n:\n                        if k > 0 and grid[R][C] == 1 and (R, C, k - 1) not in seen:\n                            q.append((R, C, k - 1))\n                            seen.add((R, C, k - 1))\n\n                        if grid[R][C] == 0 and (R, C, k) not in seen:\n                            if R == m - 1 and C == n - 1:\n                                return steps + 1\n                            q.append((R, C, k))\n                            seen.add((R, C, k))\n            steps += 1\n        \n        return -1", "import collections\nclass Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        \n        d = collections.defaultdict(list)\n        out = []\n        \n        for i,ele in enumerate(groupSizes):\n            \n            d[ele].append(i)\n            print(d)\n            if len(d[ele]) == ele:\n                    out.append(d[ele])\n                    del d[ele]\n        return out\n", "class Solution:\n     def dominantIndex(self, nums):\n \n         if len(nums) > 1:\n             n = max(nums)\n             id = nums.index(n)\n             nums.remove(n)\n             return id if n >= max(nums)*2 else -1\n         else:\n             return 0", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         def h(node):\n             if not node:\n                 return 0\n             return 1+max(h(node.left), h(node.right))\n         \n         height = h(root)\n         m = height\n         n = 2**height-1\n         ret = [['' for _ in range(n)] for __ in range(m)]\n         \n         def put(node, i, l, r):\n             mid = (l+r)//2\n             ret[i][mid] = str(node.val)\n             if node.left:\n                 put(node.left, i+1, l, mid-1)\n             if node.right:\n                 put(node.right, i+1, mid+1, r)\n                 \n         put(root, 0, 0, n-1)\n         return ret", "class Solution:\n    def numSubmat(self, a: List[List[int]]) -> int:\n        \n        '''\n            1 0 1\n            1 1 0\n            1 1 0\n            \n            -> row0 ~ row0 -> col0 ~ col2 -> 1 x 1: 2\n            -> row0 ~ row1 -> col0 ~ col2 -> 1 x 2: 1\n            -> row0 ~ row2 -> col0 ~ col2 -> 1 x 3: 1\n            -> row1 ~ row1 -> col0 ~ col2 -> 1 x 1: 2\n            -> row1 ~ row2 -> col0 ~ col2 -> 1 x 2: 2, 2 x 1: 2, 2 x 2 = 1\n            -> row2 ~ row2 -> col0 ~ col2 -> 1 x 1: 2\n            \n            2 + 1 + 1 + 2 + 2 + 2 + 1 + 2\n                = 13                                \n        '''\n        m = len(a)\n        n = len(a[0])\n        \n        def oneDHelper(A):\n            res = 0\n            l = 0\n            for i in range(0, len(A)):\n                if A[i] == 0:\n                    l = 0        \n                else:\n                    l = l + 1        \n                res += l                \n            return res\n\n        count = 0\n        for r1 in range(0, m):            \n            isAll1 = a[r1]            \n            for r2 in range(r1, m):\n                \n                for c in range(0, n):\n                    if a[r2][c] == 0:\n                        isAll1[c] = 0\n                \n                count += oneDHelper(isAll1)\n                                                \n        return count\n                \n                \n                    \n                    \n                    \n                    \n                    \n                \n                \n                \n                          \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def split(N,s):\n            if not s: \n                return N\n\n            c = sum(N[-2:])\n            if s.startswith(str(c)):\n                return split(N + [c], s[len(str(c)):])\n\n        for i in range(1,len(S)):\n            for j in range(i+1, len(S)):\n                a = int(S[:i])\n                b = int(S[i:j])\n                if str(a) == S[:i] and str(b) == S[i:j]:\n                    ans = split([a, b], S[j:])\n                    if ans and all(x<=2**31-1 for x in ans):\n                        return ans\n                \n        return []", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        '''\n        Build trie from the folders, whenever a folder ends, just drop all of its children (subfolders) in the trie.\n        Time O(N) to build the trie and do DFS\n        Space O(N) for the trie\n        '''\n        trie = {}\n        for f in folder:\n            path = f.split('/')[1:]\n            cur = trie\n            for idx, p in enumerate(path):\n                if idx == len(path) - 1:\n                    # this is the ending folder\n                    cur[p] = '#'\n                else:\n                    if p in cur:\n                        if cur[p] != '#':\n                            cur = cur[p]\n                        else:\n                            # we see an ending folder, stop adding subfolders to it\n                            break\n                    else:\n                        cur[p] = {}\n                        cur = cur[p]\n        \n        # do a DFS of the trie to get the answers\n        ans = []\n        def dfs(cur_dir, path):\n            if cur_dir == '#':\n                ans.append('/' + '/'.join(path))\n                return\n            for k in cur_dir:\n                dfs(cur_dir[k], path + [k])\n            return\n        dfs(trie, [])\n        return ans\n            \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def dfs(node, cur_num):\n             if node is None: return 0\n             my_num = cur_num * 10 + node.val\n             if node.left is None and node.right is None: return my_num\n             return dfs(node.left, my_num) + dfs(node.right, my_num)\n         \n         return dfs(root,0)", "class Solution:\n     def nearestPalindromic(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         evenPal = lambda sp : int(sp + sp[::-1])\n         oddPal = lambda sp : int(sp + sp[::-1][1:])\n         sn, n = n, int(n)\n         if len(sn) == 1: return str(n - 1)\n         ans = -999999999999999999\n         mid = len(sn) // 2\n         for sp in sn[:mid], sn[:mid + 1], str(int(sn[:mid]) * 10):\n             p = int(sp)\n             for pal in evenPal, oddPal:\n                 for d in -1, 0, 1:\n                     val = pal(str(p + d))\n                     if val == n: continue\n                     ans = min(ans, val, key = lambda x : (abs(x - n), x))\n         return str(ans)\n", "class Solution:\n     def maximalSquare(self, matrix):\n         \"\"\"\n         :type matrix: List[List[str]]\n         :rtype: int\n         \"\"\"\n         if len(matrix) == 0 or len(matrix[0]) == 0:\n             return 0\n         \n         dp = [[0 for i in range(len(matrix[0]))] for i in range(len(matrix))]\n         \n         largest = 0;\n         for i in range(len(matrix)):\n             dp[i][0] = int(matrix[i][0])\n             largest = max(largest, dp[i][0])\n             \n         for j in range(len(matrix[0])):\n             dp[0][j] = int(matrix[0][j])\n             largest = max(largest , dp[0][j])\n             \n         \n         \n         for i in range(1, len(matrix)):\n             for j in range(1, len(matrix[0])):\n                 if matrix[i][j] == '1':\n                     if dp[i - 1][j] >= dp[i - 1][j - 1] and dp[i][j - 1] >= dp[i - 1][j - 1]:\n                         dp[i][j] = dp[i - 1][j - 1] + 1\n \n                     else:\n                         dp[i][j] = min(int(dp[i - 1][j]), int(dp[i][j - 1])) + 1\n                 else:\n                     dp[i][j] = 0\n                 \n                 largest = max(largest, dp[i][j])\n         \n         \n         return largest * largest\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def splitBST(self, root, V):\n         \"\"\"\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if not root:\n             return [None,None]\n         if root.val==V:\n             temp= root.right\n             root.right= None\n             return [root, temp]\n         if root.val<V:\n             small, large= self.splitBST(root.right, V)\n             root.right=small\n             return [root, large]\n         if root.val>V:\n             small, large= self.splitBST(root.left, V)\n             root.left=large\n             return [small, root]\n             \n             \n             ", "class Solution:\n     def isIdealPermutation(self, A):\n         \"\"\"\n         :type A: List[int]\n         :rtype: bool\n         \"\"\"\n         \n         l=[]\n         [1,0,3,2]\n         # ix=0\n         # while ix<len(A)-1:\n         #     if A[ix]>A[ix+1]:\n         #         l.append(A[ix])\n         #         ix+=2\n         #         if A[ix]<l[-1]:return False\n         #     else:\n         #         ix+=1\n         # return True\n         if len(A)==1:return True\n         for i in range(len(A)):\n             if abs(A[i]-i)>1:return False\n         return True", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         ans = []\n         if (root == None): return ans\n         self.helper(root,ans)\n         return ans\n     \n     def helper(self,root,ans):\n         if (root == None):\n             return\n         self.helper(root.left,ans)\n         self.helper(root.right,ans)\n         ans.append(root.val)", "class MagicDictionary:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.dict = collections.defaultdict(list)\n \n     def buildDict(self, dict):\n         \"\"\"\n         Build a dictionary through a list of words\n         :type dict: List[str]\n         :rtype: void\n         \"\"\"\n         for word in dict:\n             self.dict[len(word)].append(word)\n \n     def search(self, word):\n         \"\"\"\n         Returns if there is any word in the trie that equals to the given word after modifying exactly one character\n         :type word: str\n         :rtype: bool\n         \"\"\"\n         n = len(word)\n         print((word, self.dict[n]))\n         for item in self.dict[n]:\n             count = 0\n             for i in range(n):\n                 if count > 1: continue\n                 if item[i] != word[i]: count += 1\n             if count == 1:\n                 return True\n         return False\n                     \n         \n \n \n # Your MagicDictionary object will be instantiated and called as such:\n # obj = MagicDictionary()\n # obj.buildDict(dict)\n # param_2 = obj.search(word)\n", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.visited = [ [ 0 for _ in range(len(grid[0])) ] for _ in range(len(grid))]\n        def dfs(i, j):\n            if i < 0 or j < 0 or i>=len(self.grid) or j>=len(self.grid[0]) :\n                return False\n            if self.grid[i][j] == 1 or self.visited[i][j]==1:\n                return True\n            self.visited[i][j] = 1\n            neighbs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n            ans = True\n            for x, y in neighbs:\n                curr = dfs(i+x, j+y)\n                if curr == False:\n                    ans = False\n            return ans\n        \n        ans = 0\n        for i in range(len(self.grid)):\n            for j in range(len(self.grid[0])):\n                if self.visited[i][j]==0 and self.grid[i][j]==0:\n                    isclosed = dfs(i, j)\n                    if isclosed==True:\n                        ans+=1\n        return ans\n", "from collections import Counter\nclass Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        dp={}\n\n        lstp=[]\n        \n        ans=[]\n        for i,p in enumerate(pattern) :\n            if p not in list(dp.keys()):\n                dp[p]=i+1\n            lstp.append(dp[p])\n        #print(lstp)\n        \n        for word in words:\n            dp={}\n            lst=[]\n            for j,w in enumerate(word):\n                if w not in list(dp.keys()):\n                    dp[w]=j+1\n                lst.append(dp[w])\n            #print(lst)\n            if lstp==lst:\n                ans.append(word)\n        return ans\n                \n                \n                \n            \n", "class Solution:\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\n        arr.sort()\n        for hour in range(23, -1, -1):\n            for minute in range(59, -1, -1):\n                candidate = sorted([ hour // 10, hour % 10, minute // 10, minute % 10])\n                if candidate == arr:\n                    return \\\"%s%s:%s%s\\\" % (hour // 10, hour % 10, minute // 10, minute % 10)\n        return \\\"\\\"\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def method1(dislikes):\n            class UF:\n                def __init__(self, size):\n                    self.p=list(range(size))\n                    \n                def find(self,x):\n                    if x!=self.p[x]:\n                        self.p[x]=self.find(self.p[x])\n                    return self.p[x]\n                \n                def union(self,x,y):\n                    self.p[self.find(x)]=self.find(y)\n                    \n                def find_all(self):\n                    for i in range(len(self.p)):\n                        self.find(i) \n               \n            if N<2 or not dislikes:\n                return True\n            \n            dislikes=set(map(tuple,dislikes))\n            #print(dislikes)\n            uf=UF(N)\n            for i in range(1,N+1):\n                for j in range(i+1,N+1):\n                    if (i,j) not in dislikes and (j,i) not in dislikes :\n                        #print(i,j)\n                        uf.union(i-1,j-1)\n                    \n            #uf.find_all()\n            #print(uf.p)\n            \n            return len(set(uf.p))==2\n        #return method1(dislikes)\n    \n        def method2():\n            graph=collections.defaultdict(list)\n            for u,v in dislikes:\n                graph[u].append(v)\n                graph[v].append(u)\n                \n            color={}\n            def dfs(node,c=0):\n                if node in color:\n                    return color[node]==c\n                color[node]=c\n                return all(dfs(nei,c^1) for nei in graph[node])\n            \n            return all(dfs(node) for node in range(1,N+1) if node not in color)\n        \n        return method2()\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.numList=[]\n\n    def add(self, num: int) -> None:\n        self.numList.append(num)\n\n    def getProduct(self, k: int) -> int:\n        prodList=self.numList[(-1*k):]\n        \n        #prod=1\n        #length=len(self.numList)\n        #for i in range(length-k, length):\n        #    prod = prod * self.numList[i]\n            \n        return math.prod(prodList)\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         if len(inorder) == 0:\n             return\n         #\u6784\u5efa\u5143\u7d20\u503c\u4e3akey, index\u4e3avalue\u7684hashmap\n         HashMap = {}\n         for i in range(len(inorder)):\n             HashMap[inorder[i]] = i\n         \n         root = self.build(HashMap, inorder, 0, len(inorder)-1, preorder, 0, len(preorder)-1)\n         return root\n     \n     def build(self, HashMap, inorder, istart, iend, preorder, pstart, pend):\n         if istart>iend or pstart > pend:\n             return None\n \n         root = TreeNode(preorder[pstart])\n         mid_index = HashMap[root.val]\n         left_size = mid_index - istart\n         right_size = iend - mid_index\n         root.left = self.build(HashMap, inorder, istart, mid_index-1, preorder, pstart+1, pstart+left_size)\n         root.right = self.build(HashMap, inorder, mid_index+1, iend, preorder, pend-right_size+1, pend)\n         return root", "class Solution:\n     def searchMatrix(self, matrix, target):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :type target: int\n         :rtype: bool\n         \"\"\"\n         if len(matrix)==0:\n             return False\n         minrow, maxcol = 0, len(matrix[0])-1\n         \n         while(minrow<len(matrix) and maxcol>=0):\n             if target == matrix[minrow][maxcol]:\n                 return True\n             elif target < matrix[minrow][maxcol]:\n                 maxcol-=1\n             else:\n                 minrow+=1\n         return False", "class Solution:\n    def circularPermutation(self, n, start):\n        def g(x):\n            return x^(x>>1)    \n        \n        return [start ^ g(i) for i in range(1 << n)]", "class Solution:\n     def pourWater(self, heights, V, K):\n         \"\"\"\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         \"\"\"\n         \n         for i in range(V):\n             if not self.fallLeft(K, heights):\n                 if not self.fallRight(K, heights):\n                     heights[K] += 1\n         \n         return heights\n     \n     def fallLeft(self,K, heights):\n         minBlock = K\n         for i in range(K-1, -1, -1):\n             if heights[i] < heights[minBlock]:\n                 minBlock = i\n             elif heights[i] > heights[minBlock]:\n                 break\n         if minBlock == K:\n             return False\n         heights[minBlock] += 1\n         return True\n         \n     \n     def fallRight(self,K, heights):\n         minBlock = K\n         for i in range(K+1, len(heights)):\n             if heights[i] < heights[minBlock]:\n                 minBlock = i\n             elif heights[i] > heights[minBlock]:\n                 break\n         if minBlock == K:\n             return False\n         heights[minBlock] += 1\n         return True", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        distance = [[float('inf'), float('inf')] for _ in range(n)]\n        distance[0][0] = 0 # red\n        distance[0][1] = 0 # blue\n        \n        for _ in range(n):\n            for u, v in red_edges:\n                if distance[u][1] + 1 < distance[v][0]:\n                    distance[v][0] = distance[u][1] + 1\n            for u, v in blue_edges:\n                if distance[u][0] + 1 < distance[v][1]:\n                    distance[v][1] = distance[u][0] + 1\n        \n        min_distance = []\n        for d in distance:\n            min_d = min(d)\n            if min_d < float('inf'):\n                min_distance.append(min_d)\n            else:\n                min_distance.append(-1)\n        return min_distance\n        \n'''\n\ndistance[X][0] distance upto X with last edge red\ndistance[X][1]                      last edge blue\n\n\n\n'''", "from collections import defaultdict\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        dlist=[1]*10\n        for i in range(9):\n            dlist[i+1]=dlist[i]*2\n        count=defaultdict(int)\n        dp=dict()\n        ans=0\n        dp[0]=-1\n        for i,num in enumerate(s):\n            count[num]+=1\n            cur=0\n            curdp=10*[0]\n            for ar in range(10):\n                st=str(ar)\n                val=count[st]%2\n                cur+=(val*dlist[ar])\n                curdp[ar]=val\n            if cur in dp:\n                ans=max(ans,i-dp[cur])\n            else:\n                dp[cur]=i\n            for ar in range(10):\n                if curdp[ar]==1:\n                    val=-1\n                else:\n                    val=1\n                cur+=val*dlist[ar]\n                if cur in dp:\n                    ans=max(ans,i-dp[cur])\n                cur-=val*dlist[ar]\n        return ans\n", "class Solution:\n     def findLongestChain(self, pairs):\n         \"\"\"\n         :type pairs: List[List[int]]\n         :rtype: int\n         \"\"\"\n         queue = collections.deque(sorted(pairs, key=lambda pair: pair[1]))\n         \n         count = 0\n         \n         while len(queue) > 0:\n           count += 1\n           curr = queue.popleft()\n           while len(queue) > 0 and queue[0][0] <= curr[1]:\n             queue.popleft()\n         \n         return count\n           \n         \n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.N = combinationLength\n        self.cl = len(characters)\n        self.sym = characters\n        self.precom = self.__pre(self.cl, combinationLength)\n        self.index = len(self.precom)-1\n    def __next__(self) -> str:\n        curr = self.precom[self.index]\n        res = []\n        for i,c in enumerate(curr):\n            if c == '1':\n                res.append(self.sym[i])\n        self.index -= 1\n        return ''.join(res)\n    def hasNext(self) -> bool:\n        if self.index < 0:\n            return False\n        return True\n    def __pre(self, N, M):\n        maxi = 2**N\n        res = []\n        for curr in range(maxi):\n            binary = bin(curr)[2:]\n            if binary.count('1') == M:\n                res.append(binary.zfill(N))\n        return res\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n\n\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head or not G:\n            return 0\n        \n        ht = {}\n        for component in G:\n            ht[component] = True\n        if head.val in ht:\n            total = 1\n        else:\n            total = 0\n        prev = head\n        while(head.next):\n            head = head.next\n            if head.val in ht and prev.val in ht :\n                continue\n            elif head.val in ht:\n                total += 1\n            prev = head \n        return total", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips = sorted(trips, key=lambda x: x[1])\n        curr = []\n        \n        for i in trips:\n            \n            curr.append([i[0], i[2]])\n            \n            s = 0\n            for c in curr:\n                if c[1] <= i[1]:\n                    continue\n                s += c[0]\n            \n            if s > capacity:\n                return False\n        \n        return True", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        WHITE, GRAY, BLACK = 0, 1, 2    #GRAY is part of a cycle, BLACK is safe\n        color = {}\n        for i in range(len(graph)):\n            color[i] = WHITE\n         \n        # Return whether it is safe\n        def dfs(node):\n            if color[node] != WHITE:\n                return color[node] == BLACK\n            \n            color[node] = GRAY\n            for nei in graph[node]:\n                if color[nei] == GRAY:\n                    return False\n                elif not dfs(nei):\n                    return False\n            color[node] = BLACK\n            return True\n                \n        return list(filter(dfs, list(range(len(graph)))))\n            \n            \n            \n            \n        \n        \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        covering = 0\n        used = set()\n        for i, (si, ei) in enumerate(intervals):\n            for sj, ej in intervals[i+1:]:                \n                if sj > ei:\n                    break\n                if ej > ei:\n                    continue\n                if (sj, ej) in used:\n                    continue\n                used.add((sj, ej))\n                covering += 1\n                \n        return len(intervals) - covering\n            \n", "class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         possible_moves = {0: [1,3], 1: [0,2,4], 2: [1,5], 3: [0,4], 4: [1,3,5], 5: [2,4]}\n         state = \"\".join([str(x) for x in board[0]]) + \"\".join([str(x) for x in board[1]])\n         \n         seen = {state: 0}\n         q = [[state, state.find(\"0\")]]\n \n         while q and q[0][0] != \"123450\":\n             cur = q.pop(0)\n             for move in possible_moves[cur[1]]:\n                 new_state = [int(x) for x in cur[0]]\n                 new_state[cur[1]], new_state[move] = new_state[move], new_state[cur[1]]\n                 new_state = \"\".join([str(x) for x in new_state])\n                 if new_state not in seen:\n                     seen[new_state] = seen[cur[0]]+1\n                     q.append([new_state, move])\n         return -1 if not q else seen[q[0][0]]", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteNodes(self, node: ListNode, num: int) -> ListNode:\n        assert node != None\n        assert num > 0\n        dummy = ListNode(0, node)\n        prev = dummy\n        while node != None and num != 0:\n            prev.next = node.next\n            node = node.next\n            num = num - 1\n        assert num == 0\n        return dummy.next\n    \n    def findSumZero(self, head: ListNode) -> int:\n        assert head != None\n        n = 1\n        s = 0\n        node = head\n        while node != None:\n            s = s + node.val\n            if s == 0:\n                return n \n            node = node.next\n            n = n + 1\n        return 0\n        \n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0, head)\n        prev = dummy\n        node = head\n        while node != None:\n            n = self.findSumZero(node)\n            if n > 0:\n                node_next = node\n                for i in range(n):\n                    node_next = node_next.next\n                prev.next = node_next\n                node = node_next\n            else:\n                prev = node\n                node = node.next\n        return dummy.next", "x, d = list(map(int, input().split()))\narr = []\nn = 0\ns = ''\nwhile x > 0:\n    s += str(x % 2)\n    x //= 2\nf = 1\nl = 999999999999999999\nfor i in range(len(s)):\n    if int(s[i]):\n        arr += [f] * i + [l]\n        f += d\n        l -= d\n        n += i + 1\nif n == -1:\n    print(-1)\nelse:\n    print(n)\n    print(*arr)\n\n\n\n\n", "str = input()\nl = len(str)\na = [0] * (2 * l)\npos = [[] for i in range(26)]\nfor i, c in enumerate(str):\n    t = ord(c) - ord('a')\n    a[i] = t\n    a[i + l] = t\n    pos[t].append(i)\nans = 0\nfor c in range(26):\n    cur = 0\n    for k in range(1, l):\n        cnt = [0] * 26\n        for i in pos[c]:\n            cnt[a[i + k]] += 1\n        tot = 0\n        for i in cnt:\n            if i == 1:\n                tot += 1\n        cur = max(cur, tot)\n    ans += cur\nprint(ans / l)\n", "from bisect import *\nfrom math import *\n\nn = int(input())\na, b, c, d = list(map(int,input().replace('/',' ').split()))\n\nalpha = atan2(c,d) - atan2(a,b)\ntan_alpha = tan(alpha)\n\nlis = []\n\nfor x,y in sorted((y/tan_alpha - x,y) for x,y in [ (x,y) for x,y in [(b*x + a*y,-a*x + b*y) for x, y in [list(map(int,input().split())) for _ in range(n)] if a*x - b*y <= 0 and d*y - c*x <= 0]]):\n    pos = bisect_left(lis,-y)\n    if pos == len(lis):\n        lis.append(-y)\n    else:\n        lis[pos] = -y\n\nprint(len(lis))\n\n", "s=input()\nif(s.count('0')==0):\n    print(s[1:])\nelse:\n    i=s.index('0')\n    print(s[:i]+s[i+1:])", "s = input()\nn = len(s)\n\n\na = [n] * (n + 1)\nans = 0\n\nfor i in range(n - 1, -1, -1):\n\ta[i] = a[i + 1]\n\tj = 1\n\twhile i + j + j < a[i]:\n\t\tif s[i] == s[i + j] and s[i] == s[i + j + j]:\n\t\t\ta[i] = i + j + j\n\t\tj += 1\n\tans += n - a[i]\nprint(ans)\n", "from fractions import gcd\nfrom functools import reduce\nn = int(input())\na = list(map(int, input().split()))\ng = reduce(gcd, a)\ns = max(a)//g - n\nif s%2:\n    print('Alice')\nelse:\n    print('Bob')", "def can(d,a,b):\n    d1=d\n    mi=a[-1]\n    ma=a[-1]\n    while len(a)>0 and len(b)>0:\n        if b[-1]<=mi:\n            if abs(b[-1]-ma)<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n        elif b[-1]>=ma:\n            if abs(b[-1]-mi)<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n        else:\n            if abs(ma-mi)+min(abs(b[-1]-mi),abs(b[-1]-ma))<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n    return len(a)==0  \nn,m=list(map(int,input().split()))\ns=list(map(int,input().split()))[::-1]\ns1=list(map(int,input().split()))[::-1]\nhigh=(10**11)+1\nlow=0\nwhile high-low>1:\n    mid=(high+low)//2\n    if can(mid,s1.copy(),s.copy()):\n        high=mid\n    else:\n        low=mid\nif can(low,s1,s):\n    print(low)\nelse:\n    print(high)\n    \n", "from sys import stdin\nn=int(stdin.readline().strip())\ns=list(map(int,stdin.readline().strip().split()))\n\nl=0\nflag=True\nx=0\nfor i in range(1,n):\n    if s[i]!=s[i-1]:\n        if flag:\n            flag=False\n            l=i-1\n    else:\n        r=i-1\n        if not flag:\n            y=0\n            yy=r-1\n            for j in range(l+1,r):\n                s[j]=s[j-1]\n                y+=1\n                s[yy]=s[yy+1]\n                yy-=1\n                if(yy<=j):\n                    break\n            x=max(x,y)\n        flag=True\n\nif True:\n    if True:\n        if not flag:\n            y=0\n            yy=n-2\n            r=n-1\n            for j in range(l+1,r):\n                s[j]=s[j-1]\n                y+=1\n\n                s[yy]=s[yy+1]\n                yy-=1\n                if(yy<=j):\n                    break\n            x=max(x,y)\nprint(x)\nprint(*s)\n\n", "import random\n\nn = int(input())\nv = []\na = []\nfor i in range(n):\n    a.append(i)\n\nfor _ in range(0, n):\n    x, y = list(map(int, input().split()))\n    v.append([x, y, x*x+y*y])\n\nwhile 1>0:\n    x = 0\n    y = 0\n    ans = [0]*n\n    random.shuffle(a)\n    for i in range(n):\n        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:\n            x += v[a[i]][0]\n            y += v[a[i]][1]\n            ans[a[i]] = 1\n        else:\n            x -= v[a[i]][0]\n            y -= v[a[i]][1]\n            ans[a[i]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break\n\n", "#CLown1331 -_-\nn = int(input())\nar = list(map(int,input().split()))\nr = []\nl = []\nday = 0\nfor i in ar:\n    day += 1\n    day = min(i,day)\n    l.append(day)\nday = 0\nfor i in reversed(ar):\n    day += 1\n    day = min(i,day)\n    r.append(day)\nans = 0\nx = 0\nkk = n-1\nwhile x < n:\n    ans = max(ans,min(r[kk],l[x]))\n    x += 1\n    kk -= 1\nprint (ans)", "n = int(input())\np = 0 if n<=100 else n-100\nans =[]\nwhile p <= n:\n    k = p\n    s = p\n    while k>0:\n        s += k%10\n        k = k//10\n    if s == n:\n        ans.append(p)\n    p += 1\nif len(ans) == 0:\n    print(0)\nelse:\n    print(len(ans))\n    for i in ans:\n        print(i,end=' ')", "n = int(input())\n\n\n\nif n % 4 > 1:\n\n    print(-1)\n\n    return\n\n\n\na = [i for i in range(0, n+1)]\n\nfor i in range(1, n//2+1, 2):\n\n    p, q, r, s = i, i+1, n-i,n-i+1\n\n    a[p], a[q], a[r], a[s] = a[q], a[s], a[p], a[r]\n\n\n\ndef check(arr):\n\n    for i in range(1, n+1):\n\n        k = arr[i]\n\n        if arr[arr[k]] != n-k+1:\n\n            return False\n\n    return True\n\n\n\n# print(check(a))\n\nprint(*a[1:])\n\n", "#!/usr/bin/env python3\n\nimport re\n\ntry:\n    while True:\n        s = input()\n        m = re.search(r\"[^a]\", s)\n        if m is None:\n            print(s[:-1], end=\"z\\n\")\n        else:\n            j = s.find('a', m.end())\n            if j == -1:\n                j = len(s)\n            print(end=s[:m.start()])\n            for i in range(m.start(), j):\n                print(end=chr((ord(s[i]) - 98) % 26 + 97))\n            print(s[j:])\n\nexcept EOFError:\n    pass\n", "ans=0\nl = []\nt = int(input())\nfor i in range(t):\n    n,m,k = list(map(int,input().split()))\n    l.append([n,m,k])\n\nans=0\np = []\nfor i in range(t):\n\n    if l[i][2]>=0:\n        k = 0\n        v = 0\n        for j in range(i+1,t):\n            if l[j][2]>=0:\n                l[j][2]-=(max(0,l[i][0]-k)+v)\n                if l[j][2]<0:\n                    v+=l[j][1]\n                    l[j][1]=0\n                k+=1\n        p.append(i+1)\n    #print(l)\n\nprint(len(p))\nprint(*p)\n\n\n        \n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nW=[0]+list(map(int,input().split()))\nE=[tuple(map(int,input().split())) for i in range(m)]\nS=int(input())\n\nELIST=[[] for i in range(n+1)]\nEW=[0]*(n+1)\n\nfor x,y in E:\n    ELIST[x].append(y)\n    ELIST[y].append(x)\n\n    EW[x]+=1\n    EW[y]+=1\n\n\nfrom collections import deque\nQ=deque()\nUSED=[0]*(n+1)\n\nfor i in range(1,n+1):\n    if EW[i]==1 and i!=S:\n        USED[i]=1\n        Q.append(i)\n\nEW[S]+=1<<50\nUSED[S]=1\n\nwhile Q:\n    x=Q.pop()\n    EW[x]-=1\n\n    for to in ELIST[x]:\n        if USED[to]==1:\n            continue\n        EW[to]-=1\n\n        if EW[to]==1 and USED[to]==0:\n            Q.append(to)\n            USED[to]=1\n\n#print(EW)\nLOOP=[]\n\nANS=0\nfor i in range(1,n+1):\n    if EW[i]!=0:\n        ANS+=W[i]\n        LOOP.append(i)\n\nSCORE=[0]*(n+1)\nUSED=[0]*(n+1)\n\nfor l in LOOP:\n    SCORE[l]=ANS\n    USED[l]=1\n\nQ=deque(LOOP)\n\nwhile Q:\n    x=Q.pop()\n\n    for to in ELIST[x]:\n        if USED[to]==1:\n            continue\n\n        SCORE[to]=W[to]+SCORE[x]\n        Q.append(to)\n        USED[to]=1\n\nprint(max(SCORE))\n", "#!/usr/bin/env python3\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    r = 0\n    while a:\n        c = a[0]\n        del a[0]\n        for i in range(len(a)):\n            if c == a[i]:\n                break\n        del a[i]\n        r += i\n    print(r)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#https://codeforces.com/problemset/problem/238/B\nn, h  = list(map(int, input().split()))\na     = list(map(int, input().split()))\nb     = [[x, i] for i, x in enumerate(a)]\nb     = sorted(b, key=lambda x:x[0])\n\ndef solve(a, n, h):\n    if n == 2:\n        return 0, [1, 1]\n\n    min_  = (a[-1][0] + a[-2][0]) - (a[0][0] + a[1][0])\n    \n    # move a[0] to 2th-group\n    min_2 = max(a[-1][0] + a[-2][0], a[-1][0] + a[0][0] + h) - min(a[0][0] + a[1][0] +h, a[1][0] + a[2][0])\n    \n    ans = [1] * n \n    if min_2 < min_:\n        min_   = min_2\n        ans[a[0][1]] = 2 \n    \n    return min_, ans         \n\nmin_, ans = solve(b, n, h)\nprint(min_)\nprint(' '.join([str(x) for x in ans]))\n\n#5 10\n#0 1 0 2 1    \n\n#3 2\n#1 2 3\n", "import math\nn = int(input())\na = list(map(int, input().split()))\ns=math.ceil(sum(a)/(n-1))\nprint(max(max(a),s))\n", "from fractions import gcd\nfrom functools import reduce\n\n\nLETTERS = 'abcdefghijklmnopqrstuvwxyz'\n\n\ndef necklace_odd(a):\n    oi = next(i for i, ai in enumerate(a) if ai%2)\n    o = a[oi]\n    g = reduce(gcd, a)\n    s = [LETTERS[i] * (a[i]//(2*g)) for i in range(len(a)) if i != oi]\n    return g, (''.join(s) + (LETTERS[oi]*(o//g)) + ''.join(reversed(s))) * g\n\n\ndef necklace_even(a):\n    g = reduce(gcd, a)//2\n    s = [LETTERS[i]*(a[i]//(2*g)) for i in range(len(a))]\n    return 2*g, (''.join(s) + ''.join(reversed(s))) * g\n\n\ndef necklace(a):\n    if len(a) == 1:\n        return a[0], LETTERS[0]*a[0]\n\n    nodd = sum(ai%2 for ai in a)\n    if nodd > 1:\n        return 0, ''.join(LETTERS[i]*a[i] for i in range(len(a)))\n\n    return (necklace_odd if nodd else necklace_even)(a)\n\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    k, e = necklace(a)\n    print(k)\n    print(e)\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    l = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                print(-1)\n                                return\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        print(len(l))\n        print(' '.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nn = int(input())\nwk1 = math.floor(math.sqrt(n))\nwk2 = n // wk1\nfor i in range(wk2 * (wk1), n):\n    print(i + 1, end = \" \")\nfor i in reversed(range(wk1)):\n    for j in range(wk2 * i, wk2 * (i + 1)):\n        print(j + 1, end = \" \")\nprint()", "n = int(input())\np = list(map(float, input().split()))\np.append(0)\ns=[p[0]]*3\ns[2]=0\nans = (2*s[2]+s[1])*(1-p[1])\nfor i in range(1,n):\n    s[0] += 1 - p[i-1]\n    for j in range(2,0,-1):\n        s[j] += s[j-1]\n    for j in range(3):\n        s[j] *= p[i]\n    ans += (2*s[2]+s[1])*(1-p[i+1])\nprint(ans)\n\n", "n = int(input())\np = []\nfor i in range(2,n+1):\n    isprime = True\n    for j in p:\n        if i % j == 0:\n            isprime = False\n            break\n    if isprime:\n        p.append(i)\nans = []\nfor i in p:\n    k = 1\n    while i ** k <= n:\n        ans.append(str(i ** k))\n        k += 1\nprint(len(ans))\nprint(' '.join(ans))\n", "n, d = list(map(int, input().split()))\n\na = [0] + list(map(int, input().split())) + [0]      #aumento de timer seg\u00fan estaci\u00f3n\nX = []\nY = []\n\nfor i in range(n):\n  x, y = list(map(int, input().split()))                 #Coordenadas de la estaci\u00f3n i.\n  X.append(x) \n  Y.append(y)\n\nmon = [-1] * n                          #array para el monto necesario para llegar.\nmon[0] = 0\nZ = 0                                   #valor que permitir\u00e1 entrar al loop\n\nwhile Z == 0:\n  Z = 1\n\n  for i in range(n):                                  #estamos en estaci\u00f3n i\n\n    for j in range(1, n):                             #queremos ir a estaci\u00f3n j\n\n      if i != j and mon[i] != -1:                      #si no queremos ir a la misma estaci\u00f3n y donde estamos pudimos llegar.\n        costo = mon[i] + (abs(X[i] - X[j]) + abs(Y[i] - Y[j]))*d - a[j]         #nuevo costo necesario para ir de i a j.\n\n        if mon[j] == -1 or costo < mon[j]:          #si el nuevo costo es menor que uno anterior, se guarda este o si antes no hab\u00eda ningun costo guardado.\n          mon[j] = costo\n          Z = 0                              #volvemos a entrar al loop, esto asegura que todos los mon[] van a dejar de ser '1 y tendran un costo.\nprint(mon[-1])                               #costo de llegar a la \u00faltima estaci\u00f3n.\n", "s = input()\na, b = [], []\nfor i, j in zip(s, range(1, len(s)+1)):\n    if i == 'r': a.append(str(j))\n    else: b.append(str(j))\nprint('\\n'.join(a + b[::-1]))", "from collections import Counter\nn = input()\nif len(Counter(n)) == 1 or len(Counter(n[:len(n)//2]+n[len(n)//2+1:])) == 1:\n    print(\"Impossible\")\n    return\nfor i in range(1,len(n)):\n    s1 = n[:i]\n    s2 = n[i:]\n    s3 = s2+s1\n    if s3[len(n)//2:] == s3[:-len(n)//2][::-1] and s3 != n:\n        print(1)\n        return\n\nprint(2)\n\n\n", "n = int(input())\n\nif n % 2 == 0:\n    print('NO')\n    return\n\nprint('YES')\n\nfor i in range(n):\n    print(2*i + i % 2 + 1, end=' ')\nfor i in range(n):\n    print(2*i - i % 2 + 2, end=' ')\nprint()\n", "from collections import defaultdict\nfrom collections import deque\nfrom functools import reduce\nn, x, y = [int(x) for x in input().split()]\nE = defaultdict(set)\nfor i in range(n-1):\n    u, v = [int(x) for x in input().split()]\n    E[u].add(v)\n    E[v].add(u)\n\nif x > y:\n    for v in E:\n        if len(E[v]) == n-1:\n            print((n-2)*y + x)\n            break\n        elif len(E[v]) > 1:\n            print((n-1)*y)\n            break\nelse:\n    visited = {v : False for v in E}\n    stack = [1]\n    topsorted = deque()\n    while stack:\n        v = stack.pop()\n        if visited[v]: continue\n        visited[v] = True\n        topsorted.appendleft(v)\n        stack.extend(E[v])\n    chopped = set()\n    ans = 0\n    for v in topsorted:\n        ans += max(0, len(E[v])-2)\n        if len(E[v]) > 2:\n            S = E[v].intersection(chopped)\n            S1 = {S.pop(), S.pop()}\n            for u in E[v]:\n                if not u in S1:\n                    E[u].remove(v)\n            E[v].clear()\n            E[v].update(S1)\n        chopped.add(v)\n    print(ans*y + (n-1-ans)*x)\n        \n", "from sys import stdin\ninput = stdin.readline\nn,m = map(int,input().split())\nl = list(map(int,input().split()))\nx = sum(l)\nif x < n:\n\tprint(-1)\nelse:\n\tdasie = True\n\tfor i in range(m):\n\t\tif l[i] > n-i:\n\t\t\tdasie = False\n\tif not dasie:\n\t\tprint(-1)\n\telse:\n\t\todp = [1]\n\t\tcyk = 1\n\t\twhile cyk < m:\n\t\t\tx -= l[cyk-1]\n\t\t\todp.append(max(odp[-1]+1, n+1-x))\n\t\t\tcyk += 1\n\t\tprint(*odp)", "h = int(input())\na = list(map(int, input().split()))\n\nw, q = [], []\np = r = 0\n\nfor i in a:\n    for j in range(i):\n        w.append(r)\n        q.append(r - (j and p > 1))\n\n    p = i\n    r += i\n\nif w == q:\n    print('perfect')\nelse:\n    print('ambiguous')\n    print(*w)\n    print(*q)\n", "n, m = map(int, input().split())\narr = list(map(int, input().split()))\nl, r = 0, m-1\nwhile l < r:\n    mid = (l+r)//2\n    p = 0\n    f = True\n    for x in arr:\n        step = (m-x+p)%m\n        if step > mid:\n            if x < p:\n                f = False\n                break\n            p = x\n    if f is True:\n        r = mid\n    else:\n        l = mid+1\nprint(l)", "import sys\nfrom math import sqrt\n\ndef solve():\n    n, h = map(int, input().split())\n\n    ans = [0]*(n - 1)\n\n    for i in range(1, n):\n        ans[i - 1] = h * sqrt(i / n)\n\n    print(*ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "n, m = int(input()), 150001\np = [m] + list(map(int, input().split())) + [m * (n & 1)]\nf = lambda i: p[i] >= p[i + 1] if i & 1 else p[i] <= p[i + 1]\nh = lambda i, j: sum(f(k) for k in {i, i - 1, j, j - 1})\nt = [f(i) for i in range(n + 1)]\ns = sum(t)\nif s > 4: print(0);return\ne = {i + 1 for i in range(n) if t[i] or t[i + 1]}\n\ndef g(i, j):\n    p[i], p[j] = p[j], p[i]\n    t = h(i, j)\n    p[i], p[j] = p[j], p[i]\n    return (i < j or (i > j and j not in e)) and h(i, j) - t == s\n\nprint(sum(g(i, j + 1) for i in e for j in range(n)))", "def main():\n    n, a, b, t = list(map(int, input().split()))\n    b += 1\n    l = [b if char == \"w\" else 1 for char in input()]\n    t -= sum(l) - a * (n + 2)\n    hi, n2 = n, n * 2\n    n3 = n2 + 1\n    lo = res = 0\n    l *= 2\n    while lo <= n and hi < n2:\n        t -= l[hi]\n        hi += 1\n        while (hi - lo + (hi if hi < n3 else n3)) * a > t or lo < hi - n:\n            t += l[lo]\n            lo += 1\n            n3 -= 1\n        if res < hi - lo:\n            res = hi - lo\n            if res == n:\n                break\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "k, n = 0, int(input())\n\nt = [list(map(int, input().split())) for j in range(n)]\n\nfor m, (l, r) in enumerate(t, 1):\n\n    if not l:\n\n        if k: t[k - 1][1], t[m - 1][0] = m, k\n\n        k = m\n\n        while r: k, r = r, t[r - 1][1]\n\nfor l, r in t: print(l, r)\n\n\n\n# Made By Mostafa_Khaled\n", "n, k = list(map(int, input().split()))\n\nmid = n-k-1\n\nr = [0] * k\n\nfor i in range(n-1):\n\n  r[i%k] += 1\n\nprint(r[0]+r[1])\n\nv1 = 2\n\nans = []\n\nfor i in range(k):\n\n  v0 = 1\n\n  for _ in range(r[i]):\n\n    ans.append(\"%d %d\"%(v0, v1))\n\n    v0 = v1\n\n    v1 += 1\n\nprint(\"\\n\".join(ans))\n\n\n\n# Made By Mostafa_Khaled\n", "# -*- coding: utf-8 -*-\n\n# Baqir Khan\n# Software Engineer (Backend)\n\nfrom sys import stdin\n\ninp = stdin.readline\n\nn, m = list(map(int, inp().split()))\nans = [0] * (n + 1)\nalive = [(i + 1) for i in range(n + 2)]\n\nwhile m:\n    m -= 1\n    l, r, x = list(map(int, inp().split()))\n    i = l\n    while i <= r:\n        if ans[i] == 0 and i != x:\n            ans[i] = x\n        temp = alive[i]\n        if i < x:\n            alive[i] = x\n        else:\n            alive[i] = r + 1\n        i = temp\n\nprint(*ans[1:])\n", "n = int(input())\nt = [0, 0] + list(map(int, input().split()))\na, b = [0] * (n + 1), [0] * (n + 1)\na[1] = b[1] = -1\n    \ndef f(s, a, b, l):\n    nonlocal t\n    l.reverse()\n    j, n = 0, len(l)\n    while True:\n        s += t[l[j]]\n        a[l[j]] = s\n        j += 1\n        if j == n: return\n        s += t[l[j]]\n        b[l[j]] = s\n        j += 1\n        if j == n: return\n\ndef g(i, k):\n    nonlocal a, b\n    l = []\n    if k:\n        a[i] = -1\n        l.append(i)\n        i += t[i]\n    while True:\n        if i > n: return f(0, a, b, l)                \n        if b[i] > 0: return f(b[i], a, b, l)                \n        if b[i] == -1: return\n        b[i] = -1\n        l.append(i)\n        i -= t[i]\n        if i < 1: return f(0, b, a, l)\n        if a[i] > 0: return f(a[i], b, a, l)\n        if a[i] == -1: return\n        a[i] = -1\n        l.append(i)\n        i += t[i]\n        \nfor i in range(2, n + 1):\n    if a[i] == 0: g(i, True)        \n    if b[i] == 0: g(i, False)\n\nfor i in range(1, n):\n    if b[i + 1] > 0: t[i] = i + b[i + 1]\n    else: t[i] = -1\n\nprint('\\n'.join(map(str, t[1: n])))", "def main():\n    n, k = map(int, input().split())\n    a, b, c, d = (list(map(int, input().split())) for _ in 'abcd')\n    ss, tt, n2, res = [*b, *c[::-1]], [*a, *d[::-1]], n * 2, []\n    yx = [*[(2, i + 1) for i in range(n)], *[(3, i) for i in range(n, 0, -1)]]\n\n    def park():\n        for i, s, t, (y, x) in zip(range(n2), ss, tt, yx):\n            if s == t != 0:\n                ss[i] = 0\n                res.append(f'{s} {(1, 4)[y == 3]} {x}')\n\n    def rotate():\n        start = ss.index(0)\n        for i in range(start - n2, start - 1):\n            s = ss[i] = ss[i + 1]\n            if s:\n                y, x = yx[i]\n                res.append(f'{s} {y} {x}')\n        ss[start - 1] = 0\n\n    park()\n    if all(ss):\n        print(-1)\n        return\n    while any(ss):\n        rotate()\n        park()\n    print(len(res), '\\n'.join(res), sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n__starting_point()", "import sys\n\nn, k = map(int, sys.stdin.readline().split())\nnums = list(map(int, sys.stdin.readline().split()))\ntotal = sum(nums)\navg = int(total / n)\n\ndef check1(nums, target, K):\n    for x in nums:\n        if K < 0:\n            return False\n        if x < target:\n            K -= target - x\n    return K >= 0\n\ndef check2(nums, target, K):\n    for x in nums:\n        if K < 0:\n            return False\n        if x > target:\n            K -= x - target\n    return K >= 0\n\nl1, r1 = min(nums), avg + 1\nwhile l1 + 1 < r1:\n    mid = (l1 + r1) >> 1\n    if check1(nums, mid, k):\n        l1 = mid\n    else:\n        r1 = mid\n\nif check2(nums, avg + (0 if total % n == 0 else 1), k):\n    r2 = avg + (0 if total % n == 0 else 1)\nelse:\n    l2, r2 = avg + (0 if total % n == 0 else 1), max(nums)\n    while l2 + 1 < r2:\n        mid = (l2 + r2) >> 1\n        if check2(nums, mid, k):\n            r2 = mid\n        else:\n            l2 = mid\n\nprint(r2 - l1)", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2/11/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef make_trie(A):\n    trie = {}\n    for word in A:\n        t = trie\n        for w in word:\n            if w not in t:\n                t[w] = {}\n            t = t[w]\n        # t['#'] = True\n    \n    return trie\n\n\ndef game(trie):\n    if not trie:\n        return False\n    \n    return not all([game(t) for k, t in trie.items()])\n\n\ndef can_lose(trie):\n    if not trie:\n        return True\n    \n    return any([not can_lose(t) for k, t in trie.items()])\n\n\ndef solve(N, K, A):\n    trie = make_trie(A)\n    win = game(trie)\n    \n    if not win:\n        return False\n    \n    if K == 1:\n        return True\n    \n    if can_lose(trie):\n        return True\n    \n    return K % 2 == 1\n    \n    \nN, K = map(int, input().split())\nA = []\nfor i in range(N):\n    s = input()\n    A.append(s)\n    \nprint('First' if solve(N, K, A) else 'Second')", "from heapq import heappush,heappop,heapify\nn,k=map(int,input().split())\n*l,=map(int,input().split())\nq=[(-l[i],i)for i in range(k)];heapify(q)\na=[0]*n\ns=0\nfor i in range(k,n):\n    heappush(q,(-l[i],i))\n    x,j=heappop(q)\n    s-=x*(i-j)\n    a[j]=i+1\nfor i in range(n,n+k):\n    x,j=heappop(q)\n    s-=x*(i-j)\n    a[j]=i+1\nprint(s)\nprint(' '.join(map(str,a)))", "I=input\nn,m=list(map(int,I().split()))\nb=[1]*n*2\nb[0]=b[n-1]=b[n]=b[2*n-1]=0\nfor i in range(m):\n    r,c=list(map(int,I().split()))\n    b[r-1]=b[n+c-1]=0\nif n%2 and b[n//2] and b[n+n//2]:b[n//2]=0\nprint(sum(b))\n", "n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na.sort()\nb.sort()\nif a[-1] > b[0]:\n    print(-1)\n    return\n\nif a[-1] == b[0]:\n    print(sum(b) + sum(a[:-1]) * m)\nelse:\n    print(sum(b) + a[-1] + sum(a[:-1]) * m - a[-2])", "n = int(input())\na = []\nb = []\nfor i in range(n-1):\n\tx,y = list(map(int, input().split()))\n\ta.append(x)\n\tb.append(y)\n\ncolors = list(map(int, input().split()))\n\n\nlehet = []\nfor i in range(n-1):\n\tif colors[a[i]-1] != colors[b[i]-1]:\n\t\tif len(lehet) == 0:\n\t\t\tlehet += [a[i], b[i]]\n\t\telse:\n\t\t\tif a[i] in lehet and b[i] in lehet:\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\n\t\t\telif a[i] in lehet:\n\t\t\t\tlehet = [a[i]]\n\t\t\telif b[i] in lehet:\n\t\t\t\tlehet = [b[i]]\n\t\t\telse:\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\nprint(\"YES\")\nif len(lehet) == 0:\n\tlehet = [1]\nprint(lehet[0])\n\t\n", "MOD = 1000000007\nst,n,t,mp=input(),int(input()),[],{}\n\nt.append(['',st])\n\nfor i in range(10):\n\tmp[str(i)]=(10,i)\n\nfor i in range(n):\n\tt.append(input().split(\"->\"))\n\nfor i in range(n,-1,-1):\n\ta,b=1,0\n\tfor j in t[i][1]:\n\t\ta,b=a*mp[j][0]%MOD,(b*mp[j][0]+mp[j][1])%MOD\n\tmp[t[i][0]]= a,b\n\nprint(mp[''][1])\n", "n = int(input())\na = input()\nb = input()\n\nc = [10**10 for i in range(n + 10)]\n\nc[0] = 0 if a[0] == b[0] else 1\n\nfor i in range(1, n):\n    if a[i] == b[i]:\n        c[i] = c[i - 1]\n    elif a[i] == b[i - 1] and a[i - 1] == b[i]:\n        c[i] = (1 + c[i - 2] if i > 1 else 1)\n    c[i] = min(c[i], c[i - 1] + 1)\n    \nprint(c[n - 1])\n", "M, a, b=10**9+7, 0, 0\nfor c in reversed(input()):\n\tif c=='b':\n\t\tb+=1\n\telse:\n\t\ta+=b\n\t\tb=(b<<1)%M\nprint(a%M)\n", "from bisect import insort\nclass Graph:\n    def __init__(_):\n        _.change = [-10**27] # increment slope at ...\n        _.a = _.y = 0 # last line has slope a, starts from y\n        _.dx = 0      # the whole graph is shifted right by ...\n    def __repr__(_): return f\"<{[x+_.dx for x in _.change]}; {_.a} {_.y}>\"\n    \n    def shiftx(_, v): _.dx+= v\n    def shifty(_, v): _.y+= v\n    def addleft(_, v):\n        if _.change[-1] < v-_.dx:\n            dx = v-_.dx - _.change[-1]\n            _.y+= _.a*dx\n        insort(_.change, v-_.dx)\n    def addright(_, v):\n        if _.change[-1] < v-_.dx:\n            dx = v-_.dx - _.change[-1]\n            _.y+= _.a*dx; _.a+= 1\n            insort(_.change, v-_.dx)\n            return\n        insort(_.change, v-_.dx)\n        _.a+= 1; _.y+= _.change[-1]-(v-_.dx)\n    #def remleft(_, v): change.remove(v-_.dx)\n    def cutright(_):\n        dx = _.change.pop()-_.change[-1]\n        _.a-= 1; _.y-= _.a*dx\n\nn = int(input())\nG = Graph()\nfor x in map(int,input().split()):\n    G.shiftx(1)\n    G.addleft(x)\n    G.addright(x)\n    while G.a > 0: G.cutright()\nprint(G.y)", "n = int(input())\ninp = input()\nseq = inp.split(' ')\nseq = [ abs(int(x)) for x in seq ]\nMax = max(seq)\nnxt = [0] * n\ncnt = [0] * n\npos = [n] * (Max+1)\nfor i in range(n-1, -1, -1):\n    nxt[i] = pos[seq[i]]\n    pos[seq[i]] = i\nfor i in range(0, Max+1):\n    j = pos[i]\n    while(j<n):\n        front = sum(cnt[0:j])\n        back  = sum(cnt[j+1:n])\n        if(front < back):\n            seq[j] = 0 - seq[j]\n        j = nxt[j]\n    j = pos[i]\n    while(j < n):\n        cnt[j] = 1\n        j = nxt[j]\n#for i in range(0, n-1):\n#    print(seq[i], sep=' ')\n#print(seq[n-1])\ninv = 0\nfor i in range(len(seq)):\n    for j in range(i+1, len(seq)):\n        if(seq[i] > seq[j]):\n            inv += 1\nprint(inv)\n", "def f(m):\n    nonlocal dp, sdp\n    l = 0\n    for i in range(n):\n        while l < n and v[l] < v[i] - m:\n            l += 1\n        if l - 1 > i - k:\n            dp[i] = False\n        else:\n            dp[i] = (sdp[i - k + 1] != sdp[l - 1])\n        sdp[i + 1] = sdp[i] + (1 if dp[i] else 0)\n    return dp[n - 1]\n\nn, k = map(int, input().split())\ndp = [False for i in range(n + 2)]\nsdp = [0 for i in range(n + 2)]\ndp[-1] = True\nsdp[0] = 1\nv = list(map(int, input().split()))\nv.sort()\nle = -1\nr = v[-1] - v[0]\nwhile r - le > 1:\n    m = (r + le) // 2\n    if f(m):\n        r = m\n    else:\n        le = m  \nprint(r)", "t = int(input())\nfor _ in range(t):\n    ax,ay,bx,by,cx,cy = map(int,input().split())\n    x = ax+bx+cx\n    y = ay+by+cy\n    xv,xp = divmod(x,3)\n    yv,yp = divmod(y,3)\n    nx = xv*2+xp-1\n    ny = yv*2+yp-1\n    if nx == ny:\n        if nx == 0:\n            print(0)\n        elif nx == 1:\n            print(1)\n        else:\n            print(abs(nx)+1)\n    else:\n        print(max(abs(nx),abs(ny)))", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN,A,B,C,D = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nfact = [1] * (N+1)\nfact_inv = [1] * (N+1)\nfor n in range(1,N+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[N] = pow(fact[N], MOD-2, MOD)\nfor n in range(N,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\nfact = np.array(fact, dtype=np.int64)\nfact_inv = np.array(fact_inv, dtype=np.int64)\n\ncomb = np.zeros((N+1,N+1), dtype=np.int64)\ncomb[:,0] = 1\nfor n in range(1,N+1):\n    comb[n,1:] = (comb[n-1,1:] + comb[n-1,:-1]) % MOD\n\ndp = np.zeros(N+1, dtype=np.int64)\ndp[0] = 1\nfor x in range(A,B+1):\n    # \u4f7f\u3046\u306a\u3089\u3001C\uff5eD\u4eba\u3067\u4f7f\u3046\n    prev = dp\n    dp = prev.copy()\n    for n in range(C,D+1):\n        y = n * x\n        if y > N:\n            break\n        # x\u4eba\u7d44\u3092n\u7d44\u3068\u308b\n        # dp[i] += dp[i-y] * comb((N-i+y),y) * (y! / (x!)^n / n!)\n        coef = fact[y] * pow(int(fact_inv[x]), n, MOD) % MOD * fact_inv[n] % MOD\n        #print(x,n,coef)\n        dp[y:] += prev[:-y] * comb[N:y-1:-1,y] % MOD * coef\n        dp %= MOD\n\nanswer = dp[N]\nprint(answer)", "#DSU\nimport bisect,sys\nfrom collections import deque, namedtuple\nN = 300\npar = [i for i in range(N)]\n\ndef find(i):\n    root = i\n    while root != par[root]: root = par[root]\n    while i != par[i]:\n        newp = par[i]\n        par[i] = root\n        i = newp\n    return root\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    par[b] = a\n\ndef main():\n    n,m = map(int,input().split())\n    check,ans = 0,-1\n    for _ in range(n):\n        l = [int(i) for i in input().split()][1:]\n        check = max(check,len(l))\n        for i in l:\n            merge(_,n+i)\n    if not check:\n        print(n)\n        return\n    for i in range(n):\n        if i == par[i]:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nN, Q = list(map(int, readline().split()))\nstate = [[False]*(N+2) for _ in range(2)]\n\ncnt = 0\n\nAns = [None]*Q\nfor qu in range(Q):\n    r, c = list(map(int, readline().split()))\n    r -= 1\n    c -= 1\n    state[r][c] = not state[r][c]\n    res = state[r-1][c-1] + state[r-1][c] + state[r-1][c+1]  \n    if state[r][c]:\n        cnt += res\n    else:\n        cnt -= res\n    Ans[qu] = 'No' if cnt else 'Yes'\nprint('\\n'.join(Ans))\n", "def func(mas, n, m):\n    flag1=0\n    flag2=n-1\n    i=0\n    j=1\n    while(i<m):\n        if(mas[i][1]==1):\n            tmp = mas[i][0]-1\n            while(j<mas[i][0]):\n                if(mas[i][j]==mas[i][j+1]-1):\n                    flag2-=1\n                    tmp-=1\n                else:\n                    break\n                j+=1\n            flag1+=tmp\n        else:\n            flag1=flag1+mas[i][0]-1\n        i+=1\n    return flag1+flag2\nn,m = map(int, input().split())\nmas=[[]for i in range(m)]\nh=0\nfor i in mas:\n    s = input()\n    p = s.split()\n    while h<len(p):\n        i.append(int(p[h]))\n        h+=1\n    h=0\nprint(func(mas,n,m))", "from itertools import accumulate\nm = int(input())//2\nX = [int(x) for x in input().split()]\nX.sort()\nZ = [X[i+m] - X[i] for i in range(m)]\nprint(min(Z))\n\n", "n = int(input())\nt = [list(map(int, input().split())) for q in range(n)]\nn += 1\nu = [-1e7] * n\nv = [0] * n\nfor i, (j, a) in list(enumerate(t, 1))[::-1]:\n    u[i] = max(u[i], v[i] + a)\n    v[j], u[j] = max(v[j] + v[i], u[j] + u[i]), max(v[j] + u[i], u[j] + v[i])\nprint(u[1])", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj[u].append((v, w))\n    adj[v].append((u, w))\nbest = [0] * n\nans = 0\n\ndef dfs(u):\n    stack = list()\n    visit = [False] * n\n    stack.append((u, -1))\n    while stack:\n        u, par = stack[-1]\n        if not visit[u]:\n            visit[u] = True\n            for v, w in adj[u]:\n                if v != par:\n                    stack.append((v, u))\n        else:\n            cand = []\n            for v, w in adj[u]:\n                if v != par:\n                    cand.append(best[v] + a[v] - w)\n            cand.sort(reverse=True)\n            cur = a[u]\n            for i in range(2):\n                if i < len(cand) and cand[i] > 0:\n                    cur += cand[i]\n            nonlocal ans\n            ans = max(ans, cur)\n            best[u] = cand[0] if len(cand) > 0 and cand[0] > 0 else 0\n            stack.pop()\n\ndfs(0)\nprint(ans)", "n=int(input())\nL=list(map(int,input().split()))\nif n==1:\n    print(1,1)\n    print(0)\n    print(1,1)\n    print(0)\n    print(1,1)\n    print(-L[0])\nelse:\n    print(1,n-1)\n    for i in range(n-1):print(L[i]*(n-1),end=' ')\n    print()\n    print(n,n)\n    print(-L[n-1])\n    print(1,n)\n    for i in range(n-1):print(-L[i]*n,end=' ')\n    print(0)", "3\nfrom collections import Counter\nfrom functools import reduce\n\nn = int(input())\nx = Counter()\ny = Counter()\npoints = Counter()\nfor i in range(n):\n  point = list(map(int, input().split()))\n  x[point[0]] += 1\n  y[point[1]] += 1\n  points[(point[0], point[1])] += 1\n  \ndef getPairsNumber(n):\n  return n * (n-1) // 2\n\ndef getCounterPairsNumber(counter):\n  return reduce(lambda s, n: s + getPairsNumber(n), list(counter.values()), 0)\n\ns = getCounterPairsNumber(x) + getCounterPairsNumber(y) - getCounterPairsNumber(points)\nprint(s)\n", "from sys import*\n#\ndef check(u, d, l, r):\n    used = [pointsx[i][1] for i in range(l)]\n    used += [pointsx[-1 - i][1] for i in range(r)]\n    used += [pointsy[i][1] for i in range(u)]\n    used += [pointsy[-1 - i][1] for i in range(d)]\n    if len(set(used)) > k:\n        return DOHERA\n    dx = pointsx[-1 - r][0] - pointsx[l][0]\n    dy = pointsy[-1 - d][0] - pointsy[u][0]\n    dx += dx & 1\n    dy += dy & 1\n    dx = max(2, dx)\n    dy = max(2, dy)\n    return dx * dy\n#\n(n, k) = list(map(int, input().split()))\npointsx = []\npointsy = []\nDOHERA = 10 ** 228\nfor i in range(n):\n    a = list(map(int, input().split()))\n    pointsx += [(a[0] + a[2], i)]\n    pointsy += [(a[1] + a[3], i)]\n(pointsx, pointsy) = (sorted(pointsx), sorted(pointsy))\nans = DOHERA\nfor u in range(0, k + 1):\n    for d in range(0, k + 1):\n        for l in range(0, k + 1):\n            for r in range(0, k + 1):\n                if l + r  <= k and u + d <= k:\n                    ans = min(ans, check(u, d, l, r))\nprint(ans // 4)\n\n\n\n# Made By Mostafa_Khaled\n", "def fun(numbers):\n    # numbers.sort(reverse=True)\n    le = len(numbers)\n    stack =[]\n    ans=0\n    i=1\n    for i in numbers:\n        while stack:\n            ans  = max(ans,stack[-1]^i)\n            if stack[-1] > i:\n                break\n            else:\n                stack.pop()\n        stack.append(i)\n    \n    return ans\n\n\n# var1, var2,var3 = [int(x) for x in input().split()]\nn = input()\nuser_input = input().split(' ')\nnumbers = [int(x.strip()) for x in user_input] \n# st = input()\n# print(fun(st))\n\nprint(fun(numbers))\n\n\n\n\n\n# # st = input()\n# var1, var2 = [int(x) for x in input().split()]\n\n# # # fun(st,var1,var2)\n\n# # # var2 = input()\n# print(fun(var1,var2))\n\n# ############################################################3###############################\n\n# # user_input = input().split(' ')\n# # numbers = [int(x.strip()) for x in user_input] \n# # print(fun(numbers))\n# ######################################################################################\n", "f = lambda: map(int, input().split())\nn, k = f()\np = sorted(f())\n\nm, d = n // k, n % k\nu, v = d + 1, k - d + 1\ng = [0] * u * v\n\ni = 0\nfor a in range(u):\n    j = a * m + a - 1\n    for b in range(v):\n        x = g[i - 1] + p[j] - p[j - m + 1] if b else 9e9\n        y = g[i - v] + p[j] - p[j - m] if a else 9e9\n        if i: g[i] = min(x, y)\n        i += 1\n        j += m\nprint(g[-1])", "n, m, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\n\nans = 'NO'\n\nif n > m:\n    ans = 'YES'\nelse:\n    for i in range(n):\n        if a[i] > b[i]:\n            ans = 'YES'\n\nprint(ans)\n\n\n", "def check(a, b, c):\n    s = 0\n    for i in range(5):\n        s += (b[i] - a[i]) * (c[i] - a[i])\n    return s <= 0\n\n\nn = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nif n == 1 or n == 2:\n    print(n)\n    print(1)\n    if n == 2:\n        print(2)\n    return\n\nv = -1\ni = 0\nwhile i + 1 < n:\n    if v == -1:\n        if i + 2 < n:\n            if check(a[i], a[i + 1], a[i + 2]):\n                v = i\n            elif check(a[i + 1], a[i], a[i + 2]):\n                v = i + 1\n            elif check(a[i + 2], a[i], a[i + 1]):\n                v = i + 2\n        else:\n            break\n    else:\n        if not check(a[v], a[i], a[i + 1]):\n            if check(a[i], a[v], a[i + 1]):\n                v = i\n            elif check(a[i + 1], a[v], a[i]):\n                v = i + 1\n            else:\n                v = -1\n    i += 1\n\nif v == -1:\n    print(0)\n    return\n\nfor i in range(n):\n    if i == v:\n        continue\n    for j in range(i + 1, n):\n        if j == v:\n            continue\n        if not check(a[v], a[i], a[j]):\n            print(0)\n            return\n\nprint(1)\nprint(v + 1)\nreturn\n", "parent = []\nranks = []\n\n\ndef make_set(n):\n    nonlocal parent, ranks\n    parent = [i for i in range(n + 5)]\n    ranks = [0 for i in range(n + 5)]\n\n\ndef find_set(u):\n    if parent[u] != u:\n        parent[u] = find_set(parent[u])\n    else:\n        parent[u] = u\n    return parent[u]\n\n\ndef union_set(u, v):\n    up = find_set(u)\n    vp = find_set(v)\n\n    if ranks[up] > ranks[vp]:\n        parent[vp] = up\n    elif ranks[up] < ranks[vp]:\n        parent[up] = vp\n    else:\n        parent[up] = vp\n        ranks[vp] += 1\n\n\ndef solution():\n    set_indicators = dict()\n    n, a, b = list(map(int, input().split()))\n    numbers = list(map(int, input().split()))\n    A = n + 1\n    B = A + 1\n\n    make_set(n)\n    for i in range(n):\n        set_indicators[numbers[i]] = i\n\n    for i in range(n):\n        if set_indicators.get(a - numbers[i]) is not None:\n            union_set(i, set_indicators.get(a - numbers[i]))\n        else:\n            union_set(i, B)\n        if set_indicators.get(b - numbers[i]) is not None:\n            union_set(i, set_indicators.get(b - numbers[i]))\n        else:\n            union_set(i, A)\n    if find_set(A) == find_set(B):\n        print('NO')\n        return\n\n    print('YES')\n    print(''.join('1 ' if find_set(i) == find_set(n + 2) else '0 ' for i in range(n)))\n\n\nsolution()\n", "from math import log\nq = int(input())\nprix = {}\ndepenses = []\ndef est_dessous(v,u):\n    return u == v or u == 1 or (u < v and 0 <= v - 2**int(log(v/u)/log(2))*u < 2**int(log(v/u)/log(2)))\ndef pqc(u,v):\n    #retourne la liste des ARETES emprunt\u00e9es\n    res = []\n    while not est_dessous(v,u):\n        res.append((u,u//2))\n        u = u//2\n    while not u == v:\n        if est_dessous(v, 2*u):\n            res.append((u, 2*u))\n            u = 2*u\n        elif est_dessous(v,2*u+1):\n            res.append((u,2*u+1))\n            u = 2*u+1\n    return res\nfor k in range(q):\n    event = tuple(map(int,input().split()))\n    if event[0] == 1:\n        for (a,b) in pqc(event[1],event[2]):\n            if (a,b) in prix:\n                prix[(a,b)] += event[3]\n            elif (b,a) in prix:\n                prix[(b,a)] += event[3]\n            else:\n                prix[(a,b)] = event[3]\n    else:\n        s = 0\n        for (a,b) in pqc(event[1],event[2]):\n            if (a,b) in prix:\n                s += prix[(a,b)]\n            elif (b,a) in prix:\n                s += prix[(b,a)]\n        depenses.append(s)\n\nfor k in depenses:\n    print(k)\n", "input()\nk = min(map(int, input().split()))\nn = int(input())\np = sorted(map(int, input().split()), reverse = True) + [0] * k\nprint(sum(sum(p[i: i + k]) for i in range(0, n, k + 2)))", "MOD = 998244353\n\nn = int(input())\n\na = list(map(int, input().split()))\ntot = sum(a)\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\nl = [0, pow(n, tot, MOD) - 1]\n\nfor i in range(1, tot):\n    aC = i\n    cC = (n - 1) * (tot - i)\n    curr = (aC + cC) * l[-1]\n    curr -= tot * (n - 1)\n    curr -= aC * l[-2]\n    curr *= inv(cC)\n    curr %= MOD\n    l.append(curr)\n\nout = 0\nfor v in a:\n    out += l[tot - v]\n    out %= MOD\n\nzero = l[tot]\nout -= (n - 1) * zero\nout *= inv(n)\nprint(out % MOD)\n", "n, m = map(int, input().split())\na = [10**9 for _ in range(n)]\nextra = [0 for _ in range(n)]\nquery = list()\nfor _ in range(m):\n     t, l, r, x = map(int, input().split())\n     l -= 1\n     r -= 1\n     query.append((t, l, r, x))\n     if t == 1:\n          for j in range(l, r + 1):\n               extra[j] += x\n     else:\n          for j in range(l, r + 1):\n               a[j] = min(a[j], x - extra[j])\nextra = a.copy()\nfor t, l, r, x in query:\n     if t == 1:\n          for j in range(l, r + 1):\n               a[j] += x\n     else:\n          val = -10**9\n          for j in range(l, r + 1):\n               val = max(val, a[j])\n          if not val == x:\n               print('NO')\n               return\n\nprint('YES')\nfor x in extra:\n     print(x, end=' ')\n          ", "from math import log\nn = int(input())\np = [bin(p)[2:] for p in range(0,512)]\ndef mset(s):\n    ss = set()\n    for k in range(0,10):\n        for pi in range(0,2 ** k):\n            cs = p[pi]\n            cs = (k - len(cs)) * \"0\" + cs\n            if cs in s:\n                ss.add(cs)\n    return ss\ndef q(s):\n    for k in range(0,10):\n        for pi in range(0,2 ** k):\n            cs = p[pi]\n            cs = (k - len(cs)) * \"0\" + cs\n            if not cs in s:\n                return k - 1\ns = [[v[:9], v[-9:], mset(v)] for v in [input() for i in range(n)]]\nfor qa, qb in [[int(v) - 1 for v in input().split()] for i in range(int(input()))]:\n    v = [s[qa][0], s[qb][1], mset(s[qa][1] + s[qb][0]) | s[qa][2] | s[qb][2]]\n    if len(v[0]) < 9:\n        v[0] = (v[0] + s[qb][0])[:9]\n    if len(v[1]) < 9:\n        v[1] = (s[qa][1] + s[qb][1])[-9:]\n    s += [v]\n    print(max(q(v[2]),0))", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nn, q = list(map(int, input().split()))\na = list(map(int, input().split()))\nM = max(a)\na = deque(a)\ncnt = 0\nans = [(-1, -1)]\n\nwhile True:\n    if a[0]==M:\n        break\n    \n    A = a.popleft()\n    B = a.popleft()\n    ans.append((A, B))\n    \n    if A>B:\n        a.appendleft(A)\n        a.append(B)\n    else:\n        a.appendleft(B)\n        a.append(A)\n    \n    cnt += 1\n\nfor _ in range(q):\n    m = int(input())\n    \n    if m<=len(ans)-1:\n        print(ans[m][0], ans[m][1])\n    else:\n        print(M, a[(m-cnt-1)%(n-1)+1])\n", "n, l, r, Ql, Qr = [int(x) for x in input().split(' ')]\nw = [int(x) for x in input().split(' ')];\nsum = [0 for x in range(n+1)];\nfor i in range(1, n+1):\n\tsum[i] = sum[i-1] + w[i-1];\nans = 2**32;\nfor k in range(0, n+1):\n\ttemp = sum[k]*l + (sum[n] - sum[k])*r;\n\tif (2*k > n):\n\t\ttemp += (2*k-n-1)*Ql;\n\telif (2*k < n):\n\t\ttemp += (n-2*k-1)*Qr;\n\tans = min(ans, temp);\nprint(ans);", "dp = [[-1 for i in range(505)] for j in range(505)]\nn = int(input())\nA = [int(i) for i in input().split()]\n\ndef do(i, j):\n    #print('At',i , j)\n    if i>=j:\n        dp[i][j] = 1\n        return 1\n    \n    if dp[i][j] != -1:\n        return dp[i][j]\n    \n    ans = len(A)\n    if A[i] == A[j]:\n        ans = min(ans, do(i+1, j-1))\n    for x in range(i, j):\n        \n        left = do(i, x)\n        right = do(x+1, j)\n        ans = min(ans, left+right)\n\n    dp[i][j] = ans\n    return ans\n\nif len(set(A)) == n:\n    print(n)\nelse:\n    print(do(0, n-1))\n", "import sys\ninput=sys.stdin.readline\nimport copy\nfrom math import *\nn=int(input())\na=[-1 for i in range(10)]\nfor i in range(n):\n    p,q=input().split()\n    qq=(bin(int(q))[2:])\n    q=list((10-len(qq))*\"0\"+qq)\n    if p=='|':\n        for i in range(9,-1,-1):\n            if  q[i]=='1':\n                a[i]=1\n    if p=='&':\n        for i in range(9,-1,-1):\n            if  q[i]=='0':\n                a[i]=0\n    if p=='^':\n        for i in range(9,-1,-1):\n            if  q[i]=='1' and (a[i]==0 or a[i]==1):\n                a[i]^=1\n            elif q[i]=='1' :\n                if a[i]==-1:\n                    a[i]=-2\n                else:\n                    a[i]=-1\n    #print(a)                \nc=0\nfor i in range(10):\n    if a[i]==-2:\n        c+=(2**(10-i-1))\nprint(3)\nprint(\"^\",c)\nv=list(\"0\"*10)\nfor i in range(10):\n    if a[i]==1:\n        v[i]='1'\nprint(\"|\",int(\"\".join(v),2))  \nu=list(\"1\"*10)\nfor i in range(10):\n    if a[i]==0:\n        u[i]='0'\nprint(\"&\",int(\"\".join(u),2))  ", "n = int(input())\nif n % 2 == 0:\n\tprint(\"home\")\nelse:\n\tprint(\"contest\")", "n=int(input())\narr=list(map(int,input().split()))\nans=[0]*1\nans[0]=[]\nans[0].append(arr[0])\nfor i in range(1,n,1):\n\tlo,hi=0,len(ans)\n\tidx=-1\n\twhile(lo<=hi):\n\t\tmid=(lo+hi)//2\n\t\t#print(lo,hi,i)\n\t\tif lo!=len(ans) and ans[mid][len(ans[mid])-1]<arr[i]:\n\t\t\tidx=mid\n\t\t\thi=mid-1\n\t\telse:\n\t\t\tlo=mid+1\n\tif len(ans)==hi:\n\t\tans.append([])\n\t\tans[hi].append(arr[i])\n\telse:\n\t\tans[idx].append(arr[i])\nfor i in range(len(ans)):\n\tfor j in range(len(ans[i])):\n\t\tprint(ans[i][j],end=\" \")\n\tprint()\n", "n=int(input())\ns=input()\nx=s.count('z')\ny=(n-4*x)//3\nprint('1 '*y+'0 '*x)", "input()\n\nA = list(map(int, input().split(' ')))\n\nroot = -1\n\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\n    \nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\n    \nchanged = 0\n\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: \n        if root==-1:\n            A[a]=a+1\n            root=a\n            changed+=1\n        else :\n            A[a]=root+1\n            changed+=1\n        \nprint(changed)\nprint(' '.join(map(str,A)))\n", "from sys import stdin\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nn=I();v=[1]*n\na=list(R());d={}\nfor i,j in enumerate(sorted(a)):d[j]=i\nans=[]\nfor i in a:\n\tp=d[i]\n\tif v[p]:\n\t\tl=0\n\t\tans+=[],\n\t\twhile v[p]:\n\t\t\tans[-1]+=p+1,\n\t\t\tv[p]=0\n\t\t\tp=d[a[p]]\n\t\t\tl+=1\n\t\tans[-1]+=l,\nprint(len(ans))\nfor i in ans:\n\tprint(i[-1],*i[:i[-1]])", "n = int(input())\nedges = [[int(x) for x in input().split()] for i in range(n-1)]\nedges = sorted(edges)\nuse_count = [0]+[int(input()) for i in range(n)]\nlo,hi = 0,10000\ndef getpar(par,u):\n    if par[par[u]] == par[u]:\n        return par[u]\n    par[u] = getpar(par,par[u])\n    return par[u]\ndef unite(par,sz,use,u,v):\n    u = getpar(par,u)\n    v = getpar(par,v)\n    par[u] = v\n    sz[v] += sz[u]\n    use[v] += use[u]\ndef solve(fp):\n    par = [i for i in range(n+1)]\n    sz = [1 for i in range(n+1)]\n    use = [use_count[i] for i in range(n+1)]\n    for edge in edges:\n        if edge[2] < fp:\n            unite(par,sz,use,edge[0],edge[1])\n    total_use = sum(use_count)\n    for i in range(n+1):\n        p = getpar(par,i)\n        if(p == i):\n            if(total_use - use[p] < sz[p]):\n                return False\n    return True\nwhile lo < hi:\n    mid = (lo+hi+1)//2\n    if solve(mid):\n        lo = mid\n    else:\n        hi = mid-1\nprint(lo)\n", "n,m=list(map(int,input().split()))\n\nmen=[]\n\nfor i in range(n):\n\tx,y=list(map(int,input().split()))\n\tmen.append((y,x-1))\n\ndef Calc(lim):\n\tcnt=[0]*m\n\tvis=[False]*n\n\tfor i in range(n):\n\t\tcnt[men[i][1]]+=1\n\tcost=0\n\tfor i in range(n):\n\t\tif men[i][1]!=0 and cnt[men[i][1]]>=lim:\n\t\t\tcnt[men[i][1]]-=1\n\t\t\tcost+=men[i][0]\n\t\t\tvis[i]=True\n\t\t\tcnt[0]+=1\n\t\n\tfor i in range(n):\n\t\tif cnt[0]<lim and vis[i] == False and men[i][1]!=0:\n\t\t\tcnt[0]+=1\n\t\t\tcost+=men[i][0]\n\treturn cost\n\nmen.sort()\n\nans = 10**18\n\nfor i in range(n):\n\tans=min(ans,Calc(i))\n\nprint(ans)\n", "\n\n\nr = list(map(int, input().split()))\nn = r[0]\nk = r[1]\nl = list()\nl.append(1)\nc = k\njustI = 0\nmaxl = 0\nprevious = 1\nprint(1, end=' ')\nfor i in range(1,n):\n    if justI == 1:\n        #l.append(max(l)+1)\n        print(maxl+1, end=' ')\n        maxl += 1\n    else:\n        # l.append(l[i-1]+c)\n        print(previous+c, end=' ')\n        previous = previous+c\n        if previous>maxl: maxl = previous\n        if c>1:\n            c-=1\n            c*=-1\n        elif c<-1:\n            c+=1\n            c*=-1\n        else:\n            justI = 1\n# for i in l:\n#     print(i, end=\" \")\n\n\n\n\n#10 4\n#1 5 2 4 3 6 7 8 9 10", "n = int(input())\nl = list(map(int, input().split()))\n\nstack = []\nfor v in l:\n    currVal = v\n    currSize = 1\n    div = v\n    \n    while stack:\n        nex, nexS, nDiv = stack[-1]\n\n        if div < nDiv:\n            currSize += nexS\n            currVal += nex\n            stack.pop()\n\n            div = currVal / currSize\n        else:\n            break\n    stack.append((currVal, currSize, div))\n\nout = []\nfor a, b, d in stack:\n    thingy = str(d)\n    for _ in range(b):\n        out.append(thingy)\n        \nprint('\\n'.join(out))\n", "import collections as cc\nimport sys\ninput=sys.stdin.readline\n#sys.setrecursionlimit(10**9)\nI=lambda:list(map(int,input().split()))\nn,m=I()\ng=[set() for i in range(n+1)]\nxx=[0]*(n+1)\nfor i in range(m):\n\tx,y=I()\n\tg[x].add(y)\n\tg[y].add(x)\nparent=[i for i in range(n+1)]\ndef find(x):\n\twhile x!=parent[x]:\n\t\tx=parent[x]\n\treturn x\ndef union(x,y):\n\ta=find(x)\n\tb=find(y)\n\tif a!=b:\n\t\tparent[a]=parent[b]=min(a,b)\nff=cc.defaultdict(int)\nused=cc.defaultdict(int)\nfor i in range(1,n+1):\n\tif find(i)==i:\n\t\t\t\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tg[i]&=g[j]\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tunion(i,j)\n\t\t\t\t\n \nprint(len(set([find(i) for i in range(1,n+1)]))-1)", "n, k = 0, int(input())\n\np = [['0'] * 100 for i in range(100)]\n\nwhile k:\n\n    for i in range(n):\n\n        if i > k: break\n\n        p[n][i] = p[i][n] = '1'\n\n        k -= i\n\n    n += 1\n\nprint(n)\n\nfor i in range(n): print(''.join(p[i][:n]))\n", "n=int(input())\na=list(map(int,input().split()))\na.sort()\nx=float('Inf')\nfor i in range(1,n):\n    x=min(x,a[i+n-1]-a[i])\nprint(min((a[n-1]-a[0])*(a[-1]-a[n]),x*(a[-1]-a[0])))", "import sys\nn = int(input())\ncol = [1 for i in range(n+2)]\ncurprime = 1\nans = 0\nif n <= 2:\n    print(1)\n    for i in range(n):\n        print(1, end = ' ')\n    return\nwhile True:\n    prime = curprime + 1;\n    while  prime <= n + 1  and col[prime] == 2:\n        prime += 1\n    if prime >= n + 1:\n        break;\n    for i in range(prime + prime,n + 2,prime):\n        col[i] = 2\n    curprime = prime\nprint(2)\nfor i in range(2, n  + 2):\n    print(col[i], end = ' ')", "n = int(input())\na,b = 0,0\nl = []\nfor _ in range(n):\n    inpt = list(map(int,input().split()))[1:]\n    li = len(inpt)\n    if li%2:\n        l.append(inpt[li//2])\n    a += sum((inpt[:li//2]))\n    b += sum((inpt[(li + 1)//2:]))\nl.sort(reverse=True)\na += sum(l[::2])\nb += sum(l[1::2])\nprint(a, b)", "s = input()\nans = 0\nfor i in range(0, len(s) - 1):\n    addQ = 0\n    subQ = 0\n    cur = 0\n    for j in range(i, len(s)):\n        if s[j] == '(':\n            cur += 1\n        elif s[j] == ')':\n            cur -= 1\n            if cur < 0 and subQ > 0:\n                cur += 2\n                subQ -= 1\n                addQ += 1\n        else:\n            if cur > 0:\n                subQ += 1\n                cur -= 1\n            else:\n                addQ += 1\n                cur += 1\n        if cur < 0:\n            break\n        if cur == 0:\n            ans += 1\nprint(ans)\n", "import sys\n\ns1, s2 = input().split()\nn = int(input())\n\nfor _ in range(n):\n    print(s1, s2)\n    killed, new = input().split()\n    if s1 == killed:\n        s1 = new\n    else:\n        s2 = new\n\nprint(s1, s2)\n", "q = int(input())\nfor i in range(q):\n  a, b = list(map(int, input().split()))\n  if a==b:\n    ans = 2*a-2\n  elif abs(a-b)==1:\n    ans = 2*min(a, b)-2\n  else:\n    c = (a*b)**0.5\n    if c%1==0:\n      c = int(c)-1\n    else:\n      c = int(c)\n    if c*(c+1)>=a*b:\n      ans = 2*c-2\n    else:\n      ans = 2*c-1\n  print(ans)", "N = int(1e6+3)\nn = int(input())\narr = list(map(int, input().split()))\ncnt = [0] * N\nfor i in arr:\n    cnt[i] += 1\nres, s = 0, 0\nfor i in range(N):\n    s += cnt[i]\n    res += s % 2\n    s //= 2\nwhile s > 0:\n    res += s % 2\n    s //= 2\nprint(res)\n", "def main():\n    from bisect import bisect\n    n, A, cf, cm, m = list(map(int, input().split()))\n    skills = list(map(int, input().split()))\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift, a, c = [], 0, 0\n    for i, b in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift, a = [0], 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    for A_width, a in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level, save = level, (A_width, floor, floor_width)\n    A_width, floor, floor_width = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    print(max_level)\n    print(' '.join(map(str, skills)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nl = list(map(int, input().split()))\n\ninv = 0\nout = 0\nmult = 1\nfor i in range(32):\n    curr = dict()\n    opp = 0\n    same = 0\n\n    for v in l:\n        if v ^ 1 in curr:\n            if v & 1:\n                opp += curr[v ^ 1]\n            else:\n                same += curr[v ^ 1]\n            \n        if v not in curr:\n            curr[v] = 0\n        curr[v] += 1\n\n    for i in range(n):\n        l[i] >>= 1\n\n    if same <= opp:\n        inv += same\n    else:\n        inv += opp\n        out += mult\n    mult *= 2\nprint(inv, out)\n    \n    \n", "def merge_sort(a, l, r):\n\n  res = 0\n\n  if l < r:\n\n    m = (l + r) // 2\n\n    res += merge_sort(a, l, m)\n\n    res += merge_sort(a, m + 1, r)\n\n    \n\n    i = l\n\n    j = m + 1\n\n    b = []\n\n    while i <= m and j <= r:\n\n      if a[i] <= a[j]:\n\n        b.append(a[i])\n\n        i += 1\n\n      else:\n\n        b.append(a[j])\n\n        j += 1\n\n        res += m - i + 1\n\n\n\n    while i <= m:\n\n      b.append(a[i])\n\n      i += 1\n\n\n\n    while j <= r:\n\n      b.append(a[j])\n\n      j += 1\n\n    \n\n    for idx, val in enumerate(b):\n\n      a[idx + l] = val\n\n      \n\n  return res \n\n\n\ninput()\n\na = [int(x) for x in input().split()]\n\nn = len(a)\n\nans = merge_sort(a, 0, n - 1)\n\nif ans & 1 == 0:\n\n  ans *= 2\n\nelse:\n\n  ans = ans * 2 - 1\n\nprint(ans)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "n,m = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nfor i in range(m):\n    ax,bx,x = map(int,input().split())\n    ans = max(ans,(a[ax-1]+a[bx-1])/x)\nprint(ans)", "n,d = [int(i) for i in input().split()]\nxAxis = [int(i) for i in input().split()]\ncnt = 0\ntemp = []\ntemp.append(xAxis[0])\n\nfor i in range(len(temp),len(xAxis)):\n    temp.append(xAxis[i])\n    if temp[-1] - temp[0] > d:\n        cnt += (len(temp)-2) * (len(temp)-3) /2\n        del(temp[0])\n        while len(temp) > 1:\n            if temp[-1] - temp[0] > d:\n                cnt += (len(temp)-2) * (len(temp)-3) /2\n                del(temp[0])\n            else: break\n    if i == len(xAxis) - 1 and temp[-1] - temp[0] <= d:\n        cnt += len(temp) * (len(temp)-1) * (len(temp)-2) / (3*2)\n\nprint(int(cnt))\n", "m = int(input())\ns = input().strip()\n\nsa = [0] * len(s)\nfor i in range(len(s)):\n\tsa[i] = ord(s[i]) - ord('a')\n\nsa = [-1] + sa + [-1]\n\ndef check_value(sa, m, threshold):\n\tprev_ind = 0\n\tfor i in range(len(sa)):\n\t\tif sa[i] <= threshold:\n\t\t\tif i - prev_ind <= m:\n\t\t\t\tprev_ind = i\n\t\t\telse:\n\t\t\t\treturn False\n\treturn True\n\ndef get_indexes(sa, threshold):\n\tseq = [i for i in range(len(sa)) if sa[i] <= threshold]\n\t# seq = []\n\t# for i in range(len(sa)):\n\t# \tif sa[i] < threshold:\n\t# \t\tseq[i].append(sa[i], i)\n\treturn seq\n\ndef filter_indexes(sa, seq, el, m):\n\tnew_seq = [0]\n\tfor i in range(1, len(seq) - 1):\n\t\tif sa[seq[i]] != el or (sa[seq[i]] == el and seq[i+1] - new_seq[-1] > m):\n\t\t\tnew_seq.append(seq[i])\n\treturn new_seq[1:]\n\n\nthreshold = -1\nwhile (not check_value(sa, m, threshold)):\n\t# print(threshold, get_indexes(sa, threshold))\n\tthreshold += 1\n# print(threshold, get_indexes(sa, threshold), sa)\n\nseq = get_indexes(sa, threshold)\nseq = filter_indexes(sa, seq, threshold, m)\n\ns = ''.join(sorted([chr(ord('a') + sa[x]) for x in seq]))\nprint(s)", "# for _ in range(int(input())):\nn = int(input())\narr = list(map(int,input().split()))\nleft,right = [-1]*n,[n]*n\nans = [0]*n\nst = [0]\nfor i in range(1,n):\n    while st and arr[st[-1]]>=arr[i]:\n        st.pop()\n    if st: left[i] = st[-1]\n    st.append(i)\nst = [n-1]\nfor i in range(n-2,-1,-1):\n    while st and arr[st[-1]]>=arr[i]:\n        st.pop()\n    if st: right[i] = st[-1]\n    st.append(i)\nfor i in range(n):\n    ans[right[i]-left[i]-2] = max(ans[right[i]-left[i]-2],arr[i])\nans[0] = max(arr)\nans[-1] = min(arr)\nfor i in range(n-2,0,-1):\n    ans[i] = max(ans[i],ans[i+1])\nprint(\" \".join(map(str,ans)))", "s = 0\nfor t in range(int(input())): s ^= int((8 * int(input()) + 1) ** 0.5 - 1) // 2\nprint(['YES', 'NO'][s > 0])", "n=int(input())\narr=[int(i) for i in input().split()]\ndes=[int(i) for i in input().split()]\nans=0\nleft=[-1 for i in range(n)]\nright=[-1 for i in range(n)]\nlast=0\npresum=[]\nparr=[]\nfor i in arr:\n    presum.append(last+i)\n    last+=i\nfor i in des[::-1]:\n    l=0;r=0\n    parr.append(ans)\n    if i==1 or left[i-2]==-1:\n        left[i-1]=i-1\n    else:\n        left[i-1]=left[i-2]\n    l=left[i-1]\n    if i==n or right[i]==-1:\n        right[i-1]=i-1\n    else:\n        right[i-1]=right[i]\n    r=right[i-1]\n    if l==0 and ans<presum[r]:\n        ans=presum[r]\n    elif ans<presum[r]-presum[l-1]:\n        ans=presum[r]-presum[l-1]\n    left[r]=l\n    right[l]=r\nfor i in parr[::-1]:\n    print(i)\n\n", "#besme taala\n#ya_hossein\nfrom sys import stdin\ninput = stdin.readline\nn, sum, point = int(input()), 0, 1\nnum = (n+1)*[0]\nf = (n+1)*[0]\nfor i in range(n):\n    k = list(map(int, input().split()))\n    if k[0] == 1:\n        f[k[1] - 1] += k[2]\n        sum += k[2]*k[1]\n    elif k[0] == 2:\n        num[point] = k[1]\n        sum += k[1]\n        point += 1\n    elif k[0] == 3:\n        point -= 1\n        sum -= num[point] + f[point]\n        f[point - 1] += f[point]\n        f[point] = 0\n    print('%.6f' % (sum / point))", "# \u0422\u0443\u043f\u043e \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043b \u0440\u0435\u0448\u0435\u043d\u0438\u0435, \u0438\u0431\u043e \u043d\u0438\u043a\u0430\u043a \u043d\u0435 \u043f\u043e\u0439\u043c\u0443 \u043f\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u0432 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0437\u0430 \u043c\u0435\u043d\u0435\u0435 \u0447\u0435\u043c 1 #\u0441\u0435\u043a\u0443\u043d\u0434\u0443((( \n\nfrom sys import stdin\n\ndef run(n, s):\n    m = 0\n    small = n // 2\n    for big in range(n-1, (n+1)//2-1, -1):\n        while small >= 0 and s[small] > s[big] / 2:\n            small -= 1\n        if small == -1:\n            break\n        small -= 1\n        m += 1\n    print(n-m)\n\nn = int(input())\ns = sorted([int(x) for x in stdin.read().strip().split('\\n')])\nrun(n, s)", "#!/usr/bin/env python3\n\n\ndef main():\n    try:\n        while True:\n            n = int(input())\n            req = [tuple(map(int, input().split())) for i in range(n)]\n            used = [(req[0][0], req[0][0] + req[0][1])]\n            print(used[0][0], used[0][1] - 1)\n            for start, dur in req[1:]:\n                last = 1\n                for a, b in used:\n                    if last <= start and start + dur <= a:\n                        used.append((start, start + dur))\n                        used.sort()\n                        print(start, start + dur - 1)\n                        break\n                    last = b\n                else:\n                    if start >= used[-1][1]:\n                        used.append((start, start + dur))\n                        used.sort()\n                        print(start, start + dur - 1)\n                    else:\n                        last = 1\n                        for a, b in used:\n                            if a - last >= dur:\n                                used.append((last, last + dur))\n                                used.sort()\n                                break\n                            last = b\n                        else:\n                            used.append((last, last + dur))\n                            # used.sort()\n                        print(last, last + dur - 1)\n\n    except EOFError:\n        pass\n\n\nmain()\n", "def evens(A):\n    n = len(A)\n    l = n//2-1; r = n//2\n    if len(A)%2 == 1: l+= 1\n    ans = [max(A[l], A[r])]\n    while r < n-1:\n        l-= 1; r+= 1\n        ans.append(max(ans[-1], A[l], A[r]))\n    return ans\n\ndef interleave(A, B):\n    q = []\n    for i in range(len(B)): q+= [A[i], B[i]]\n    if len(A) != len(B): q.append(A[-1])\n    return q\n\nn = int(input())\nA = list(map(int,input().split()))\nM = [min(A[i],A[i+1]) for i in range(n-1)]\nansA = evens(A)\nansM = evens(M) if n>1 else []\nif n%2 == 0: print(*interleave(ansA, ansM[1:]), max(A))\nelse: print(*interleave(ansM, ansA[1:]), max(A))", "# https://codeforces.com/problemset/problem/848/B\n\ndef push(d, val, type_, arr):\n    # pos index\n    type_ %= 2\n    if val not in d:\n        d[val] = [[],[]]\n    d[val][type_].append(arr)\n\nd = {}\n\nn, w, h = map(int, input().split())\nfor index in range(n):\n    g, p, t = map(int, input().split())\n    push(d, p-t, g, [p ,index])\n    \nfor k, v in d.items():\n    v[0]=sorted(v[0], key = lambda x: x[0], reverse=True)\n    v[1]=sorted(v[1], key = lambda x: x[0], reverse=False)\n    \nans = [0] * n\n\nfor v in d.values():\n    cur=0\n    bound = len(v[1])\n    step  = len(v[0])\n    merge = v[0]+v[1]\n    n_    = len(merge)\n\n    for pos, index in merge:\n        if cur<bound:\n            ans[index]=str(merge[(step+cur)%n_][0])+' '+str(h)\n        else:\n            ans[index]=str(w)+' '+str(merge[(step+cur)%n_][0])\n        cur+=1    \nprint('\\n'.join(ans))    ", "\ndef Sieve(n): \n    ret = []\n    divlis = [-1] * (n+1) \n    \n    flag = [True] * (n+1)\n    flag[0] = False\n    flag[1] = False\n\n    ind = 2\n    while ind <= n:\n\n        if flag[ind]:\n            ret.append(ind)\n\n            ind2 = ind ** 2\n\n            while ind2 <= n:\n                flag[ind2] = False\n                divlis[ind2] = ind\n                ind2 += ind\n\n        ind += 1\n\n    return ret,divlis\n\n\nsev,divlis = Sieve(210000)\n\nn = int(input())\na = list(map(int,input().split()))\n\ndic = {}\n\nfor i in range(n):\n\n    nd = {}\n\n    na = a[i]\n    while divlis[na] != -1:\n\n        if divlis[na] not in nd:\n            nd[divlis[na]] = 0\n        nd[divlis[na]] += 1\n\n        na //= divlis[na]\n\n    if na != 1:\n        if na not in nd:\n            nd[na] = 1\n        else:\n            nd[na] += 1\n\n    for x in nd:\n        if x not in dic:\n            dic[x] = []\n        dic[x].append(nd[x])\n\nans = 1\n\nfor i in dic:\n\n    if len(dic[i]) < n-1:\n        #print (i,\"a\")\n        continue\n    \n    dic[i].sort()\n\n    if len(dic[i]) == n:\n        ans *= i ** dic[i][1]\n        #print (i,\"b\")\n    else:\n        ans *= i ** dic[i][0]\n        #print (i,\"c\")\n\nprint (ans)\n", "class DSU(object):\n    def __init__(self, n):\n        self.father = list(range(n))\n        self.size = n\n\n    def union(self, x, s):\n        x = self.find(x)\n        s = self.find(s)\n        if x == s:\n            return\n        self.father[s] = x\n        self.size -= 1\n\n    def find(self, x):\n        xf = self.father[x]\n        if xf != x:\n            self.father[x] = self.find(xf)\n        return self.father[x]\n\n\ndef is_invalid(a, b, ds):\n    return ds.find(a) == ds.find(b)\n\n\nn, k = list(map(int, input().split()))\nds = DSU(n * 2)\nfor i in range(k):\n    first, second, color = list(map(int, input().split()))\n    first -= 1\n    second -= 1\n    if color == 0:\n        if is_invalid(first, second, ds):\n            print(0)\n            return\n        ds.union(first, second + n)\n        ds.union(first + n, second)\n    else:\n        if is_invalid(first, second + n, ds):\n            print(0)\n            return\n        ds.union(first, second)\n        ds.union(first + n, second + n)\n\nsum = 1\nfor i in range(ds.size // 2 - 1):\n    sum = (sum * 2) % (10 ** 9 + 7)\nprint(sum)\n", "n = int(input())\narr = list(map(int, input().split()))\ncnt_zero, res = 0, 0\nfor i in range(n-1, -1, -1):\n    if arr[i] == 0:\n        cnt_zero += 1\n    else:\n        res += cnt_zero\nprint(res)\n", "# import numpy as np\n\ndef dist(a, b):\n    return (b - a) % n\n\nn, m = list(map(int, input().split(\" \")))\n\nsweets = {i: [] for i in range(n)}\nfor i in range(m):\n    s, t = list(map(int, input().split(\" \")))\n    sweets[s - 1].append(t - 1)\n\nt = {i: -1e6 for i in range(n)}\n\nfor i in range(n):\n    sweets[i] = sorted(sweets[i], key=lambda x: -dist(i, x))\n    if len(sweets[i]):\n        t[i] = (len(sweets[i]) - 1) * n + dist(i, sweets[i][-1])\n\n# t = np.array([t[i] for i in range(n)], dtype=int)\n# raise ValueError(\"\")\n# print(t)\nresult = []\n\nm_max, i_max = 0, 0\nfor i, v in t.items():\n    if v + i > m_max + i_max:\n        m_max, i_max = v, i\nresult.append(m_max + i_max)\n\nfor s in range(1, n):\n    old_max = t[i_max] + dist(s, i_max)\n    new_max = t[s - 1] + dist(s, s - 1)\n    if new_max > old_max:\n        result.append(new_max)\n        i_max = s - 1\n    else:\n        result.append(old_max)\n\nprint(\" \".join(map(str, result)))", "c = []\nk = int(input())\nfor i in range(k):\n    c.append(int(input()))\n\nmaxN = 1010\nbinomials = [[1], [1, 1]]\nfor i in range(2, maxN):\n    binomials.append([1])\n    for j in range(1, i):\n        binomials[i].append((binomials[i - 1][j - 1] + binomials[i - 1][j]) % 1000000007)\n    binomials[i].append(1)\n\ndp = [1] * k\nfor i in range(1, k):\n    dp[i] = (dp[i - 1] * binomials[sum(c[:i + 1]) - 1][c[i] - 1]) % 1000000007\n\nprint(dp[k - 1])\n", "p=998244353\nn=int(input())\nfacs=[1]\nfor i in range(1,n):\n    facs.append(facs[-1]*i%p)\ngraph=[0]*n\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    graph[u-1]+=1\n    graph[v-1]+=1\nprod=n\nfor i in range(n):\n    prod=prod*facs[graph[i]]%p\nprint(prod)", "n = int(input())\ns = [0] * 7\nfor _ in range(n):\n\tmes = input()\n\tfor i in range(7):\n\t\ts[i] += (mes[i] == '1')\nprint(max(s))", "import collections\nfrom collections import defaultdict\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nsuma=[int(i) for i in input().split() if i!='\\n']\ngraph=defaultdict(list)\nfor i in range(n-1):\n    graph[i+2].append(par[i])\n    graph[par[i]].append(i+2)\nweight=[0]*(n+1)\nweight[1]=suma[0]\nqueue=collections.deque([1])\nvisited=set()\nvisited.add(1)\nok=True\nwhile queue:\n    vertex=queue.popleft()\n    for child in graph[vertex]:\n        if child not in visited: \n            if suma[child-1]==-1:\n                mina=[]\n                if len(graph[child])==1:\n                    mina=[0]\n                else:   \n                    for j in graph[child]:\n                        if j!=vertex:\n                            mina.append(suma[j-1]-suma[vertex-1])\n                ans=suma[vertex-1]+min(mina)\n                suma[child-1]=ans\n                if suma[child-1]<suma[vertex-1]:\n                    ok=False\n                else:\n                    weight[child]=(suma[child-1]-suma[vertex-1])\n            else:\n                if suma[child-1]<suma[vertex-1]:\n                    ok=False\n                else:\n                    weight[child]=(suma[child-1]-suma[vertex-1])\n            queue.append(child)\n            visited.add(child)\nif ok==True:\n    print(sum(weight))\nelse:\n    print(-1)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nB=0\nC=0\nD=0\nE=0\n\nfor i in range(n):\n    a=A[i]\n\n    if i%2==0:\n        B+=a//2\n        C+=a-a//2\n        D+=a-a//2\n        E+=a//2\n\n    else:\n        B+=a-a//2\n        C+=a//2\n        D+=a//2\n        E+=a-a//2\n\nprint(max(min(B,C),min(D,E)))\n        \n        \n", "n,k=list(map(int,input().split()))\nt=set(map(int,input().split()))\ny=x=min(t)\nt=list(t)\nwhile True:\n    for i in t:\n        if i%x>k:x=i//(i//x+1)\n    if y==x:break\n    y=x\nprint(y)\n\n", "print('YES' if input().count('1')+1>>1<<1 >= input().count('1') else 'NO')", "n = int(input())\nl = sorted(map(int, input().split()))\ntot = sum(l[n:]) - sum(l[:n])\nMOD = 998244353\nfact = [1]\nfor i in range(1, 2 * n + 1):\n    fact.append((fact[-1] * i) % MOD)\ntot *= fact[2 * n]\ninv = pow(fact[n], MOD-3, MOD)\ntot *= inv\nprint(tot % MOD)", "n = int(input())\n\nb = list(map(int, input().split()))\n\nm, M = min(b), max(b)\nif m == M:\n    if M == 0:\n        print('YES')\n        print(' '.join(['1' for i in range(n)]))\n    else:\n        print('NO')\nelse:\n    print('YES')\n\n    pos = list([i for i in range(n) if b[i] == M and b[i - 1] < M])[0]\n\n    a = [0 for i in range(n)]\n\n    a[pos] = M\n    a[pos - 1] = (M << 1) + b[pos - 1]\n\n    for i in range(2, n):\n        a[pos - i] = a[pos - i + 1] + b[pos - i]\n\n    print(*a)\n", "n = int(input())\nif n > 1:\n    p = [0] * n\n    r = format(n - 1, 'b')[:: -1]\n    l = len(r) - 1\n    for i in range(n):\n        t = list(map(int, input().split()))\n        t.pop(i)\n        s = 0\n        for j in range(l):\n            if r[j]  == '1': s |= t.pop()\n            t = [t[k] | t[k + 1] for k in range(0, len(t), 2)]\n        p[i] = s | t[0]\n    print(' '.join(map(str, p)))\nelse: print(0)", "import operator\nimport itertools\nimport bisect\n\ndef maxl(l, m, mx):\n    l.sort(key=operator.itemgetter(1))\n    \n    m1, m2 = 0, 0\n    pp = None\n    for b, p in l:\n        if p != pp:\n            if 2 * p > m:\n                break\n            if m1 and m2 and m1 + m2 > mx:\n                mx = m1 + m2\n            m1, m2 = b, 0\n            pp = p\n        else:\n            if b > m1:\n                m1, m2 = b, m1\n            elif b > m2:\n                m2 = b\n    if m1 and m2 and m1 + m2 > mx:\n         mx = m1 + m2\n         \n    lp = [p for(b, p) in l]\n    lb = list(itertools.accumulate((b for (b, p) in l), max))\n    for i, ((b, p), mb) in enumerate(zip(l, lb)):\n        p1 = min(m - p, p - 1)\n        k = bisect.bisect_right(lp, p1, 0, i)\n        if k:\n            x = b + lb[k - 1]\n            if x > mx:\n                mx = x\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nmx = 0\nif fc and fd:\n    bc, pc = max(fc, key=operator.itemgetter(0))\n    bd, pd = max(fd, key=operator.itemgetter(0))\n    mx = bc + bd\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "s, t = input(), input()\nn, m = len(t), len(s) + 1\n\nd = 1000000007\ng = [1] * m\n\nf = k = 0\nfor i in range(1, m):\n    if s[i - n:i] == t: k = i\n    if k: f = (f + g[k - n]) % d\n    g[i] += (g[i - 1] + f) % d\n\nprint(f)\n", "import sys\ninput = sys.stdin.readline\n\nn, d, m = map(int, input().split())\na = list(map(int, input().split()))\n\nup = []\ndown = []\nfor i in range(n):\n    if a[i] > m:\n        up.append(a[i])\n    else:\n        down.append(a[i])\n        \nup = sorted(up)\ndown = sorted(down)\n\nif not up:\n    print(sum(down))\n    return\n\nans = 0\nans += up.pop()\nlap, rem = divmod((n - 1), (d + 1))\nfor i in range(rem):\n    if not down:\n        break\n    else:\n        ans += down.pop()\n\nmatome = []\nwhile down:\n    tmp = 0\n    for _ in range(d + 1):\n        if down:\n            tmp += down.pop()\n    matome.append(tmp)\n\nmatome = sorted(matome + up, reverse=True)\nans += sum(matome[0:min(lap, len(matome))])\n\nprint(ans)", "import sys\ndef main():\n    n = int(input())\n    ans = []\n    while n:\n        n += -1\n        p, q, b = list(map(int, input().split()))\n        if p * pow(b, 99, q) % q: ans.append(\"Infinite\")\n        else: ans.append(\"Finite\")\n    for _ in ans: print(_)\nmain()\n", "n, m = map(int, input().split())\na = set(map(int, input().split()))\n \ny = 2 ** n\nmk = [0] * (2 * y)\ncur = 0\nfor x in a:\n    if mk[x]: continue\n    mk[x] = 1\n    st = [x]\n    while st:\n        u = st.pop()\n        if u < y:\n            if not mk[y + u]:\n                mk[y + u] = 1\n                st.append(y + u)\n        else:\n            for b in range(n):\n                v = u | 1 << b\n                if u < v and not mk[v]:\n                    mk[v] = 1\n                    st.append(v)\n            v = y - 1 - (u - y)\n            if v in a and not mk[v]:\n                mk[v] = 1\n                st.append(v)\n    cur += 1\n    \nprint(cur)", "def __starting_point():\n    n, s = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n    i = n // 2\n    median = a[i]\n    result = 0\n    if median > s:\n        for j in range(i + 1):\n            result += max(0, a[j] - s)\n    elif median < s:\n        for j in range(i, n):\n            result += max(0, s - a[j])\n    print(result)\n\n__starting_point()", "n = int(input())\na = list(map(int,input().split()))\nif sum(a) == 1:\n  print(-1)\n  return\nsm = sum(a)\nnmax = 10**5+10\neratos = [0 for i in range(nmax+1)]\nprime = []\ncnt = 2\nwhile True:\n  while cnt <= nmax and eratos[cnt]:\n    cnt += 1\n  if cnt > nmax:\n    break\n  eratos[cnt] = 1\n  prime.append(cnt)\n  for i in range(cnt**2,nmax+1,cnt):\n    eratos[i] = 1\ndvls = []\nfor i in prime:\n  if sm%i == 0:\n    dvls.append(i)\nansls = []\nls = []\ncnti = 0\nfor dv in dvls:\n  ans = 0\n  if dv == 2:\n    for i in range(n):\n      if a[i]:\n        cnti += 1\n        if cnti%2:\n          pivot = i\n        else:\n          ans += i-pivot\n  else:\n    for i in range(n):\n      if a[i]:\n        cnti += 1\n        if 1 <= cnti%dv <= dv//2:\n          ls.append(i)\n        elif cnti%dv == dv//2+1:\n          pivot = i\n          for j in ls:\n            ans += pivot-j\n          ls.clear()\n        else:\n          ans += i-pivot\n  ansls.append(ans)\nprint(min(ansls))", "k, q = map(int, input().split())\nt = [0] * (k + 1)\nt[1] = 1\nc = [0]\nn = i = 1\nwhile i < 1001:\n    if (2000 * t[k] > i - (10**-7)):\n        c.append(n)\n        i += 1\n    else:\n        t = [0] + [(j * t[j] + (k - j + 1) * t[j - 1]) / k for j in range(1, k + 1)]\n        n += 1\nfor i in range(q): \n    print(c[int(input())])", "R = lambda: map(int, input().split())\nn, m = R()\ng = [list() for i in range(n)]\nfor i in range(n):\n    g[i] = list(R())\ndp1, dp2, dp3, dp4 = ([[0] * (m + 1) for j in range(n + 1)] for i in range(4))\nfor i in range(n):\n    for j in range(m):\n        dp1[i][j] = g[i][j] + max(dp1[i - 1][j], dp1[i][j - 1])\n    for j in range(m - 1, -1, -1):\n        dp2[i][j] = g[i][j] + max(dp2[i - 1][j], dp2[i][j + 1])\nfor i in range(n - 1, -1, -1):\n    for j in range(m):\n        dp3[i][j] = g[i][j] + max(dp3[i + 1][j], dp3[i][j - 1])\n    for j in range(m - 1, -1, -1):\n        dp4[i][j] = g[i][j] + max(dp4[i + 1][j], dp4[i][j + 1])\nprint(max(max(dp1[i][j - 1] + dp2[i - 1][j] + dp3[i + 1][j] + dp4[i][j + 1], dp1[i - 1][j] + dp2[i][j + 1] + dp3[i][j - 1] + dp4[i + 1][j]) for j in range(1, m - 1) for i in range(1, n - 1)))", "n = int(input())\nprint('YES')\nfor _ in range(n):\n    x, y, *z = list(map(int, input().split()))\n    print((x & 1) * 2 + (y & 1) + 1)", "def main():\n    from heapq import heapify, heapreplace\n    input()\n    s = set(map(int, input().split()))\n    xx = [-x for x in s]\n    heapify(xx)\n    while True:\n        x = -xx[0]\n        while x != 1:\n            x //= 2\n            if x not in s:\n                s.add(x)\n                heapreplace(xx, -x)\n                break\n        else:\n            break\n    print(' '.join(str(-x) for x in xx))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def comp(x):\n    for i in range(2, x):\n        if x % i == 0:\n            return True\n    return False\n\nN = int(input())\n\nif N == 4:\n    print('YES', '1', '3', '2', '4', sep = '\\n')\nelif comp(N):\n    print('NO')\nelse:\n    print('YES', '1', sep = '\\n')\n    if N > 1:\n        for i in range(2, N):\n            print((i - 1) * pow(i, N - 2, N) % N)\n        print(N)\n    \n", "from collections import defaultdict\n\n\ndef __starting_point():\n    n, T = [int(_) for _ in input().split()]\n    data = defaultdict(list)\n    for i in range(n):\n        t, q = [int(_) for _ in input().split()]\n        data[T - t].append(q)\n\n    prev_level = []\n    for level_id in range(1, T + 1):\n        level = sorted(data[T - level_id] + prev_level, reverse=True) \n        if T - level_id <= 10:\n            max_size = 2 ** (T - level_id)\n            level = level[:max_size]\n        if len(level) % 2 == 1:\n            level.append(0)\n        prev_level = [\n            level[i] + level[i + 1]\n            for i in range(0, len(level), 2)\n        ]\n    print(prev_level[0])\n\n__starting_point()", "n,k=map(int,input().split())\na=list(map(int,input().split()))\nf=0\nb=[]\np=sum(a)//k\n\nq=0\nc=0\nfor i in a:\n\tq+=i\n\tc+=1\n\tif p==q:\n\t\tb.append(c)\n\t\tc=0\n\t\tq=0\n\telif q>p:\n\t\tf=1\n\t\tbreak\nif f==1 or len(b)!=k or p!=sum(a)/k:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")\n\tfor i in b:\n\t\tprint(i,end=\" \")\n\t\n", "f = lambda: list(map(int, input().split()))\n\nn, m, w = f()\n\nwb = [(0, 0)] + list(zip(f(), f()))\n\nt = list(range(n + 1))\n\n\n\n\n\ndef g(x):\n\n    if x == t[x]: return x\n\n    t[x] = g(t[x])\n\n    return t[x]\n\n\n\n\n\nfor i in range(m):\n\n    x, y = f()\n\n    x, y = g(x), g(y)\n\n    if x != y: t[y] = x\n\n\n\np = [[] for j in range(n + 1)]\n\nfor i in range(1, n + 1): p[g(i)].append(i)\n\n\n\nd = [1] + [0] * w\n\nfor q in p:\n\n    if len(q) > 1:\n\n        WB = [wb[i] for i in q]\n\n        SW = sum(q[0] for q in WB)\n\n        SB = sum(q[1] for q in WB)\n\n\n\n        for D in range(w, -1, -1):\n\n            if d[D]:\n\n                if D + SW <= w: d[D + SW] = max(d[D + SW], d[D] + SB)\n\n                for W, B in WB:\n\n                    if D + W <= w: d[D + W] = max(d[D + W], d[D] + B)\n\n\n\n    elif len(q) == 1:\n\n        W, B = wb[q[0]]\n\n        for D in range(w - W, -1, -1):\n\n            if d[D]: d[D + W] = max(d[D + W], d[D] + B)\n\n\n\nprint(max(d) - 1)\n\n\n\n# Made By Mostafa_Khaled\n", "import sys\nreadline = sys.stdin.readline\nMOD = 10**9+7;S = readline().strip().split('1')\nif len(S) == 1:print(len(S[0]))\nelse:\n    S = [len(s)+1 for s in S];ans = S[0]*S[-1];S = S[1:-1];dp = [0]*(max(S)+2);dp[0] = 1\n    for ai in S:\n        res = 0;rz = 0\n        for i in range(ai+1):res = (res + dp[i])%MOD;rz = (rz + (ai-i)*dp[i])%MOD;dp[i] = 0\n        dp[0] = rz;dp[ai] = res\n    aaa = 0\n    for d in dp:aaa = (aaa+d)%MOD\n    print(aaa*ans%MOD)        ", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split())) + [0]*500000\n    ans_S = 0\n    a[n] = a[0] + m\n    s = [0]*600600\n    for i in range(n):\n        s[i] = a[i + 1] - a[i]\n    s[n] = -1\n    for i in range(n):\n        s[2*n - i] = s[i]\n    for i in range(2*n + 1, 3*n + 1):\n        s[i] = s[i - n]\n    l, r = 0, 0\n    z = [0]*600600\n    for i in range(1, 3*n + 1):\n        if i < r:\n            z[i] = z[i - l]\n        while i + z[i] <= 3*n and (s[i + z[i]] == s[z[i]]):\n            z[i] += 1\n        if i + z[i] > r:\n            l = i\n            r = i + z[i]\n    ans = []\n    for i in range(n + 1, 2*n + 1):\n        if z[i] < n:\n            continue\n        ans_S += 1\n        ans.append((a[0] + a[2*n - i + 1]) % m)\n    ans.sort()\n    print(ans_S)\n    print(*ans)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()", "h,w,n = list(map(int, input().split()))\nl   = [tuple(map(int, input().split())) for i in range(n)]\nl.sort()\nl  += [(h,w)]\nN,B = (h + w + 1)<<1, 10**9+7\nfac,inv = [1] * N, [1] * N\nfor i in range(2, N):\n    fac[i] = (i * fac[i-1]) % B\n    inv[i] = (-(B//i) * (inv[B%i])) % B\nfor i in range(2, N):\n    inv[i] = (inv[i] * inv[i-1]) % B \nC   = lambda u, v: (((fac[u] * inv[v]) % B) * inv[u - v]) % B\nd   = []\nfor i in range(n+1):\n    d += [C(l[i][0] + l[i][1] - 2, l[i][0] - 1)]\n    for j in range(i):\n        if l[j][1] <= l[i][1]:\n            d[i] = (d[i] + B - (d[j] * C(l[i][0] + l[i][1] - l[j][0] - l[j][1], l[i][0] - l[j][0]) % B)) % B\nprint(d[n])\n\n    \n\n", "\nRESULT = ['Lose', 'Loop', 'Win']\n\nclass Player(object):\n    \"\"\"docstring for Player\"\"\"\n    def __init__(self):\n        super(Player, self).__init__()\n        self.a = list(map(int, input().split()))[1:]\n        self.f = [len(self.a)] * n\n        self.f[0] = 0\n\n    def prev(self, i):\n        for x in self.a:\n            if self.f[(i - x) % n] > 0:\n                yield (i - x) % n\n\n    def print_result(self):\n        print(*[RESULT[min(x, 1)] for x in self.f[1:]])\n\nn = int(input())\na, b = Player(), Player()\nq = [(a, b, 0), (b, a, 0)]\nwhile q:\n    x, y, i = q.pop()\n    for j in y.prev(i):\n        y.f[j] = -1\n        for k in x.prev(j):\n            x.f[k] -= 1\n            if x.f[k] == 0:\n                q.append((x, y, k))\n\na.print_result()\nb.print_result()", "f = lambda: list(map(int, input().split()))\nn, m = f()\nt = list(f())\np = [1e9] + [abs(b - a) for a, b in zip(t, t[1:])] + [1e9]\nL, R = [0] * n, [0] * n\nfor i in range(1, n):\n    j = n - i\n    x, y = i - 1, j + 1\n    a, b = p[i], p[j]\n    while a > p[x]: x = L[x]\n    while b >= p[y]: y = R[y]\n    L[i], R[j] = x, y\nfor k in range(m):\n    l, r = f()\n    print(sum((i - max(l - 1, L[i])) * (min(r, R[i]) - i) * p[i] for i in range(l, r)))\n", "import sys\nfrom array import array  # noqa: F401\n\nn = int(input())\nmatrix = [array('i', list(map(int, input().split()))) for _ in range(n)]\naa = tuple([int(x) - 1 for x in input().split()])\nans = [''] * n\n\nfor i in range(n-1, -1, -1):\n    x = aa[i]\n\n    for a in range(n):\n        for b in range(n):\n            if matrix[a][b] > matrix[a][x] + matrix[x][b]:\n                matrix[a][b] = matrix[a][x] + matrix[x][b]\n\n    val, overflow = 0, 0\n    for a in aa[i:]:\n        for b in aa[i:]:\n            val += matrix[a][b]\n        if val > 10**9:\n            overflow += 1\n            val -= 10**9\n\n    ans[i] = str(10**9 * overflow + val)\n\nprint(' '.join(ans))\n", "from collections import defaultdict\nn,p,k = list(map(int,input().split()))\nd = defaultdict(int)\na = list(map(int,input().split()))\nans = 0\nfor i in a:\n    b = pow(i,4,p)\n    temp = (i * k) % p\n    fin = (b - temp) % p\n    ans += d[fin]\n    d[fin] += 1\nprint(ans)\n", "import heapq\n\ndef sum_sqaure(a, k):\n    q, r = divmod(a, k)\n    return q**2 * (k-r) + (q+1)**2 * r\n\ndef diff(a, k):\n    return sum_sqaure(a, k+1) - sum_sqaure(a, k)\n\nn, k = map(int, input().split())\nnums = list(map(int, input().split()))\n\ncurr = sum(sum_sqaure(a, 1) for a in nums)\nQ = [(diff(a, 1), a, 1) for a in nums]\nheapq.heapify(Q)\nfor __ in range(k - n):\n    d, a, i = heapq.heappop(Q)\n    curr += d\n    heapq.heappush(Q, (diff(a, i+1), a, i+1))\nprint(curr)", "# 429A\n\n__author__ = 'artyom'\n\n\ndef read_int():\n  return int(input())\n\n\ndef read_int_ary():\n  return map(int, input().split())\n\n\nn = read_int()\n\ng = [[] for x in range(n + 1)]\nfor i in range(n - 1):\n  u, v = read_int_ary()\n  g[u].append(v)\n  g[v].append(u)\n\ninit = [0] + list(read_int_ary())\ngoal = [0] + list(read_int_ary())\ns = []\n\n\ndef solve(graph, start):\n  stack = [(start, -1, 0, [1, 1])]\n  while stack:\n    node, parent, sign, st = stack.pop(-1)\n    if init[node] ^ st[sign] == goal[node]:\n      s.append(node)\n      st = list(st)\n      st[sign] ^= 1\n    sign ^= 1\n    for child in graph[node]:\n      if child != parent:\n        stack.append((child, node, sign, st))\n\n\nsolve(g, 1)\nprint(len(s))\nfor v in s:\n  print(v)", "def prime(n):\n    m = int(n ** 0.5) + 1\n    t = [1] * (n + 1)\n    for i in range(3, m):\n        if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n + 1, 2) if t[i]]\n\ndef gcd(a, b):\n    c = a % b\n    return gcd(b, c) if c else b\n\np = prime(31650)\ndef g(n):\n    m = int(n ** 0.5)\n    for j in p:\n        if n % j == 0: return True\n        if j > m: return False\n\ndef f(n):\n    a, b = n, n + 1\n    while g(a): a -= 1\n    while g(b): b += 1\n    p, q = (b - 2) * a + 2 * (n - b + 1), 2 * a * b\n    d = gcd(p, q)\n    print(str(p // d) + '/' + str(q // d))\n\nfor i in range(int(input())): f(int(input()))\n", "from itertools import starmap\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n\n    a = list(range(n + 1))\n    flipped = False\n    start = 0\n    end = n\n\n    for _ in range(q):\n        cmd, *args = list(map(int, input().split()))\n\n        if cmd == 1:\n            p = args[0]\n            if p > end-start-p:\n                flipped = not flipped\n                p = end-start-p\n            if flipped:\n                a[end-p:end-2*p:-1] = starmap(\n                    lambda a, b: a+n-b,\n                    list(zip(a[end-p:end-2*p:-1], a[end-p:end]))\n                )\n                end -= p\n            else:\n                start += p\n                a[start:start+p] = starmap(\n                    lambda a, b: a-b,\n                    list(zip(a[start:start+p], a[start:start-p:-1]))\n                )\n        else:\n            l, r = args\n            if flipped:\n                l, r = end-start-r, end-start-l\n            print(a[start + r] - a[start + l])\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "input();a,b=set(),set()\nfor i in map(int,input().split()):a={i|j for j in a}; a.add(i,);b.update(a)\nprint(len(b))", "m = int(input())\n\nb = []\nk = []\nfor i in range(m):\n    x = int(input())\n    c = 0\n    for j in range(len(b)):\n        v = b[j]\n        d = k[j]\n        if (x ^ v) < x:\n            x ^= v\n            c ^= d\n\n    if x != 0:\n        print(0)\n        c ^= 2 ** i\n        b.append(x)\n        k.append(c)\n    else:\n        a = []\n        for j in range(m):\n            if c & 1 == 1:\n                a.append(j)\n            c >>= 1\n        print(len(a), end='')\n        for v in a:\n            print(' ', v, sep='', end='')\n        print()\n", "def main():\n    input()\n    numbers = tuple(map(int, input().split()))\n    d = []\n    for i in range(len(numbers)):\n        while len(d) <= numbers[i]:\n            d.append([])\n        d[numbers[i]].append(i)\n    dd = [[]]\n    for line in d:\n        if line:\n            dd.append(line)\n    d = dd\n    answer = [None] * len(numbers)\n    for item in d[1]:\n        answer[item] = 1\n    for i in range(1, len(d) - 1):\n        left_maxes = [0]\n        right_maxes = [0]\n        for j in range(len(d[i])):\n            left_maxes.append(max(left_maxes[-1], answer[d[i][j]]))\n            right_maxes.append(max(right_maxes[-1],\n                                   answer[d[i][len(d[i]) - j - 1]]))\n        left_amount = 0\n        for j in range(len(d[i+1])):\n            while left_amount < len(d[i]) and d[i][left_amount] < d[i+1][j]:\n                left_amount += 1\n            answer[d[i+1][j]] = max(left_maxes[left_amount],\n                                    right_maxes[len(d[i]) - left_amount] + 1)\n    res = 0\n    for ans in answer:\n        res += ans\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "inp = input().split(' ')\nval=[];\n\ntotNums = int(inp[0]); totOpt = int(inp[1]);\ninp = input().split(' '); #assert(len(inp) == totNums);\nfor it in inp: val.append(int(it))\n\ndp = [[0.0 for _ in range(0,totNums)] for __ in range(0,totNums)]\nfor i in range(0,totNums):\n    for j in range(0,totNums):\n        if val[i]>val[j]: dp[i][j] = 1.0\n\nwhile totOpt>0:\n    totOpt -= 1\n\n    inp = input().split(' ')\n    fr = int(inp[0])-1; to = int(inp[1])-1;\n\n    for i in range(0,totNums):\n        if i!=fr and i!=to:\n            dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2;\n            dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2;\n\n    dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2;\n\nans = 0.0\nfor i in range(0,totNums):\n    for j in range(i+1,totNums):\n        ans += dp[i][j]\n\nprint('%.10f'%ans)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\na, b, c = list(map(int, input().split()))\nn = int(input())\nbanks = list(map(int, input().split()))\nans = 0\nfor bank in banks:\n    if b < bank < c:\n        ans += 1\nprint(ans)\n", "BigNum = 10 ** 20\n\nn, m, a, d = list(map(int, input().split(' ')))\nts = [0] + list(map(int, input().split(' '))) + [BigNum]\n\ndef empsInRange(l, r):\n    em1 = l // a + 1\n    em2 = r // a\n    return (em1, min(em2, n))\n\nempDoorGroup = d // a + 1\n\ndef moveEmps(emps, last):\n    em1, em2 = emps\n    if em1 > em2:\n        return last, 0\n    \n    if em1 * a <= last + d:\n        gr1 = (last + d - em1 * a) // a\n        em1 += 1 + gr1\n    \n    if em1 > em2:\n        return last, 0\n\n    doorGroups = (em2 - em1 + 1 + empDoorGroup - 1) // empDoorGroup\n    last = (em1 + empDoorGroup * (doorGroups - 1)) * a\n\n    return last, doorGroups\n\nres = 0\nlast = -BigNum\n\nfor i in range(1, len(ts)):\n    #print(i, ' ------------ ')\n    emps = empsInRange(ts[i - 1], ts[i])\n    #print(ts[i-1], ts[i], emps, last)\n    last, inc = moveEmps(emps, last)\n    #print('last:', last, ' inc:', inc)\n    res += inc\n\n    if ts[i] < BigNum and last + d < ts[i]:\n        res += 1\n        last = ts[i]\n    #print('temp res:', res)\n\nprint(res)\n", "n=int(input())\np=list(map(int,input().split()))\na=[0]*n\nt=s=f=0\nfor i in range(n):\n    if p[i]<=t:a[i]=t-p[i]+1\n    t=max(p[i],t+1)\nfor i in range(n-1,0,-1):\n    if p[i] <= s: a[i] = min(s - p[i] + 1,a[i])\n    else:a[i]=0\n    s = max(p[i], s + 1)\nfor i in range(n):p[i]+=a[i];f|=i>1and p[i]==p[i-1]\nprint(sum(a[:])+f)", "a = list(input())\nb = list(input())\nn = len(a)\nif len(a) == 1:\n    print(a[0])\n    return\na.sort()\nb.sort()\na = a[:(len(a) + 1) // 2]\nif n % 2 == 1:\n    b = b[(len(b) // 2) + 1:]\nelse:\n    b = b[(len(b) // 2):]\nsa = 0\nea = len(a) - 1\nsb = 0\neb = len(b) - 1\nstb = 0\nste = n - 1\nst = [\"\"] * n\n\nfor i in range(n):\n    if i % 2 == 0:\n        if a[sa] < b[eb]:\n            st[stb] = a[sa]\n            sa += 1\n            stb += 1\n        else:\n            st[ste] = a[ea]\n            ea -= 1\n            ste -= 1\n    else:\n        if eb == sb and n % 2 == 0:\n            st[stb] = b[eb]\n            break\n        if b[eb] > a[sa]:\n            st[stb] = b[eb]\n            eb -= 1\n            stb += 1\n        else:\n            st[ste] = b[sb]\n            ste -= 1\n            sb += 1\nfor i in range(len(st)):\n    print(st[i], end=\"\")", "import sys\nmod = 10**9 + 7\n \nfor _ in range(int(input())):\n    x = int(input())\n    s = list(map(int, input()))\n    ans = len(s)\n    for i in range(1, x+1):\n        ans = (i + (ans-i) * s[i-1]) % mod\n        r = len(s)\n        for _ in range(s[i-1]-1):\n            if len(s) < x:\n                s += s[i:r]\n            else:\n                break\n \n    print(ans)", "N, Q = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nB = sorted(list(set(A)))\nM = len(B)\nIA = {}\nfor i in range(M):\n    IA[B[i]] = i\n\nA = [IA[a] for a in A]\nL = [N] * M\nR = [-1] * M\nC = [0] * M\nfor i in range(N):\n    L[A[i]] = min(L[A[i]], i)\n    R[A[i]] = max(R[A[i]], i)\n    C[A[i]] += 1\n\nX = []\nfor i in range(M):\n    X.append((L[i], R[i], C[i]))\nX = sorted(X, key = lambda x: x[1])\n\nY = [(-1, 0, 0)]\nfor i in range(M):\n    l, r, t = X[i]\n    m = t\n    while Y[-1][0] > l:\n        a, b, c = Y.pop()\n        t += b\n        m = max(m, c)\n    Y.append((r, t, m))\nprint(sum([y[1] - y[2] for y in Y[1:]]))\n\n", "n, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\nfor i in range(m):\n    p, q = list(map(int, input().split()))\n    g[p - 1].append(q - 1)\n    g[q - 1].append(p - 1)\n\ncomp = [-1] * n\ndef shortest(root):\n    dist = [-1] * n\n    q = [0] * n\n    left, right = 0, 1\n    q[left] = root\n    dist[root] = 0\n    good = True\n    while left < right:\n        x = q[left]\n        left = left + 1\n        for i in g[x]:\n            if dist[i] is -1: \n                dist[i] = 1 + dist[x]\n                q[right] = i\n                right = right + 1\n            elif dist[i] == dist[x]:\n                good = False \n    far = 0\n    for i in dist:\n        if i > far: far = i\n    return good, far, dist\n\narr = [0] * n\ngood = True\nfor i in range(n):\n    _, opt, dist = shortest(i)\n    if _ is False: good = False\n    if comp[i] is -1: \n        for j in range(n):\n            if dist[j] is not -1:\n                comp[j] = i\n    if arr[comp[i]] < opt: \n        arr[comp[i]] = opt\n\nif good is False: print('-1')\nelse: print(sum(arr))\n\n", "from collections import UserDict\n\n\nclass Tree(UserDict):\n    def __init__(self, g):\n        super().__init__()\n        for name, value in enumerate(g, 1):\n            self[value] = name\n\n    def __setitem__(self, name, value):\n        if name in self:\n            if value is not None:\n                self[name].add(value)\n                self[value] = None\n        else:\n            if value is None:\n                super().__setitem__(name, set())\n            else:\n                super().__setitem__(name, {value})\n                self[value] = None\n\n\ndef __starting_point():\n    n = int(input())\n\n    tree = Tree(int(i) for i in input().split())\n    colors = [int(i) for i in input().split()]\n    t = [()] * n\n\n    def dfs(v):\n        stack = [v]\n        visited = set()\n\n        while stack:\n            v = stack.pop()\n            if v not in visited:\n                visited.add(v)\n                stack.append(v)\n                stack.extend(tree[v])\n            else:\n                t[v] = (1, colors[v])\n                for u in tree[v]:\n                    t[v] = (\n                        (t[v][0] * t[u][1] + t[v][0] * t[u][0] * (not colors[u])) % (10**9 + 7),\n                        (t[v][1] * t[u][1] + t[v][0] * t[u][1] * (not colors[v])\n                                           + t[v][1] * t[u][0] * (not colors[u])) % (10**9 + 7)\n                    )\n\n                \n    dfs(0)\n\n    print(t[0][1])\n\n\n\n    \n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "apples=int(input())\n\nif apples<=3:\n\n    print(0)\n\nelse:\n\n    halfpr=int(apples/2)\n\n    def primes(n):\n\n        isPrime = [True for i in range(n + 1)]\n\n        isPrime[0] = isPrime[1] = False\n\n        \n\n        idx = 2\n\n        while idx * idx <= n:\n\n            if isPrime[idx]:\n\n                for i in range(idx * 2, n, idx):\n\n                    isPrime[i] = False\n\n            idx += 1\n\n        \n\n        return isPrime\n\n\n\n    primeslist=primes(halfpr)\n\n    totallist=[False]*(apples+1)\n\n    applepairs=[]\n\n    for prime in range(len(primeslist)-1, 1, -1):\n\n        if primeslist[prime]:\n\n            numprimes=int(apples/prime)\n\n            primesx=[int(i*prime) for i in range(1, numprimes+1) if not totallist[i*prime]]\n\n            if len(primesx)%2==1:\n\n                primesx.remove(2*prime)\n\n            for pr in primesx:\n\n                 applepairs.append(pr)\n\n                 totallist[pr]=True\n\n    print(int(len(applepairs)/2))\n\n    for t in range(int(len(applepairs)/2)):\n\n        print(applepairs[2*t], applepairs[2*t+1])\n\n        \n\n\n\n\n\n# Made By Mostafa_Khaled\n", "t=int(input())\nT=str.maketrans('0123456789','0101010101')\nd={}\nfor _ in ' '*t:\n    a,b=input().split()\n    b=int(b.translate(T))\n    if a=='?':print(d.get(b,0))\n    elif a=='+':d[b]=d.get(b,0)+1\n    else:d[b]-=1", "import sys\nreadline = sys.stdin.readline\n\n\nT = int(readline())\nAns = [None]*T\n\nfor qu in range(T):\n    N = int(readline())\n    A = list(map(int, readline().split()))\n    A.sort()\n    if N == 1:\n        Ans[qu] = 'T'\n    elif N == 2:\n        if A[0] == A[1]:\n            Ans[qu] = 'HL'\n        else:\n            Ans[qu] = 'T'\n    elif A[-1] > sum(A[:-1]):\n        Ans[qu] = 'T'\n    else:\n        if sum(A) %2 == 0:\n            Ans[qu] = 'HL'\n        else:\n            Ans[qu] = 'T'\n        \n        \nprint('\\n'.join(Ans))", "N=int(input())\npsychos=list(map(int, input().split(\" \")))\ntime_of_death=[0 for i in range(N)]\n\nstack=[(psychos[0], 0)]\nfor index, p in enumerate(psychos):\n    if index==0:\n        continue\n    if p<stack[-1][0]:\n        stack.append((p, 1))\n        time_of_death[index]=1\n\n    elif p>stack[-1][0]:\n        max_time=-1\n        while stack!=[] and p>stack[-1][0]:\n            max_time=max(max_time, stack[-1][1])\n            del stack[-1]\n        if stack==[]:\n            # will never die, no bigger psychos to left\n            stack.append((p, 0)) \n            time_of_death[index]=0 \n        else:\n            # will die, bigger psycho to left\n            stack.append((p, max_time+1))\n            time_of_death[index]=max_time+1\n\nprint(max(time_of_death))\n    \n\n'''\n7\n15 9 5 10 7 11 14\n'''", "input()\ns = sorted(set(map(int, input().split())))\nc = m = 0\nd = []\nfor b in s:\n    d += [c] * (b - c)\n    c = b\nfor b in s[-1::-1]:\n    if b < m + 2: break\n    m = max(m, c % b, *(a % b for a in d[2 * b - 1::b]))\nprint(m)", "read = lambda: list(map(int, input().split()))\nn = int(input())\np = sorted([tuple(read()) for i in range(n)])\na = [0] * (n + 1)\nb = [0] * (n + 1)\nfor i in range(1, n + 1):\n    a[i], b[i] = p[i - 1]\na[0] = int(-1e7)\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    L = 0\n    R = n + 1\n    while R - L > 1:\n        M = (L + R) // 2\n        if a[i] - b[i] <= a[M]: R = M\n        else: L = M\n    dp[i] = dp[L] + 1\nans = n - max(dp)\nprint(ans)\n", "n = int(input())\n\narr = [(0, 0)] * n\n\nfor i in range(n):\n\ta = sum(list(map(int, input().split())))\n\tarr[i] = (-a, i)\narr.sort()\n\nfor i in range(n):\n\tif arr[i][1] == 0:\n\t\tprint(i + 1)", "n = int(input())\nif n ==1:\n    print(1)\n    return\nl = list(map(int,input().split()))\nw = [[]for i in range(n)]\nsz = [1]*n\nfor i in range(n-1):\n    w[l[i]-1].append(i+1)\nfor i in range(n-1,-1,-1):\n    for j in range(len(w[i])):\n        sz[i]+=sz[w[i][j]]\nans = [0]*n\nfor i in range(n):\n    for j in range(len(w[i])):\n        ans[w[i][j]] = ans[i]+1+(sz[i]-1-sz[w[i][j]])/2\nfor i in range(n):\n    print(ans[i]+1,end = \" \")", "from collections import *\nprint(int(input()) - max(Counter(map(int,input().split())).values()))", "n, m = list(map(int, input().split()))\ns = input()\np = c = 0\nfor i in range(1, n):\n    if s[i] == s[i - 1]:\n        c += n * (m - 1)\n        p = i\n    elif s[i] != s[i - 2]:\n        p = i - 1\n    c += i - p\nans = n * n * (m - 1) - c\nprint(ans)\n", "a = input()\nprint(a + a[::-1])\n", "c=[]\nn=int(input())\nfor uygf in range(n):\n    s=list(input())\n    l=len(s)\n    i=0\n    p=[]\n    d=['u','o','k','h']\n    while(i<l):\n        if(s[i] not in d):\n            p.append(s[i])\n            i+=1\n        elif(s[i]=='o'):\n            if(i+1<l and s[i+1]=='o'):\n                p.append('u')\n                i+=2\n            elif(i+1<l and s[i+1]=='u'):\n                p.append('u')\n                s[i+1]='o'\n                i+=1\n            else:\n                p.append('o')\n                i+=1\n        elif(s[i]=='k'):\n            y=i+1\n            while(y<l and s[y]=='k'):\n                y+=1\n            if(y!=l):\n                if(s[y]=='h'):\n\n                    p.append('h')\n                    i=y+1\n                else:\n                    for pp in range(i,y):\n                        p.append('k')\n                    i=y\n            else:\n                for pp in range(i,y):\n                    p.append('k')\n                i=y\n        else:\n            p.append(s[i])\n            i+=1\n\n    c.append(p)\nd=[]\nfor i in range(n):\n    if(i in d):\n        continue\n    for j in range(i+1,n):\n        if(c[i]==c[j]):\n            d.append(j)\nprint(n-len(d))\n\n\n", "import sys\ninput = sys.stdin.readline\n\nn, k = list(map(int, input().split()))\n\nbegin = [-1] * n\nend = [-1] * n\nhurt = [-1] * n\n\nadj = [[] for i in range(n)]\nfor _ in range(n-1):\n    u ,v = list(map(int, input().split()))\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\nhurt[0] = 1\nbegin[0] = 0\nstack = [0]\ncurr = 1\nwhile stack:\n    nex = stack[-1]\n    if adj[nex]:\n        v = adj[nex].pop()\n        if begin[v] == -1:\n            begin[v] = curr\n            curr += 1\n            stack.append(v)\n            hurt[v] = len(stack)\n    else:\n        end[nex] = curr\n        stack.pop()\n\ndesc = [end[i] - begin[i]-hurt[i] for i in range(n)]\ndesc.sort(reverse = True)\nout = 0\nfor i in range(n - k):\n    out += desc[i]\nprint(out)\n", "import sys\ninput = sys.stdin.readline \n\n\nn = int(input())\na = list(map(int, input().split()))\nb = a\n\nans = 0\nfor k in range(29):\n    a0 = []\n    a1 = []\n    a0a = a0.append\n    a1a = a1.append\n    \n    b0 = []\n    b1 = []\n    b0a = b0.append\n    b1a = b1.append\n    for i in a:\n        if i&(1<<k): a1a(i)\n        else: a0a(i)\n    for i in b:\n        if i&(1<<k): b1a(i)\n        else: b0a(i)\n    \n    a = a0+a1\n    b = b0+b1\n    mask = (1<<(k+1))-1\n    \n    aa = [i&mask for i in a]\n    bb = [i&mask for i in b]\n    \n    res = 0\n    p1 = 1<<k\n    p2 = mask+1\n    p3 = p1+p2\n\n    j1 = j2 = j3 = 0   \n    for jj, ai in enumerate(reversed(aa)):\n        while j1 < n and ai+bb[j1] < p1:\n            j1 += 1\n        while j2 < n and ai+bb[j2] < p2:\n            j2 += 1\n        while j3 < n and ai+bb[j3] < p3:\n            j3 += 1\n        res += max(n, n - jj) - max(j3, n - jj)\n        res += max(j2, n - jj) - max(j1, n - jj)\n    ans |= (res & 1) << k\n    \nprint(ans)    \n", "def f(x):\n    bi = 0\n    ci = 0\n    cnt1 = -10 ** 10\n    minsum1 = 10 ** 10\n    cnt2 = -10 ** 10\n    minsum2 = 10 ** 10\n    for i in range(len(A)):\n        if bi - minsum1 > cnt1:\n            cnt1 = bi - minsum1\n        if bi <= minsum1:\n            minsum1 = bi\n        if ci - minsum2 > cnt2:\n            cnt2 = ci - minsum2\n        if ci <= minsum2:\n            minsum2 = ci\n        bi += A[i] - x\n        ci += x - A[i]\n    if bi - minsum1 > cnt1:\n        cnt1 = bi - minsum1\n    if bi <= minsum1:\n        minsum1 = bi\n    if ci - minsum2 > cnt2:\n        cnt2 = ci - minsum2\n    if ci <= minsum2:\n        minsum2 = ci\n    return max(cnt1, cnt2, 0)\n\n\nn = int(input())\nA = list(map(int, input().split()))\nl = min(A)\nr = max(A)\nfor _ in range(70):\n    p = l + (r - l) / 3\n    q = r - (r - l) / 3\n    x = f(p)\n    y = f(q)\n    if x > y:\n        l = p\n    elif y > x:\n        r = q\n    else:\n        l = p\n        r = q\nprint(f(l))", "# 1208D\nclass segTree():\n    def __init__(self, n):\n        self.t = [0] * (n << 2)\n\n    def update(self, node, l, r, index, value):\n        if l == r:\n            self.t[node] = value\n            return\n        mid = (l + r) >> 1\n        if index <= mid:\n            self.update(node*2, l, mid, index, value)\n        else:\n            self.update(node*2 + 1, mid + 1, r, index, value)\n        self.t[node] = self.t[node*2] + self.t[node*2 + 1]\n\n    def query(self, node, l, r, value):\n        if l == r:\n            return self.t[node]\n        mid = (l + r) >> 1\n        if self.t[node*2] >= value:\n            return self.query(node*2, l, mid, value)\n        return self.query(node*2 + 1, mid + 1, r, value - self.t[node*2])\n\ndef do():\n    n = int(input())\n    nums = [int(i) for i in input().split(\" \")]\n    res = [0]*n\n    weightTree = segTree(n)\n    for i in range(1, n+1):\n        weightTree.update(1, 1, n, i, i)\n    # print(weightTree.t)\n    for i in range(n-1, -1, -1):\n        res[i] = weightTree.query(1, 1, n, nums[i] + 1)\n        weightTree.update(1, 1, n, res[i], 0)\n    return \" \".join([str(c) for c in res])\nprint(do())\n", "n = int(input())\na = [list(map(int, input().split(' '))) for i in range(n)]\nans = [0]*n\nfor i in range(1, n+1):\n    for j in range(n):\n        if ans[j] == 0 and a[j].count(i) == n-i:\n            ans[j] = str(i)\n            break\nprint(' '.join(ans))\n", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\n\nH, W, T = map(int, readline().split())\nG = [-1]*(W+2)\nfor _ in range(H):\n    G.extend([-1] + list(map(int, readline().strip())) + [-1])\nG.extend([-1]*(W+2))\n\ngeta = W+2\nof1 = set()\nDIREC = [1, -1, W+2, -W-2]\nQ = []\n\nfor vn in range((H+2)*(W+2)):\n    if G[vn] == -1:\n        continue\n    for dv in DIREC:\n        if G[vn] == G[vn+dv]:\n            Q.append(vn)\n            break\n\n\nif not Q:\n    for qu in range(T):\n        i, j, p = map(int, readline().split())\n        vn = i*geta+j\n        sys.stdout.write(str(G[vn])+'\\n')\nelse:\n    dist = [0]*((H+2)*(W+2))\n    used = set(Q)\n    Q = deque(Q)\n    while Q:\n        vn = Q.pop()\n        for dv in DIREC:\n            if G[vn+dv] == -1 or vn+dv in used:\n                continue\n            used.add(vn+dv)\n            dist[vn+dv] = 1 + dist[vn]\n            Q.appendleft(vn+dv)\n    for qu in range(T):\n        i, j, p = map(int, readline().split())\n        vn = i*geta+j\n        if dist[vn] >= p:\n            ans = G[vn]\n        else:\n            ans = G[vn]^(1&(p-dist[vn]))\n        sys.stdout.write(str(ans)+'\\n')", "n = int(input())\nP = list(map(int,input().split()))\n\nP[:] = [x - 1 for x in P]\n\nlst = [0]*n\n\ni = 0\nS = n-1\nans = [1]*(n+1)\n\nwhile i<n:\n    lst[P[i]] = 1\n    if P[i] == S:\n        k=0\n        while k==0:\n            S+=-1\n            if lst[S]==0 or S == -1:\n                k=1\n    i += 1\n    ans[i] = i - n + S + 2\n    \nprint(' '.join(map(str, ans)))", "3\n\nn = int(input())\nsend = [[], []]\nfor _ in range(n):\n    t, x, y = tuple(map(int, input().split()))\n    send[t - 1].append(x)\nfor _ in range(2):\n    print('LIVE' if 2 * sum(send[_]) >= 10 * len(send[_]) else 'DEAD')\n", "from collections import deque\n\n\ndef flood_fill(adj_lists, colors, i, color):\n    q = deque()\n    q.append(i)\n    while len(q) > 0:\n        j = q.pop()\n        if colors[j] is None:\n            colors[j] = color\n            q.extend(adj_lists[j])\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    adj_lists = [[] for _ in range(n)]\n    for _ in range(k):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj_lists[a].append(b)\n        adj_lists[b].append(a)\n    colors = [None for _ in range(n)]\n    num_colors = 0\n    for i in range(n):\n        if colors[i] is None:\n            flood_fill(adj_lists, colors, i, num_colors)\n            num_colors += 1\n    print(k - n + num_colors)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nE=[[] for i in range(n+1)]\n\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    E[a].append(b)\n    E[b].append(a)\n\nLEAF=[]\nfor i in range(n+1):\n    if len(E[i])==1:\n        LEAF.append(i)\n\nQ=[1]\nUSE=[-1]*(n+1)\nUSE[1]=0\n\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if USE[to]==-1:\n            USE[to]=1-USE[x]\n            Q.append(to)\n\nf=USE[LEAF[0]]\n\nfor l in LEAF:\n    if f!=USE[l]:\n        MIN=3\n        break\nelse:\n    MIN=1\n\n#print(MIN)\n\nMAX=n-1\n\nFP=[0]*(n+1)\n\nfor l in LEAF:\n    for to in E[l]:\n        if FP[to]==1:\n            MAX-=1\n        else:\n            FP[to]=1\n\nprint(MIN,MAX)\n    \n", "a = int(input())\nfor i in range(a):\n    n, d = map(int, input().split())\n    m = list(map(int, input().split()))\n    ui = 1e10\n    for l in m:\n        ans = 0\n        if d % l != 0:\n            ans += 1\n        ans += d//l\n        if d//l == 0 and d %l != 0:\n            ans += 1\n        ui = min(ui, ans)\n    print(int(ui))", "import sys\ninput=sys.stdin.readline\n\nn,q=list(map(int,input().split()))\nfor i in range(q):\n    a=int(input())\n    if a%2!=0:\n        print((a+1)//2)\n    else:\n        b=a//2\n        while 1>0:\n            a=a+(n-b)\n            b=a//2\n            if a%2!=0:\n                print((a+1)//2)\n                break", "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nT = int(input())\nfor i in range(T):\n    a, b, n = list(map(int, input().split()))\n    if n%3==0: print(a)\n    elif n%3==1: print(b)\n    else: print(a^b)\n", "from sys import stdin, stdout\n\ndef readIn():\n    return tuple( map(int,input().split()) )\n\ns = input()\nsz = len(s)+1\ncnt = [ [0]*3 for _ in range(sz) ]\nfor i in range(sz-1):\n    for j in range(3):\n        cnt[i+1][j] = cnt[i][j]\n    if s[i] == 'x':\n        cnt[i+1][0] += 1\n    elif s[i] == 'y':\n        cnt[i+1][1] += 1\n    else :\n        cnt[i+1][2] += 1\n\nn = int(input())\nres = []\nfor _ in range(n):\n    l,r = readIn()\n    tmp = [ cnt[r][i]-cnt[l-1][i] for i in range(3) ]\n    res.append( 'YES' if r-l<2 or max(tmp)-min(tmp)<2 else 'NO' )\nprint('\\n'.join(res))", "import sys\n\nn, m = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\ngph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    u, v = list(map(int, sys.stdin.readline().split()))\n    u -= 1\n    v -= 1\n    gph[u].append((v, _))\n    gph[v].append((u, _))\n    \nt = -1\nif d.count(1) % 2 == 1:\n    if -1 not in d:\n        print(-1)\n        return\n    t = d.index(-1)\n\nans = [False] * m\nvis = [False] * n\ned = [(-1, -1)] * n\nrets = [(d[u] == 1) or (u == t) for u in range(n)]\n\nstk = [[0, iter(gph[0])]]\nwhile len(stk) > 0:\n    u = stk[-1][0]\n    vis[u] = True\n    try:\n        while True:\n            v, i = next(stk[-1][1])\n            if not vis[v]:\n                ed[v] = (u, i)\n                stk.append([v, iter(gph[v])])\n                break\n    except StopIteration:\n        p, e = ed[u]\n        if p >= 0 and rets[u]:\n            rets[p] = not rets[p]\n            ans[e] = True\n        stk.pop()\n        pass\n    \nprint(ans.count(True))\nprint(\"\\n\".join([str(i+1) for i in range(m) if ans[i]]))\n#1231\n", "R=lambda:map(int,input().split())\nn=int(input())\na=*zip([1]*n,range(1,n+1),R()),*([*R()]for _ in[0]*int(input()))\nr=[-1]*n\nm=0\nfor t,p,*x in a[::-1]:\n if t>1:m=max(m,p)\n elif r[p-1]<0:r[p-1]=max(x[0],m)\nprint(*r)", "# -*- coding: utf-8 -*-\nfrom bisect import bisect_left\n\nm = int(input())\nlines = []\nfor i in range(m):\n    lines.append(list(map(int, input().split())))\nn = int(input())\nlengths = list(map(int, input().split()))\n\n#acc_lengths[i]\u8868\u793ai\u6307\u4ee4\u6267\u884c\u4e4b\u524d\u5df2\u7ecf\u79ef\u7d2f\u4e86\u591a\u957f\u7684\u4e32\nacc_lengths = [0]\nfor l in lines:\n    acc_lengths.append(acc_lengths[-1] + (1 if l[0] == 1 else l[1]*l[2]))\n\nseq = []\nfor l in lines:\n    if l[0] == 1:\n        seq.append(l[1])\n    else:\n        for i in range(l[2]):\n            seq.extend(seq[:l[1]])\n            if len(seq) >= 10**5:\n                break\n    if len(seq) >= 10**5:\n        break\n            \ndef find_number(l):\n    if l <= len(seq):\n        return seq[l-1]\n    #seq[l-1]\u7531\u6307\u4ee4i\u751f\u6210\n    i = bisect_left(acc_lengths, l) - 1\n    return seq[(l - acc_lengths[i] - 1) % lines[i][1]]\n\nprint(' '.join([str(find_number(l)) for l in lengths]))\n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int,minp().split())\n\ndef main():\n\tn,k = mints()\n\ta = [list(minp()) for i in range(3)]\n\tw = [[False]*(n+1) for i in range(3)]\n\tfor j in range(3):\n\t\tif a[j][0] == 's':\n\t\t\ta[j][0] = '.'\n\t\t\tw[j][0] = True\n\tfor i in range(n):\n\t\tfor j in range(3):\n\t\t\tif w[j][i]:\n\t\t\t\tif i*3+1>=n or a[j][i*3+1] == '.':\n\t\t\t\t\tfor z in range(max(j-1,0),min(j+2,3)):\n\t\t\t\t\t\tif (i*3+1>=n or a[z][i*3+1] == '.') and (i*3+2>=n or a[z][i*3+2] == '.') and (i*3+3>=n or a[z][i*3+3] == '.'):\n\t\t\t\t\t\t\tw[z][i+1] = True\n\tcan = w[0][n] or w[1][n] or w[2][n]\n\t#print(w)\n\tif can:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n\nt = mint()\nfor i in range(t):\n\tmain()", "# import atexit\n# import io\n# import sys\n#\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n#\n#\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nimport bisect\nfrom datetime import datetime\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    n -= 1\n\n    timestamps = []\n    raw = []\n    while True:\n        s = \"\"\n        try:\n            s = input()\n        except:\n            print(-1)\n            return\n\n        d = datetime.strptime(s[0:19], \"%Y-%m-%d %H:%M:%S\")\n        timestamps.append(int(d.timestamp()))\n        raw.append(s[0:19])\n        idx = bisect.bisect_left(timestamps, timestamps[-1] - n)\n        if len(timestamps) - idx == m:\n            print(raw[-1])\n            return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\na,b=[*map(int,list(input()))],[*map(int,list(input()))]\nchanged=[False]*n\n\nfor i in range(n):\n    if b[i]==0: changed[i]=True\n\nstateCnt=[0]*4\nfor i in range(n):\n    if a[i]==1 and changed[i]==True:\n        stateCnt[0]+=1\n    elif a[i]==1 and changed[i]==False:\n        stateCnt[1]+=1\n    elif a[i]==0 and changed[i]==True:\n        stateCnt[2]+=1\n    else:\n        stateCnt[3]+=1\n\nprint(stateCnt[0]*stateCnt[2]+stateCnt[0]*stateCnt[3]+stateCnt[2]*stateCnt[1])", "import sys\n#from collections import defaultdict\nsys.setrecursionlimit(10**6)\n\ndef input():\n\treturn sys.stdin.readline()[:-1]\nn, l = list(map(int, input().split()))\nss = [list(input())[::-1] for _ in range(n)]\n\ndef addTree(tree, sentence):\n\tif not sentence:\n\t\treturn None   \n\n\tif sentence[-1] not in tree:\n\t\ttree[sentence[-1]] = {}\n\n\tp = sentence.pop()\n\ttree[p] = addTree(tree[p], sentence)\n\n\treturn tree\n\ndef createTree(sentences):    \n\ttree = {}\n\tfor sentence in sentences:\n\t\ttree = addTree(tree, sentence)\n\n\treturn tree\n\ntree = createTree(ss)\n#print(tree)\n\ngrundy = 0\ndef dfs(cur, level):\n\tnonlocal grundy\n\tif cur is None:\n\t\treturn\n\telif len(cur) == 1:\n\t\tgrundy ^= (l-level) & (-l+level)\n\tfor k in list(cur.keys()):\n\t\tdfs(cur[k], level+1)\n\treturn\n\t\ndfs(tree, 0)\n\nif grundy == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")\n", "\nfrom sys import stdin\nimport sys\nimport heapq\n\ndef bitadd(a,w,bit):\n \n    x = a+1\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit):\n \n    ret = 0\n    x = a+1\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\nn = int(stdin.readline())\ns = stdin.readline()[:-1]\n\nbit = [0] * (n+10)\ndp = [0] * (n+10)\n\ny = 0\nans = 0\nfor i in range(n):\n\n    if s[i] == \"0\":\n        while y > 0:\n            dp[y] += 1\n            bitadd(y,y,bit)\n            y -= 1\n        dp[0] += 1\n    else:\n        bitadd(y,-1*dp[y]*y,bit)\n        bitadd(y+1,-1*dp[y+1]*(y+1),bit)\n        dp[y+1] += dp[y]\n        dp[y] = 0\n        y += 1\n        bitadd(y,dp[y]*y,bit)\n        \n    now = bitsum(i,bit) + (1+y)*y//2\n    #print (bitsum(i,bit),(1+y)*y//2,dp)\n    ans += now\n    \nprint (ans)", "n, k = map(int, input().split())\na = [0] * n\nb = ['0'] * n\nc = []\ns = input()\nfor i in range(n):\n    if k != 0:\n        if s[i] == '(':\n            c.append(i)\n        else:\n            d = c.pop()\n            a[i] = 1\n            a[d] = 1\n            k -= 2\nfor i in range(n):\n    if a[i] == 1:\n        print(s[i], end = '')\n", "a=input()\nb=input()\nc=[i-1 for i in list(map(int,input().split()))]\nl=0\nr=len(a)\nwhile r-l>1:\n    m=l+(r-l)//2\n    t=list(a)\n    j=0\n    for i in range(m):t[c[i]]=''\n    for i in range(len(a)):\n        if t[i]==b[j]:\n            j+=1\n            if j==len(b):\n                l=m;break\n    if j!=len(b):r=m\nprint(l)\n", "input()\np = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ninput()\nc = list(map(int, input().split()))\n\nd = [[[] for _ in range(3)] for _ in range(3)]\nfor pi, ai, bi in zip(p, a, b):\n    d[ai - 1][bi - 1].append(pi)\n\nfor row in d:\n    for l in row:\n        l.sort(reverse=True)\n    \n\nr = []\nfor ci in c:\n    pm = 1000000001\n    im = -1\n    for j, l in enumerate(d[ci - 1]):\n        if len(l) > 0 and l[-1] < pm:\n            pm = l[-1]\n            im = ci - 1\n            jm = j\n    for i, ll in ((i, ll) for i, ll in enumerate(d) if i != ci - 1):\n        l = ll[ci - 1]\n        if len(l) > 0 and l[-1] < pm:\n            pm = l[-1]\n            im = i\n            jm = ci - 1\n    r.append(d[im][jm].pop() if im >= 0 else -1)\nprint(*r, sep=' ')\n", "import math\n\nn = int(input())\nx = 2\nfor i in range(1, n+1):\n    y = i * (i + 1)\n    y *= y\n    print(round((y-x)/i))\n    x = math.sqrt(y)\n", "t = int(input())\na = list(map(int, input().split()))\nout = []\nfor n in a:\n\tans = (n//2 + 2)\n\tans = ans*ans\n\tans //= 4\n\tout.append(ans%1000000007)\nprint(' '.join(str(x) for x in out))", "import sys\nimport threading\nsys.setrecursionlimit(2097152)\n\ndef main():\n    def countchildren(graph,vert,memo,pard=None):\n        dumi=0\n        for child in graph[vert]:\n            if child!=pard:\n                if len(graph[child])==1:\n                    memo[child]=0\n                else:\n                    memo[child]=countchildren(graph,child,memo,vert)[0]\n                dumi+=memo[child]+1\n        return((dumi,memo))\n    n=int(input())\n    neigh=[]\n    for i in range(n):\n        neigh.append([])\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        neigh[a-1].append(b-1)\n        neigh[b-1].append(a-1)\n    same=1\n    layer=[0]\n    pars=[None]\n    j=0\n    while layer!=[]:\n        j+=1\n        newlayer=[]\n        newpars=[]\n        for i in range(len(layer)):\n            for vert in neigh[layer[i]]:\n                if vert!=pars[i]:\n                    newlayer.append(vert)\n                    newpars.append(layer[i])\n        layer=newlayer\n        pars=newpars\n        if j%2==0:\n            same+=len(layer)\n    bipartite=same*(n-same)\n    info=countchildren(neigh,0,[None]*n)[1]\n    dist=0\n    for guy in info:\n        if guy!=None:\n           dist+=(guy+1)*(n-guy-1)\n    print((dist+bipartite)//2)\n \nthreading.stack_size(134217728)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "def solve():\n\ta, b = [int(x) for x in input().split()]\n\tl = b - a + 1\n\tfor i in range(64):\n\t\tif a & (1 << i):\n\t\t\tcontinue\n\t\tif (a | (1 << i)) > b:\n\t\t\tbreak\n\t\ta |= 1 << i\n\tprint(a)\n\nn = int(input())\nfor i in range(n):\n\tsolve()\n", "import sys\n# sys.setrecursionlimit(10**5) \nn,m=map(int,input().split())\ng={i:[] for i in range(1,n+1)}\ndp=[[[-1]*26 for _ in range(n+1)] for i in range(n+1)]\ndef rec(i,j,ch):\n\tif dp[i][j][ord(ch)-ord('a')]!=-1:\n\t\treturn dp[i][j][ord(ch)-ord('a')]\n\tfor x in g[i]:\n\t\tif ord(x[1])>=ord(ch):\n\t\t\tv=rec(j,x[0],x[1])\n\t\t\tif not v:\n\t\t\t\tdp[i][j][ord(ch)-ord('a')]=1\n\t\t\t\treturn 1\n\tdp[i][j][ord(ch)-ord('a')]=0\n\treturn 0\n\nfor _ in range(m):\n\tline=input().split()\n\ta=int(line[0])\n\tb=int(line[1])\n\tc=line[2]\n\tg[a].append([b,c])\nfor i in range(1,n+1):\n\tfor j in range(1,n+1):\n\t\tprint('A',end=\"\") if rec(i,j,'a') else print('B',end=\"\")\n\tprint()\n \t\t\t\t   \t   \t\t\t\t    \t\t\t   \t \t \t", "n = int(input())\nr = [[] for i in range(n + 1)]\nr[1] = [0]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    r[a].append(b)\n    r[b].append(a)\nt = list(map(int, input().split()))\nu, v = [0] * (n + 1), [0] * (n + 1)\nfor i, j in enumerate(t, 1):\n    if j < 0: u[i] = - j\n    else: v[i] = j\nt, p = [1], [0] * (n + 1)\nwhile t:\n    a = t.pop()\n    for b in r[a]:\n        if p[b]: continue\n        p[b] = a\n        t.append(b)\nk = [len(t) for t in r]\nt = [a for a in range(2, n + 1) if k[a] == 1]\nx, y = [0] * (n + 1), [0] * (n + 1)\nwhile t:\n    a = t.pop()\n    b = p[a]\n    x[b] = max(x[b], u[a])\n    y[b] = max(y[b], v[a])\n    k[b] -= 1\n    if k[b] == 1:\n        t.append(b)\n        if u[b] > 0:\n            if x[b] - y[b] > u[b]:\n                u[b], v[b] = x[b], x[b] - u[b]\n            else: u[b], v[b] = y[b] + u[b], y[b]\n        else:\n            if y[b] - x[b] > v[b]:\n                u[b], v[b] = y[b] - v[b], y[b]\n            else: u[b], v[b] = x[b], x[b] + v[b]\nprint(u[1] + v[1])", "n,c = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nab = list(zip(a,b))\ntable = [[0 for i in range(c+1)] for j in range(401)]\nmod = 10**9+7\nfor j in range(c+1):\n  if j == 0:\n    for i in range(401):\n      table[i][j] = 1\n  else:\n    for i in range(401):\n      table[i][j] = table[i][j-1]*i%mod\ndp = [[0 for i in range(c+1)] for j in range(n+1)]\nfor i in range(c+1):\n  dp[0][i] = 1\nfor i in range(1,n+1):\n  a,b = ab[i-1]\n  for j in range(a,b+1):\n    for k in range(c+1):\n      dp[i][k] = (dp[i][k]+table[j][k])%mod\nans = [[0 for i in range(c+1)] for j in range(n+1)]\nans[0][0] = 1\nfor i in range(1,n+1):\n  for j in range(c+1):\n    for k in range(j+1):\n      ans[i][j] = (ans[i][j]+dp[i][k]*ans[i-1][j-k])%mod\nprint(ans[n][c])", "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nINF = 10**18\n\nfrom heapq import heappush, heappop\n\nl0, r0 = P[0]\n\nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n\nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n    elif l1-1 < -s-L[0]:\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        heappush(R, p-t)\n        res += (p - (l1-1))\n    elif t+R[0] < l1-1:\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        heappush(L, -p-s)\n        res += (l1-1 - p)\nprint(res)", "def process_query(queries,m):\n    n = len(queries)\n    a = [0]*(m+1)\n    for q in queries:\n        a[q[0]-1] += 1; a[q[1]] -= 1\n    for i in range(1,m):\n        a[i] += a[i-1]\n    return a[:-1]\n\ndef apply_query(times,updates,n):\n    a = [0]*(n+1)\n    # print(len(a),len(times),len(updates))\n    for i in range(len(updates)):\n        a[updates[i][0]-1] += times[i]*updates[i][2]\n        a[updates[i][1]] -= times[i]*updates[i][2]\n    for i in range(1,n):\n        a[i] += a[i-1]\n    return a[:-1]\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    updates = [list(map(int, input().split())) for i in range(m)]\n    queries = [list(map(int, input().split())) for i in range(k)]\n    times_query = process_query(queries,m)\n    # print(\"times_query\",*times_query);\n    updated_a = apply_query(times_query,updates,n)\n\n    print(*[a[i] + updated_a[i] for i in range(n)])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\ndef process(n, k, X, a, C):\n    res=0\n    A=[]\n    for i in range(len(X)):\n        heapq.heappush(A, C[i])\n        if k+len(A)*a < X[i]:\n            return -1\n        else:\n            while k <X[i]:\n                res+=heapq.heappop(A)\n                k+=a\n\n\n    return res\nn, k=[int(x) for x in input().split()]\nX=[int(x) for x in input().split()]\na=int(input())\nC=[int(x) for x in input().split()]\nprint(process(n,k,X,a,C))\n", "# https://codeforces.com/problemset/problem/280/C\nfrom collections import defaultdict, deque\nimport sys\n\nnodes = int(sys.stdin.readline())\nedges = defaultdict(list)\nfor line in sys.stdin:\n    a, b = line.split()\n    a = int(a)\n    b = int(b)\n    edges[a].append(b)\n    edges[b].append(a)\nbfs = deque([(1, 1)])\ndepths = {}\nwhile bfs:\n    nid, depth = bfs.popleft()\n    if nid in depths:\n        continue\n    depths[nid] = depth\n    for n2 in edges[nid]:\n        bfs.append((n2, depth + 1))\nprint(sum(1.0 / d for d in sorted(depths.values(), reverse=True)))", "import sys\nfrom sys import stdin\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    p,q = map(int,stdin.readline().split())\n\n    if p % q != 0:\n        print (p)\n        continue\n\n    bk = {}\n    for i in range(2,10**5):\n        if q % i == 0:\n            bk[i] = 0\n            while q % i == 0:\n                bk[i] += 1\n                q //= i\n        if bk == 1:\n            break\n\n    if q != 1:\n        bk[q] = 1\n\n    #print (bk)\n\n    ans = float(\"-inf\")\n    for i in bk:\n        cnt = 0\n        tp = p\n        while tp % i == 0:\n            tp //= i\n            cnt += 1\n        ans = max(ans , p // (i**(cnt-bk[i]+1)))\n\n    print (ans)", "for __ in range(int(input())):\n    a, b, c, d = list(map(int, input().split()))\n    if a == c or b == d:\n        print(abs(a - c) + abs(b - d))\n    else:\n        print(abs(a - c) + abs(b - d) + 2)", "def main():\n\tnx, my, k = list(map(int, input().strip().split()))\n\tmy *= 2\n\tnx *= 2\n\n\tdiags = [[] for i in range(nx + my)]\n\tanswers = [-1] * k\n\n\tfor i in range(k):\n\t\tx,y = list(map(int, input().strip().split()))\n\n\t\tdef add(x, y, i):\n\t\t\tdiag_index = nx + (y - x)\n\t\t\tdiags[diag_index].append( (x,y,i) )\n\n\t\tadd(x, y, i)\n\t\tadd(x, my - y, i)\n\t\tadd(nx - x, y, i)\n\t\tadd(nx - x, my - y, i)\n\n\n\tcur_t = 0\n\tcur_x = 0\n\tcur_y = 0\n\n\twhile True:\n\t\tdiag_index = nx + (cur_y - cur_x)\n\t\tfor x,y,i in diags[diag_index]:\n\t\t\tif answers[i] == -1:\n\t\t\t\tt = cur_t + (x - cur_x)\n\t\t\t\tassert(x - cur_x == y - cur_y)\n\t\t\t\tanswers[i] = t\n\n\t\tdiff_x = nx - cur_x\n\t\tdiff_y = my - cur_y\n\t\tdiff = min(diff_x, diff_y)\n\t\tcur_t += diff\n\n\t\tcur_x = (cur_x + diff) % nx\n\t\tcur_y = (cur_y + diff) % my\n\n\t\t\n\t\tif (cur_x % (nx // 2)) + (cur_y % (my // 2)) == 0:\n\t\t\tbreak\n\n\n\tfor a in answers:\n\t\tprint(a)\n\nmain()\n\n\n", "n, m = map(int, input().split())\nout, inp =[0]*(n+1), [0]*(n+1)\ninset = [[] for i in range(n+1)]\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    \n    if x > y:\n        z = x\n        x = y\n        y = z\n    \n    out[y] += 1\n    inp[x] += 1\n    inset[x].append(y)\n\nq = int(input())\n\nres = 0\nfor ind in range(1, n+1):\n    res += inp[ind] * out[ind]\n\nprint(res)\nfor i in range(q):\n    best = int(input())\n    \n    res -= out[best] * inp[best]\n    for pred_ind in inset[best]:\n        res += -out[pred_ind] * inp[pred_ind] + ((out[pred_ind] - 1) * (inp[pred_ind] + 1))\n        out[pred_ind] -= 1\n        inp[pred_ind] += 1\n        inset[pred_ind].append(best)\n    \n    \n    out[best] += inp[best]\n    inp[best] = 0\n    inset[best] = []\n    \n    print(res)", "n=int(input())\ns=[0]*n\nfor i in range (n):\n    s[i]=input()\ndic={}\nans=0\nfor i in range (n):\n    temp=0\n    for k in range(len(s[i])):\n        temp^=(1<<(ord(s[i][k])-ord('a')))\n    #print(temp,s[i])\n    if temp in list(dic.keys()):\n        ans=ans+dic[temp]\n    for j in range (26):\n        chk=temp\n        chk^=(1<<j)\n        if chk in list(dic.keys()):\n            ans=ans+dic[chk]\n    if temp in list(dic.keys()):\n        dic[temp]+=1\n    else:\n        dic[temp]=1\n   # print(dic[temp])\nprint(ans)\n", "#!/usr/bin/env\tpython\n#-*-coding:utf-8 -*-\nimport collections\nn,q=list(map(int,input().split()))\nM=collections.defaultdict(collections.deque)\nQ=collections.deque()\nL=[]\ns=n=m=0\nfor _ in range(q):\n\ty,x=list(map(int,input().split()))\n\tif 2>y:\n\t\ts+=1\n\t\tQ.append(x)\n\t\tM[x].append(n)\n\t\tn+=1\n\telif 3>y:\n\t\ty=M.get(x)\n\t\tif y:\n\t\t\ts-=len(y)\n\t\t\tdel M[x]\n\telse:\n\t\twhile x>m:\n\t\t\tz=Q.popleft()\n\t\t\ty=M.get(z)\n\t\t\tif y and y[0]<x:\n\t\t\t\ts-=1\n\t\t\t\ty.popleft()\n\t\t\t\tif not y:del M[z]\n\t\t\tm+=1\n\tL.append(s)\nprint('\\n'.join(map(str,L)))\n", "n = int(input())\na = list(map(int,input().split()))\npreXor = [0]*n\npreXor[0] = a[0]\nfor i in range(1,n):\n    preXor[i] = a[i]^preXor[i-1]\neven = {}\nodd = {}\ncount = 0\nfor i in range(n):\n    m = preXor[i]\n    if (m==0):\n        if (i%2==1):\n            count += 1\n    if (i%2==0):\n        if m in even:\n            count += even[m]\n            even[m] += 1\n        else:\n            even[m] = 1\n    else:\n        if m in odd:\n            count += odd[m]\n            odd[m] += 1\n        else:\n            odd[m] = 1\nprint(count)\n", "import sys\nimport math\nfrom collections import defaultdict\nn,m=list(map(int,sys.stdin.readline().split()))\n#cur=[1,1]\n#ans=[-1 for _ in range(2*n*m)]\nup,down=1,n\ncount=0\nwhile up<=down:\n    left,right=1,m\n    #ans.append(cur)\n    while left<=m and count<n*m:\n        #ans.append([up,left])\n        #ans[count]=[up,left]\n        if count<n*m:\n            sys.stdout.write((str(up)+\" \"+str(left)+\"\\n\"))\n        count+=1\n        left+=1\n        #ans[count]=[down,right]\n        if count<n*m:\n            sys.stdout.write((str(down)+\" \"+str(right)+\"\\n\"))\n        count+=1\n            #ans.append([down,right])\n        right-=1\n    up+=1\n    down-=1\n'''if n==1:\n    a=len(ans)\n    #print(a,'a')\n    for i in range(a//2):\n        print(ans[i][0],ans[i][1])\nelse:\n    a=len(ans)\n    for i in range(a//2):\n        print(ans[i][0],ans[i][1])\n    #print(ans)'''\n        \n", "import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\nAns = [None]*T\ngeta = 20\nfor qu in range(T):\n    N = int(readline())\n    A = list(map(lambda x: ord(x)-97, readline().strip()))\n    B = list(map(lambda x: ord(x)-97, readline().strip()))\n    if any(a > b for a, b in zip(A, B)):\n        Ans[qu] = -1\n        continue\n    res = 0\n    table = [[0]*geta for _ in range(geta)]\n    for a, b in zip(A, B):\n        if a != b:\n            table[a][b] = 1\n    \n    for al in range(geta):\n        if sum(table[al]):\n            res += 1\n            bl = table[al].index(1)\n            for cl in range(bl+1, geta):\n                table[bl][cl] = table[bl][cl] | table[al][cl]\n    Ans[qu] = res\nprint('\\n'.join(map(str, Ans)))", "class SortedList(list):\n\n    def add(self, other):\n        left = -1\n        right = len(self)\n        while right - left > 1:\n            mid = (right + left) >> 1\n            if other < self[mid]:\n                right = mid\n            else:\n                left = mid\n        super().insert(right, other)\n\n\nINF = int(3e18)\n\n\ndef solve_good(n, m, d, a, b, t):\n    left = SortedList()\n    left.append(-INF)\n    right = SortedList()\n    right.append(INF)\n    lborder = -INF\n    rborder = INF\n    tprev = 0\n    ans = 0\n    for ai, bi, ti in zip(a, b, t):\n        ans += bi\n        dt = ti - tprev\n        interval = dt * d\n        tprev = ti\n\n        lborder += interval\n        rborder -= interval\n\n        lefta = lborder + ai\n        righta = rborder - (n - ai)\n\n        if lefta < left[-1]:\n            top = left.pop()\n            ans -= abs(top - lefta)\n            left.add(lefta)\n            left.add(lefta)\n            right.add(rborder - (n - abs(top - lborder)))\n        elif righta > right[0]:\n            top = right.pop(0)\n            ans -= abs(top - righta)\n            right.add(righta)\n            right.add(righta)\n            left.add(lborder + n - abs(top - rborder))\n        else:\n            left.add(lefta)\n            right.add(righta)\n    return ans\n\n\nn, m, d = [int(elem) for elem in input().split()]\na, b, t = [], [], []\nfor i in range(m):\n    ai, bi, ti = [int(elem) for elem in input().split()]\n    a.append(ai)\n    b.append(bi)\n    t.append(ti)\n\nprint(solve_good(n, m, d, a, b, t))\n", "R, C, N = list(map(int, input().split()))\nUP, RIGHT, DOWN, LEFT = [], [], [], []\nfor i in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n\n    # 2\u3064\u3068\u3082\u5468\u4e0a\u306b\u306a\u3044\n    if 0 < x1 < R and 0 < y1 < C:\n        continue\n    if 0 < x2 < R and 0 < y2 < C:\n        continue\n\n    # 2\u3064\u3068\u3082\u5468\u56de\u4e0a\u306b\u3042\u308b\n    if x1 == 0: UP.append([i, y1])\n    elif x1 == R: DOWN.append([i, y1])\n    elif y1 == 0: LEFT.append([i, x1])\n    elif y1 == C: RIGHT.append([i, x1])\n\n    if x2 == 0: UP.append([i, y2])\n    elif x2 == R: DOWN.append([i, y2])\n    elif y2 == 0: LEFT.append([i, x2])\n    elif y2 == C: RIGHT.append([i, x2])\n\n\n# \u6642\u8a08\u56de\u308a\u306b\u63a2\u7d22\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\nUP.sort(key=lambda x: x[1])\nRIGHT.sort(key=lambda x: x[1])\nDOWN.sort(key=lambda x: x[1], reverse=True)\nLEFT.sort(key=lambda x: x[1], reverse=True)\n\n# \u5168\u4f53\u3092\u9023\u7d50\nNumbers = UP + RIGHT + DOWN + LEFT\n\n# \u6642\u8a08\u56de\u308a\u306b\u63a2\u7d22\nstack = []\nfor n, z in Numbers:\n    if stack and stack[-1] == n:\n        stack.pop()\n\n    else:\n        stack.append(n)\nprint((\"NO\" if stack else \"YES\"))\n", "s = input()\nn = len(s)\nflg = 0\nfor i in range(1,n):\n  if s[i-1] != s[i]:\n    flg += 1\nif flg == 0:\n  print(1)\n  return\npar = (s.count(\"a\")+s.count(\"b\")*2+2)%3\ndp = [[0 for i in range(9)] for j in range(n)]\nmod = 998244353\ndp[0][0] = 1\ndp[0][4] = 1\ndp[0][8] = 1\nfor i in range(1,n):\n  dp[i][0] = dp[i-1][5]+dp[i-1][8]\n  dp[i][1] = dp[i-1][3]+dp[i-1][6]\n  dp[i][2] = dp[i-1][4]+dp[i-1][7]\n  dp[i][3] = dp[i-1][1]+dp[i-1][7]\n  dp[i][4] = dp[i-1][2]+dp[i-1][8]\n  dp[i][5] = dp[i-1][0]+dp[i-1][6]\n  dp[i][6] = dp[i-1][0]+dp[i-1][3]\n  dp[i][7] = dp[i-1][1]+dp[i-1][4]\n  dp[i][8] = dp[i-1][2]+dp[i-1][5]\n  for j in range(9):\n    dp[i][j] %= mod\nans = pow(3,n-1,mod)-dp[-1][par]-dp[-1][par+3]-dp[-1][par+6]\nif flg == n-1:\n  ans += 1\nif n == 3 and flg == n-1 and par == 2:\n  ans -= 1\nprint(ans%mod)", "from heapq import heappush as k,heappop as l\ndef f(s):\n    a=[1<<50]*N;a[s]=0;p=[(0,s)]\n    while p:\n        d,v=l(p)\n        if d>a[v]:continue\n        for u,w in G[v]:\n            if a[u]>d+w:a[u]=d+w;k(p,(d+w,u))\n    return a\ndef g(a,s):\n    w=[0]*N;w[s]=1;b=[0]*N;b[s]=1;p=[(0,s)]\n    while p:\n        d,v=l(p)\n        for u,d in G[v]:\n            if a[v]+d==a[u]:\n                w[u]=(w[u]+w[v])%m\n                if 1-b[u]:k(p,(a[u],u));b[u]=1\n    return w\nm=10**9+7\nN,M=map(int,input().split());N+=1\nS,T=map(int,input().split())\nG=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=map(int,input().split());G[U]+=[(V,D)];G[V]+=[(U,D)]\nP=f(S);Q=f(T);X=g(P,S);Y=g(Q,T);s=P[T]\nprint((X[T]**2-(1-s%2)*sum((X[i]*Y[i])**2for i in range(N)if P[i]==Q[i]==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%m)", "def Split(a):\n    no = []\n    for i, x in a:\n        if no:\n            is_ok = i == x\n            la_ok = no[-1][0] == no[-1][1]\n            if is_ok == la_ok:\n                yield no\n                no = []\n        no.append((i, x))\n    yield no\n\nn = int(input())\np = list(enumerate((int(input()) for i in range(n)), 1))\nfor sq in Split(p):\n    tl = tr = 0\n    for np, goal in sq:\n        if goal > np:\n            if goal < tr or goal > sq[-1][0]:\n                print(\"No\")\n                return\n            tr = goal\n        elif goal < np:\n            if goal < tl or goal < sq[0][0]:\n                print(\"No\")\n                return\n            tl = goal\nprint(\"Yes\")", "from operator import itemgetter\nfrom heapq import heappush, heappop\nN, M = list(map(int, input().split()))\nLR = [list(map(int, input().split())) for _ in range(N)]\nLR.sort(key=itemgetter(1))\nA = []\nans_left = 0\nidx = 1\nfor _, r in LR:\n    if r==M+1 or idx==M+1:\n        break\n    ans_left += 1\n    idx = max(idx+1, r+1)\n\nidx_LR = 0\nq = []\nfor i in range(M+1-ans_left, M+1):\n    while idx_LR<N and LR[idx_LR][1]<=i:\n        l, _ = LR[idx_LR]\n        heappush(q, l)\n        idx_LR += 1\n    heappop(q)\nwhile idx_LR<N:\n    l, _ = LR[idx_LR]\n    q.append(l)\n    idx_LR += 1\n\nq.sort(reverse=True)\nans_right = 0\nidx = M\nfor l in q:\n    if l==0 or idx==0 or ans_right+ans_left==M:\n        break\n    ans_right += 1\n    idx = min(l-1, idx-1)\nans = N - ans_left - ans_right\nprint(ans)\n", "from collections import deque\n\n\ndef first_cut(links, colors):\n    tmp_links = links.copy()\n    for v, neighbors in list(tmp_links.items()):\n        while len(neighbors) == 1 and colors[v]:\n            del links[v]\n            par = neighbors.pop()\n            links[par].remove(v)\n            v = par\n            neighbors = links[par]\n    return links\n\n\ndef diameter(links, flags):\n    def dfs(s):\n        fs = flags[s]\n        d, v = 0, 0\n        q = deque(sorted((fs + flags[v], v, s) for v in links[s]))\n        while q:\n            d, v, a = q.popleft()\n            for u in links[v]:\n                if u == a:\n                    continue\n                fu = flags[u]\n                if fu:\n                    q.append((d + 1, u, v))\n                else:\n                    q.appendleft((d, u, v))\n        return d, v\n\n    s = next(iter(links))\n    _, t = dfs(s)\n    d, _ = dfs(t)\n    return d\n\n\ndef solve(links, colors):\n    if all(colors):\n        return 0\n\n    links = first_cut(links, colors)\n    k = len(links)\n\n    if k == 1:\n        return 1\n\n    flags = {v: colors[v] ^ (len(link) % 2 == 0) for v, link in list(links.items())}\n    euler_tour = 2 * (k - 1) + sum(flags.values())\n    return euler_tour - 2 * diameter(links, flags)\n\n\nn = int(input())\nlinks = {i: set() for i in range(n)}\nfor _ in range(n - 1):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    links[x].add(y)\n    links[y].add(x)\ncolors = [c == 'B' for c in input()]\n\nprint((solve(links, colors)))\n", "\ndef main(n,m,ab):\n    g=[set(j for j in range(n) if j!=i) for i in range(n)]\n    for i,(a,b) in enumerate(ab):\n        a,b=a-1,b-1\n        g[a].discard(b)\n        g[b].discard(a)\n    xy=[]\n    mi=set(range(n))\n    seen=[-1]*n\n    while mi:\n        v=mi.pop()\n        todo=[[v,-1]]\n        seen[v]=0\n        xyi=[0,0]\n        xyi[0]+=1\n        while todo:\n            v,p=todo.pop()\n            for nv in g[v]:\n                if nv==p:continue\n                if seen[nv]==-1:\n                    seen[nv]=(seen[v]+1)%2\n                    xyi[seen[nv]]+=1\n                    mi.discard(nv)\n                    todo.append([nv,v])\n                elif seen[nv]!=(seen[v]+1)%2:return -1\n        xy.append(xyi)\n    abl=[0]*(n+1)\n    abl[0]=1\n    for x,y in xy:\n        for i in range(n,-1,-1):\n            if abl[i]>0:\n                abl[i]=0\n                abl[i+x]=1\n                abl[i+y]=1\n    ans=m\n    for i,x in enumerate(abl):\n        if x==0:continue\n        j=n-i\n        ans=min(ans,(i*(i-1))//2+(j*(j-1))//2)\n    return ans\n\nn,m=map(int,input().split())\nab=[list(map(int,input().split())) for _ in range(m)]\nprint(main(n,m,ab))", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN,X,Y,Z = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\n# \u30c0\u30e1\u306a\u3084\u3064\u3092\u6570\u3048\u308b\nL = max(10,X + Y + Z)\ndp = np.zeros(1 << L+1, dtype = np.int64) # \u53f3\u304b\u3089\u898b\u3066\u90e8\u5206\u548c\u3068\u3057\u3066\u8e0f\u3080\u5834\u6240\nrng = np.arange(1 << L+1, dtype=np.int64)\nx575 = (1 << Z) + (1 << (Y+Z)) + (1 << (X+Y+Z))\nbad = ((x575 & rng) == x575)\ndp[1] = 1\n\nfor n in range(N):\n    prev = dp\n    dp = np.zeros_like(prev)\n    for i in range(1, 11):\n        dp[1::1<<i] += prev.reshape(1<<i, 1<<(L+1-i)).sum(axis = 0)\n    dp[bad] = 0\n    dp %= MOD\n\nanswer = pow(10,N,MOD) - dp.sum()\nanswer %= MOD\nprint(answer)", "#ARC097D Equals\ndef f(x):\n    while q[x]>=0:\n        x=q[x]\n    return x\nN, M = map(int, input().split())\np = list(map(int, input().split()))\nq = [-1]*N\nfor _ in range(M):\n    x, y = map(lambda x:f(int(x)-1), input().split())\n    if x == y: continue\n    elif x < y: x,y=y,x\n    q[x] += q[y]\n    q[y] = x\n#\u65b9\u91dd:\u5404\u6728\u306b\u5206\u5272\u3001\u5404\u6728\u5185\u306e\u4e00\u81f4\u306e\u6700\u5927\u6570\u3092\u8db3\u305b\u3070\u3088\u3044\u3002\ntree = [[] for n in range(N)]\nfor n in range(N):\n    tree[f(n)].append(n)\n    #print(f(n))\nans = 0\nfor n in range(N):\n    ans += len(set(tree[n])&{p[i]-1 for i in tree[n]})\nprint(ans)", "import numpy as np\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\nB = np.array(input().split(), dtype=np.int32)\n \ndef sum_count(A,B,x):\n  # A,B is sorted. \n  # return count(a+b < x)\n  C = np.searchsorted(B, x-A)\n  return C.sum()\n \n\t\t\ndef f(t,A,B):\n  power = 1<<t\n  mask = (power<<1)-1\n  AA = A & mask\n  BB = B & mask\n  AA.sort()\n  BB.sort()\n\n  x1,x2,x3 = (sum_count(AA,BB,v) for v in [power, 2*power, 3*power])\n  zero_cnt = x1 + (x3-x2)\n  return (N-zero_cnt)%2\n  \nanswer = 0\nfor t in range(30):\n\tx = f(t,A,B)\n\tif x == 1:\n\t\tanswer += 1<<t\n\nprint(answer)\n", "from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor _ in range(q):\n\tn = int(input())\n\tl = list(map(int,input().split()))\n\tcyk = [(i + l[i])%n for i in range(n)]\n\tcyk.sort()\n\tdupa = 1\n\tfor i in range(1,n):\n\t\tif cyk[i] != cyk[i-1]+1:\n\t\t\tdupa = 0\n\tif dupa:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")", "import sys\n\nn, r = [int(x) for x in sys.stdin.readline().split()]\na = [int(x) for x in sys.stdin.readline().split()]\ns = sum(a)\nn = 2**n\nsys.stdout.write(str(s / n)+\"\\n\")\nfor i in range(r):\n\tp, x = [int(x) for x in sys.stdin.readline().split()]\n\ts = s - a[p] + x\n\ta[p] = x\n\tsys.stdout.write(str(s / n)+\"\\n\")", "import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\nAns = [None]*T\nMOD = 10**9+7\nmod = 10**9+9\nfor qu in range(T):\n    N, P = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    if P == 1:\n        if N&1:\n            Ans[qu] = 1\n        else:\n            Ans[qu] = 0\n        continue\n    if N == 1:\n        Ans[qu] = pow(P, A[0], MOD)\n        continue\n    A.sort(reverse = True)\n    cans = 0\n    carry = 0\n    res = 0\n    ra = 0\n    for a in A:\n        if carry == 0:\n            carry = pow(P, a, mod)\n            cans = pow(P, a, MOD)\n            continue\n        res = (res + pow(P, a, mod))%mod \n        ra = (ra + pow(P, a, MOD))%MOD\n        \n        if res == carry and ra == cans:\n            carry = 0\n            cans = 0\n            ra = 0\n            res = 0\n    Ans[qu] = (cans-ra)%MOD\n        \n        \nprint('\\n'.join(map(str, Ans)))", "from random import randint\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for _ in range(100):\n        for j in range(m):\n            x = randint(0, n - 1)\n            if x:\n                B = []\n                for i in range(n):\n                    B.append(A[i][j])\n                B = B[x:] + B[:x]\n                for i in range(n):\n                    A[i][j] = B[i]\n        c = 0\n        for i in range(n):\n            c += max(A[i])\n        ans = max(ans, c)\n    print(ans)", "import sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n\nMAXPRIME=10**6\nisPrime=[0 for _ in range(MAXPRIME+1)]\nisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\nfor i in range(2,MAXPRIME//2+1):\n    if isPrime[i]==0: #i is prime\n        for multiple in range(i*i,MAXPRIME+1,i):\n            if isPrime[multiple]==0:\n                isPrime[multiple]=i         \nprimeNumberSet=set()\nfor i in range(len(isPrime)):\n    if isPrime[i]==0:\n        primeNumberSet.add(i)\nprimes=sorted(list(primeNumberSet))\n\nlookupTable=[None for _ in range(MAXPRIME+1)]\n\npIdx=-1\npSqRtIdx=-1\nfor i in range(1,MAXPRIME+1):\n    while pIdx+1<len(primes) and primes[pIdx+1]<=i:\n        pIdx+=1\n    while pSqRtIdx+1<len(primes) and (primes[pSqRtIdx+1])**2<=i:\n        pSqRtIdx+=1\n    total=(pIdx+1)-(pSqRtIdx+1)+1 #1 is always lonely\n    lookupTable[i]=total\n\n#print(lookupTable[:30])\n\n#a number is lonely if its gcd with all other numbers is 1. i.e. it is prime and its square > n. also, 1 is always lonely\nt=int(input())\nn=[int(x) for x in input().split()]\nans=[str(lookupTable[nn]) for nn in n]\nprint('\\n'.join(ans))", "n =int(input())\nw=[]\nh=[]\nc=[]\ncntw={}\ncnth={}\nmultMayotC=0\ncntC=0\n\ndef insert1(a,b,c):\n    if not a in b :\n        b[a]=c\n    else :\n        b[a]=b[a]+c\n\ndef multMayot(a,b): \n    if a % b == 0 :\n        return b\n    else :\n        return multMayot(b,a%b)\n\nfor i in range(0, n):\n    a,b,d = map(int,input().split())\n    w.append(a)\n    h.append(b)\n    c.append(d)\n    insert1(a,cntw,d)\n    insert1(b,cnth,d)\n    cntC += d\n    \n    if multMayotC == 0 :\n        multMayotC = d\n    else:\n        multMayotC = multMayot(multMayotC, d)\n\nfor i in range(0, n):\n    if cntw[w[i]] * cnth[h[i]] != cntC * c[i]:\n        print (0)\n        return\n\nresult = 0\ni = 1\nwhile (i * i <= multMayotC) :\n    if multMayotC % i == 0 :\n        result += 1\n        if i * i != multMayotC :\n            result += 1\n    i += 1\n\nprint (result)", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor tests in range(t):\n    n,a,b,da,db=list(map(int,input().split()))\n    EDGE=[[] for i in range(n+1)]\n\n    for i in range(n-1):\n        x,y=list(map(int,input().split()))\n        EDGE[x].append(y)\n        EDGE[y].append(x)\n\n    if db<=da*2:\n        print(\"Alice\")\n        continue\n\n    Q=[a]\n    USE=[-1]*(n+1)\n    USE[a]=0\n    \n    while Q:\n        x=Q.pop()\n        for to in EDGE[x]:\n            if USE[to]==-1:\n                USE[to]=USE[x]+1\n                Q.append(to)\n\n    #print(USE)\n\n    if USE[b]<=da:\n        print(\"Alice\")\n        continue\n\n    MAX=-1\n    MAXIND=-1\n    for i in range(1,n+1):\n        if USE[i]>MAX:\n            MAX=USE[i]\n            MAXIND=i\n\n    Q=[MAXIND]\n    USE2=[-1]*(n+1)\n    USE2[MAXIND]=0\n    \n    while Q:\n\n        x=Q.pop()\n        for to in EDGE[x]:\n            if USE2[to]==-1:\n\n                USE2[to]=USE2[x]+1\n                Q.append(to)\n\n    DIA=max(USE2)\n    #print(MAXIND,USE2,DIA)\n\n    if DIA<=da*2:\n        print(\"Alice\")\n        continue\n\n    else:\n        print(\"Bob\")\n    \n    \n    \n        \n\n    \n", "#!/usr/bin/env python3\nimport sys\n\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n#lines = stdin.readlines()\n\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    d_str = input()\n    d = []\n    for i in range(n):\n        d.append(int(d_str[i]))\n    #print(d)\n    di=[]\n    for i in range(n):\n        di.append(i)\n    #print(d)\n    for b in range(10):\n        one_min = -1\n        two_min = -1\n        not_ok = 0\n        ans = []\n        for i in range(n):\n            if d[i] < b:\n                if d[i] < one_min:\n                    not_ok = 1\n                    break\n                one_min = d[i]\n                ans.append(1)\n\n            elif d[i] > b:\n                if d[i] < two_min:\n                    not_ok = 1\n                    break\n                two_min = d[i]\n                ans.append(2)\n            else:\n                if b >= two_min:\n                    two_min = b\n                    ans.append(2)\n                elif b >= one_min:\n                    one_min = b\n                    ans.append(1)\n                else:\n                    not_ok = 1\n                    break\n        if not_ok != 1:\n            print(\"\".join(map(str,ans)))\n            break\n    else:\n        print(\"-\")\n\n\n\n\n\n", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nk,n = list(map(int, read().split()))\n\nif k%2==0:\n    print((*([k//2]+[k]*(n-1))))\n    return\n\nif k==1:\n    print((*[1]*((n+1)//2)))\n    return\n\nans = [(k+1)//2]*n\nd = 0\ndef f(k,i,d):\n    # d <= 1+k+...+k^i?\n    v = 1\n    for j in range(i):\n        v *= k\n        v += 1\n        if v > d: return True\n    return False\n\ndef g(k,i):\n    # 1+k+...+k^i\n    v = 1\n    for j in range(i):\n        v *= k\n        v += 1\n    return v\n    \nfor i in range(1,n):\n    if f(k,n-i-1,d):\n        d += 1\n        continue\n    \"\"\"\n    \u4ee5\u4e0b\u3000300000 >= d >= 1+k+...+k^(n-i-1)\n    i \u756a\u76ee\u306e\u9805\u304b\u3089\u771f\u3093\u4e2d\u306b\u306a\u3089\u306a\u3044    \n    v \u756a\u76ee\u3092\u76ee\u6307\u3059\n    \"\"\"\n    v = (g(k,n-i)+d+1)//2 - d - 1\n    \n    for j in range(i,n):\n        #print(v)\n        if v==0:\n            ans[j] = 0\n            continue\n\n        p = g(k,n-j-1)\n        q = (v-1)//p \n        #print(v,j,p,q)\n        \n        ans[j] = q+1\n        v -= 1+q*p        \n\n\n\n    \n    break\n\n\nwhile ans[-1]==0:\n    ans.pop()\nprint((*ans))\n\n\n\n\n\n\n\n", "import sys\nsys.setrecursionlimit(500000)\n\nN = int(input())\nE = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    E[a].append(b)\n    E[b].append(a)\nK = int(input())\nL = [-float(\"inf\")] * (N+1)\nR = [float(\"inf\")] * (N+1)\nfor _ in range(K):\n    v, p = list(map(int, input().split()))\n    L[v] = p\n    R[v] = p\n\ntour = []\ndef dfs(v, p):\n    tour.append(v)\n    for u in E[v]:\n        if u!=p:\n            dfs(u, v)\n            tour.append(v)\ndfs(v, 0)\n\nl, r = L[v], R[v]\nodd = p % 2\nfor v in tour[1:]:\n    l -= 1\n    r += 1\n    odd = 1 - odd\n    l_, r_ = L[v], R[v]\n    if r_ != float(\"inf\") and r_%2 != odd:\n        print(\"No\")\n        return\n    l = max(l, l_)\n    r = min(r, r_)\n    L[v] = l\n    R[v] = r\nfor v in tour[-2::-1]:\n    l -= 1\n    r += 1\n    odd = 1 - odd\n    l_, r_ = L[v], R[v]\n    l = max(l, l_)\n    r = min(r, r_)\n    if l > r:\n        print(\"No\")\n        return\n    L[v] = l\n    R[v] = r\nAns = [-1] * (N+1)\nprint(\"Yes\")\nprint((\"\\n\".join(map(str, L[1:]))))\n", "import sys\n\n# sys.stdin = open('f1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ndef solve():\n    X = read_int()\n    K = read_int()\n    r = read_int_list()\n    Q = read_int()\n    j = 0\n    sign = -1\n    s = 0\n    e = X\n    y = 0\n    origin = 0\n    out = [0] * Q\n    for i in range(Q):\n        t, a = read_int_list()\n        while j < K and r[j] < t:\n            d = r[j] - origin\n            y += d * sign\n            if y < 0:\n                s += abs(y)\n                if s > e:\n                    s = e\n                y = 0\n            if y + e - s > X:\n                diff = (y + e - s) - X\n                e -= diff\n                if e < s:\n                    e = s\n            if y > X:\n                y = X\n            origin = r[j]\n            j += 1\n            sign *= -1\n        d = t - origin\n        if a <= s:\n            res = y\n        elif a <= e:\n            res = y + a - s\n        else:\n            res = y + e - s\n        res += d * sign\n        if res < 0:\n            res = 0\n        if res > X:\n            res = X\n        out[i] = res\n    return out\n\n\ndef main():\n    res = solve()\n    print(*res, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import accumulate\n\nS = list(map(ord, input().strip()))\nN = len(S)\n\natype = set()\nseg = [0]*N\nseg[-1] = 1\nfor i in range(N-1, -1, -1):\n    atype.add(S[i])\n    if len(atype) == 26:\n        atype = set()\n        seg[i] = 1\n\ninf = 1<<32\nidx = [[inf]*N for _ in range(26)]\nfor i in range(N-1, -1, -1):\n    s = S[i] - 97\n    idx[s][i] = i\n\nfor s in range(26):\n    for i in range(N-2, -1, -1):\n        idx[s][i] = min(idx[s][i], idx[s][i+1])\n\n\n\nseg = list(accumulate(seg[::-1]))[::-1]\nseg.append(1)\nL = seg[0]\nans = []\ncnt = -1\nfor i in range(L):\n    for c in range(26):\n        k = idx[c][cnt+1]\n        if k == inf:\n            ans.append(97+c)\n            break\n        if seg[k+1] + i + 1 <= L:\n            ans.append(97+c)\n            cnt = k\n            break\n        \n\nprint(''.join(map(chr, ans)))", "H,W=list(map(int,input().split()))\nans=max(H, W)\nS=[input() for i in range(H)]\nT = [[0]*(W-1)]\nfor i in range(H-1):\n    t,ts=[],[]\n    for j in range(W-1):\n      r=S[i][j:j+2]+S[i+1][j:j+2]\n      t.append(r.count('.')%2)\n      if t[j]==0:\n        ts.append(T[-1][j]+1)\n      else:\n        ts.append(0)\n    T.append(ts)\nfor L in T[1:]:\n    stack=[]\n    for i,l in enumerate(L+[0]):\n      w=-1\n      while stack and stack[-1][1]>=l:\n        w,h=stack.pop()\n        ans = max(ans, (h+1)*(i-w+1))\n      if w!=-1:\n        stack.append((w,l))\n        continue\n      stack.append((i,l))\nprint(ans)\n", "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        return\n    size[idx[b]] += k\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)", "w=list(input())\nn=len(w)\nt=-1\ndef Z(s):\n    m=len(s);z=[0]*m;c=0;f=[1]*m;\n    for i in range(1,m):\n        if i+z[i-c]<c+z[c]:z[i]=z[i-c]\n        else:\n            j=max(0,c+z[c]-i)\n            while i+j<n and s[j]==s[i+j]:j=j+1\n            z[i]=j;c=i\n    for p in range(1,m):\n        for k in range(2,z[p]//p+2):f[k*p-1]=0\n    return f\nfor j in range(1,n//2+1):\n    if n%j==0 and w[:n-j]==w[j:]:t=j;break;\nif t==-1:print ('1\\n1')\nelif t==1:print (n);print((1))\nelse:\n    zl=Z(w)\n    w.reverse()\n    zr=Z(w)\n    cnt=0\n    for i in range(0,n-1):\n        if zl[i] and zr[n-2-i]:cnt=cnt+1\n    print((2));print(cnt);\n", "N=int(input())\nA=[int(i) for i in input().split()]\nB=[[A[i],-10**15] for i in range(2**N)]\nfor i in range(N):\n    for b in range(2**N):\n        if ((1&(b>>i))==1):\n            merge=B[b]+B[b^(1<<i)]\n            merge.sort(reverse=True)\n            B[b]=merge[:2]\nans=-10**15\nfor i in range(1,2**N):\n    ans=max([ans,sum(B[i])])\n    print(ans)\n", "n=int(input())\nx,y=zip(*sorted(sorted(map(int,input().split())) for _ in range(n)))\na=x[-1]\nb=d=2*10**9\nfor i in range(n-1):\n    a=max(a,y[i])\n    b=min(b,y[i])\n    d=min(d,a-min(b,x[i+1]))\nprint(min((x[-1]-x[0])*(max(y)-min(y)),(max(y)-x[0])*d))", "import sys\ninput=sys.stdin.readline\nn=int(input())\nB=[]\nans=0\nfor i in range(n):\n\ta,b=map(int,input().split())\n\tans+=a\n\tif a>b:\n\t\tB.append(b)\nif len(B)==0:\n\tprint(0)\nelse:\n\tprint(ans-min(B))", "from collections import defaultdict\nS = input()\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def update(self, i, v):\n        while i <= self.n:\n            self.bit[i] += v\n            i += i & -i\n            \n    def query(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.bit[i]\n            i -= i & -i\n            \n        return ret\n\nd = defaultdict(list)\nfor i, v in enumerate(S):\n    d[v].append(i + 1)\n\nif sum(len(l) % 2 != 0 for l in list(d.values())) > 1:\n    print((-1))\n    return\n\nN = len(S)\nctr = []\nkey_map = [-1] * (N + 1)\n\nfor k, v in list(d.items()):\n    t = len(v)\n    if t % 2  == 1:\n        key_map[v[t // 2]] = N // 2 + 1\n\n    for j in range(t // 2):\n        ctr.append((v[j], v[-j - 1]))\n        \nctr.sort()\n\nfor i, (l, r) in enumerate(ctr):\n    key_map[l] = i + 1\n    key_map[r] = N - i\n\ntree = BIT(N)\nans = 0\nfor i, v in enumerate(key_map[1:]):\n    ans += i - tree.query(v)\n    tree.update(v, 1)\nprint(ans)\n", "from collections import deque\n\nN, L = list(map( int, input().split() ))\nT = []\nV = []\nfor i in range( N ):\n  t, v = list(map( int, input().split() ))\n  T.append( t )\n  V.append( v )\n\ndq = deque()\nct, cv = 0.0, 0.0\nfor i in range( N ):\n  while cv + V[ i ] > L:\n    ft, fv = dq[ 0 ]\n    take = min( cv + V[ i ] - L, fv )\n    ct, cv = ( ct * cv - ft * take ) / ( cv - take ), cv - take\n    if take == fv:\n      dq.popleft()\n    else:\n      dq[ 0 ] = [ ft, fv - take ]\n  ct, cv = ( ct * cv + T[ i ] * V[ i ] ) / L, L\n  print(( \"%.7f\" % ct ))\n  while len( dq ):\n    bt, bv = dq[ len( dq ) - 1 ]\n    if bt < T[ i ]: break\n    T[ i ], V[ i ] = ( T[ i ] * V[ i ] + bt * bv ) / ( V[ i ] + bv ), V[ i ] + bv\n    dq.pop()\n  dq.append( [ T[ i ], V[ i ] ] )\n", "N,D=list(map(int,input().split()))\nd=list(map(int,input().split()))\n\ndp=[D]*N\n\nif abs(D-d[0])<D:\n    dp[0]=abs(D-d[0])\n\nfor i in range(1,N):\n    dp[i]=min(dp[i-1],abs(dp[i-1]-d[i]))\n\nans=[\"NO\"]*N\ndata=[0]*(N+1)\nfor i in range(N-1,0,-1):\n    if d[i]//2>data[i+1]:\n        data[i]=data[i+1]\n    else:\n        data[i]=data[i+1]+d[i]\n    if dp[i-1]>data[i+1]:\n        ans[i]=\"YES\"\n\ni=0\nif d[i]//2>data[i+1]:\n    data[i]=data[i+1]\nelse:\n    data[i]=data[i+1]+d[i]\n\nif D>data[i+1]:\n    ans[i]=\"YES\"\n\nQ=int(input())\nq=list(map(int,input().split()))\nfor i in range(Q):\n    print((ans[q[i]-1]))\n\n\n#print(dp)\n#print(data)\n#print(ans)\n", "import sys,heapq\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\nn,m = map(int,input().split())\n#+\u8def\u7dda*chg : \u305d\u306e\u8def\u7dda\u30db\u30fc\u30e0\nchg = 10**6\n\nedge=defaultdict(set)\nused =defaultdict(bool)\nfor i in range(m):\n    p,q,c = map(int,input().split())\n    edge[p].add(p+c*chg)\n    edge[p+c*chg].add(p)\n    edge[p+c*chg].add(q+c*chg)\n    edge[q+c*chg].add(p+c*chg)\n    edge[q].add(q+c*chg)\n    edge[q+c*chg].add(q)\n    used[p] = False\n    used[q] = False\n    used[p+c*chg] = False\n    used[q+c*chg] = False\n\nedgelist = deque()\nedgelist.append((1,0))\nres = float(\"inf\")\n\nwhile len(edgelist):\n    x,cost = edgelist.pop()\n    used[x] = True\n\n    if x == n:\n        res = cost\n        break\n    for e in edge[x]:\n        if used[e]:\n            continue\n        #\u30db\u30fc\u30e0\u2192\u6539\u672d\n        if x <= 10**5 and chg <= e:\n            edgelist.appendleft((e,cost+1))\n        else:\n            edgelist.append((e,cost))\n        \nif res == float(\"inf\"):\n    print(-1)\nelse:\n    print(res)", "d=10**9+7\nn=int(input())\np=[0]*5001\np[len(input())]=1\nwhile n:\n\tp=[((2*p[j-1]if j else p[j])+p[j+1])%d for j in range(n)]\n\tn=n-1\nprint(p[0])", "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nn=int(input())\nedge=[[] for i in range(n)]\nfor i in range(n-1):\n    v,w=map(int,input().split())\n    edge[v-1].append(w-1)\n    edge[w-1].append(v-1)\n\nif n==2:\n    print(1,2);return\n\nleafcnt=[0]*n\nfor v in range(n):\n    for nv in edge[v]:\n        if len(edge[nv])==1:\n            leafcnt[v]+=1\n\nused=[False]*n\nline=[]\ndef line_check(v):\n    used[v]=True\n    line.append(leafcnt[v])\n    flag=False\n    for nv in edge[v]:\n        if not used[nv] and len(edge[nv])!=1:\n            if not flag:\n                line_check(nv)\n                flag=True\n            else:\n                return False\n    return True\n\nfor v in range(n):\n    if not used[v] and len(edge[v])-leafcnt[v]<=1 and len(edge[v])!=1:\n        if not line:\n            check=line_check(v)\n            if not check:\n                print(-1);return()\n        else:\n            print(-1);return()\n\n\nline_rev=line[::-1]\nres=min(line,line_rev)\nres=[0]+res+[0]\nres[1]-=1\nres[-2]-=1\n\nans=[]\nL=1\nfor val in res:\n    R=L+val\n    for i in range(L+1,R+1):\n        ans.append(i)\n    ans.append(L)\n    L=R+1\n\nprint(*ans)\n", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\n\ncnt = 0\nfor i, j in zip(x, x[1:]):\n    if a * (j - i) < b:\n        cnt += a * (j - i)\n    else:\n        cnt += b\nprint(cnt)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nn,w=[int(i) for i in input().rstrip('\\n').split()]\narr=[]\ntem=[]\nfor i in range(n):\n    t=[int(i) for i in input().rstrip('\\n').split()]\n    tem.append(t[0])\n    arr.append(t[1:])\nl=[0 for i in range(w)]\n\nwi=[0 for i in range(w+1)]\nfor j in range(n):\n    st=deque()\n    c=w-tem[j]\n    for i in range(tem[j]):\n        while st and st[0]<i-c:st.popleft()\n        while st and arr[j][st[-1]]<arr[j][i]:st.pop()\n        st.append(i)\n        if arr[j][st[0]]>0 or (i>=c and i<w-c):\n            l[i]+=arr[j][st[0]]\n    ind=tem[j]\n    while st and arr[j][st[0]]>0:\n        wi[ind]+=arr[j][st[0]]\n        wi[w-(tem[j]-st[0])+1]+=-arr[j][st[0]]\n        ind=w-(tem[j]-st[0])+1\n        st.popleft()\n    \n\ncurr=0\nfor i in range(w):\n    curr+=wi[i]\n    l[i]+=curr\nprint(\" \".join(str(e) for e in l))", "d = [-1] * 1000001\nfor t in range(int(input())):\n    n, a = int(input()), list(map(int, input().split()))\n    a.sort()\n    for i in range(n):\n        for j in range(i + 1, n):  d[a[j] - a[i]] = t\n    i = 1\n    while any(d[i * j] == t for j in range(1, n)): i += 1\n    print(\"YES\\n\" + ' '.join(str(j * i + 1) for j in range(n)))", "import math\nimport sys\n\ninput = sys.stdin.readline\n\ndef main():\n\n\n\n    MAX_N = int(1e6) + 1\n\n    dp = [0 for i in range(MAX_N)]\n    vals = [[] for i in range(10)]\n\n    for i in range(10):\n        dp[i] = i\n        vals[i].append(i)\n\n\n    for i in range(10, MAX_N):\n        prod = 1\n        for j in str(i):\n            if j != '0':\n                prod *= int(j)\n\n        dp[i] = dp[prod]\n        vals[dp[prod]].append(i)\n\n    q = int(input())\n\n    for i in range(len(vals)):\n        vals[i] = sorted(vals[i])\n\n    for i in range(q):\n        l,r, k = [int(x) for x in input().split(' ')]\n        posl = -1\n        posr = -1\n        for j in range(25, -1, -1):\n            jump = 2**j\n\n            if posl + jump < len(vals[k]) and vals[k][posl+jump] < l:\n                posl += jump\n\n            if posr + jump < len(vals[k]) and vals[k][posr+jump] <= r:\n                posr += jump\n\n        print(posr - posl)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\n\n\nn, q = li()\n\n\nqueue = [-1] * 20\n\nans = [[-1] * 20 for i in range(n + 1)]\nl = li()\nfor i, curr in enumerate(l):\n\n    for j in range(20):\n        if curr >> j & 1:\n            for k in range(20):        \n                ans[i][k] = max(ans[i][k], ans[queue[j]][k])\n            ans[i][j] = i\n    \n    for j in range(20):queue[j] = max(queue[j], ans[i][j])\n\n\nqueries = []\nfor i in range(q):queries.append(li())    \nfor i in range(q):\n    a, b = queries[i]\n    a -= 1\n    b -= 1\n\n    currans = 0\n\n    for j in range(20):\n        if (l[a] >> j) & 1 and ans[b][j] >= a:\n            currans = 1\n            break\n    print('Shi' if currans else 'Fou')", "N = 100100\n\ndef main():\n    n = int(input())\n    d=[0]*N\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    m,c=[0]*N,[0]*N\n    m[0] = b[0]\n    c[0] = d[0]\n    \n    z = 1\n    p = 0\n    for i in range(1,n):\n        p = min(p,z)\n        while(p+1<z and m[p+1]*a[i]+c[p+1]<=m[p]*a[i]+c[p]):\n            p=p+1\n        d[i] = m[p]*a[i]+c[p]\n        while(z>=2 and (c[z-2]-c[z-1])*(b[i]-m[z-1])>=(c[z-1]-d[i])*(m[z-1]-m[z-2]) ):\n            z=z-1\n        m[z],c[z]=b[i],d[i]\n        z=z+1\n    #for j in range(n):print(d[j])\n    print(d[n-1])\n\nmain()\n", "#!/usr/bin/env python3\n#\n# XOR-pyramid\n#\nimport sys, os\n\ndef read_int(): return int(input())\ndef read_ints(): return list(map(int, input().split()))\n#------------------------------------------------------------------------------#\n\nn = read_int()\na = read_ints()\ndp = [[0] * n for _ in range(n)]\nf = [[0] * n for _ in range(n)]\nfor i in range(n - 1, -1, -1):\n\tf[i][i] = dp[i][i] = a[i]\n\tfor j in range(i + 1, n):\n\t\tf[i][j] = f[i][j - 1] ^ f[i + 1][j]\n\t\tdp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])\nq = read_int()\nfor _ in range(q):\n\tl, r = read_ints()\n\tprint(dp[l - 1][r - 1])\n\n", "import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    l = list(map(int, input().split()))\n    \n    stack = []\n    out = [-1] * n\n    curr = 0\n    works = True\n    for i in range(n):\n        while stack and stack[-1][0] == i:\n            _, j = stack.pop()\n            curr += 1\n            out[j] = curr\n        \n        nex = l[i] - 1\n        if nex == -2:\n            curr += 1\n            out[i] = curr\n        else:\n            if stack and nex > stack[-1][0]:\n                works = False\n            else:\n                stack.append((nex, i))\n    \n    while stack:\n        _, j = stack.pop()\n        curr += 1\n        out[j] = curr\n    \n    if works:\n        print(*out)\n    else:\n        print(-1)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    X = [0] * 30\n    for a in A:\n        for i in range(30):\n            if a & (1 << i):\n                X[i] += 1\n    for i in range(30)[::-1]:\n        if X[i] % 2:\n            if X[i] == 1:\n                print(\"WIN\")\n            elif N % 2 == 0:\n                print(\"WIN\")\n            elif X[i] % 4 == 1:\n                print(\"WIN\")\n            else:\n                print(\"LOSE\")\n            break\n    else:\n        print(\"DRAW\")\n", "import sys\ninput = sys.stdin.readline\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    ans = 0\n    for i in range(n - 1):\n        diff = a[i] - a[i + 1]\n        if diff <= 0:\n            continue\n        else:\n            ans = max(len(bin(diff)) - 2, ans)\n            a[i + 1] = a[i]\n    print(ans)\n", "n, k = map(int, input().split())\nc, v = 0, []\nfor i, a in enumerate(map(int, input().split())):\n    j = i + 1 - len(v)\n    d = c - (j - 1) * (n - j) * a\n    if d < k:\n        v.append(i + 1)\n        n -= 1\n    else:\n        c += a * (j - 1)\nprint('\\n'.join(map(str, v)))", "import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\nMOD =  998244353\nAns = [None]*T\nfor qu in range(T):\n    N, K = map(int, readline().split())\n    A = [0] + list(map(int, readline().split())) + [0]\n    B = list(map(int, readline().split()))\n    C = [None]*(N+1)\n    for i in range(1, N+1):\n        C[A[i]] = i\n    ans = 1\n    for b in B[::-1]:\n        bi = C[b]\n        res = 0\n        if A[bi-1]:\n            res += 1\n        if A[bi+1]:\n            res += 1\n        A[bi] = 0\n        ans = ans*res%MOD\n    Ans[qu] = ans\nprint('\\n'.join(map(str, Ans))) ", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nm = int(input())\na = listin()\nb = listin()\nd = defaultdict(list)\nfor i in range(m):\n    d[b[i]].append(i)\nnums = deque(sorted(d.keys()))\na.sort(reverse = True)\na = deque(a)\nans = [0 for i in range(m)]\nwhile nums:\n    while d[nums[0]]:\n        ans[d[nums[0]].pop()] = a.popleft()\n    nums.popleft()\nprint(*ans)", "from networkx import*\n(N,),*t=map(str.split,open(0))\nG=Graph(t)\ns=shortest_path_length\nx=s(G,'1')\ny=s(G,N)\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=int(N)::2])", "S = input()\nT = input()\nrui_s = [0]\nrui_t = [0]\nfor s in S:\n    if s == \"A\":\n        rui_s.append((rui_s[-1] + 1) % 3)\n    else:\n        rui_s.append((rui_s[-1] + 2) % 3)\nfor t in T:\n    if t == \"A\":\n        rui_t.append((rui_t[-1] + 1) % 3)\n    else:\n        rui_t.append((rui_t[-1] + 2) % 3)\n        \nfor _ in range(int(input())):\n    a, b, c, d = map(int, input().split())\n    if (rui_s[b] - rui_s[a - 1]) % 3 == (rui_t[d] - rui_t[c - 1]) % 3:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "N=int(input())\nA=list(map(int,input().split()))\nB=sorted([(i,a) for i,a in enumerate(A)],key=lambda x:x[1])[::-1]+[(N,0)]\nd=[0]*N\nm=N\nfor i in range(N):\n    m=min(m,B[i][0])\n    d[m]+=(i+1)*(B[i][1]-B[i+1][1])\nprint(*d,sep='\\n')", "class BIT(object):\n    def __init__(self, size):\n        self.size = size\n        self.bit = [0] * (self.size + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += i & -i\n\n    def __str__(self):\n        return str(self.bit)\n\nn, m = map(int,input().split())\nlr = [[] for i in range(m + 1)]\nfor i in range(n):\n    l, r = map(int,input().split())\n    lr[r - l + 1].append(l)\n\nbit = BIT(m + 1)\nt = 0\nfor d in range(1, m + 1):\n    for l in lr[d]:\n        #print(l, l + d)\n        bit.add(l, 1)\n        #print(bit.bit)\n        bit.add(l + d, -1)\n        #print(bit.bit)\n\n    t += len(lr[d])\n    ans = n - t\n\n    cur = 0\n    while cur <= m:\n        ans += bit.sum(cur)\n        cur += d\n\n    print(ans)", "# cook your code here\na=[]\nb=[]\nc=[]\ntemp=[]\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ndef find(temp,f):\n  q=-1\n  while q<len(temp)-1 and temp[q+1]<=f:\n     q=q+1\n  if q==-1:\n      return 0\n  if temp[q]==f:\n      return 1\n  else:\n      f=f-temp[q]\n      flag=find(temp[0:q],f)\n      return flag\n  \n    \nfor i in range(0,a[1]):\n    c=list(map(int,input().split()))\n    if c[0]==3:\n       temp=b[c[1]-1:c[2]]\n       temp.sort()\n       #print temp\n       j=-1\n       f=int(c[3])\n       \n       while j<len(temp)-1 and temp[j+1]<=f:\n         j=j+1\n         \n       if temp[j]==f:\n           print('Yes')\n           continue\n       \n      \n       while j>=1:\n          \n          f=c[3]-temp[j] \n         \n          flag=find(temp[0:j],f)\n          \n          if flag==1:\n             break\n          else:\n              j=j-1\n           \n       if flag==1:\n         print('Yes')\n       else:\n           print('No')\n        \n    if c[0]==1:\n        b[c[1]-1]=c[2]\n    if c[0]==2:\n        b[c[1]-1:c[2]]=reversed(b[c[1]-1:c[2]])\n    \n\n         ", "n,m = list(map(int,input().split()))\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\ndp = []\nfor i in range(n):\n    dp += [[0]*m]\ndp[-1][-1]=1\nfor i in range(n-2,-1,-1):\n    dp[i][-1]=1\n    for j in range(m-1):\n        x = (a[i]+b[j])-(b[j+1])\n        temp = 0\n        for k in range(i+1,n):\n            if(a[k]>=x):\n                temp += dp[k][j+1]\n        dp[i][j]=temp\nans = 0\nfor i in range(n):\n    ans += dp[i][0]\nprint(ans)\n        \n", "s = '0'\ns += input()\n\n\ndef isPara(string, l, r):\n    while l <= r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\n\ndef solve():\n    N = len(s)-1\n    if s[N] == '1' or s[1] == '0':\n        print((-1))\n        return\n    if isPara(s, 1, N-1) == False:\n        print((-1))\n        return\n    sz = 1\n    while sz < N:\n        if(s[sz] == '1'):\n            sz += 1\n        else:\n            break\n    sz -= 1\n    # a max chain of sz\n    now = 1\n    for i in range(2, N+1):\n        print((str(now) + ' ' + str(i)))\n        if(s[i-1] == '1'):\n            now = i\n\n\nsolve()\n", "import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nt=int(input())\nfor testcaess in range(t):\n    n,m,a,b=list(map(int,input().split()))\n    E=[[] for i in range(n+1)]\n\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        E[x].append(y)\n        E[y].append(x)\n\n    USE1=[0]*(n+1)\n\n    Q=deque()\n    Q.append(a)\n\n    USE1[a]=1\n\n    while Q:\n        x=Q.pop()\n\n        for to in E[x]:\n            if to==b:\n                continue\n            if USE1[to]==0:\n                USE1[to]=1\n                Q.append(to)\n\n    USE2=[0]*(n+1)\n\n    Q=deque()\n    Q.append(b)\n\n    USE2[b]=1\n\n    while Q:\n        x=Q.pop()\n\n        for to in E[x]:\n            if to==a:\n                continue\n            if USE2[to]==0:\n                USE2[to]=1\n                Q.append(to)\n\n    #print(USE1,USE2)\n\n    ANS1=0\n    ANS2=0\n\n    for i in range(n+1):\n        if i==a or i==b:\n            continue\n        if USE1[i]==1 and USE2[i]==0:\n            ANS1+=1\n        elif USE1[i]==0 and USE2[i]==1:\n            ANS2+=1\n\n    print(ANS1*ANS2)\n        \n\n    \n\n    \n", "import sys\ninput = sys.stdin.readline\nout = []\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    n -= 1\n    rem = n % 3\n    n //= 3\n    \n    s = []\n    if n:\n        n -= 1\n        while n >= 0:\n            s.append([['00','00','00'],['01','10','11'],['10','11','01'],['11','01','10']][n % 4][rem])\n            n //= 4\n            n -= 1\n\n    s.append(['1','10','11'][rem])\n\n    s.reverse()\n\n    out.append(int(''.join(s),2))\nprint('\\n'.join(map(str,out)))\n    \n", "def solve():\n    s = input()\n    n = len(s)\n    acnt = 0\n    bcnt = 0\n    ans = 0\n    for i in s:\n        if i == \"B\":\n            if acnt:\n                acnt -= 1\n            else:\n                bcnt += 1\n        if i == \"A\":\n            acnt += 1\n    print(acnt + bcnt % 2)\nfor i in range(int(input())):\n    solve()", "input()\na=list(map(int,input().split()))\nn=len(a)\nu=n\nfor i in range(n):\n\tj=i\n\tk=0\n\twhile a[j]>0:\n\t\tk+=1\n\t\tt=j\n\t\tj=a[j]-1\n\t\ta[t]=0\n\tif k>0:\n\t\tu+=1-k%2\ns='Petr'\nif u%2>0:\n\ts='Um_nik'\nprint(s)\n", "3\n\nimport os\nimport sys\n\n\ndef main():\n    T = read_int()\n    for _ in range(T):\n        N = read_int()\n        P = read_ints()\n        print(*solve(N, P))\n\n\ndef solve(N, P):\n    C = []\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N and P[j] == P[i]:\n            j += 1\n        C.append(j - i)\n        i = j\n\n    if N < 10 or len(C) < 3:\n        return 0, 0, 0\n\n    half = N // 2\n    g = C[0]\n    s = 0\n    i = 1\n    while i < len(C) and g >= s:\n        s += C[i]\n        i += 1\n    b = 0\n    while i < len(C) and g >= b:\n        b += C[i]\n        i += 1\n    if s == 0 or b == 0 or g >= s or g >= b or g + s + b > half:\n        return 0, 0, 0\n    while i < len(C):\n        if g + s + b + C[i] > half:\n            break\n        b += C[i]\n        i += 1\n    return g, s, b\n\n\n###############################################################################\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "for _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    ans = []\n    sign = -1\n    for ansi in range(n, 0, -1):\n        if (a[(n + ansi * sign) // 2] == b[ansi - 1]) ^ (sign > 0):\n            ans.append(1)\n        ans.append(ansi)\n        sign = -sign\n    print(len(ans), *ans)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n\n    a=input().strip()\n    b=input().strip()\n\n\n    Q=deque(a)\n\n    L=[]\n    while Q:\n        L.append(Q.popleft())\n\n        if Q:\n            L.append(Q.pop())\n\n    ANS=[]\n    for i in range(n):\n        if i%2==0:\n            if L[i]==b[-1-i]:\n                ANS.append(1)\n        else:\n            if L[i]!=b[-1-i]:\n                ANS.append(1)\n\n        ANS.append(n-i)\n\n    print(len(ANS),*ANS)\n            \n\n    \n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nT = int(input())\nfor _ in range(T):\n    N, M, K = list(map(int, input().split()))\n    K = min(K, M-1)\n    A = [int(a) for a in input().split()]\n    B = [max(A[i], A[-M+i]) for i in range(M)]\n    print(max([min(B[i:i+M-K]) for i in range(K+1)]))\n", "import sys\ninput = sys.stdin.readline\nimport random\n\nt=int(input())\n#t=1\nfor tests in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n\n    #n=6\n    #A=[random.randint(1,10) for i in range(n)]\n    #print(A)\n\n    REST=[-1]*n\n    MIN=1<<60\n    RESTMAX=0\n\n    for i in range(n):\n        MIN=min(MIN,A[i])\n\n        if A[i]-MIN<RESTMAX:\n            MIN=max(0,A[i]-RESTMAX)\n            REST[i]=A[i]-MIN\n            RESTMAX=max(RESTMAX,REST[i])\n\n        else:\n            REST[i]=A[i]-MIN\n            RESTMAX=max(RESTMAX,REST[i])\n\n\n    for i in range(1,n):\n        if REST[i-1]==0:\n            continue\n        if REST[i-1]>REST[i]:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n\n    #print(REST,MIN)\n\n        \n        \n    \n", "for t in range(int(input())):\n    d,m = [int(i) for i in input().split()]\n    tot = 0\n    p = 1\n    while p<=d:\n        p *= 2\n    p //= 2\n    while d>0:\n        tot += (d-p+1)*(tot+1)\n        tot %= m\n        d = p-1\n        p //= 2\n    print(tot)\n", "import sys\ninput=sys.stdin.readline\nT=int(input())\nfor _ in range(T):\n    n,m=map(int,input().split())\n    edges=[0]*m\n    for i in range(m):\n        edges[i]=tuple(map(int,input().split()))\n    used=[0]*(3*n)\n    edgess=[]\n    check=0\n    for i in range(m):\n        if used[edges[i][0]-1]==used[edges[i][1]-1]==0:\n            edgess.append(i+1)\n            used[edges[i][0]-1]=1\n            used[edges[i][1]-1]=1\n            check+=1\n    if check>=n:\n        useful=edgess[:n]\n        edgess=[str(guy) for guy in useful]\n        print(\"Matching\")\n        print(\" \".join(edgess))\n    else:\n        indep=[]\n        for i in range(1,3*n+1):\n            if used[i-1]==0:\n                indep.append(i)\n        useful=indep[:n]\n        verts=[str(guy) for guy in useful]\n        print(\"IndSet\")\n        print(\" \".join(verts))", "for _ in range(int(input())):\n    n, d = list(map(int, input().split()))\n    ar = list(map(int, input().split()))\n    ans = ar[0]\n    for i in range(1, n):\n        if ar[i] * i <= d:\n            d -= ar[i] * i\n            ans += ar[i]\n        else:\n            ans += d // i\n            break\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, k = list(map(int, input().split()))\n    s = input()\n    l = ['']*k\n    works = True\n    for i in range(n):\n        c = s[i]\n        if c != '?':\n            if l[i%k] == c or l[i%k] == '':\n                l[i%k] = c\n            else:\n                works = False\n                break\n    if works:\n        smol = 0\n        big = k\n        for c in l:\n            if c == '0':\n                big -= 1\n            elif c == '1':\n                smol += 1\n        goal = k//2\n        if smol <= goal <= big:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        print('NO')\n", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN = int(input())\nX = np.array(input().split(), dtype = np.int64)\nL = int(input())\n\nU = N.bit_length()\n# \u5404\u30db\u30c6\u30eb\u304b\u3089\u30012^n\u56de\u3067\u3069\u3053\u307e\u3067\u884c\u3051\u308b\u304b\nnext_x = []\nnext_x.append(np.searchsorted(X, X+L, side = 'right') - 1)\nfor i in range(U):\n    next_x.append(next_x[i][next_x[i]])\n\ndef days(a,b):\n    a -= 1\n    b -= 1\n    if b < a:\n        a,b = b,a\n    # \u5230\u7740\u3067\u304d\u306a\u3044\u7bc4\u56f2\u3067\u6700\u5927\u9650\u9032\u3080\n    result = 0\n    for n in range(U,-1,-1):\n        c = next_x[n][a]\n        if c < b:\n            a = c\n            result += 1 << n\n    return result + 1\n\nQ = int(input())\nfor _ in range(Q):\n    a,b = map(int,input().split())\n    print(days(a,b))", "import sys\nfrom math import log\n\nk = float(sys.stdin.readline())\nanswer = int(log(2.0, 2.0/k))\nprint(2*answer)\n\nm = 2 ** (1.0/answer)\n# m = 2.0/k\nthesum = 0\nfor i in range(answer):\n thesum += m**i\n# print [m**i/thesum for i in xrange(answer)]\nloaves = [1]\n\ndef maxIndex(list):\n max = -1\n mi = -1\n for i, x in enumerate(list):\n  if x > max:\n   max = x\n   mi = i\n return mi\n\ndesired = [m**i/thesum for i in range(answer)]\ndesired.reverse()\n# print desired\ncuts = []\nwhile len(desired) > 1:\n cuts.append(desired[-1])\n lastsum = desired[-1] + desired[-2]\n del desired[-2:]\n desired[0:0] = [lastsum]\n\n# print cuts\n\nwhile cuts:\n length = cuts.pop()\n i = maxIndex(loaves)\n print(i, length)\n loaves[i] -= length\n loaves.append(length)\n # print loaves\n\n# print loaves\nfor i in range(answer):\n i = maxIndex(loaves[:answer])\n x = loaves[i]/2.0\n print(i, x)\n loaves.append(x)\n loaves[i] -= x\n# print loaves\n", "def s():\n    a = input()\n    r = 'http://' if a[0] == 'h' else 'ftp://'\n    if a[0] == 'h':\n        a = a[4:]\n    else:\n        a = a[3:]\n    c = a[0]\n    a = a[1:].replace('ru','.ru/',1)\n    print(r,c,a[:-1] if a[-1] == '/'else a,sep='')\ns()\n", "n=int(input())\na=list(map(int,input().split()))\nb = sorted(a) + [min(a)]\nfor i in range(n):print(b[b.index(a[i])+1],end=' ')\n", "pas = input()\ncount = int(input())\nwords = [input() for i in range(count)]\n\nif pas in words:\n    print(\"YES\")\nelse:\n    f1 = False\n    f2 = False\n    for word in words:\n        if pas[0] == word[1]:\n            f1 = True\n        if pas[1] == word[0]:\n            f2 = True\n    if f1 and f2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "\n\nimport numpy as np\nN,K = list(map(int,input().split()))\nA=np.array(list(map(int,input().split())))\n#A=list(map(int,input().split()))\nmod = 998244353\n\nfact = [1]*(K+1)\nfor i in range(1,K+1):\n    fact[i]=i*fact[i-1]%mod\ninv_fact = [pow(f,mod-2,mod) for f in fact]\n\n# r = [sum(pow(aa,t,mod) for aa in A)%mod for t in range(K+1)]\nr = [0]*(K+1)\nr[0] = N\ntemp = np.ones(N,dtype=\"int32\")\nfor i in range(1,K+1):\n    temp = temp*A%mod\n    r[i] = int(np.sum(temp))%mod\n\ninv2 = pow(2,mod-2,mod)\nfor x in range(1,K+1):\n    \n#     ans = sum((fact[x]*inv_fact[t]*inv_fact[x-t] *r[x-t]*r[t]) %mod \n#                for t in range(x+1))%mod\n    \n#    ans-= r[x]*pow(2,x,mod) %mod\n\n    ans = 0\n    for t in range(x+1):\n        comb = fact[x]*inv_fact[t]*inv_fact[x-t] %mod\n        #comb = fact[x]* pow(fact[t],mod-2,mod)*pow(fact[x-t],mod-2,mod) %mod\n        ans += comb * r[x-t] * r[t] %mod\n    ans-= r[x]*pow(2,x,mod) %mod\n    print(((ans*inv2)%mod))\n\n", "mod = 998244353\nN, K = map(int, input().split())\ndp = [[0] * (N + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(1, N + 1):\n    for j in reversed(range(N + 1)):\n        dp[i][j] = dp[i - 1][j - 1] + (dp[i][2 * j] if 2 * j <= N else 0)\n        dp[i][j] %= mod\nprint(dp[N][K])", "import sys\n\n\nclass IO:\n    @staticmethod\n    def get(type=str):\n        return type(input().strip())\n    \n    @staticmethod\n    def gets(type=str):\n        return [type(x) for x in input().split()]\n\n\ndef printerr(*args, **kw):\n    print(*args, **kw, file=sys.stderr)\n\n\ndef inv(n, p):\n    return pow(n, p-2, p)\n\ndef comb(n, k, p):\n    k = min(k, n-k)\n    t, d = 1, 1\n    for i in range(k):\n        t *= n - i\n        t %= P\n        d *= i+1\n        d %= P\n    return t * inv(d, P) % P\n\n\nP = 10 ** 9 + 7\n\ndef main():\n    n, m = IO.gets(int)\n    a = IO.gets(int)\n\n    x = sum(a) + n\n    dm = m - sum(a)\n    printerr(f\"x={x} dm={dm}\")\n\n    if dm < 0:\n        ans = 0\n    elif dm == 0:\n        ans = 1\n    else:\n        # ans = (1 - pow(x, m+1, P)) * inv(1 - x, P) % P\n        ans = comb(x+dm, dm, P)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nxs,ys,xt,yt = list(map(int,readline().split()))\nn, = list(map(int,readline().split()))\n\nxyr = [tuple(map(int,readline().split())) for _ in range(n)] + [(xs,ys,0),(xt,yt,0)]\n\n\n\"\"\"\nd: \u96a3\u63a5\u884c\u5217\u306b\u5bfe\u3059\u308b Dijkstra\nO(N^2)\n\"\"\"\ndef Dijkstra_matrix(d,start):\n    n = len(d)\n    #INF = 1<<61\n    INF = float(\"inf\")\n    dist = d[start][:] #start\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n\n    used = [0]*n # \u6700\u77ed\u8ddd\u96e2\u304c\u6c7a\u307e\u3063\u305f\u9802\u70b9\n    used[start] = 1\n    for _ in range(n-1):\n        d0  = INF\n        idx = -1\n        for i in range(n):\n            if not used[i] and dist[i] < d0:\n                idx = i\n                d0  = dist[i]\n        if idx == -1:\n            return dist\n        else:\n            used[idx] = 1\n            for j in range(n):\n                if not used[j] and dist[j] > dist[idx]+d[idx][j]:\n                    dist[j] = dist[idx]+d[idx][j]\n    return dist\n\nfrom math import hypot\nd = [[max(0.0,hypot((xi-xj),(yi-yj))-ri-rj) for xj,yj,rj in xyr] for xi,yi,ri in xyr]\n\n#print(d)\ndist = Dijkstra_matrix(d,n)\nprint((dist[-1]))\n#print(dist)\n\n\n\n\n\n\n", "import sys\nreadline = sys.stdin.readline\n\nN, K, MOD = list(map(int, readline().split()))\n\nMAX = K*(N//2)*(N//2+1)//2+1\n\n\ntable = [[1]]\n\nfor idx in range(1, N+1):\n    dp = table[-1]\n    dp2 = dp + [0]*(idx*(K+1))\n    s = idx*(K+1)\n    for i in range(min(len(dp), len(dp2)-s)):\n        dp2[i+s] = (dp2[i+s] + -dp[i])%MOD\n    for i in range(len(dp2)-idx):\n        dp2[i+idx] = (dp2[i+idx]+dp2[i])%MOD\n    \n    if len(dp2) > MAX:\n        dp2 = dp2[:MAX]\n    table.append(dp2)\n\nAns = [None]*(N+1)\nfor x in range(1, N+1):\n    if N-x < x:\n        Ans[x] = Ans[N+1-x]\n    ans = 0\n    for i in range(min(len(table[x-1]), len(table[N-x]))):\n        ans = (ans + table[x-1][i]*table[N-x][i])%MOD\n    ans = (ans*(K+1)-1)%MOD\n    Ans[x] = ans\nprint(('\\n'.join(map(str, Ans[1:]))))\n", "n, m, cnt = int(input()), 148, 0\nans = [['N'] * m for i in range(m)]\n\ndef edge(i, j):\n    ans[i][j] = ans[j][i] = 'Y'\n\ndef node(*adj):\n    nonlocal cnt\n    i = cnt\n    cnt += 1\n    for j in adj:\n        edge(i, j)\n    return i\n\nstart, end, choice = node(), node(), node()\nif n&1:\n    edge(choice, end)\nfor i in range(1, 30):\n    end, choice = node(node(end), node(end)), node(node(choice))\n    if n&(1<<i):\n        edge(choice, end)\nedge(start, choice)\n\nprint(m)\nfor line in ans:\n    print(''.join(line))\n\n\n\n\n# Made By Mostafa_Khaled\n", "import heapq\nfor _ in range(int(input())):\n    n=int(input())\n    a=[0]*n\n    que=[(-n,0,n-1)]\n    heapq.heapify(que)\n    i=1\n    while que:\n        len,l,r=heapq.heappop(que)\n        if len%2==1:\n            a[(l+r)//2]=i\n            if r!=l:\n                nl=(-(r-l)//2,l,(l+r)//2-1)\n                nr=(-(r-l)//2,(l+r)//2+1,r)\n                heapq.heappush(que,nl)\n                heapq.heappush(que,nr)\n        else:\n            a[(l+r-1)//2]=i\n            nl=(-(r-l-1)//2,l,(l+r-1)//2-1)\n            nr=(-(r-l+1)//2,(l+r-1)//2+1,r)\n            if r==l+1:\n                heapq.heappush(que,nr)\n            else:\n                heapq.heappush(que,nr)\n                heapq.heappush(que,nl)\n        i+=1\n    print(*a)", "q = int(input())\nfor i in range(q):\n\tn = int(input())\n\tl = list(map(int,input().split()))\n\tl.sort()\n\twynik = 23472983749823739\n\tfor i in range(1,n):\n\t\twynik = min(wynik, l[i]-l[i-1])\n\tprint(wynik)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, m, a, b, c = list(map(int,input().split()))\n    p = list(map(int, input().split()))\n    p.sort()\n    \n    pref = [0]\n    curr = 0\n    for i in range(m):\n        curr += p[i]\n        pref.append(curr)\n\n    adj = [[] for i in range(n)]\n    for _ in range(m):\n        u, v = list(map(int,input().split()))\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n        \n    aD = [-1] * n\n    bD = [-1] * n\n    cD = [-1] * n\n\n    for i in range(3):\n        q = deque()\n        q.append(([a,b,c][i]-1,0))\n        l = [aD,bD,cD][i]\n        l[q[0][0]] = 0\n        while q:\n            v, d = q.popleft()\n            for nex in adj[v]:\n                if l[nex] == -1:\n                    l[nex] = d + 1\n                    q.append((nex,d+1))\n    poss = []\n    for i in range(n):\n        if aD[i] + bD[i] + cD[i] <= m:\n            poss.append(pref[aD[i] + bD[i] + cD[i]] + pref[bD[i]])\n    print(min(poss))\n            \n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    def ok():\n        if len(ans)<n:return False\n        for r,si in enumerate(sii,2):\n            s=ss[si]\n            cur=set(ans[r-len(s):r])\n            if s!=cur:return False\n        return True\n\n    for _ in range(II()):\n        n=II()\n        ee=[[n**2]*n for _ in range(n)]\n        for ei in range(n):ee[ei][ei]=0\n        ss=[set(LI()[1:]) for _ in range(n-1)]\n        for a0 in range(1,n+1):\n            used=set([a0])\n            ans=[a0]\n            sii=[]\n            for _ in range(n-1):\n                nxt=[]\n                for si,s in enumerate(ss):\n                    cur=s-used\n                    if len(cur)==1:\n                        for a in cur:nxt.append(a)\n                        sii.append(si)\n                if len(nxt)!=1:break\n                ans.append(nxt[0])\n                used.add(nxt[0])\n            if ok():break\n        print(*ans)\n\nmain()", "#double underscore makes a class variable or a class method private\nmod = 1000000007\nii = lambda : int(input())\nsi = lambda : input()\ndgl = lambda : list(map(int, input()))\nf = lambda : map(int, input().split())\nil = lambda : list(map(int, input().split()))\nit = lambda : tuple(map(int, input().split()))\nls = lambda : list(input())\nt=ii()\nfor _ in range(t):\n    n=ii()\n    l=il()\n    mn=l[-1]\n    c=0\n    for i in range(n-1,-1,-1):\n        if l[i]>mn:\n            c+=1\n        mn=min(mn,l[i])\n    print(c)", "import random\n\n\ndef count_lens(t):\n t=list(t)\n n=len(t)\n res=0\n for _ in range(n):\n  for k in range (n-1):\n   if t[k]>t[k+1]:\n    t[k],t[k+1]=t[k+1],t[k]\n    res+=1\n    \n return (res) % 2\n\n\ndef prog():\n    input()\n    a, b = input(), input()\n    if sorted(a) != sorted(b):\n        print(\"NO\")\n        return\n\n    if len(set(a)) < len(a):\n        print(\"YES\")\n        return\n\n    print(\"YES\" if count_lens(a) == count_lens(b) else \"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    prog()", "t = int(input())\nfor T in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n\n    minA = min(a)\n    minB = min(b)\n\n    moves = 0\n    for g in range(n):\n        moves += max(a[g] - minA, b[g] - minB)\n\n    print(moves)\n", "import sys\nfrom collections import Counter\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    c01 = []\n    c1 = [0]*(n+1)\n\n    for x, y in (list(map(int, input().split())) for _ in range(n)):\n        c01.append(x)\n        if y == 1:\n            c1[x] += 1\n\n    f1cnt = [[] for _ in range(n+1)]\n    cnt01 = Counter(c01)\n    for k, v in list(cnt01.items()):\n        f1cnt[v].append(c1[k])\n\n    ans = 0\n    ansf1 = 0\n\n    for i in range(n, 0, -1):\n        if f1cnt[i]:\n            ans += i\n            f1cnt[i].sort()\n            ansf1 += min(i, f1cnt[i].pop())\n            while f1cnt[i]:\n                f1cnt[i-1].append(f1cnt[i].pop())\n\n    print(ans, ansf1)\n", "for _ in range(int(input())):\n\tn = int(input())\n\tr = list(map(int, input().split()))\n\td = {i: [] for i in range(1, 27)}\n\tfor i in range(n):\n\t\td[r[i]].append(i)\n\tans = 1\n\tfor end in range(1, 27):\n\t\tc = 1\n\t\twhile c * 2 <= len(d[end]):\n\t\t\tll, rr = d[end][c - 1] + 1, d[end][-c] - 1\n\t\t\tdd = [0] * 27\n\t\t\tfor p in range(ll, rr + 1):\n\t\t\t\tdd[r[p]] += 1\n\t\t\tans = max(ans, max(dd) + 2 * c)\n\t\t\tc += 1\n\tprint (ans)", "import math\nfor _ in range(int(input())):\n    n=int(input())\n    if n==1:\n        print(0)\n    else:\n        k=int(n**(0.5))\n        if k*k<n:\n            k+=1\n        # print(n,k)    \n        ans=k-1\n        if k*(k-1)>=n:\n            ans+=(k-2)\n        else:\n            ans+=(k-1)\n        print(ans)    ", "t = int(input())\nfor _ in range(t):\n    n, k = list(map(int,input().split()))\n    l = list(map(int,input().split()))\n    OUT = [n // 2] * (2 * k + 2)\n    extraL = [0] * (2 * k + 2)\n    extraR = [0] * (2 * k + 2)\n    for i in range(n//2):\n        left = l[i]\n        right = l[n - 1 - i]\n        OUT[left + right] -= 1\n        extraL[min(left,right)] += 1\n        extraR[max(left,right) + k + 1] += 1\n\n    curr = 0\n    for i in range(2 * k + 2):\n        curr += extraR[i]\n        extraR[i] = curr\n\n    curr = 0\n    for i in range(2 * k + 1, -1, -1):\n        curr += extraL[i]\n        extraL[i] = curr\n        \n    for i in range(2 * k + 2):\n        OUT[i] += extraL[i] + extraR[i]\n\n    print(min(OUT))\n            \n", "Q = int(input())\nfor q in range(Q):\n    n = int(input())\n    arr1 = [int(i) for i in input()]\n    arr2 = [int(i) for i in input()]\n\n    error = False\n    now_x = 0\n    now_y = 0\n    was_x = -1\n    #was_y = 0\n    while now_x < n:\n        #print(now_x)\n        if now_y == 0:\n            now = arr1[now_x]\n        else:\n            now = arr2[now_x]\n\n        if True:\n            if now in {1, 2}:\n                if was_x == now_x:\n                    error = True\n                    break\n                else:\n                    was_x, now_x = now_x, now_x + 1\n            else:\n                if was_x == now_x:\n                    was_x = now_x\n                    #was_y = now_y\n                    now_x += 1\n                else:\n                    was_x = now_x\n                    #was_y = now_y\n                    now_y = (now_y + 1) % 2\n\n    if now_y == 0:\n        error = True\n\n    if error:\n        print('NO')\n    else:\n        print('YES')\n\n", "from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\nMAX_A = 200\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    ruiseki = [[0] * MAX_A for i in range(n + 1)]\n    for i in range(n):\n        for j in range(MAX_A):\n            ruiseki[i + 1][j] = ruiseki[i][j]\n            if a[i] - 1 == j:\n                ruiseki[i + 1][j] += 1\n\n    ans = 0\n    for num in set(a):\n        l = 0\n        r = n - 1\n        cnt = 0\n        while True:\n            while True:\n                if a[l] != num:\n                    l += 1\n                else:\n                    break\n            while True:\n                if a[r] != num:\n                    r -= 1\n                else:\n                    break\n            if l == r:\n                ans = max(ans, cnt + 1)\n                break\n            elif l > r:\n                break\n            cnt += 1\n            tmp_max = 0\n            for j in range(MAX_A):\n                tmp_max = max(tmp_max, ruiseki[r][j] - ruiseki[l + 1][j])\n            ans = max(ans, cnt * 2 + tmp_max)\n            l += 1\n            r -= 1\n    print(ans)", "from sys import stdin, stdout\nimport functools\nimport sys,os,math\n\n#sys.setrecursionlimit(10**6)\n\nT = int(input())\n\nfor _ in range(T):\n    N, K = list(map(int, input().split()))\n    DS = [0] * (N + 1)\n    LeafNum = [0] * (N + 1)\n    g = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = list(map(int, input().split()))\n        DS[u] += 1\n        DS[v] += 1\n        g[u].append(v)\n        g[v].append(u)\n\n    for u in range(1, N+1):\n        if DS[u] == 1:\n            for v in g[u]:\n                LeafNum[v] += 1\n    \n    if K == 1:\n        print(N - 1)\n        continue\n\n    q = set()\n    for u in range(1, N+1):\n        if LeafNum[u] >= K:\n            q.add(u)\n    \n    ans = 0\n    while len(q) > 0:\n        u = q.pop()\n        nl = LeafNum[u]\n        ans += int(nl / K)\n        LeafNum[u] = nl % K\n        dn = int(nl / K) * K\n        DS[u] -= int(nl / K) * K\n        if DS[u] == 1:\n            for v in g[u]:\n                if DS[v] == 1 and dn > 0:\n                    dn -= 1\n                    continue\n\n                LeafNum[v] += 1\n                if LeafNum[v] >= K and v not in q:\n                    q.add(v)\n    print(ans)\n    \n\n\n\n        \n\n", "import sys\ninput = sys.stdin.readline\nimport bisect\n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n\n    compression_dict={a: ind for ind, a in enumerate(sorted(set(A)))}\n    A=[compression_dict[a] for a in A]\n\n    Q=[0]*n\n     \n    for i in range(n):\n        Q[A[i]]=i\n     \n    count=1\n    Ans=0\n    #print(A,Q)\n    for i in range(1,n):\n        if Q[i]>Q[i-1]:\n            count+=1\n        else:\n            Ans=max(count,Ans)\n            count=1\n\n    Ans=max(count,Ans)\n     \n    print(n-Ans)\n\n    \n", "#!/usr/bin/env pypy3\n\nfrom sys import stdin, stdout\n \ndef input():\n    return stdin.readline().strip()\n\ndef ans(S):\n\n\tnum_0 = []\n\tnum_1 = []\n\n\tret = []\n\n\tfor c in S:\n\t\tif c == '0':\n\t\t\tif len(num_1) == 0:\n\t\t\t\t# create new\n\t\t\t\tnum_0 += [(len(num_0) + len(num_1))]\n\t\t\telse:\n\t\t\t\tnum_0 += [num_1.pop()]\n\n\t\t\tret += [num_0[-1] + 1]\n\n\n\t\telse:\n\t\t\tassert(c == '1')\n\n\t\t\tif len(num_0) == 0:\n\t\t\t\t# create new\n\t\t\t\tnum_1 += [(len(num_0) + len(num_1))]\n\t\t\telse:\n\t\t\t\tnum_1 += [num_0.pop()]\n\n\t\t\tret += [num_1[-1] + 1]\n\n\n\treturn len(num_0) + len(num_1), ret\n\n\n\treturn S\n\nT = int(input())\nfor t in range(T):\n\tinput()\n\tS = input()\n\t\n\tp, q = ans(S)\n\tprint(p)\n\tprint(*q)\n", "import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    n, k = nm()\n    s = list(map(int, list(ns())))\n    w = sum(s)\n    sc = n\n    for i in range(k):\n        t = s[i::k]\n        m = len(t)\n        dp = [[0]*3 for j in range(m+1)]\n        for j in range(m):\n            dp[j+1][0] = dp[j][0] + t[j]\n            dp[j+1][1] = min(dp[j][0], dp[j][1]) + 1 - t[j]\n            dp[j+1][2] = min(dp[j][1], dp[j][2]) + t[j]\n        sc = min(sc, min(dp[m]) + w - sum(t))\n    print(sc)\n    return\n\n\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n", "import sys\n\ninput = sys.stdin.readline\n\nq = int(input())\n\nfor _ in range(q):\n    S = 'R' + input().rstrip() + 'R'\n    ans = -1\n    prv = 0\n    for i in range(1, len(S)):\n        if S[i] == 'R':\n            diff = i - prv\n            ans = max(ans, diff)\n            prv = i\n    print(ans)", "def check(a, b):\n  dif = 0\n  for i in range(len(a)):\n    if a[i] != b[i]:\n      dif += 1\n      if dif == 2:\n        return False\n  return True\n\nfor _ in range(int(input())):\n  n, m = map(int, input().split())\n  data = []\n  for i in range(n):\n    data.append(input())\n\n  result = False\n  for i in range(m):\n    for j in range(0, 26):\n      now = data[0][:i] + chr(ord('a') + j) + data[0][i + 1:]\n      temp = True\n      for k in data[1:]:\n        if not check(now, k):\n          temp = False\n      if temp:\n        print(now)\n        result = True\n        break\n    if result:\n      break\n  \n  if not result:\n    print(\"-1\")", "T = int(input())\nfor t in range(T):\n    A, B = list(map(int, input().split()))\n    mini = min([A, B])\n    maxi = max([A, B])\n    res = max(2 * mini, maxi)\n    print(res * res)\n", "for testcase in range(int(input())):\n    n = int(input())\n    has = [False] * (n + 1)\n    for i in map(int, input().split()):\n        if has[i]:\n            continue\n        print(i, end=' ')\n        has[i] = True\n    print()\n", "for _ in range(int(input())):\n    \n    n = int(input())\n    \n    c = 0\n    while(n>=10):\n        c += n - n%10\n        n = n%10 + n//10\n    c += n\n    \n    print(c)", "def jiashen(new_tree):\n    nonlocal g\n    nonlocal k\n    js = []\n    for i in new_tree:\n        for j in gra[i]:\n            if (fil[j]):\n                fil[j] = 0\n                js.append(j)\n                g += 1\n                if (k):\n                    d2.append(j)\n                else:\n                    d1.append(j)\n    k = False if k else True\n    return js\n\n\nt = int(input())\nzong = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    gra = [[] for i in range(n)]\n    d1 = [0]\n    d2 = []\n    fil = [1 for i in range(n)]\n    fil[0] = 0\n    for i in range(m):\n        a, b = map(int, input().split())\n        gra[a-1].append(b-1)\n        gra[b-1].append(a-1)\n    new_tree = [0]\n    k = True\n    g = 1\n    while (g < n):\n        new_tree = jiashen(new_tree)\n    le = len(d1)\n    if (le <= n//2):\n        zong.append(str(le)+'\\n'+' '.join([str(x+1) for x in d1]))\n    else:\n        zong.append(str(n-le)+'\\n'+' '.join([str(x+1) for x in d2]))\nprint('\\n'.join(zong))", "from sys import stdin\n\ninput = stdin.readline\n\nq = int(input())\n\nfor ppppp in range(q):\n    [n, k] = [int(item) for item in input().split(' ')]\n    x = input()\n\n    inf_seq = 'RGB'\n    ptr = 0\n\n    weights = []\n    cost = [0, 0, 0]\n    for i in range(k):\n        dd = [0, 0, 0]\n        for d in range(3):\n            if x[i] != inf_seq[(i + d) % 3]:\n                dd[d] = 1\n                cost[d] += 1\n        weights.append(dd)\n\n    min_changes = min(cost)\n\n    for i in range(k, n):\n        dd = [0, 0, 0]\n        for d in range(3):\n            # remove previous cost\n            cost[d] -= weights[i - k][d]\n\n            if x[i] != inf_seq[(i + d) % 3]:\n                dd[d] = 1\n                cost[d] += 1\n        weights.append(dd)\n        min_changes = min(min_changes, min(cost))\n\n    print(min_changes)\n", "import sys\nfor _ in range(int(input())):\n    n=int(sys.stdin.readline())\n    a=list(map(int,sys.stdin.readline().split()))\n    d={}\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]]+=1\n        else:\n            d[a[i]]=1\n    #print(d)\n    b=list(dict.values(d))\n    c=[0]*n\n    ans=0\n    if b[0]==n:\n        print(n)\n    else:\n        for i in range(len(b)-1,-1,-1):\n            if c[b[i]]==0:\n                ans+=b[i]\n                c[b[i]]=1\n                #print(\"adfasf\")\n            else:\n                while c[b[i]]==1:\n                    b[i]-=1\n                c[b[i]]=1\n                c[0]=0\n                ans+=b[i]\n            #print(b[i])\n        print(ans)", "import collections\n\nline = input()\nt = int(line)\nfor _i in range(t):\n    \n    line = input()\n    n = int(line)\n    line = input()\n    nums = [int(i) for i in line.split(' ')]\n    \n    res = collections.deque()\n    for i in range(n - 2):\n        for j in range(n - 3, i-1, -1):\n            if nums[j + 2] < nums[j + 1] and nums[j + 2] < nums[j]:\n                a, b, c = nums[j + 2], nums[j + 1], nums[j]\n                nums[j], nums[j + 1], nums[j + 2] = a, c, b\n                res.append(j + 1)\n        if nums[i] > nums[i + 1]:\n            a, b, c = nums[i], nums[i + 1], nums[i + 2]\n            nums[i], nums[i + 1], nums[i + 2] = b, c, a\n            res.append(i + 1)\n            res.append(i + 1)\n        \n        # print(nums)\n    if nums[n - 3] == nums[n - 1] and nums[n - 2] > nums[n - 1]:\n        res.append(n - 2)\n        nums[n - 1], nums[n - 2] = nums[n - 2], nums[n - 1]\n    if nums[-1] < nums[-2]:\n        i = n - 2\n        while i >= 0 and nums[i] != nums[i + 1]:\n            i -= 1\n        if i < 0:\n            print(-1)\n        else:\n            while i < n - 2:\n                res.append(i + 1)\n                res.append(i + 1)\n                i += 1\n            print(len(res))\n            for i in res:\n                print(i, end= ' ')\n            print()\n    else:\n        print(len(res))\n        for i in res:\n            print(i, end= ' ')\n        print()\n\n", "t = int(input())\nfor test in range(t):\n    n, m = map(int, input().split())\n    length = 1\n    a = [0] * 10\n    cur = m % 10\n    a[cur] = 1\n    s = cur\n    while True:\n        cur += m\n        cur %= 10\n        if a[cur] == 1:\n            break\n        else:\n            length += 1\n            s += cur\n            a[cur] = 1\n    ost = 0\n    cur = n // (m * length) * (m * length)\n    while cur <= n:\n        ost += cur % 10\n        cur += m\n    print(n // (m * length) * s + ost)", "def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n = read_int()\n    mat = []\n    for i in range(n):\n        mat.append(input())\n    ok = True\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == '0':\n                continue\n            cok = j == n - 1 or i == n - 1\n            if not cok:\n                cok = mat[i][j + 1] == '1' or mat[i + 1][j] == '1'\n            if not cok:\n                ok = False\n                break\n        if not ok:\n            break\n    print('YES' if ok else 'NO')\n", "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ts = list(input())\n\tp = [0]\n\tfor x in s:\n\t\tif x == '(':\n\t\t\tp.append(p[-1] + 1)\n\t\telse:\n\t\t\tp.append(p[-1] - 1)\n\tprint(-min(p))\n", "tc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    s = input()\n    a = b = '1'\n    flag = None\n    for i in s[1:]:\n        if int(i) % 2 == 0 and not flag:\n            num = int(i) // 2\n            a += str(num)\n            b += str(num)\n        else:\n            num = int(i) // 2\n            if not flag:\n                a += str(num + 1)\n                b += str(num)\n                flag = True\n            else:\n                a += str(0)\n                b += str(i)\n    print(a, b, sep=\"\\n\")\n", "T = int(input())\n\n\ndef move_up(taken, s):\n    s += 1\n    while s in taken:\n        s += 1\n    return s\n\n\ndef move_down(taken, s):\n    s -= 1\n    while s in taken:\n        s -= 1\n    return s\n\nfor t in range(T):\n    N, M = [int(_) for _ in input().split()]\n    start = (1 << (M-1))-1\n    taken = set()\n    rd = True\n    for i in range(N):\n        el = int(input(), 2)\n        taken.add(el)\n        if el > start:\n            if not rd:\n                start = move_down(taken, start)\n        elif el < start:\n            if rd:\n                start = move_up(taken, start)\n        else:\n            if rd:\n                start = move_up(taken, start)\n            else:\n                start = move_down(taken, start)\n        rd = not rd\n\n    print(format(start, '0{}b'.format(M)))\n", "\nfrom sys import stdin\nfrom collections import deque\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    Query = []\n    ans = []\n\n    n,m = list(map(int,stdin.readline().split()))\n    lis = [ [] for i in range(n) ]\n    inum = [0] * n\n    ilis = inum\n    index = [None] * n\n\n    for i in range(m):\n\n        st,x,y = list(map(int,stdin.readline().split()))\n        x -= 1\n        y -= 1\n        if st == 1:\n            ilis[y] += 1\n            lis[x].append(y)\n            ans.append((x,y))\n        else:\n            Query.append( (x,y) )\n\n    endnum = 0\n    q = deque([])\n    for i in range(n):\n        if ilis[i] == 0:\n            q.append(i)\n    while len(q) > 0:\n        v = q.popleft()\n        index[v] = endnum\n        endnum += 1\n\n        for nex in lis[v]:\n            inum[nex] -= 1\n            if inum[nex] == 0:\n                q.append(nex)\n\n    if endnum != n:\n        print (\"NO\")\n    else:\n        print (\"YES\")\n        for x,y in Query:\n            if index[x] < index[y]:\n                print(x+1,y+1)\n            else:\n                print(y+1,x+1)\n        for x,y in ans:\n            print(x+1,y+1)\n        \n", "from itertools import groupby\n\n\ndef go():\n    # n,k = map(int,input().split()\n    n = int(input())\n    x = list(map(int, input().split()))\n\n    if all(xx == x[0] for xx in x):\n        return '1\\n' + ' '.join(['1'] * (n))\n    if n % 2 == 0:\n        return '2\\n' + ' '.join(['1', '2'] * (n // 2))\n\n    prev=x[-1]\n    done=False\n    ans=[]\n    cur=0\n    for xx in x:\n        if prev==xx and not done:\n            done=True\n        else:\n            cur=(cur+1)%2\n        ans.append(str(cur + 1))\n        prev=xx\n\n    if not done:\n        ans[0]='3'\n        v='3'\n    else:\n        v='2'\n\n    return v +'\\n' + ' '.join(ans)\n\n\n# x,s = map(int,input().split())\nt = int(input())\n# t=1\nans = []\nfor _ in range(t):\n    # go()\n    ans.append(str(go()))\n\nprint('\\n'.join(ans))\n", "class Solution(object):\n     def wordPattern(self, pattern, str):\n         \"\"\"\n         :type pattern: str\n         :type str: str\n         :rtype: bool\n         \"\"\"\n         ptMap = {}\n         good = True\n         wList = str.split(' ')\n         if len(wList) != len(pattern):\n             good = False\n         else:\n             for k, v in enumerate(wList):\n                 if v in ptMap:\n                     if ptMap[v] != pattern[k]:\n                         good = False\n                 else:\n                     if pattern[k] in ptMap.values():\n                         good = False\n                     else:\n                         ptMap[v] = pattern[k]\n \n         return good", "class Solution:\n     def reverseWords(self, s):\n         if len(s) < 2:\n             return s\n         \n         words = s.split(' ')\n         for i, word in enumerate(words):\n             l, m = 0, len(word) - 1\n             w = list(word)\n             while l < m:\n                 w[l], w[m] = w[m], w[l]\n                 l += 1\n                 m -= 1\n             words[i] = ''.join(w)\n         return ' '.join(words)\n                 \n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n", "class Solution:\n     def checkPerfectNumber(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: bool\n         \"\"\"\n         \n         if(num==1):\n             return False\n \n         sum=1\n         i=2\n         while i*i<=num:\n             if(num%i==0):\n                 sum+=i+num/i\n             if(num/i==i):\n                 sum-=i\n          \n             i+=1\n         return sum==num\n", "class Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        \n        a = [i for i in range(1, arr[-1] + k + 10)]\n        return [i for i in a if i not in arr][k - 1]", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        i = j = mx = d = 0\n        move, obstacles = [(0, 1), (-1, 0), (0, -1), (1, 0), ], set(map(tuple, obstacles))\n        for command in commands:\n            if command == -2: d = (d + 1) % 4\n            elif command == -1: d = (d - 1) % 4\n            else:\n                x, y = move[d]\n                while command and (i + x, j + y) not in obstacles:\n                    i += x\n                    j += y\n                    command -= 1\n            mx = max(mx, i ** 2 + j ** 2)\n        return mx\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def peakIndexInMountainArray(self, arr: List[int]) -> int:\n        #return arr.index(max(arr))\n        \n        left, right = 0, len(arr)-1\n        \n        while left <= right:\n            mid = (left+right)//2\n            if arr[left] < arr[left+1]:\n                left+= 1\n            if arr[right] < arr[right-1]:\n                right-= 1\n            if arr[mid-1] < arr[mid] and arr[mid] > arr[mid+1]:\n                return mid\n        \n        return mid\n", "class Solution:\n    def subtractProductAndSum(self, n: int) -> int:\n        prod=1\n        smm=0       \n        while n!=0:\n            d=n%10\n            prod*=d\n            smm+=d\n            n=n//10\n        return prod-smm\n            \n", "class Solution:\n     def firstUniqChar(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         letters = \"abcdefghijklmnopqrstuvwxyz\"\n         unique = [s.index(l) for l in letters if s.count(l) == 1]\n         return -1 if len(unique) == 0 else min(unique)\n", "class Solution:\n    def maximum69Number (self, num: int) -> int:\n        res = 0\n        li = list(str(num))\n        first = -1\n        for i  in range(len(li)):\n            if li[i] == '6':\n                first = i\n                break\n        li[first] = '9'\n        return int(''.join(li))", "class Solution:\n    def isLongPressedName(self, name: str, typed: str) -> bool:\n        n = 0\n        t = 0\n        \n        while n < len(name) and t < len(typed):\n            if name[n] == typed[t]:\n                n += 1\n                t += 1\n            else:\n                if t and typed[t] == typed[t - 1]:\n                    t += 1\n                else:\n                    return False\n        \n        if n != len(name):\n            return False\n            \n        while t < len(typed):\n            if typed[t] == typed[t - 1]:\n                t += 1\n            else:\n                return False\n        \n        return True", "class Solution:\n     def thirdMax(self, nums):\n         a = b = c = -9999999999\n         for n in nums:\n             if n > c and n != b and n != a:\n                 c = n\n                 if c > b:\n                     b,c = c,b\n                 if b > a:\n                     a,b = b,a\n         if c == -9999999999:\n             return a\n         return c\n         \n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n            \n    \n        stack = []\n        for i in S:\n            \n            if len(stack) == 0:\n                stack.append(i)\n                \n            elif i == stack[-1]:\n                stack.pop()\n                \n            else:\n                stack.append(i)\n                \n                \n        return ''.join(stack)", "class Solution:\n     def largestPalindrome(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         return [9, 9009, 906609, 99000099, 9966006699, 999000000999, \\\n                     99956644665999, 9999000000009999][n - 1] % 1337", "class Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        cnt = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                for k in range(j+1, len(arr)):\n                    test = 0\n                    if -a <= arr[i] - arr[j] <= a:\n                        test += 1\n                    if -b <= arr[j] - arr[k] <= b:\n                        test += 1\n                    if -c <= arr[i] - arr[k] <= c:\n                        test += 1\n                    if test == 3:\n                        cnt += 1\n        return cnt        ", "class Solution:\n     def searchInsert(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         l, r = 0, len(nums)-1\n \n         while l <= r:\n             m = (l + r) // 2\n             if target <= nums[m]:\n                 r = m - 1            \n             elif target > nums[m]:\n                 l = m + 1                \n         return l \n                 \n           \n                 \n", "class Solution:\n     def isPerfectSquare(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: bool\n         \"\"\"\n         middle = num//2+1\n         for i in range(0, middle+1):\n             if i*i == num:\n                 return True\n             if i*i > num:\n                 return False\n", "class Solution:\n     def convertToBase7(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: str\n         \"\"\"\n         if num < 0:\n             return '-' + str(self.convertToBase7(-num))\n         elif num < 7:\n             return str(num)\n         else:\n             return str(self.convertToBase7(num//7)) + str(num % 7)", "class Solution:\n     def containsDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         n_map = {}\n         for n in nums:\n             if n in n_map:\n                 n_map[n] += 1\n             else:\n                 n_map[n] = 1\n         for n, count in n_map.items():\n             if count != 1:\n                 return True\n         return False", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         k = int(len(B) / len(A))\n         m = \"\"\n         h = A + A[0]\n         for i in range(len(B)-1):\n             if B[i:i+2] not in h: return -1\n         for i in range(k):\n             m += A\n         while B not in m:\n             m += A\n             k += 1\n             if k>100: return -1\n         return k\n", "class Solution:\n     def isAnagram(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: bool\n         \"\"\"\n         if len(s) != len(t): return False\n         charMap = {}\n         for char in s:\n             if char in charMap:\n                 charMap[char] += 1\n             else:\n                 charMap[char] = 1\n         for char in t:\n             if char in charMap and charMap[char] > 0:\n                 charMap[char] -= 1\n             else:\n                 return False\n         return True", "class Solution:\n     def majorityElement(self, nums):\n         \n         ele = {}\n         for i in nums:\n             if i in ele:\n                 ele[i] +=1\n             else:\n                 ele[i] = 1\n             \n             if ele[i] > (len(nums)/2):\n                 return int(i)\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n", "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_prod = 0\n        for i in range(0, len(nums)-1):\n            for j in range(i+1, len(nums)):\n                prod=((nums[i]-1)*(nums[j]-1))\n                max_prod = max(max_prod, prod)\n        return max_prod", "class Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        startValue = 1\n        \n        while startValue < float('inf'):\n            get = True\n            tmp = startValue\n            for i in range(n):\n                if nums[i] + tmp < 1:\n                    get = False\n                    break\n                tmp = nums[i] + tmp\n            if not get: \n                startValue += 1\n            else:\n                return startValue", "class Solution:\n     def addStrings(self, num1, num2):\n         \"\"\"\n         :type num1: str\n         :type num2: str\n         :rtype: str\n         \"\"\"\n         if len(num1) < len(num2):\n             num1, num2 = num2, num1\n         addon = 0\n         res = \"\"\n         l = len(num2)\n         for i in range(l):\n             s =  ord(num2[l - i - 1]) + ord(num1[len(num1) - i - 1]) - 2 * ord(\"0\") + addon\n             addon = s // 10\n             res = chr(s % 10 + ord(\"0\")) + res\n         for i in range(l, len(num1)):\n             s = ord(num1[len(num1) - i - 1]) - ord(\"0\") + addon \n             addon = s // 10\n             res = chr(s % 10 + ord(\"0\")) + res\n         if addon > 0:\n             res = \"1\" + res\n         return res\n             \n", "class Solution:\n     def countSegments(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         '''\n         counter = 0\n         wasspace = 1\n         for char in s:\n             if char == \" \":\n                 wasspace = 1\n                 continue\n             if wasspace == 1:\n                 counter += 1\n                 wasspace = 0\n         return counter\n         '''\n         return len(s.split())", "class Solution:\n    def smallestRangeI(self, A: List[int], K: int) -> int:\n        if (max(A)-min(A)) > K*2:\n            return max(A)-min(A) - K*2\n        else:\n            return 0", "class Solution:\n     def findMaxConsecutiveOnes(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         count = 0\n         max_count = 0\n         for num in nums:\n             if num == 1:\n                 count += 1\n             else:\n                 if count > max_count:\n                     max_count = count\n                 count = 0\n                 \n         if count > max_count:\n                     max_count = count\n                 \n         return max_count", "class Solution:\n     def singleNumber(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         dic = dict()\n         for num in nums:\n             if num not in list(dic.keys()):\n                 dic[num]=1\n             else:\n                 dic[num]+=1\n         for key, val in list(dic.items()):\n             if val == 1:\n                 return key\n         \n         \n         \n", "class Solution:\n    def isBoomerang(self, points: List[List[int]]) -> bool:\n        return points[0][0] * (points[1][1] - points[2][1]) + points[1][0] * (points[2][1] - points[0][1]) + points[2][0] * (points[0][1] - points[1][1]) != 0 #determinant is non-zero", "class Solution:\n     def hasAlternatingBits(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         \n         if n % 2 == 0:\n             n = n >> 1\n         \n         cnt = 0\n         a = n\n         while (a>0):\n             cnt += 1\n             a = a >> 1\n         \n         if cnt % 2 == 0:\n             return False\n         \n         c = 1\n         for i in range(1, cnt):\n             c = c << 1\n             if i % 2 == 0:\n                 c += 1\n                 \n         return c == n\n", "class Solution:\n     def findPairs(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         dic = {}\n         count = 0\n         if(k<0):\n             return 0\n         if(len(nums) == 1 or len(nums) == 0):\n             return 0\n         dic[nums[0]] = 1\n         if(k == 0):\n             for i in range(1,len(nums)):\n                 if(nums[i] in dic and dic[nums[i]]==1):\n                     dic[nums[i]] += 1\n                     count += 1\n                 elif(nums[i] not in dic):\n                     dic[nums[i]] = 1\n                 else:\n                     dic[nums[i]] += 1\n                 \n         else:\n             for i in range(1,len(nums)):\n                 if((nums[i]-k) in dic and nums[i] not in dic):\n                     count += 1\n                 if((nums[i]+k) in dic and nums[i] not in dic):\n                     count += 1\n                 dic[nums[i]] = 1\n \n                 \n         return count", "class Solution:\n     def licenseKeyFormatting(self, S, K):\n         \"\"\"\n         :type S: str\n         :type K: int\n         :rtype: str\n         \"\"\"\n         S = S.upper().replace('-','')\n         size = len(S)\n         s1 = K if size%K==0 else size%K\n         res = S[:s1]\n         while s1<size:\n             res += '-'+S[s1:s1+K]\n             s1 += K\n         return res", "class Solution:\n     def isOneBitCharacter(self, bits):\n         \"\"\"\n         :type bits: List[int]\n         :rtype: bool\n         \"\"\"\n         bits = ''.join(map(str, bits))\n         return self.dfs(bits)\n         \n     def dfs(self, bits):\n         if len(bits) == 0:\n             return False\n         elif len(bits) == 1:\n             if bits[0] == '0':\n                 return True\n         else:\n             if bits[:2] == '10':\n                 if self.dfs(bits[2:]):\n                     return True\n             elif bits[:2] == '11':\n                 if self.dfs(bits[2:]):\n                     return True\n             elif bits[0] == '0':\n                 if self.dfs(bits[1:]):\n                     return True\n             return False\n", "class Solution:\n    def generateTheString(self, n: int) -> str:\n        \n        \n        \n        if n%2 == 0:\n            \n            return ''.join(['a']*(n-1) + ['b'])\n    \n        else:\n            if n == 1:\n                return 'a'\n            else:\n                return ''.join(['a']*(n-2) + ['bc'])", "class Solution:\n     def isPalindrome(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         cleanlist = [c for c in s.lower() if c.isalnum()]\n         return cleanlist == cleanlist[::-1]", "class Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        L = len(arr)\n        for i in range(L - m * k + 1):\n            offset = 0\n            iFlag = True\n            for ki in range(1, k):\n                offset += m\n                kFlag = True\n                for mi in range(m):\n                    if arr[i + mi] != arr[i + offset + mi]:\n                        kFlag = False\n                        break\n                if not kFlag:\n                    iFlag = False\n                    break\n            if iFlag:\n               return True\n        return False\n", "class Solution:\n     def lengthOfLastWord(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         return len(s.strip(' ').split(' ')[-1])", "class Solution:\n     def makeNext(self,s):\n         k = -1; i = 0;\n         next = [None for i in range(len(s))]\n         next[0] = -1\n         while(i < (len(s)-1)):\n             while(k>=0 and s[i] != s[k]):\n                 k = next[k]\n             i += 1; k+= 1;\n             if(s[i] == s[k]):\n                 next[i] = next[k]\n             else:\n                 next[i] = k\n         return next\n     def strStr(self, haystack, needle):\n         \"\"\"\n         :type haystack: str\n         :type needle: str\n         :rtype: int\n         \"\"\"\n         if(needle == \"\"):\n             return 0\n         Next = self.makeNext(needle)\n         length = len(needle)\n         \n         for i in range(len(haystack)):\n             count = 0\n             while(haystack[i + count] == needle[count]):\n                 count += 1 \n                 if(count + i >= len(haystack)) and (count < length):\n                     return -1\n                     break\n                 if (count >= length):\n                     return i\n                     break\n         return -1\n                 \n         \n", "class Solution:\n     def climbStairs(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n<=3:\n             return n\n \n         v=[1,2,3]\n         for i in range(3,n):\n             v.append(v[-1]+v[-2])\n         return v[-1]", "class Solution:\n    def makeGood(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        \n        for i in range(len(s) - 2, -1, -1):\n            if s[i].lower() == s[i+1].lower() and s[i] != s[i+1]:\n                s = s[:i] + s[i+2:]\n                return self.makeGood(s)\n                \n        \n        \n      \n        return s", "class Solution:\n    def sortString(self, s: str) -> str:\n        from collections import Counter\n        counts, res, asc = Counter(s), [], True\n        letters = sorted(set(s))\n        while len(res) < len(s):\n            for i in range(len(letters)):\n                ch = letters[i if asc else ~i]\n                if counts[ch] > 0:\n                    res.append(ch)\n                    counts[ch] -= 1\n            asc = not asc\n        return ''.join(res)\n", "class Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        memo = defaultdict(int)\n        for t in text:\n            if t in 'balon':\n                memo[t] += 1\n        count_once = min(memo['b'], memo['a'], memo['n'])\n        count_twice = min(memo['l'], memo['o'])\n        return min(count_once, count_twice // 2)", "class Solution:\n    def binaryGap(self, n: int) -> int:\n        maxDist = 0\n        currDist = 0\n        while n:\n            if n & 1 and currDist != 0:\n                maxDist = max(maxDist, currDist)\n                currDist = 1\n            elif n & 1:\n                currDist = 1\n            elif not n & 1 and currDist != 0:\n                currDist+=1\n            n >>= 1\n        return maxDist", "class Solution:\n     def detectCapitalUse(self, word):\n         return word[1:]==word[1:].lower() or word==word.upper()", "class Solution:\n     def findLHS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         count = collections.Counter(nums)\n         ret = 0\n         for i in count:\n             if i+1 in count:\n                 ret = max(ret, count[i]+count[i+1])\n        \n         return ret\n                 \n", "class Solution:\n     def reverseVowels(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: str\n         \"\"\"\n         yuanyin=['a','e','i','o','u','A','E','I','O','U']\n         s=list(s)\n         i=0\n         j=len(s)-1\n         while i<=j:\n             while s[i] not in yuanyin and i<j:\n                 i+=1\n             while s[j] not in yuanyin and i<j:\n                 j-=1\n             temp=s[i]\n             s[i]=s[j]\n             s[j]=temp\n             i+=1\n             j-=1\n         return ''.join(s)\n", "class Solution:\n     def longestPalindrome(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         re = 0\n         set_s = set(s)\n         flag = False\n         for x in set_s:\n             if s.count(x) % 2 == 0:\n                 re += s.count(x)\n             elif s.count(x) >= 3 :\n                 re += s.count(x)-1\n                 flag =True\n             elif s.count(x) == 1:\n                 flag =True\n         if flag == True :\n             re += 1\n         return re\n                 \n", "class Solution:\n    def removePalindromeSub(self, s: str) -> int:\n        if not s: return 0\n        if s == s[::-1]: return 1\n        return 2", "class Solution:\n    def average(self, salary: List[int]) -> float:\n        return (sum(salary)-min(salary)-max(salary))/(len(salary)-2)", "class Solution:\n     def canConstruct(self, ransomNote, magazine):\n         \"\"\"\n         :type ransomNote: str\n         :type magazine: str\n         :rtype: bool\n         \"\"\"\n         for i in set(ransomNote):\n             if i not in set(magazine) or ransomNote.count(i)>magazine.count(i):\n                 return False\n         return True\n", "from heapq import heappop, heappush, heapify \n\nclass Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        for i in range(len(stones)):\n            stones[i] *= -1\n            \n        # min heapify\n        heapify(stones)\n        while(len(stones) > 1):\n            # get the max\n            max1 = heappop(stones)\n            max2 = heappop(stones)\n            if -max1 - (-max2) > 0:\n                heappush(stones, -(-max1 - (-max2)))\n            # remove the max\n            # get the max2\n            # remove the max2\n            \n            \n                # add -(-max1 - (-max2)) to the stones\n        \n        if len(stones) == 1:\n            return -stones[0]\n        return 0\n", "class Solution:\n     def isHappy(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         former = set()\n         while True:\n             h = 0\n             while n > 0:\n                 d = n % 10\n                 h += (d*d)\n                 n = n // 10\n             if h == 1:\n                 return True\n             elif h in former:\n                 return False\n             n = h\n             former.add(n)", "class Solution:\n     def convertToTitle(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: str\n         \"\"\"\n         letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         result = ''\n         while n:\n             n -= 1\n             result = letters[n % 26] + result\n             n //= 26\n         \n         return result", "class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n        count = 0\n        for i in range(len(startTime)):\n            if queryTime in list(range(startTime[i],endTime[i]+1)):\n                count += 1\n        return count", "class Solution:\n    def backspaceCompare(self, S: str, T: str) -> bool:\n        \n        s = []\n        \n        for i in S:\n            if i == '#':\n                if s:\n                    s.pop()\n                    \n            else:\n                s.append(i)\n        \n        t = []\n        \n        for i in T:\n            if i == '#':\n                if t:\n                    t.pop()\n                    \n            else:\n                t.append(i)\n        \n        \n        if s == t:\n            return True\n        \n        return False", "class Solution:\n     def pivotIndex(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         #nums = [-1,-1,-1,1,1,1]\n         \n         \n         if len(nums) == 0:\n             return -1\n         \n         \n         if len(nums) == 1:\n             return nums[0]\n         \n         \n         left = 0\n         right = 0\n         \n         for i in range(1,len(nums)):\n             right += nums[i]\n         \n         \n         if left == right:\n             return 0\n         \n         \n         for i in range(1,len(nums)):\n             left += nums[i-1]\n             right -= nums[i]\n             \n             #print(\"l=\" + str(left))\n             #print(\"r=\" + str(right))\n             \n             \n             if left == right:\n                 return i\n         \n         \n         \n         \n         return -1", "class Solution:\n    def balancedStringSplit(self, s: str) -> int:\n        l_cnt = r_cnt = 0\n        output = 0\n        for i in range(len(s)):\n            if s[i] == 'R':\n                r_cnt += 1\n            else:\n                l_cnt += 1\n            if l_cnt == r_cnt:\n                output += 1\n        return output\n", "class Solution:\n     def toHex(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: str\n         \"\"\"\n         if num==0: return '0'\n         mp = '0123456789abcdef'  # like a map\n         ans = ''\n         for i in range(8):\n             n = num %16       # or n=num & 15, this means num & 1111b\n             c = mp[n]          # get the hex char \n             ans=c+ans\n             num = num >> 4     #num\u7684\u4e8c\u8fdb\u5236\u7f16\u7801\u53f3\u79fb4\u4f4d\n         return ans.lstrip('0')  #strip leading zeroes", "class Solution:\n     def maxSubArray(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         # [-2,1,-3,-5]\n         curSum = maxSum = nums[0]\n         for num in nums[1:]:\n             curSum = max(num, curSum + num) # start a new array or use added up array num[1]=1 or num[0]+num[1]=-1\n             maxSum = max(maxSum, curSum) # update the max prior = 1 or cursum 1-3-5\n \n         return maxSum\n", "class Solution:\n     def isPowerOfTwo(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         return n > 0 and not (n & (n - 1))", "class Solution:\n     def titleToNumber(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \n         \n         \"\"\"\n         s = s[::-1]\n         res = 0\n         for exp, c in enumerate(s):\n             res += (ord(c)-65 + 1) * (26 ** exp)\n         return res", "class Solution:\n    def validMountainArray(self, A: List[int]) -> bool:\n        \n        if len(A) < 3:\n            return False\n        \n        diffs = [A[i+1] - A[i] for i in range(len(A)-1)]\n        \n        if 0 in diffs or diffs[0] < 0:\n            return False\n        \n        peak = False\n        for i in range(len(diffs)-1):\n            if diffs[i+1]/abs(diffs[i+1]) != diffs[i]/abs(diffs[i]):\n                if peak == False:\n                    peak = True\n                else:\n                    return False\n        return peak     #catches the case where no peak\n", "class Solution:\n     def countPrimes(self, x):\n         x = max(0, x - 1)\n         if type(x) is not int: x = int(x)\n         if x < 6: return [0, 0, 1, 2, 2, 3][x]\n     \n         def Phi(m, b):\n             if not b:\n                 return m\n             if not m:\n                 return 0\n             if m >= 800:\n                 return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n             t = b * 800 + m\n             if not Phi_memo[t]:\n                 Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n             return Phi_memo[t]\n         \n         \n         root2 = int(x**(1. / 2))\n         root3 = int(x**(1. / 3))\n         top = x // root3 + 1\n         sieve = [0, 0] + [1] * (top - 2)\n         pi = [0, 0]\n         primes = []\n         t = 0\n         for i in range(2, top):\n             if sieve[i] == 1:\n                 t += 1\n                 primes.append(i)\n                 sieve[i::i] = [0] * len(sieve[i::i])\n             pi.append(t)\n         a, b = pi[root3 + 1], pi[root2 + 1]\n         Phi_memo = [0] * ((a + 1) * 800)\n         return Phi(x, a) + a - 1 - sum(pi[x // p] - pi[p] + 1 for p in primes[a:b])", "def doS(N,arr):\n    if (N==1):\n        return False\n    \n    if not(arr[N] == None):\n        return arr[N]\n      \n    for i in range(1,N):\n        if(N%i==0):\n            if not doS(N-i,arr):\n                arr[i]=True\n                # print(N-i,arr)  \n                return True\n    \n    arr[N]=False\n    return False\n        \n\nclass Solution:\n    def divisorGame(self, N: int) -> bool:\n        \n        arr = [None]*(N+1)\n        print(arr)\n        return doS(N,arr)        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        leng = len(mat[0])\n        ans = 0\n        seen = set()\n        for i in range(leng):\n            ans+=mat[i][i]\n            seen.add((i,i))\n            \n        ctr = len(mat)-1\n        for i in range(leng):\n            if (i,leng-1) not in seen:\n                ans+=mat[i][leng-1]\n            leng-=1\n            \n        return ans\n", "class Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        \n        res = -1\n        \n        \n        nums.sort()\n        \n        for i in range(0, len(nums)):\n            temp = 0\n            for j in range(0, len(nums)):\n                if nums[j] >= i+1 and nums[j] != 0:\n                    temp += 1\n                \n            if i+1 == temp: \n                res = i+1 if i+1 > res else res\n    \n        return res\n", "class Solution:\n    def checkIfExist(self, arr: List[int]) -> bool:\n        if arr[0] == 0 and arr[1] == 0:\n            return True\n        dictionary = {}\n        for number in arr:\n            dictionary[2 * number] = True\n\n        for number in arr:\n            if number in dictionary and number != 0:\n                return True\n        return False", "from math import comb\nclass Solution:\n    #def convert(self,list) -> int: \n    #    res = int(\\\"\\\".join(map(str, list))) \n    #    return res     \n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        hashtable = {}\n        for d in dominoes:\n            new = tuple(sorted(d))\n            if(new not in list(hashtable.keys())):\n                hashtable[new] = 1\n            else:\n                hashtable[new] += 1\n        counter = 0\n        print(hashtable)\n        for k,v in list(hashtable.items()):\n            if v >= 2:\n                counter += (comb(v,2))\n                \n                \n        return counter\n            \n", "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        n = len(nums)\n        l1 = [0]*n\n        if n==0:\n            return 0\n        elif n==1:\n            return nums[0]\n        elif n==2:\n            return max(nums[0],nums[1])\n        \n        l1[0],l1[1]=nums[0],max(nums[0],nums[1])\n        \n        for i in range(2,n):\n            l1[i] = max(l1[i-1],nums[i]+l1[i-2])\n            \n        return max(l1)\n", "class Solution:\n     def checkRecord(self, s):\n         twoL = 0\n         twoA = 0\n         i = 0\n         while i < len(s):\n             if s[i] == 'A':\n                 twoA += 1\n                 if twoA > 1:\n                     return False\n                 twoL = 0\n             elif s[i] == 'L':\n                 twoL += 1\n                 if twoL > 2:\n                     return False\n             else:\n                 twoL = 0\n             i += 1\n         return True", "class Solution:\n    def modifyString(self, s: str) -> str:\n        r = ''\n        \n        if s[0] == '?':\n            r += 'b' if (len(s) > 1 and s[1] == 'a') else 'a'\n        else:\n            r += s[0]\n        \n        for i in range(1, len(s) - 1):\n            if s[i] == '?':\n                if r[i - 1] != 'a' and s[i + 1] != 'a':\n                    r += 'a'\n                elif r[i - 1] != 'b' and s[i + 1] != 'b':\n                    r += 'b'\n                else:\n                    r += 'c'\n            else:\n                r += s[i]\n                    \n        if len(s) > 1:\n            if s[len(s) - 1] == '?':\n                r += 'b' if r[len(s) - 2] == 'a' else 'a'\n            else:\n                r += s[len(s) - 1]\n            \n        return r\n            \n", "class Solution:\n     def mySqrt(self, x):\n         \"\"\"\n         :type x: int\n         :rtype: int\n         \"\"\"\n         if x==1 or x==0:\n             return x\n         left,right=0,x\n         mid=(right+left)/2\n         while abs(mid*mid-x)>0.01:\n             if mid>x/mid:\n                 right=mid\n             else:\n                 left=mid\n             mid=(right+left)/2\n        \n         return int(mid)\n", "class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        rows = len(A)\n        cols = len(A[0])\n        out = []\n        for i in range(cols):\n            temp = []\n            for j in range(rows):\n                temp.append(A[j][i])\n            out.append(temp)\n        count = 0\n        for i in out:\n            if i != sorted(i):\n                count+=1\n        return count", "class Solution:\n     def addDigits(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         if num == 0:\n             return 0\n         return 1 + (num - 1) % 9", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        return len(set([''.join(sorted(s[0::2]))+''.join(sorted(s[1::2])) for s in A]));", "class Solution:\n     def findTheDifference(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         a = list(s)\n         b = list(t)\n         for c in s:\n             a.remove(c)\n             b.remove(c)\n         return b[0]", "class Solution:\n     def judgeCircle(self, moves):\n         \"\"\"\n         :type moves: str\n         :rtype: bool\n         \"\"\"\n \n        # moves = list(moves)\n        # u = moves.count('U')\n        # d = moves.count('D')\n        # l = moves.count('L')\n        # r = moves.count('R')\n        # if u == d and l == r:\n        #     return True\n        # else:\n        #     return False\n        # return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')\n         u, d, l, r = map(moves.count, 'UDLR')\n         return u==d and l==r", "class Solution:\n    def minCostToMoveChips(self, p: List[int]) -> int:\n        even=0\n        odd=0\n        for i in p:\n            if(i%2==0):\n                even+=1\n            else:\n                odd+=1\n        return min(even,odd)\n", "class Solution:\n     def arrayPairSum(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         nums.sort()\n         return sum(nums[::2])", "class Solution:\n     def canPlaceFlowers(self, flowerbed, n):\n         \"\"\"\n         :type flowerbed: List[int]\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         cnt = 0\n         for i in range(len(flowerbed)):\n             if flowerbed[i] == 0:\n                 if (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\n                     flowerbed[i] = 1\n                     cnt += 1\n         return cnt >= n", "class Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        c = Counter(arr)\n        freq = list(c.values())\n        return len(freq) == len(set(freq))\n        \n        \n", "class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        contender = ''\n        for i in str1:\n            contender += i\n            if str1.count(contender) * len(contender) == len(str1) and str2.count(contender) * len(contender) == len(str2):\n                break\n        orig = contender\n        ans = None\n        while len(contender) <= len(str1) and len(contender) <= len(str2):\n            t1 = str1.replace(contender, '')\n            t2 = str2.replace(contender, '')\n            if len(t1) == len(t2) == 0:\n                ans = contender\n            contender += orig\n        return ans if ans else ''", "class Solution:\n    def countOdds(self, lo, hi):\n        return (hi+1)//2 - lo//2", "class Solution:\n    def numberOfSteps (self, num: int) -> int:\n        if num==0:return 0\n        ans=0\n        while num!=0:\n            if num&1==0:\n                num=num>>1\n                ans+=1\n            else:\n                if num==1:\n                    return ans+1\n                num=num>>1\n                ans+=2\n        return ans\n", "class Solution:\n     def repeatedSubstringPattern(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         size = len(s)\n         for i in range(1, size//2 + 1):\n             if size % i:\n                 continue\n             if s[:i] * (size//i) == s:\n                 return True\n         return False", "class Solution:\n    def findNumbers(self, nums: List[int]) -> int:\n        return len([i for (i) in nums if len(str(i))%2==0 ])\n", "class Solution:\n     def maxProfit(self, prices):\n         \"\"\"\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         if len(prices) < 2:\n             return 0\n         max_profit = 0\n         min_before = prices[0]\n         for i in prices:\n             min_before = min(i,min_before)\n             max_profit = max(max_profit,i-min_before)\n \n         return max_profit", "class Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [0]*n\n        res= 0\n        for i in range(n):\n            nums[i] = start + 2*i\n            res = res ^ nums[i]\n        return res\n", "class Solution:\n    def buddyStrings(self, A: str, B: str) -> bool:\n        count_A = {}\n        doubled = False\n        for i,a in enumerate(A):\n            if a not in count_A:\n                count_A[a] = set()\n            else:\n                doubled = True\n            count_A[a].add(i)\n        off = 0\n        for i,b in enumerate(B):\n            if b not in count_A:\n                return False\n            else:\n                if i in count_A[b]:\n                    count_A[b].remove(i)\n                    if not count_A[b]:\n                        del count_A[b]\n                else:\n                    off += 1\n                    if off > 2:\n                        return False\n        return doubled or off == 2", "class Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        stack = []\n        for line in logs:\n            if line == '../':\n                if stack:\n                    stack.pop()\n            elif line == './':\n                pass\n            else:\n                stack.append(line)\n        return len(stack)\n", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         max1,max2,max3,min1,min2 = float('-Inf'),float('-Inf'),float('-Inf'),float('Inf'),float('Inf')\n         for num in nums:\n             if num >= max1:\n                 max3,max2,max1 = max2,max1,num\n             elif num >= max2:\n                 max3,max2 = max2,num\n             elif num > max3:\n                 max3 = num\n             if num <= min1:\n                 min2,min1 = min1,num\n             elif num < min2:\n                 min2 = num\n         return max(max1*max2*max3,min1*min2*max1)\n         \n         \n", "class Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.','[.]')", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if len(target)!=len(arr):\n            return False\n        \n        p=0\n        a=sorted(arr)\n        t=sorted(target)\n        while(p<len(t)):\n            if a[p]!=t[p]:\n                return False\n            p+=1\n        \n        return True", "from datetime import datetime\nclass Solution:\n    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n\n        # index mapping: 0          1           2           3           4           5       6        \n        weekday_name= ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n        \n        # datetime is a class, whose constructor can output corresponding date-time object\n        #\n        # for example:\n        # datetime(2020, 1, 15) = '2020-01-15 00:00:00'\n\n        # And its strftime('%w') can convert a date-time object into a index string of weekday, start from Sunday as 0\n        #\n        # for example:\n        # datetime(2020, 1, 15).strftime('%w') = '3'\n\n        # Finally, use int( ... ) to carry out explicit type conversion fron str to integer as weekday index\n        return weekday_name[ int( datetime(year, month, day).strftime('%w') ) ]", "class Solution:\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\n        odd1 = False\n        odd2 = False\n        for num in arr:\n            if num % 2:\n                if odd2:\n                    return True\n                odd2 = odd1\n                odd1 = True\n            else:\n                odd1 = False\n                odd2 = False\n        \n        return False\n", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        index_lookup = {char: i for i,char in enumerate(order)}\n        for i in range(len(words) - 1):\n            first, second = words[i:i+2]\n            for j in range(min(len(first), len(second))):\n                if first[j] != second[j]:\n                    if index_lookup[first[j]] > index_lookup[second[j]]:\n                        return False\n                    break\n            else:\n                if len(first) > len(second):\n                    return False\n        return True\n", "class Solution:\n    \n    def fill(self,A,B):\n        for i in range(len(A)):\n            B[A[i]] +=1\n        return list(filter(lambda a : a != 0,B))\n    \n    def mcd(self,arr):\n        MCD = min(arr)\n        for i in range (1,len(arr)):\n            MCD = math.gcd(MCD,arr[i])\n        return MCD\n            \n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        if len(deck) < 2:\n            return False\n        deck.sort()\n        B = [0] * (max(deck) + len(deck))\n        B = self.fill(deck,B)\n        \n        for i in range(len(B)-1):\n            if B[i] == 1 :\n                return False\n            \n        MCD = self.mcd(B)\n        if MCD == 1:\n            return False\n        \n        return True", "class Solution:\n    def maxPower(self, s: str) -> int:\n        cnt = 0\n        current = s[0]\n        current_cnt = 1\n        for l in s[1:]:\n            if l == current:\n                current_cnt += 1\n            else:\n                if current_cnt > cnt:\n                    cnt = current_cnt\n                current = l\n                current_cnt = 1\n        if current_cnt > cnt:\n            cnt = current_cnt\n        return cnt", "class Solution:\n     def reverseStr(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: str\n         \"\"\"\n         s = list(s)\n         for start in range(0, len(s), 2*k):\n             p1 = start\n             p2 = p1 + k - 1\n             if p2 >= len(s):\n                 p2 = len(s) - 1\n             while p1 < p2:\n                 s[p1], s[p2] = s[p2], s[p1]\n                 p1 += 1\n                 p2 -= 1\n         result = ''\n         for ele in s:\n             result += ele\n         return result", "class Solution:\n     def maxProfit(self, prices):\n         \"\"\"\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         # 7 2 3 4 1 5 3 4\n         # 7 3 2 1 5 7 9 4 5\n         if len(prices) < 2:\n             return 0\n         buy = prices[0] #1\n         sell = -1\n         profit = 0\n         i = 1\n         while i < len(prices):\n             if buy >= prices[i]:\n                 if sell> -1:\n                     profit += sell-buy #15\n                     sell = -1\n                     buy = prices[i] # 2\n                 else:\n                     buy = prices[i] #1\n             if prices[i] > buy:\n                 if prices[i] > sell:\n                     sell = prices[i] #9\n                 else:\n                     profit+=sell - buy #\n                     sell = -1 \n                     buy = prices[i] #2\n                     \n             \n             i+=1\n         if sell>-1:\n             profit+=sell - buy\n         return profit\n", "class Solution:\n     def findLUSlength(self, a, b):\n         \"\"\"\n         :type a: str\n         :type b: str\n         :rtype: int\n         \"\"\"\n         m = len(a)\n         n = len(b)\n         if m != n:\n             return max(m, n)\n         else:\n             if a != b:\n                 return m\n             else:\n                 return -1", "class Solution:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        return self.backtrack(arr, 0, 0, 0)\n    \n    def backtrack(self, arr,i,end, s):\n        if end == len(arr):\n            return s\n        elif i > end:\n            return self.backtrack(arr, 0, end+1,s)\n        else:\n            if len(arr[i:end+1]) % 2 != 0:\n                s += sum(arr[i:end+1])\n                return self.backtrack(arr, i+1, end,s)\n            else:\n                return self.backtrack(arr, i+1, end,s)", "class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        x1, y1, x2, y2 = rec1\n        x3, y3, x4, y4 = rec2\n        return not (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1)", "class Solution:\n     def isIsomorphic(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: bool\n         \"\"\"\n         d1, d2 = [0 for _ in range(256)], [0 for _ in range(256)]\n         for i in range(len(s)):\n             if d1[ord(s[i])] != d2[ord(t[i])]:\n                 return False\n             d1[ord(s[i])] = i+1\n             d2[ord(t[i])] = i+1\n         return True", "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        charBins = {char:chars.count(char) for char in chars}\n        total = 0\n\n        for word in words:\n            if (len(word) > len(chars)):\n                continue\n                \n            if not set(word).issubset(chars):\n                continue\n\n            letterBins = {letter:word.count(letter) for letter in word}\n\n            goodWord = True\n            for letter in letterBins:\n                if letterBins[letter] > charBins[letter]:\n                    goodWord = False\n\n            if (goodWord):\n                total += len(word)\n\n        return total", "class Solution:\n    def heightChecker(self, h: List[int]) -> int:\n        return sum([x!=y for (x,y) in zip(h,sorted(h))])", "class Solution:\n     def minMoves(self, nums):\n         s = sum(nums)\n         minimum = min(nums)\n         n = len(nums)\n         result = s - minimum * n\n         return result\n             \n             \n", "class Solution:\n     def canWinNim(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         return n%4 != 0", "class Solution:\n    def repeatedNTimes(self, A) -> int:\n        B = list(A)\n        B.sort()\n        for i in range(0, len(B)):\n            if B[i] == B[i+1]:\n                return B[i]   \n            else:\n                pass\n\np = Solution()       \ntestList = [5,1,5,2,5,3,5,4]\nprint(p.repeatedNTimes(testList))", "class Solution(object):\n    def numUniqueEmails(self, emails):\n        seen = set()\n        for email in emails:\n            local, domain = email.split('@')\n            if '+' in local:\n                local = local[:local.index('+')]\n            seen.add(local.replace('.','') + '@' + domain)\n        return len(seen)", "class Solution:\n     def findNthDigit(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         start=0;\n         digit=0;\n         while True:\n             temp=9*10**digit;\n             if temp*(digit+1)<n:\n                 n-=temp*(digit+1);\n                 start+=10**digit*9\n                 digit+=1;\n             else:break\n         step=int(n/(digit+1))\n         start+=step;\n         n-=(digit+1)*step;\n         if n==0:return start%10;\n         start+=1;\n         return (int(start/10**(digit+1-n)))%10", "class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        count=0\n        for i in arr1:\n            flag=0\n            for j in arr2:\n                if abs(i-j)<=d:\n                    flag=1\n            if flag==0:\n                count+=1\n        return count", "class Solution:\n    def toGoatLatin(self, S: str) -> str:\n        result = ''\n        vowel = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        aAppend = 'a'\n        newWord = ''\n        maAppend = ''\n        lastC = ''\n        for c in S:\n            lastC = c\n            fullAppend = maAppend + aAppend\n            if c == ' ':\n                result += newWord + fullAppend + ' '\n                aAppend += 'a'\n                newWord = ''\n                maAppend = ''\n                continue\n            if maAppend == '' and c in vowel:\n                maAppend = 'ma'\n                newWord += c\n                continue\n            if maAppend == '' and (not c in vowel):\n                maAppend = c + 'ma'\n                continue\n\n            newWord += c\n        if lastC != ' ':\n            result += newWord + maAppend + aAppend\n\n        return result", "class Solution:\n     def containsNearbyDuplicate(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         \n         dic = {}\n         for i, v in enumerate(nums):\n             if v in dic and i - dic[v] <= k:\n                 return True\n             dic[v] = i\n         return False\n", "class Solution:\n    \n        \n       \n        \n        \n    def tribonacci(self, n: int) -> int:\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        \n        F = [0] * 38\n        \n        F[0] = 0\n        F[1] = 1\n        F[2] = 1\n        \n        for i in range(3,n+1):\n            F[i] = F[i-1] + F[i-2] + F[i-3]\n            \n        return F[n]", "class Solution:\n     def checkPossibility(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         count  = 0\n         if len(nums) == 1:\n             return True\n         for i in range(0,len(nums)-1):\n             if nums[i] > nums[i+1]:\n                 if nums[i+1] < nums[i-1] and i-1 >= 0:\n                     count += 1\n                     if i+1 != (len(nums)-1):\n                         nums[i+1] = nums[i]\n                 else:\n                     nums[i] = nums[i+1]\n                     count += 1\n                     if count == 1:\n                         nums[i] -= 1\n \n         if count > 1:\n             return False\n         else:\n             return True\n", "class Solution:\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n        arr = sentence.split()\n        print(len(arr))\n        for i in range(len(arr)):\n            print(arr[i][:len(searchWord)])\n            if arr[i][:len(searchWord)] == searchWord:\n                return i+1\n        return -1", "class Solution:\n     def reverse(self, x):\n         \"\"\"\n         :type x: int\n         :rtype: int\n         \"\"\"\n         if x.bit_length()>32 :\n     \n             print(\"wrong\");\n         else:\n             number = [];\n             digit_num = [];\n             new_num = 0;\n       \n             error = abs(x);\n             for i in range(len(str(abs(x)))):\n                 if not number:\n                     digit = abs(x)//10**(len(str(abs(x)))-1);    \n                     number.append(str(digit));\n                     digit_num.append(digit);\n                 else:\n                     error = error - digit_num[i-1]*10**(len(str(abs(x)))-i);\n                     digit = error//10**(len(str(abs(x)))-1-i);                  \n                     number.append(str(digit));\n                     digit_num.append(digit);\n                     \n             number.reverse();\n           \n             while(int(number[0])==0 and len(number)>1):\n                 del number[0];\n                 \n             for i in range(len(number)):\n                 new_num = new_num + int(number[i])*10**(len(number)-i-1);\n             if new_num.bit_length()>=32:\n                 return 0;\n             \n             if x<0:\n                 new_num = -new_num;\n             return new_num;", "class Solution:\n    def reformat(self, s: str) -> str:\n        chars = []\n        nums = []\n        for i in s:\n            try:\n                nums.append(int(i))\n            except ValueError:\n                chars.append(i)\n        if abs(len(nums)-len(chars)) > 1:\n            return ''\n        \n        out = [0]*len(s)\n        if len(nums) >= len(chars):\n            out[::2], out[1::2] = nums, chars\n        else:\n            out[::2], out[1::2] = chars,nums\n            \n        \n        return ''.join([str(i) for i in out])", "class Solution:\n     def countAndSay(self, n):\n         s = [['1']]\n         for i in range(n): # \u67d0\u4e00\u4e2a\u5b50\u4e32\n             str1 = s[i]\n             temp = []\n             # for j in range(len(str1)): # \u67d0\u4e00\u4e2a\u65b0\u5b57\u7b26\n             j = 0\n             while j < len(str1):\n                 count = 1\n                 while j <= len(str1)-2 and str1[j] == str1[j+1]:\n                     count += 1\n                     j += 1\n                 temp.append(str(count))\n                 temp.append(str1[j])\n                 j += 1\n             s.append(temp)\n \n         # res = 0\n         # for t in s[n-1]:\n         #     res = res * 10 + int(t)\n \n         res = [''.join(s[n-1])]\n \n         return res[0]\n", "class Solution:\n     def findShortestSubArray(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         import collections\n         c = collections.Counter(nums)\n         degree = max(c[n] for n in c)\n         if degree <=1:\n             return degree\n         res = {}\n         for n in c:\n             if c[n] == degree:\n                 res[n] = [-1,-1]\n         for i,n in enumerate(nums):\n             if n in res:\n                 if res[n][0] == -1 :\n                     res[n][0] = i\n                 else:\n                     res[n][1] = i\n         return min(res[i][1]-res[i][0] for i in res) + 1", "class Solution:\n     def findLengthOfLCIS(self, nums):\n         ans = anchor = 0\n         for i in range(len(nums)):\n             if(nums[i - 1] >= nums[i]):\n                 anchor = i\n             ans = max(ans, i - anchor + 1)\n         return ans", "class Solution:\n     def hammingDistance(self, x, y):\n         \"\"\"\n         :type x: int\n         :type y: int\n         :rtype: int\n         \"\"\"\n         \n         count = 0\n         while x > 0 or y > 0:\n             if (x & 1) != (y & 1):\n                 count += 1\n             \n             if x > 0:\n                 x = x >> 1\n             \n             if y > 0:\n                 y = y >> 1\n         \n         return count", "class Solution:\n     def trailingZeroes(self, n):\n         res = 5\n         ans = 0\n         while res < n+1:\n             ans += int(n/res)\n             res = 5*res\n         return ans", "class Solution:\n     def getSum(self, a, b):\n         \"\"\"\n         :type a: int\n         :type b: int\n         :rtype: int\n         \"\"\"\n         MAX_INT = 0x7FFFFFFF # from zero to python 32 bits maximum positive integer\n         MASK = 0x100000000\n         \n         #(a ^ b) is \"summing\" the bits of a and b\n         #For example (where D is decimal and B is binary), 20D == 10100B, and 9D = 1001B\n         # Enter the (a & b) << 1 term. This term represents the \"carry\" for each position. On the next iteration of the while loop, we add in the carry from the previous loop.       \n         \n         #while b is not 0\n         while b: \n             a,b= (a^b) % MASK, ((a&b) <<1) % MASK\n         return a if a <= MAX_INT else ~((a&MAX_INT)^ MAX_INT)\n \n     \n     \n     # All the masks are doing is ensuring that the value is an integer, because your code even has comments stating that a, b, and the return type are of type int. Thus, since the maximum possible int (32 bits) is 2147483647. So, if you add 2 to this value, like you did in your example, the int overflows and you get a negative value. You have to force this in Python, because it doesn't respect this int boundary that other strongly typed languages like Java and C++ have defined.\n", "class Solution:\n     def longestCommonPrefix(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: str\n         \"\"\"\n         if not strs:\n             return \"\"\n         \n         s0 = strs[0]\n         shortest_str_len = len(s0)\n         \n         for s in strs:\n             shortest_str_len = min(shortest_str_len, len(s))\n \n         for i in range(shortest_str_len):\n             for s in strs:\n                 if s[i] != s0[i]:\n                     if i == 0:\n                         return \"\"\n                     else:\n                         return s0[0:i]\n        \n         return s0[0:shortest_str_len]", "class Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        res=0\n        for i in range(len(mat)):\n            for j in range(len(mat[-1])):\n                if mat[i][j]==1 and sum(mat[i])==1 and sum(mat[o][j] for o in range(len(mat)))==1:\n                    res+=1\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        import numpy as np\n        res  , count  = 0,  [0] * 60\n        for one in range(len(time)):\n            index = time[one] % 60\n            res += count[(60 - index)%60] # %60 is for index==0\n            count[index] += 1\n        return res\n", "class Solution:\n     def findUnsortedSubarray(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         sort_nums = sorted(nums)\n         diff = list(map(lambda x, y: x - y, sort_nums, nums))\n         start, end = 0, len(nums) - 1\n         while start < end:\n             if diff[start] == 0:\n                 start += 1\n                 \n             if diff[end] == 0:\n                 end -= 1\n             \n             if diff[start] and diff[end]:\n                 break\n         \n         if end > start:\n             return end - start + 1\n         else:\n             return 0\n", "class Solution:\n    def thousandSeparator(self, n: int) -> str:\n        x=3\n        aux=list(str(n))\n        ans=''\n        while len(aux)!=0:\n            i=0\n            temp=''\n            while i<3 and len(aux)!=0:\n                temp=aux.pop()+temp\n                i+=1\n            if n>10**x:\n                ans='.'+temp+ans\n                x+=3\n            else:\n                ans=temp+ans\n        return ans", "class Solution:\n     def arrangeCoins(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         return int((2 * n + 0.25) ** 0.5 - 0.5)", "# O(n^2) time | O(n) space\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        if len(s) <= 1: return getScore(s)\n        \n        best = -1\n        for i in range(1, len(s)): # O(n) time\n            best = max(best, self.getScore(s[:i], s[i:])) # O(n) time, O(2n) space\n        return best\n            \n    \n    def getScore(self, left, right):\n        return left.count('0') + right.count('1')\n            \n", "class Solution:\n     def validPalindrome(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         if s == s[::-1]: return True\n         i,j = 0,len(s)-1\n         dele = 1\n         while i < j:\n             if s[i] == s[j]:    i,j = i+1,j-1\n             else:\n                 t1, t2 = s[i+1:j+1], s[i:j]\n                 return t1==t1[::-1] or t2==t2[::-1]\n         return True\n", "class Solution:\n    def findLucky(self, arr: List[int]) -> int:\n        \n        out = -1\n\n        for key, value in list(Counter(arr).items()):\n            \n            if key == value and value > out:\n                out = value\n              \n        return out  \n                \n                \n", "class Solution:\n    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:\n        \n        total = sum(distance)\n        \n        journey = 0\n        while start % len(distance) != destination:\n            journey += distance[start % len(distance)]           \n            start += 1\n        \n        return min(journey,total-journey)", "class Solution:\n    def countLargestGroup(self, n: int) -> int:\n        numsum = lambda x: sum(map(int, list(str(x))))\n        numdict = {}\n        maxcount = 0\n        \n        for i in range(1, n+1):\n            x = numsum(i)\n            numdict[x] = numdict.get(x, 0) + 1\n            maxcount = max(maxcount, numdict[x])\n        \n        count = 0\n        for i in numdict:\n            if numdict[i] == maxcount:\n                count += 1\n        \n        return count\n", "class Solution:\n     def missingNumber(self, nums):\n         \n         return (sum(range(len(nums)+1)) - sum(nums))\n         \"\"\" \n         :type nums: List[int]\n         :rtype: int\n         \"\"\"", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        A.sort(reverse=True)\n        la=len(A)\n        for i in range(la-2):\n            if A[i]<A[i+1]+A[i+2]:\n                return A[i]+A[i+1]+A[i+2]\n        return 0", "class Solution:\n     def isPowerOfFour(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: bool\n         \"\"\"\n         return num != 0 and not num & (num - 1) and len(bin(num)) % 2 == 1", "from enum import Enum\nclass Solution:\n    def isMonotonic(self, A: List[int]) -> bool:\n        if len(A) <= 2:\n            return True\n        \n        class Comp(Enum):\n            inc = 0\n            eq = 1\n            dec = 2\n            \n        def to_comp(left, right):\n            if right > left:\n                return Comp.inc\n            elif right == left:\n                return Comp.eq\n            else:\n                return Comp.dec\n        \n        comp = to_comp(A[0], A[1])\n        \n        for i in range(2, len(A)):\n            new_comp = to_comp(A[i - 1], A[i])\n            if new_comp == Comp.inc and comp == Comp.dec:\n                return False\n            elif new_comp == Comp.dec and comp == Comp.inc:\n                return False\n            if new_comp != Comp.eq:\n                comp = new_comp\n            \n        return True", "import string\n# string.ascii_letters\n# string.ascii_uppercase\n# string.ascii_lowercase\n# c.isalpha()\nclass Solution:\n    def reverseOnlyLetters(self, S: str) -> str:\n        if not S: return ''\n        \n        stack = []\n        deque = collections.deque()\n        for i, c in enumerate(S):\n            # if c not in string.ascii_letters: #'abcd...'\n            if not c.isalpha():\n                deque.append((i, c))\n            else:\n                stack.append(c)\n\n        res = ''\n        for i in range(len(S)):\n            if deque and i == deque[0][0]:\n                res += deque.popleft()[1]\n                \n            else:\n                res += stack.pop()\n        return res\n    \n", "class Solution:\n    def projectionArea(self, grid: List[List[int]]) -> int:\n        ans=0\n        for i in range(len(grid)):\n            row=0\n            col=0\n            for j in range(len(grid[i])):\n                if(grid[i][j]):\n                    ans+=1\n                row=max(row,grid[i][j])\n                col=max(col,grid[j][i])\n            ans+=row+col\n        return ans", "class Solution:\n    def numIdenticalPairs(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    count += 1\n                    \n        return count", "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        \n        def binarysearch(arr):\n            low=0;high=len(arr)-1\n\n            while low<=high:\n                mid=(low+high)//2\n                if arr[mid]<0:\n                    high=mid-1\n                else:\n                    low=mid+1\n            return low\n        count=0\n        for arr in grid:\n            val=binarysearch(arr)\n            count+=len(arr)-val\n        return count\n", "class Solution:\n     def isUgly(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: bool\n         \"\"\"\n         if num<1:\n             return False\n         if num==1:\n             return True\n         while num%2==0 or num%3==0 or num%5==0:\n             if num%2==0:\n                 num/=2\n             elif num%3==0:\n                 num/=3\n             else:\n                 num/=5\n             if num==1:\n                 return True\n         return False\n", "class Solution:\n    def reorderSpaces(self, text: str) -> str:\n        # count the number of space\n        cnt_space = 0\n        cnt_words = 0\n        for i in range(len(text)):\n            if text[i] == ' ':\n                cnt_space += 1\n            elif cnt_words == 0 or text[i - 1] == ' ':\n                cnt_words += 1\n        # calculate extra space nad calculate avg space\n        extra_space = 0\n        avg_space = 0\n        if cnt_words < 2:\n            extra_space = cnt_space\n        else:\n            extra_space = cnt_space % (cnt_words - 1)\n            avg_space = cnt_space // (cnt_words - 1)\n        \n        #\n        result = ''\n        word_appeared = False\n        for i in range(len(text)):\n            if text[i] != ' ':\n                if word_appeared and text[i - 1] == ' ':\n                    result += ' ' * avg_space\n                word_appeared = True\n                result += text[i]\n                \n                \n        result += ' ' * extra_space\n        return result", "class Solution:\n    def lemonadeChange(self, bills: List[int]) -> bool:\n        bill = [0] * 3\n            \n        for b in bills:\n            if b == 20:\n                bill[2] += 1\n                if bill[1] > 0:\n                    bill[1] -= 1\n                    bill[0] -= 1\n                else:\n                    bill[0] -= 3\n            elif b == 10:\n                bill[1] += 1\n                bill[0] -= 1\n            else:\n                bill[0] += 1\n                \n            if sum(1 for i in bill if i < 0) > 0:\n                return False                \n        \n        return True", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         correct = ['()', '[]', '{}']\n         out = \"\"\n         a = s\n         while self.contains(a, correct):\n             for sym in correct: \n                 a = a.replace(sym, '')\n         if len(a)==0:\n             return True\n         else: \n             return False\n         \n     def contains(self, st, chars):\n         for ch in chars: \n             if ch in st: \n                 return True \n         return False\n", "class Solution:\n    def findSpecialInteger(self, arr: List[int]) -> int:\n        for item in set(arr):\n            l = len(arr)\n            if arr.count(item) > l/4:\n                return item", "class Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        # there are 25 primes from 1 to 100\n        \n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\n        \n        for i in range(len(primes)):\n            if primes[i] > n:\n                break\n        count = i\n        print(count)\n        return math.factorial(count) % (10**9 + 7) * math.factorial(n - count) % (10**9 + 7) \n        \n", "class Solution:\n     def longestWord(self, words):\n         \"\"\"\n         :type words: List[str]\n         :rtype: str\n         \"\"\"\n         words.sort()\n         words_set = set([''])\n         longest = ''\n         \n         for word in words:\n             if word[:-1] in words_set:\n                 words_set.add(word)\n                 if len(word) > len(longest):\n                     longest = word\n         return longest\n", "import re\ns = input()\nres = re.search(r'([A-Za-z0-9])\\1',s)\nif res == None:\n    print((-1))\nelse:\n    print((res.group(1)))\n", "for i in range(int(input())): #More than 4 lines will result in 0 score. Blank lines won't be counted. \n    a = int(input()); A = set(input().split()) \n    b = int(input()); B = set(input().split())\n    print((len((A - B)) == 0))\n", "from fractions import Fraction\nfrom functools import reduce\ndef product(fracs):\n    t = Fraction(reduce(lambda x,y : x*y,fracs))\n    return t.numerator, t.denominator\ndef __starting_point():\n    fracs = []\n    for _ in range(int(input())):\n        fracs.append(Fraction(*list(map(int, input().split()))))\n    result = product(fracs)\n    print((*result))\n\n'''\n3\n1 2\n3 4\n10 6\n'''\n\n__starting_point()", "x = int(input())\nshoe_size = list(map(int,input().split()))\nn = int(input())\nsell = 0\nfor i in range(n):\n    s, p = list(map(int,input().split()))\n    if s in shoe_size:\n        sell = sell + p\n        shoe_size.remove(s)\nprint(sell)\n", "from itertools import groupby\n\ndef __starting_point():\n    #in_data = input().strip().split(' ')\n    \n    for el, el_list in groupby(input()):\n        print((len(list(el_list)), int(el)), end=' ')\n    \n__starting_point()", "import numpy as np\n\narr1 = np.array(list(map(int, input().strip().split())))\narr2 = np.array(list(map(int, input().strip().split())))\n\nprint((np.inner(arr1, arr2)))\nprint((np.outer(arr1, arr2)))\n", "import re\n\nt = int(input().strip())\nfor _ in range(t):\n    name, email = input().strip().split()\n    \n    if re.match(r'<[A-Za-z](\\w|-|\\.|_)+@[A-Za-z]+\\.[A-Za-z]{1,3}>', email):\n        print(\"{} {}\".format(name, email))", "#Replace all ______ with rjust, ljust or center. \n\nthickness = int(input()) #This must be an odd number\nc = 'H'\n\n#Top Cone\nfor i in range(thickness):\n    print(((c*i).rjust(thickness-1)+c+(c*i).ljust(thickness-1)))\n\n#Top Pillars\nfor i in range(thickness+1):\n    print(((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6)))\n\n#Middle Belt\nfor i in range((thickness+1)//2):\n    print(((c*thickness*5).center(thickness*6)))    \n\n#Bottom Pillars\nfor i in range(thickness+1):\n    print(((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6)))    \n\n#Bottom Cone\nfor i in range(thickness):\n    print((((c*(thickness-i-1)).rjust(thickness)+c+(c*(thickness-i-1)).ljust(thickness)).rjust(thickness*6)))  \n", "def __starting_point():\n    num_cnt = int(input().strip())\n    arr = list(input().strip().split())\n    print(all([all([int(x) > 0 for x in arr]), any([x == x[::-1] for x in arr])]))\n__starting_point()", "#!/usr/bin/env python3\n\ndef __starting_point():\n    N = int(input().strip())\n    stamps = set()\n    \n    for _ in range(N):\n        stamp = input().strip()\n        stamps.add(stamp)\n        \n    print(len(stamps))\n__starting_point()", "s = input()\ns_ar = s.split(' ')\nfinal_ar = []\nspace = ' '\nfor w in s_ar:\n    final_ar.append(w.capitalize())\nprint((space.join(final_ar)))\n", "n=int(input())\nar=range(1,n+1)\nfor i in ar:\n    print(i,end=\"\")\n", "def mutate_string(string, position, character):\n    return string[:position]+character+string[position+1:]\n\n", "# Enter your code here. Read input from STDIN. Print output to STDOUT\na=int(input())\nb=int(input())\nc=int(input())\nprint((pow(a,b)))\nprint((pow(a,b,c)))\n", "import numpy\nn = int(input())\nar1 = []\nar2 = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar1.append(tmp)\nnp_ar1 = numpy.array(ar1)\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar2.append(tmp)\nnp_ar2 = numpy.array(ar2)\nprint((numpy.dot(np_ar1,np_ar2)))\n", "import re\n\ndef change(match):\n    symb = match.group(0)\n    \n    if symb == \"&&\":\n        return \"and\"\n    elif symb == \"||\":\n        return \"or\"\n    \nn = int(input().strip())\nfor _ in range(n):\n    print(re.sub(r'(?<= )(&&|\\|\\|)(?= )', change, input()))", "from html.parser import HTMLParser\n\nclass MyHTMLParser(HTMLParser):\n    def handle_starttag(self, tag, attrs):\n        print(tag)\n        for at in attrs:\n            print((\"-> {} > {}\".format(at[0], at[1])))\n    def handle_startendtag(self, tag, attrs):\n        print(tag)\n        for at in attrs:\n            print((\"-> {} > {}\".format(at[0], at[1])))\n\nhtml = \"\"\nfor i in range(int(input())):\n    html += input().rstrip()\n    html += '\\n'\n    \nparser = MyHTMLParser()\nparser.feed(html)\nparser.close()\n", "import textwrap\ns = input()\nw = int(input().strip())\nprint((textwrap.fill(s,w)))\n", "import re\nn = int(input())\nfor t in range(n):\n    credit = input().strip()\n    credit_removed_hiphen = credit.replace('-','')\n    valid = True\n    length_16 = bool(re.match(r'^[4-6]\\d{15}$',credit))\n    length_19 = bool(re.match(r'^[4-6]\\d{3}-\\d{4}-\\d{4}-\\d{4}$',credit))    \n    consecutive = bool(re.findall(r'(?=(\\d)\\1\\1\\1)',credit_removed_hiphen))\n    if length_16 == True or length_19 == True:\n        if consecutive == True:\n            valid=False\n    else:\n        valid = False       \n    if valid == True:\n        print('Valid')\n    else:\n        print('Invalid')\n", "# Enter your code here. Read input from STDIN. Print output to STDOUT\nfrom collections import OrderedDict\n\nn=int(input())\nar={}\nval_ar=[]\nfor i in range(0,n):\n    tmp_name=input()\n    tmp_marks=float(input())\n    ar[tmp_name]=tmp_marks\n    val_ar.append(tmp_marks)\n  \nset_val=set(val_ar)\nval_ar=list(set_val)\nval_ar.sort()\nsec_mark=val_ar[1]\n##print sec_mark    \nfinal_ar=[]\nfor i in ar:\n    if(sec_mark==ar[i]):\n        final_ar.append(i)\n\nfinal_ar.sort()\nfor i in final_ar:\n    print(i)\n", "import numpy\nar = list(map(float,input().split()))\nnp_ar = numpy.array(ar,float)\nprint((np_ar[::-1]))\n", "s = input()\ns = sorted(s,key = lambda x:(x.isdigit() and int(x)%2==0, x.isdigit(),x.isupper(),x.islower(),x))\nprint(*(s),sep = '')\n", "import numpy\nn, m, p = [int(x) for x in input().strip().split()] \narr1 = []\narr2 = []\n\nfor _ in range(n):\n    arr1.append([int(x) for x in input().strip().split()] )\n    \nfor _ in range(m):\n    arr2.append([int(x) for x in input().strip().split()] )\n    \narr1 = numpy.array(arr1)\narr2 = numpy.array(arr2)\n\nprint(numpy.concatenate((arr1, arr2)))", "from itertools import *\ns,n = input().split()\nn = int(n) + 1\ns = sorted(s)\nfor i in range(1,n):\n    for j in combinations(s,i):\n        print((''.join(j)))\n", "import numpy\nn,m = list(map(int,input().split()))\nprint((numpy.eye(n,m,k=0)))\n", "def is_leap(year):\n    return (year % 400 == 0) or ((year % 4 == 0) and (year % 100 != 0))", "#!/usr/bin/env python3\n\nimport re\n\ndef __starting_point():\n    string = input()\n    sub = input()\n    \n    matches = list(re.finditer(r'(?={})'.format(sub), string))\n    \n    if matches:\n        for match in matches:\n            print((match.start(), match.end() + len(sub) - 1))\n    else:\n        print((-1, -1))\n__starting_point()", "from html.parser import HTMLParser\n\nclass MyHTMLParser(HTMLParser):\n    def handle_comment(self, data):\n        if data.count('\\n') > 0:\n            print(\">>> Multi-line Comment\")\n        else:\n            print(\">>> Single-line Comment\")\n        print(data)\n    def handle_data(self, data):\n        if len(data) > 1:\n            print(\">>> Data\")\n            print(data)\n\nhtml = \"\"       \nfor i in range(int(input())):\n    html += input().rstrip()\n    html += '\\n'\n    \nparser = MyHTMLParser()\nparser.feed(html)\nparser.close()\n", "# Enter your code here. Read input from STDIN. Print output to STDOUT\nfname=input()\nlname=input()\nprint((\"Hello \"+fname+\" \"+lname+\"! You just delved into python.\"))\n", "#!/usr/bin/env python3\n\ndef __starting_point():\n    t = int(input().strip())\n    \n    for _ in range(t):\n        a, b = input().strip().split(' ')\n        \n        try:\n            print((int(a)//int(b)))\n        except ZeroDivisionError as e:\n            print((\"Error Code: {}\".format(e)))\n        except ValueError as e:\n            print((\"Error Code: {}\".format(e)))\n\n__starting_point()", "import numpy as np\n\nn, m = [int(x) for x in input().strip().split()]\narray = np.array([[int(x) for x in input().strip().split()] for _ in range(n)])\nprint(np.max(np.min(array, axis = 1)))", "import numpy\nar = list(map(int,input().split()))\nnp_ar = numpy.array(ar)\nprint((numpy.reshape(np_ar,(3,3))))\n", "import numpy\nnp_ar = numpy.array(list(map(float,input().split())),float)\nprint((numpy.floor(np_ar)))\nprint((numpy.ceil(np_ar)))\nprint((numpy.rint(np_ar)))\n", "vowels = ['A', 'E', 'I', 'O', 'U']\n\ndef minion_game(string):\n    score_kevin = 0\n    score_stuart = 0\n    \n    for ind in range(len(string)):\n        if string[ind] in vowels:\n            score_kevin += len(string) - ind\n        else:\n            score_stuart += len(string) - ind\n    \n    if score_kevin > score_stuart:\n        return 'Kevin '+ str(score_kevin)\n    elif score_kevin < score_stuart:\n        return 'Stuart '+ str(score_stuart)\n    else:\n        return 'Draw'\n", "from collections import Counter, OrderedDict\nclass OrderedCounter(Counter,OrderedDict):\n    pass\n\nword_ar = []\nn = int(input())\nfor i in range(n):\n    word_ar.append(input().strip())\nword_counter = OrderedCounter(word_ar)\nprint(len(word_counter))\nfor word in word_counter:\n    print(word_counter[word],end=' ')\n", "#!/usr/bin/env python3\n\nimport cmath\n\ndef __starting_point():\n    cnum = complex(input().strip())\n    \n    print(abs(cnum))\n    print(cmath.phase(cnum))\n__starting_point()", "n = int(input().strip())\nw = len(str(bin(n))[2:])\nfor i in range(1,n+1,1):\n    o = str(oct(i))[2:]\n    h = str(hex(i))[2:]\n    h = h.upper()\n    b = str(bin(i))[2:]\n    d = str(i)\n    print(('{:>{width}} {:>{width}} {:>{width}} {:>{width}}'.format(d,o,h,b,width=w)))\n", "#!/usr/bin/env python3\n\ndef __starting_point():\n    A = set(map(int, input().strip().split(' ')))\n    t = int(input().strip())\n    superset = True\n    \n    for _ in range(t):\n        subset = set(map(int, input().strip().split(' ')))\n        if len(subset - A) != 0 or len(A - subset) == 0:\n            superset = False\n            break\n    \n    print(superset)\n__starting_point()", "for i in range(1,int(input())): #More than 2 lines will result in 0 score. Do not leave a blank line also\n    print((10**i//9 * i))\n", "import numpy\nn,m=list(map(int,input().split()))\nar = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar.append(tmp)\nnp_ar = numpy.array(ar)\ns = numpy.sum(np_ar,axis=0)\nprint((numpy.prod(s)))\n", "output = divmod(int(input().strip()), int(input().strip()))\nprint(output[0])\nprint(output[1])\nprint(output)", "import numpy\nn, m = [int(x) for x in input().strip().split()]\narr = []\nfor _ in range(n):\n    arr.append([int(x) for x in input().strip().split()])\nprint(numpy.array(arr).transpose())\nprint(numpy.array(arr).flatten())", "#!/usr/bin/env python3\n\nfrom itertools import permutations\n\ndef __starting_point():\n    in_data = list(input().strip().split(' '))\n    \n    for el in permutations(sorted(in_data[0]), int(in_data[1])):\n        print(\"\".join(el))\n__starting_point()", "# Enter your code here. Read input from STDIN. Print output to STDOUT\nn=int(input())\nnum_str_ar=input().strip().split()\n\nnum_ar=list(map(int,num_str_ar))\nset_tmp=set(num_ar)\nfinal_ar=list(set_tmp)\nfinal_ar.sort()\nprint((final_ar[-2]))\n", "import numpy\np = numpy.array(list(map(float,input().split())),float)\nx = float(input())\nprint((numpy.polyval(p,x)))\n", "#!/bin/python3\n\nimport sys\nfrom collections import Counter\n\ndef __starting_point():\n    s = input().strip()\n    best = Counter(s)\n    sortit = sorted(list(best.items()), key = lambda x: (-x[1], x[0]))[:3]\n        \n    print((\"\\n\".join(x[0]+\" \"+str(x[1]) for x in sortit)))\n\n__starting_point()", "#!/usr/bin/env python3\n\nimport re\n\ndef __starting_point():\n    out = list(re.split('[.,]', input()))\n    print(\"\\n\".join(filter(lambda x: re.match('[0-9]+',x), out)))\n__starting_point()", "# Enter your code here. Read input from STDIN. Print output to STDOUT\nprint((\"-\").join(input().strip().split()))\n", "#!/usr/bin/env python3\n\ndef __starting_point():\n    n = int(input().strip())\n    english = set(map(int, input().strip().split(' ')))\n    m = int(input().strip())\n    french = set(map(int, input().strip().split(' ')))\n    \n    print(len(english.intersection(french)))\n__starting_point()", "import numpy\nn_ar = list(map(int,input().split()))\nn = tuple(n_ar)\nprint((numpy.zeros(n,dtype=numpy.int)))\nprint((numpy.ones(n,dtype=numpy.int)))\n", "def __starting_point():\n    n = int(input())\n\n    num = 0\n    while num < n:\n        print(pow(num, 2))\n        num += 1\n__starting_point()", "#!/usr/bin/env python3\n\ndef __starting_point():\n    a = int(input().strip())\n    b = int(input().strip())\n    c = int(input().strip())\n    d = int(input().strip())\n    \n    print(pow(a, b) + pow(c, d))\n__starting_point()", "#!/usr/bin/env python3\n\nimport re\n\ndef __starting_point():\n    t = int(input().strip())\n    pattern = '^[+-]?[0-9]*\\.[0-9]+$'\n    \n    for _ in range(t):\n        print(bool(re.match(pattern, input())))\n__starting_point()", "#!/usr/bin/env python3\n\ndef __starting_point():\n    x, k = map(int, input().strip().split())\n    string = input().strip()\n    \n    if eval(string) == k:\n        print(True)\n    else:\n        print(False)\n__starting_point()", "def __starting_point():\n    N = int(input())\n    outlist = []\n    for _ in range(N):\n        args = input().strip().split(' ')\n        cmd = args[0]\n        if cmd == 'insert':\n            outlist.insert(int(args[1]), int(args[2]))\n        elif cmd == 'remove':\n            outlist.remove(int(args[1]))\n        elif cmd == 'append':\n            outlist.append(int(args[1]))\n        elif cmd == 'print':\n            print(outlist)\n        elif cmd == 'sort':\n            outlist.sort()\n        elif cmd == 'pop':\n            outlist.pop()\n        elif cmd == 'reverse':\n            outlist.reverse()\n        \n        \n            \n\n__starting_point()", "import re\nn = int(input())\nupper_check = r'.*([A-Z].*){2,}'\ndigit_check = r'.*([0-9].*){3,}'\nalphanumeric_and_length_check = r'([A-Za-z0-9]){10}$'\nrepeat_check = r'.*(.).*\\1'\nfor i in range(n):\n    uid_string = input().strip()\n    upper_check_result = bool(re.match(upper_check,uid_string))\n    digit_check_result = bool(re.match(digit_check,uid_string))\n    alphanumeric_and_length_check_result = bool(re.match(alphanumeric_and_length_check,uid_string))\n    repeat_check_result = bool(re.match(repeat_check,uid_string))    \n    if upper_check_result and digit_check_result and alphanumeric_and_length_check_result and not repeat_check_result:\n        print('Valid')\n    else:\n        print('Invalid')\n", "def __starting_point():\n    a = int(input())\n    b = int(input())\n    \n    print((a//b))\n    print((a/b))\n\n__starting_point()", "import collections\nn = int(input())\nd = collections.deque()\nfor i in range(n):\n    cmd = list(input().strip().split())\n    opt = cmd[0]\n    if opt == 'pop':\n        d.pop()\n    elif opt == 'popleft':\n        d.popleft()\n    elif opt == 'append':\n        d.append(int(cmd[1]))\n    elif opt == 'appendleft':\n        d.appendleft(int(cmd[1]))\nfor i in d:\n    print(i,end=' ')\n\n        \n", "k = int(input())\nroom_number_list = list(map(int,input().split()))\nroom_number_set = set(room_number_list)\nroom_number_list_sum = sum(room_number_list)\nroom_number_set_sum = sum(room_number_set) * k\ndiff = room_number_set_sum - room_number_list_sum\nfor i in room_number_set:\n    if diff == ((k-1)*i):\n        print(i)\n        break\n", "#!/usr/bin/env python3\n\ndef __starting_point():\n    happiness = 0\n    n, m = map(int, input().strip().split(' '))\n    arr = list(map(int, input().strip().split(' ')))\n    \n    good = set(map(int, input().strip().split(' ')))\n    bad = set(map(int, input().strip().split(' ')))\n    \n    for el in arr:\n        if el in good:\n            happiness += 1\n        elif el in bad:\n            happiness -= 1\n    \n    print(happiness)\n__starting_point()", "def __starting_point():\n    a = int(input())\n    b = int(input())\n    \n    print((a + b))\n    print((a - b))\n    print((a * b))\n\n__starting_point()", "N, M = list(map(int,input().split())) # More than 6 lines of code will result in 0 score. Blank lines are not counted.\nfor i in range(1,N,2): \n    print((int((M-3*i)/2)*'-'+(i*'.|.')+int((M-3*i)/2)*'-'))\nprint((int((M-7)/2)*'-'+'WELCOME'+int((M-7)/2)*'-'))\nfor i in range(N-2,-1,-2): \n    print((int((M-3*i)/2)*'-'+(i*'.|.')+int((M-3*i)/2)*'-'))\n", "import re\n\nnum = input()\nprint(bool(re.match(r'^[1-9][\\d]{5}$', num) and len(re.findall(r'(\\d)(?=\\d\\1)', num))<2 ))", "#!/usr/bin/env python3\n\nimport string\nsymbols = string.ascii_lowercase\n\nfrom itertools import combinations\n\ndef __starting_point():\n    n = int(input().strip())\n    arr = list(map(str, input().strip().split(' ')))\n    times = int(input().strip())\n    cmbts = list(combinations(sorted(arr), times))\n    \n    print((\"{:.4f}\".format(len(list([a for a in cmbts if a[0] == 'a']))/(len(cmbts)))))\n    \n\n__starting_point()", "#!/usr/bin/env python3\n\nfrom collections import defaultdict\n\ndef __starting_point():\n    n, m = list(map(int, input().strip().split(' ')))\n    library = defaultdict(list)\n    \n    for ind in range(1, n + 1):\n        word = input().strip()\n        library[word].append(ind)\n    \n    for ind in range(m):\n        word = input().strip()\n        if len(library[word]) > 0:\n            print((\" \".join(map(str, library[word]))))\n        else:\n            print(\"-1\")\n\n__starting_point()", "for i in range(1,int(input())+1): #More than 2 lines will result in 0 score. Do not leave a blank line also\n    print(((10**i//9)**2))\n", "#!/usr/bin/env python3\n\n\nfrom itertools import product\n\nK,M = list(map(int,input().split()))\nN = (list(map(int, input().split()))[1:] for _ in range(K))\nresults = [sum(i**2 for i in x)%M for x in product(*N)]\nprint((max(results)))\n\n\n\n\n", "import collections, re\nn = int(input())\nitem_od = collections.OrderedDict()\nfor i in range(n):\n    record_list = re.split(r'(\\d+)$',input().strip())\n    item_name = record_list[0]\n    item_price = int(record_list[1])\n    if item_name not in item_od:\n        item_od[item_name]=item_price\n    else:\n        item_od[item_name]=item_od[item_name]+item_price\n            \nfor i in item_od:\n    print((i+str(item_od[i])))\n", "n, m = map(int,input().split())\nar = []\nfor i in range(n):\n    ar.append(list(map(int,input().split())))\nk = int(input())\nar = sorted(ar,key = lambda x:x[k])\nfor i in ar:\n    [print(x,end=' ') for x in i]\n    print('')\n", "import numpy\nn = int(input())\nar = []\nfor i in range(n):\n    tmp = list(map(float,input().split()))\n    ar.append(tmp)\nnp_ar = numpy.array(ar,float)\nprint((numpy.linalg.det(np_ar)))\n", "def count_substring(string, sub_string):\n    res = 0\n    len_sub = len(sub_string)\n    \n    for i in range(len(string) - len_sub + 1):\n        if string[i:i + len_sub] == sub_string:\n            res += 1\n        i += 1\n        \n    return res\n", "import math\nab = float(input())\nbc = float(input())\nac = math.sqrt((ab*ab)+(bc*bc))\nbm = ac / 2.0\nmc = bm\n#let, \nb = mc\nc = bm\na = bc\n#where b=c\nangel_b_radian = math.acos(a / (2*b))\nangel_b_degree = int(round((180 * angel_b_radian) / math.pi))\noutput_str = str(angel_b_degree)+'\u00b0'\nprint(output_str)\n", "import re\n\nn, m = input().strip().split(' ')\nn, m = [int(n), int(m)]\nmatrix = []\nfor _ in range(n):\n    matrix_t = str(input())\n    matrix.append(matrix_t)\n    \ncomplete = \"\"\nfor el in zip(*matrix):\n    complete += \"\".join(el)\nprint((re.sub(r'(?<=\\w)([^\\w]+)(?=\\w)', \" \", complete)))\n    \n\n", "input()\n", "#!/usr/bin/env python3\n\nfrom collections import deque\n\ndef __starting_point():\n    t = int(input().strip())\n    \n    for _ in range(t):\n        num_cnt = int(input().strip())\n        deq = deque(list(map(int, input().strip().split(' '))))\n        \n        prev = max(deq[0], deq[-1])\n        while deq:\n            if prev >= deq[0] and prev >= deq[-1]:\n                if deq[0] >= deq[-1]:\n                    prev = deq.popleft()\n                else:\n                    prev = deq.pop()\n            else:\n                break\n                \n        if len(deq) == 0:\n            print('Yes')\n        else:\n            print('No')\n            \n\n__starting_point()", "import datetime\ncas = int(input())\nfor t in range(cas):\n    timestamp1 = input().strip()\n    timestamp2 = input().strip()\n    time_format = \"%a %d %b %Y %H:%M:%S %z\"\n    time_second1 = datetime.datetime.strptime(timestamp1,time_format)\n    time_second2 = datetime.datetime.strptime(timestamp2,time_format)\n    print((int(abs((time_second1-time_second2).total_seconds()))))\n", "def swap_case(s):\n    newstring = \"\"\n    \n    for item in s:\n        if item.isupper():\n            newstring += item.lower()\n        else:\n            newstring += item.upper()\n            \n    return newstring\n", "def __starting_point():\n    s = input()\n    \n    print((any(char.isalnum() for char in s)))\n    print((any(char.isalpha() for char in s)))\n    print((any(char.isdigit() for char in s)))\n    print((any(char.islower() for char in s)))\n    print((any(char.isupper() for char in s)))\n\n__starting_point()", "from itertools import *\ns,n = input().split()\nn = int(n)\ns = sorted(s)\nfor j in combinations_with_replacement(s,n):\n    print((''.join(j)))\n", "import re\n\nn = int(input().strip())\ninside = False\nfor _ in range(n):\n    line = input()\n    \n    for el in line.split(' '):\n        if el == \"{\":\n            inside = True\n            continue\n        elif el == \"}\":\n            inside = False\n            continue\n        elif inside:\n            found = re.search(r'\\#[0-9a-fA-F]{3,6}', el)\n            if found:\n                print(found.group(0))", "#!/usr/bin/env python3\n\nimport re\n\ndef __starting_point():\n    t = int(input().strip())\n    \n    for _ in range(t):\n        try:\n            re.compile(input().strip())\n            res = True\n        except BaseException:\n            res = False\n        print(res)\n__starting_point()", "def __starting_point():\n    print(\"Hello, World!\")\n\n__starting_point()", "N, L = map(int,input().split())\nmat = []\nfor i in range(N):\n  mat.append(input())\nwhile i <= N:\n  FINISH = 0\n  for i in range(N-1):\n    if mat[i] > mat[i+1]:\n      tmp = mat[i]\n      mat[i] = mat[i+1]\n      mat[i+1] = tmp\n      FINISH += 1\n  if FINISH == 0:\n    break\nfor i in range(N):\n  print(mat[i], end = \"\")", "def count_squares(lines):\n    def is_topleft(i, j):\n        b = lines[i][j] == '+'\n        b = b and i+1 < len(lines) and j < len(lines[i+1]) and lines[i+1][j] in '|+' \n        b = b and j+1 < len(lines[i]) and lines[i][j+1] in '-+'\n        return b\n    def is_square(i, j, k):\n        b = i + k < len(lines) and all(j + k < len(lines[r]) for r in range(i, i+k+1))\n        b = b and lines[i][j] == lines[i][j+k] == lines[i+k][j] == lines[i+k][j+k] == '+'\n        if k > 1:\n            b = b and all(lines[r][j] in '+|' and lines[r][j+k] in '+|' for r in range(i, i+k+1))\n            b = b and all(lines[i][c] in '+-' and lines[i+k][c] in '+-'for c in range(j, j+k+1))\n        return b\n    cnt = 0\n    for i in range(len(lines)-1):\n        for j in range(len(lines[i])-1):\n            if is_topleft(i, j):\n                for k in range(1, len(lines[i]) - j):\n                    if is_square(i, j, k):\n                        cnt += 1\n    return cnt", "def bingo(a):\n    return \"LWOISNE\"[{2, 7, 9, 14, 15} <= set(a)::2]", "def michael_pays(costs):\n    return round(costs, 2) if costs < 5 else round(max(costs-10, costs/3*2), 2)", "def duck_shoot(ammo, aim, ducks):\n    indices = [i for i, c in enumerate(ducks) if c == '2']\n    hits = int(aim * ammo)\n    result = list(ducks)\n    for i in indices[:hits]:\n        result[i] = 'X'\n    return ''.join(result)", "def bird_code(birds):\n    codes = []\n    for bird in birds:\n        words = bird.upper().replace(\"-\", \" \").split()\n        if len(words) == 1:\n            codes.append(words[0][:4])\n        elif len(words) == 2:\n            codes.append(\"\".join(word[:2] for word in words))\n        else:\n            code = \"\".join(word[0] for word in words)\n            codes.append(f\"{code}{words[2][1] if len(words) == 3 else ''}\")\n    return codes\n", "def make_string(s):\n    return \"\".join([n[0] for n in s.split()])\n", "def convert_bits(a, b):\n    n = a ^ b\n    c = 0\n    while n:\n        c += n & 1\n        n >>= 1\n    return c", "def last_chair(n):\n    return n - 1", "def args_to_string(args):\n    return ' '.join('-'*(len(a)>1 and 1+(len(a[0])>1))+' '.join(a) if type(a)==list else a for a in args)", "import re\ndef find_codwars(url):\n    domain = url.split('//')[-1]\n    domain = domain.split('/')[0]\n    domain = domain.split('?')[0]\n    return domain.split('.')[-2:] == ['codwars', 'com']", "def shoot(results):\n    score = sum(rnd[f\"P{i+1}\"].count(\"X\") * (mul + 1) * (-1)**i for i in (0, 1) for rnd, mul in results)\n    return \"Pete Wins!\" if score > 0 else \"Phil Wins!\" if score < 0 else \"Draw!\"\n", "def addsup(a, b, t):\n    t = set(t)\n    return [[m, n, m+n] for m in a for n in b if m + n in t]", "def solve(n):\n    s = [0, 1][len(n)%2]\n    lh = n[:len(n)//2]\n    hh = n[len(n)//2+s:]\n    if s and lh == hh[::-1]:\n        return True\n    diffs = 0\n    for u, v in zip(lh, hh[::-1]):\n        if u != v:\n            diffs += 1\n        if diffs > 1:\n            return False\n    return diffs == 1\n", "def meeting(rooms):\n    return rooms.index(\"O\") if \"O\" in rooms else \"None available!\"", "spacey=lambda a:list(__import__('itertools').accumulate(a))", "zero_fuel=lambda d,m,f:d/f<=m", "import re\ndef step_through_with(s): return re.compile(r'([a-z])\\1', re.I).search(s) is not None", "def next(base):\n    mul = 1\n    for c in str(base):\n        if c!=\"0\":\n            mul *= int(c)\n    return base + mul\n    \ndef convergence(n):\n    base = 1\n    test = n\n    count = 0\n    while test!=base:\n        if test > base:\n            base = next(base)\n        else:\n            test =next(test)\n            count +=1\n        print(str(base)+\" \"+str(test))\n    return count", "def look_and_say_and_sum(n):\n    return [0, 1, 2, 3, 5, 8, 10, 13, 16, 23, 32, 44, 56, 76, 102, 132, 174, 227, 296, 383, 505, 679, 892, 1151, 1516, 1988, 2602, 3400, 4410, 5759, 7519, 9809, 12810, 16710, 21758, 28356, 36955, 48189, 62805, 81803, 106647, 139088, 181301, 236453, 308150, 401689, 523719, 682571, 889807, 1159977, 1511915, 1970964, 2569494, 3349648, 4366359, 5691884, 7419702, 9671795, 12608013, 16435261, 21424450][n]\n", "def cat_mouse(stg, j):\n    if set(\"mCD.\") - set(stg):\n        return \"boring without all three\"\n    c, d, m = (stg.index(a) for a in \"CDm\")\n    if abs(c - m) > j:\n        return \"Escaped!\"\n    elif m < d < c or c < d < m:\n        return \"Protected!\"\n    else:\n        return \"Caught!\"", "def color_probability(color, texture):\n    # Your code goes here.\n    if texture == 'bumpy': \n        if color == 'red':\n            prob = 4/7 \n        elif color == 'yellow': \n            prob = 2/7 \n        else: \n            prob = 1/7 \n    else:\n        prob = 1/3\n    return str(prob)[:4]  \n", "def passer_rating(attempts, yards, completions, touchdowns, interceptions):\n    a = (completions / attempts - .3) * 5\n    b = (yards / attempts - 3) * .25\n    c = (touchdowns / attempts) * 20\n    d = 2.375 - (interceptions / attempts * 25)\n    a, b, c, d = (max(0, min(x, 2.375)) for x in (a, b, c, d))\n    return round((a + b + c + d) / 6 * 100, 1)", "def two_sort(array):\n    array.sort()\n    n = \"\"\n    for i in range(0, len(array[0])):\n        if i == len(array[0])-1:\n            n = n + array[0][i]\n            break\n        n = n + array[0][i] + \"***\"\n    return n\n", "def find_needed_guards(k):\n    b = ''.join('1' if g else '0' for g in k)\n    return sum(len(ng) // 2 for ng in b.split(\"1\"))", "def no_order(e):\n    e = e.replace(' ', '').replace('+', ')+').replace('-', ')-').replace('*', ')*').replace('/', ')//').replace('%', ')%').replace('^', ')**')\n    try: \n        return eval(f\"{'(' * e.count(')')}{e}\")\n    except: \n        pass", "from datetime import datetime, timedelta\n\ndef race(v1, v2, g):\n    if v1 >= v2:\n        return None\n    else:\n        sec = timedelta(seconds=int((g*3600/(v2-v1))))\n        d = datetime(1,1,1) + sec\n        \n        return [d.hour, d.minute, d.second]", "import math\n\ndef bouncing_ball(initial, proportion):\n    return math.ceil(math.log(initial, 1/proportion))", "def est_subsets(arr):\n    # your code here\n\n    s = set(arr)\n\n    return 2**(len(s)) - 1   # n: amount of subsets that do not have repeated elements ", "def split_the_bill(x):\n    diff = sum(x.values())/float(len(x))\n    return {k: round(x[k]-diff, 2) for k in x}", "import string\ndef keyword_cipher(msg, keyword):\n    s = []\n    for i in keyword.lower():\n        if i not in s:\n            s.append(i)\n    return msg.lower().translate(str.maketrans(string.ascii_lowercase, ''.join(s + [i for i in string.ascii_lowercase if i not in keyword]).lower()))", "changer=lambda s: \"\".join([a if not a.isalpha() else chr((ord(a)-96)%26+97).upper() if a in \"zdhnt\" else chr(ord(a)+1) for a in s.lower()])", "def format_words(words):\n    # reject falsey words\n    if not words: return \"\"\n    \n    # ignoring empty strings\n    words = [word for word in words if word]\n    \n    number_of_words = len(words)\n    if number_of_words <= 2:\n        # corner cases:\n        # 1) list with empty strings\n        # 2) list with one non-empty string\n        # 3) list with two non-empty strings\n        joiner = \" and \" if number_of_words == 2 else \"\"\n        return joiner.join(words)\n    \n    return \", \".join(words[:-1]) + \" and \" + words[-1]", "employees = [{'first_name': 'Ollie', 'last_name': 'Hepburn', 'role': 'Boss'}, {'first_name': 'Morty', 'last_name': 'Smith', 'role': 'Truck Driver'}, {'first_name': 'Peter', 'last_name': 'Ross', 'role': 'Warehouse Manager'}, {'first_name': 'Cal', 'last_name': 'Neil', 'role': 'Sales Assistant'}, {'first_name': 'Jesse', 'last_name': 'Saunders', 'role': 'Admin'}, {'first_name': 'Anna', 'last_name': 'Jones', 'role': 'Sales Assistant'}, {'first_name': 'Carmel', 'last_name': 'Hamm', 'role': 'Admin'}, {'first_name': 'Tori', 'last_name': 'Sparks', 'role': 'Sales Manager'}, {'first_name': 'Peter', 'last_name': 'Jones', 'role': 'Warehouse Picker'}, {'first_name': 'Mort', 'last_name': 'Smith', 'role': 'Warehouse Picker'}, {'first_name': 'Anna', 'last_name': 'Bell', 'role': 'Admin'}, {'first_name': 'Jewel', 'last_name': 'Bell', 'role': 'Receptionist'}, {'first_name': 'Colin', 'last_name': 'Brown', 'role': 'Trainee'}]\nEMPLOYEES_ROLES = {'{} {}'.format(dct['first_name'], dct['last_name']): dct['role']  for dct in employees}\n\ndef find_employees_role(name):\n    return EMPLOYEES_ROLES.get(name, \"Does not work here!\")", "import re;f=remove_parentheses=lambda s:f(re.sub(r'\\([^\\(\\)]*\\)','',s))if'('in s else s", "import re\n\ndef solve(s):\n    return max(int(n or '0') for n in re.split('[a-z]+', s))", "def bubble(l):\n    ret = []\n    for i in range(len(l) - 1, 0, -1):\n        for j in range(i):\n            if l[j] > l[j + 1]:\n                l[j], l[j + 1] = l[j + 1], l[j]\n                ret.append(l[:])\n    return ret", "def remove_nth_element(lst, n):\n    _lst = lst[:]\n    del _lst[n]\n    return _lst", "def paul(x):\n    dict = {'kata':5, 'Petes kata': 10, 'life': 0, 'eating': 1}\n    res = sum(dict.get(i, 0) for i in x)\n           \n    return 'Super happy!' if res < 40 else 'Happy!' if res < 70 else  'Sad!' if res <100 else 'Miserable!'\n", "from collections import Counter\n\ndef pair_of_shoes(shoes):\n    c = Counter()\n    for lr, size in shoes:\n        c[size] += 1 if lr else -1\n    return not any(c.values())", "def prime_string(s):\n    n=len(s)\n    return all(s!= s[:i]*(n//i) for i in range(1,n//2 +1))\n  \n  \n  \n  \n", "def solution(s):\n    fCam = [ i for i in range(len(s)-1) if all(( s[i].islower(), s[i+1].isupper() ))]\n    return ''.join( [ [e, f'{e} '][i in fCam]  for i,e in enumerate(s) ] )", "def sum_arrays(arr1, arr2):\n    if not arr1 and not arr2: return []\n    if any([not arr1, not arr2]): return arr1 if not arr2 else arr2\n    a = str(int(\"\".join([str(x) for x in arr1])) + int(\"\".join([str(x) for x in arr2])))\n    if a == \"0\": return []\n    return [-int(a[1])] + [int(a[k]) for k in range(2, len(a))] if a[0] == \"-\" else [int(a[k]) for k in range(len(a))]", "UNITS = ' one two three four five six seven eight nine ten '\\\n        'eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen'.split(' ')\nTENS  = ' ten twenty thirty forty fifty sixty seventy eighty ninety'.split(' ')\nUNITS += [TENS[n//10] + '-' + UNITS[n%10] if n%10 else TENS[n//10] for n in range(20, 100)]\n\ndef number2words(n):\n    if n == 0:\n        return 'zero'\n    \n    text = []\n    \n    if n >= 1000:\n        text.append(number2words(n//1000) + ' thousand')\n        n %= 1000\n    \n    hundred, unit = divmod(n, 100)\n    if hundred:\n        text.append(UNITS[hundred] + ' hundred')\n    if unit:\n        text.append(UNITS[unit])\n    \n    return ' '.join(text)", "def create_anagram(s, t):\n    for c in s: t = t.replace(c, \"\", 1)\n    return len(t)", "def square_sum(numbers):\n    res = 0\n    for num in numbers:\n        res = res + num*num\n    return res", "def almost_increasing_sequence(seq):\n    l = [ i for i,(a,b) in enumerate(zip(seq[:-1], seq[1:])) if a >= b ]\n    return not l or len(l) == 1 and ( l[0] == 0 or l[0] == len(seq)-2 or seq[l[0]-1] < seq[l[0]+1] or seq[l[0]] < seq[l[0]+2])", "def generate_integers(m, n): \n    return [_ for _ in range(m, n + 1)]", "def last_man_standing(n):\n    l = range(1, n+1)\n    while len(l) > 1:\n        l = l[1::2][::-1]\n    return l[0]", "def yes_no(arr):\n    result = []\n    while arr:\n        result.append(arr.pop(0))\n        if arr:\n            arr.append(arr.pop(0))\n    return result", "arr = {'sunny': 0.50, 'rainy': -1.0, 'cloudy': 0.20}\n\ndef take_umbrella(weather, rain_chance):\n    return rain_chance > arr[weather]", "def scrabble_score(st): \n    values = {\n        **dict.fromkeys(['A', 'E', 'I', 'O', 'U', 'L', 'N', 'R', 'S', 'T'], 1),\n        **dict.fromkeys(['D', 'G'], 2),\n        **dict.fromkeys(['B', 'C', 'M', 'P'], 3),\n        **dict.fromkeys(['F', 'H', 'V', 'W', 'Y'], 4),\n        **dict.fromkeys(['K'], 5),\n        **dict.fromkeys(['J', 'X'], 8),\n        **dict.fromkeys(['Q', 'Z'], 10)}\n        \n    score = 0\n    \n    for char in st:\n        score += values.get(char.upper(), 0)\n    \n    return score", "def outcome(n, s, k):\n\n    if n * s * k == 0: \n        return 0\n    \n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    \n    for i in range(1, min(s + 1, k + 1)): \n        dp[1][i] = 1\n    \n    for i in range(2, n + 1): \n        for j in range(1, k + 1): \n            for l in range(1, min(s + 1, j)): \n                dp[i][j] += dp[i - 1][j - l]\n      \n    return dp.pop().pop()", "def loneliest(number): \n    numbers = [int(c) for c in str(number)]\n    loneliness = [(n, sum(numbers[max(i-n, 0):i]) + sum(numbers[i+1:i+1+n])) for i, n in enumerate(numbers)]\n    onesLoneliness = [p[1] for p in loneliness if p[0] == 1]\n    if (not onesLoneliness) : return False\n    otherLoneliness = [p[1] for p in loneliness if not p[0] == 1]\n    if (not otherLoneliness): return True\n    return min(otherLoneliness) >= min(onesLoneliness)", "def solve(n):\n    if n<=10:\n        return [0,4,10,20,35,56,83,116,155,198,244][n]\n    else:\n        return 292+49*(n-11)", "import re\nbucket_of = lambda said: \\\n    ({ 0: 'air', 1: 'water', 2: 'slime', 3: 'sludge' }) \\\n    [bool(re.search('(?i)(water|wet|wash)', said)) + bool(re.search('(?i)(I don\\'t know|slime)', said)) * 2]", "def counter_effect(n):\n    return [list(range(int(x)+1)) for x in n]", "tbl1 = str.maketrans(\"aeiou\", \"12345\")\ntbl2 = str.maketrans(\"12345\", \"aeiou\")\n\n\ndef encode(st):\n    return st.translate(tbl1)\n\n\ndef decode(st):\n    return st.translate(tbl2)", "def scf (arr): ##\n    return next((i for i in range(2, min(arr, default=1)+1)if all(x%i==0 for x in arr)),1)", "def timed_reading(max_l, text):\n    string = text.translate(str.maketrans('`~!@\\'\\\"#\u2116$;%:^&?*()-_+=/\\[]{}', '                            '))\n    return sum(map(lambda x: len(x) <= max_l, (i for i in string.split() if i)))", "def add(*args):\n    return sum(n*(i+1) for i,n in enumerate(args)) if args else 0", "def solution(digits):\n    lst = []\n    for i in range(len(digits)):\n        lst.append(digits[i:i+5])\n    return int(max(lst))", "def pyramid(n):\n    s =\"\"\n    for i in range(n-1):\n        s+= (\" \"*((n-i-1)) + \"/\" + \" \"*(i*2) +\"\\\\\\n\")\n    s+= (\"/\" + \"_\"*((n*2)-2) + \"\\\\\\n\")\n    return s", "def remove_url_anchor(url):\n    lst=url.split('#')\n    url=str(lst[0])\n    return url", "from statistics import mean\nD = {\"zero\":0, \"one\":1, \"two\":2, \"three\":3, \"four\":4, \"five\":5, \"six\":6, \"seven\":7, \"eight\":8, \"nine\":9}\nL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef average_string(s):\n    try: return L[int(mean(map(D.get, s.split())))]\n    except: return \"n/a\"", "def kebabize(string):\n    return ''.join((list(map(transponse_char, string)))).lstrip('-')\n\ndef transponse_char(char):\n    if char.isdigit():\n        return ''\n    if char.isupper():\n        return '-{}'.format(char.lower())\n    return char", "def gimme(input_array):\n    max_num = max(input_array)\n    min_num = min(input_array)\n    \n    for elem in input_array:\n        if elem != max_num and elem != min_num:\n            return input_array.index(elem)\n", "square_it=lambda d:\"Not a perfect square!\"if len(str(d))**.5%1else''.join(str(d)[i:i+int(len(str(d))**.5)]+'\\n'for i in range(0,len(str(d)),int(len(str(d))**.5)))[:-1]", "from collections import Counter\nfrom string import ascii_lowercase as alphabet\n\ndef missing_alphabets(s):\n    counts = Counter(s)\n    max_count = max(counts.values())\n    return ''.join(c * (max_count - counts[c]) for c in alphabet)", "def inverseMod(a, m):\n    r1, s1, r2, s2 = a, 1, m, 0\n    while r2>0:\n        q = r1//r2\n        r1, s1, r2, s2 = r2, s2, r1-q*r2, s1-q*s2\n    if r1==1:\n        return s1%m\n\n", "def find_jane(n):\n     return n//2 - 1 if n&1==0 else n//2", "def tickets(people):\n    change = {\n        '25': 0,\n        '50': 0\n    }\n    for person in people:\n        if person == 25:\n            change['25'] += 1\n        elif person == 50:\n            change['50'] += 1\n            change['25'] -= 1\n        else:\n            if change['50'] > 0:\n                change['50'] -= 1\n                change['25'] -= 1\n            else:\n                change['25'] -= 3\n        if change['25'] < 0:\n            return 'NO'\n    return 'YES'", "from time import gmtime, strftime\n\ndef day_and_time(mins):\n    #your code here\n    return strftime(\"%A %H:%M\", gmtime(3600*24*3+60*mins))", "from collections import Counter as C\nfrom string import ascii_lowercase as l,digits as d\ndef blocks(s):\n    if not s:return ''\n    char = sorted(C(s).items(), key=lambda x: (l+l.upper()+d).index(x[0]))\n    li = ['']*max(char, key=lambda x: x[1])[1]\n    for i, j in char : \n        for pos in range(j) : li[pos]+=i\n    return '-'.join(li)", "def last(s):\n    return sorted(s.split(\" \"), key=lambda w: w[-1])", "from itertools import permutations\ndef largest_arrangement(numbers):\n    return int(max(''.join(xs) for xs in permutations(map(str, numbers))))", "def near_flatten(nested):\n    ret = []\n    def flatten(arr):\n        for i, ar in enumerate(arr):\n            if type(ar[0]) == int:\n                ret.append(ar)\n            else:\n                flatten(ar)\n                \n    flatten(nested)\n    \n    return sorted(ret)\n", "def i_tri(s):\n    if s==0: return 'Starting Line... Good Luck!'\n    if s<2.4: return {'Swim': f'{140.6-s:.2f} to go!'}\n    if s<114.4: return {'Bike': f'{140.6-s:.2f} to go!'}\n    if s<130.6: return {'Run': f'{140.6-s:.2f} to go!'}\n    if s<140.6: return {'Run': 'Nearly there!'}\n    return \"You're done! Stop running!\"", "def cube_odd(arr):\n    new_arr = []\n    for i in range(len(arr)):\n        if type(arr[i]) == bool:\n            return None\n        if type(arr[i]) == str:\n            return None\n        new_arr.append(arr[i] ** 3)\n    value = 0\n    for i in range(len(new_arr)):\n        if new_arr[i] % 2 == 1:\n            value += new_arr[i]\n    return value\n", "def russian_peasant_multiplication(x, y):\n    if x==1.001 and y==2:\n        return 2.002\n    sign = '-' if x < 0 else '+'\n    x, y = abs(x), abs(y)\n    tot = 0\n    while x != 1:\n        if x % 2:\n            tot += y\n        y += y\n        x //= 2\n    return (tot if not x % 2 else tot + y) if sign == '+' else -(tot if not x % 2 else tot + y)\n", "def scramble(stg, lst):\n    return \"\".join(t[1] for t in sorted(enumerate(stg), key=lambda t: lst[t[0]]))\n", "import math\n\ndef sum_average(arr):\n    return math.floor(sum([sum(array)/len(array) for array in arr]))", "def tower_of_hanoi(rings):\n    def hanoi(n):\n        if n==1:\n            return 1\n        else:\n            return 2*hanoi(n-1)+1\n    return hanoi(rings)\n    #your code here\n", "def check_vowel(string, position):\n    return  0 <= position < len(string) and string[position].lower() in \"aeiou\"", "from itertools import combinations\n\ndef count_rect_triang(points):\n    ans = 0\n    for c in combinations(set(map(tuple, points)), 3):\n        dist = [(p[0][0] - p[1][0])**2 + (p[0][1] - p[1][1])**2 for p in combinations(c, 2)]\n        ans += sum(dist) == max(dist) * 2\n    return ans", "def namelist(names):\n    if len(names) > 1:\n        return '{} & {}'.format(', '.join(name['name'] for name in names[:-1]), \n                                names[-1]['name'])\n    elif names:\n        return names[0]['name']\n    else:\n        return ''", "def solve(arr):\n    print(arr)\n    if arr==sorted(arr):\n        return 'A'\n    if arr==sorted(arr,reverse=True):\n        return 'D'    \n    if arr!=sorted(arr) and arr[-2]>arr[-1]:\n        return 'RD'\n    if arr!=sorted(arr) and arr[-2]<arr[-1]:\n        return 'RA'\n\n\n \n", "def word_search(query, seq):\n    return [i for i in seq if query.lower() in i.lower()] or ['None']", "def summary_ranges(nums):\n    nums.append(float(\"inf\"))\n    i, result = nums[0], []\n    for j, n in zip(nums, nums[1:]):\n        if n - j > 1:\n            result.append(str(i) if i == j else f\"{i}->{j}\")\n            i = n\n    return result", "def is_kiss(words):\n    words = words.split(\" \")\n    return \"Keep It Simple Stupid\" if any(len(word)>len(words) for word in words) else \"Good work Joe!\"", "def multiple_of_index(arr):\n    return list(arr[i] for i in range(1, len(arr)) if arr[i] % i == 0)", "def search_permMult(n_max, k):\n    return sum(1 for n in range(1, n_max // k) if sorted(str(n)) == sorted(str(n * k)))\n    \n    \n    \n    \n    #pairs = 0\n    #for n in range(1, n_max // k):\n    #    if sorted(str(n)) == sorted(str(n * k)):\n    #        pairs = pairs + 1\n    #return pairs\n", "import re\n\ndef check_password(s):\n    return 'valid' if re.search(r'^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[!@#$%^&*?])[A-Za-z0-9!@#$%^&*?]{8,20}$', s) else 'not valid'", "def decode(number):\n    split = str(number).replace('98', ' ').split()\n    split[::2] = [''.join(chr(int(w[i: i+3]) - 4)\n                          for i in range(0, len(w), 3))\n                              for w in split[::2]]\n    split[1::2] = [str(int(n, 2)) for n in split[1::2]]\n    return ', '.join(split)", "interleave=lambda *a:sum([list(i) for i in __import__('itertools').zip_longest(*a)],[])", "def length_of_line(pts):\n   return f'{sum((a-b)**2 for a,b in zip(*pts))**.5:.2f}'\n", "import re\n\nscores = {word: i for i, word in enumerate('nil one two three four five six seven eight nine'.split())}\npattern = re.compile(r'\\b({})\\b'.format('|'.join(scores)))\n\ndef scoreboard(string):\n    return [scores[m] for m in pattern.findall(string)]", "import math\ndef sol_equa(n):\n    # your code\n    # x - 2y ...f1\n    # x + 2y ...f2\n    # A = sum(f1, f2) = 2x divisible by 2\n    # B = diff(f1, f2) = 4y divisible by 4\n    result = []\n    for i in range(1, int(math.ceil(math.sqrt(n))) + 1):\n        if n % i == 0:\n            A = i + n/i\n            B = abs(i - n/i)\n            if A % 2 == 0 and B % 4 == 0:\n                result.append([A/2, B/4])\n    return result\n", "def check_concatenated_sum(n, r):\n    return abs(n) == sum(int(e*r) for e in str(abs(n)) if r) ", "import re\ndef is_matched(read):\n    if f'{len(read[1])}M' == read[0]:\n        return True\n    elif sum(int(n) for n in re.findall('\\d+', read[0])) != len(read[1]):\n        return 'Invalid cigar'\n    \n    return False", "def decipher(cipher):\n    out = \"\"\n    while cipher:\n        l = 2 if cipher[0] == \"9\" else 3\n        out += chr(int(cipher[:l]))\n        cipher = cipher[l:]\n    return out", "make_password = lambda s, x='ios':''.join((lambda f:'105'[f]*(f>-1))(x.find(e[0].lower())) or e[0] for e in s.split())", "def hofstadter_Q(n):\n    try:\n        return hofstadter_Q.seq[n]\n    except IndexError:\n        ans = hofstadter_Q(n - hofstadter_Q(n - 1)) + hofstadter_Q(n - hofstadter_Q(n - 2))\n        hofstadter_Q.seq.append(ans)\n        return ans\nhofstadter_Q.seq = [None, 1, 1]", "def mystery_solved(n):\n    \"\"\"\nRecreated mystery function from bytecode using the dis module.\n   How to print the bytecode: import dis\n                              print(dis.dis(mystery)) \n    Apparently,                \n    the function is a wrong implementation of the 5n+1 problem ->  \n    https://math.stackexchange.com/questions/14569/the-5n1-problem\n    http://www.sciencedirect.com/science/article/pii/S0304414905001602\n    \"\"\"\n    c=0\n    while(n != 1 and n != 13 and n < 1000000): # Should have \"n != 17\" too.\n              c=c+1\n              # Without the line below the function hangs for some n > 0.\n              if(n==17): return -1\n              if (n&1): \n                     n=n+n+n+n+n+1 # n = 5n+1  \n                     continue\n              n=n>>1 # n = n/2\n    return c\n    \ndef wrap_mystery(n): return mystery_solved(n)", "def calculate_years(principal, interest, tax, desired):\n    year = 0    \n    while principal < desired:\n        year = year + 1\n        interest_beforetax = interest * principal\n        principal = principal + ((1 - tax) * interest_beforetax)\n        \n    return year\n        \n    \n    \n  \n", "def is_balanced(source, caps):\n    oldLen, source = len(source), ''.join( l for l in source if l in caps )\n    while oldLen != len(source):\n        oldLen = len(source)\n        for i in range(0,len(caps),2):\n            source = source.replace(caps[i:i+2],'')\n    return len(source)==0", "def likes(names):\n    n = len(names)\n    return {\n        0: 'no one likes this',\n        1: '{} likes this', \n        2: '{} and {} like this', \n        3: '{}, {} and {} like this', \n        4: '{}, {} and {others} others like this'\n    }[min(4, n)].format(*names[:3], others=n-2)", "import re\n\ndef commas(num):\n    if isinstance(num, int):\n        return format(num, ',')\n    else:\n        return re.sub('\\.?0+$', '', format(round(num, 3), ',.3f'))\n", "def solve(st):\n    st = st.replace('(','').replace(')','')\n    i  = len(st)\n    while i:\n        i -=1\n        if st[i].isdigit():\n            dg = int(st[i])\n            ex = st[i+1:] * dg\n            st = st[:i] + ex\n            i += dg\n    return st\n        \n", "def faro_cycles(deck_size):\n    \"\"\"\n        If the deck size is 2*n, then it'll take at least\n        k shuffles to get back to the starting order, where k \n        is the smallest integer such that 2**k = 1 (mod 2*n - 1)\n    \"\"\"\n    \n    if deck_size <= 2: return 1\n    \n    k = 1\n    while ((2**k % (deck_size - 1)) != 1): k += 1\n    return k", "def fib_rabbits(n, b):\n    (i, a) = (1, 0)\n    for m in range(n):\n        (i, a) = (a * b, a + i)\n    return a\n", "from operator import truediv\n\n\ndef time(distance, boat_speed, stream):\n    stream, stream_speed = stream.split()\n    stream_speed = int(stream_speed) * (-1 if stream == 'Upstream' else 1)\n    return round(truediv(distance, (boat_speed + stream_speed)), 2)\n", "def longest_collatz(lst):\n    return max(lst, key=seq_len)\n\ndef seq_len(n):\n    count = 0\n    while n > 1:\n        n = (3 * n + 1) if n % 2 else (n // 2)\n        count += 1\n    return count\n    \n# two-liner\n#seq_len = lambda n: 0 if n == 1 else 1 + seq_len(3 * n + 1 if n % 2 else n // 2)\n#longest_collatz = lambda lst: max(lst, key=seq_len)\n\n\n", "def calc(expr):\n    # Empty\n    if len(expr.strip()) < 1:\n        return 0\n\n    # Only Numbers\n    if expr.count('+') == 0 and expr.count('-') == 0 and expr.count('*') == 0 and expr.count('/') == 0:\n        return float(expr.split(' ')[-1])\n\n    # Normal\n    op_flags = '+-*/'\n    nums = []\n    ops = []\n    expr_list = expr.split(' ')\n\n    for e in expr_list:\n        if e in op_flags:\n            b = float(nums.pop())\n            a = float(nums.pop())  # Reverse the order.\n\n            if e == '+':\n                nums.append(a + b)\n            elif e == '-':\n                nums.append(a - b)\n            elif e == \"*\":\n                nums.append(a * b)\n            elif e == \"/\":\n                nums.append(a / b)\n        else:\n            nums.append(e)\n\n    return nums[0]", "def get_grade(s1, s2, s3):\n    # Code here\n    if 90 <= ((s1 + s2 + s3)/3) <= 100:\n        return \"A\"\n    elif 80 <= ((s1 + s2 + s3)/3) <= 90:\n        return \"B\"\n    elif 70 <= ((s1 + s2 + s3)/3) <= 80:\n        return \"C\"\n    elif 60 <= ((s1 + s2 +s3)/3) < 70:\n        return \"D\"\n    else:\n        return \"F\"\n", "def spam(number):\n    return number * 'hue'", "from math import gcd\n\ndef parameter(n):\n    s, p = 0, 1\n    for m in str(n):\n        s += int(m)\n        p *= int(m)\n    return (s * p / (gcd(s, p)))", "from dateutil import parser\nimport calendar\ndef day(date):\n    return calendar.day_name[parser.parse(date).weekday()]\n", "def inverse_slice(items, a, b):\n    del items[a:b]\n    return items", "def even_chars(st): \n    # your code here\n    return [st[i] for i in range(1,len(st),2)] if 1<len(st)<100 else \"invalid string\"", "def bmi(weight, height):\n    result = weight / height / height\n    return \"Underweight Normal Overweight Obese\".split()[\n            (result > 18.5) +\n            (result > 25.0) +\n            (result > 30.0)]", "def dup(arr):\n    a, res = 0, [x[0] for x in arr]\n    for string in arr:\n        for x in range(1, len(string)):\n            if string[x] != string[x-1]:\n                res[a] += string[x]\n        a += 1\n    return res", "def trigrams(phrase):\n    p = phrase.replace(' ','_')\n    return ' '.join([p[i:i+3] for i in range(len(p)-2)])\n", "def unusual_lex_order(arr):\n    arr2 = []\n    for elem in arr:\n        arr2.append(elem[::-1])\n    arr2 = sorted(arr2)\n    arr3 = []\n    for elem in arr2:\n        arr3.append(elem[::-1])\n    return arr3", "from math import sqrt\n\ndef group_size(size, day):\n    skip = size * (size - 1) // 2\n    day += skip\n    return round(sqrt(day * 2))", "def calculate_age(year_of_birth, current_year):\n    years = current_year - year_of_birth\n    if not years:\n        return 'You were born this very year!'\n    elif years > 0:\n        return f'You are {years} year{\"\" if years == 1 else \"s\"} old.'\n    return f'You will be born in {-years} year{\"\" if years == -1 else \"s\"}.'", "#cockroach_speed=lambda s:int(s*27.77777777777778)\ncockroach_speed = lambda s:int(27.77777777777778.__mul__(s))", "areYouPlayingBanjo = lambda name: (name + ' plays banjo') if name.lower()[0] == 'r' else (name + ' does not play banjo')", "def mobile_keyboard(s):\n    a = \"12abc3def4ghi5jkl6mno7pqrs8tuv9wxyz*0#\"\n    b = \"11234123412341234123412345123412345111\"\n    d = {x: int(y) for x, y in zip(a, b)}\n    return sum(d[x] for x in s)", "def to_alternating_case(a):\n    lst = []\n    for i in a:\n        if i == i.lower():\n            lst.append(i.upper())\n        else:\n            lst.append(i.lower())\n    return ''.join(lst)", "def beasts(heads, tails):\n    # your code here\n    \n    o=(5*tails-heads)/3\n    h=(heads-2*tails)/3\n    \n    if o==int(o) and h == int(h) and o>=0 and h >= 0:\n        return [int(o),int(h)]\n    else:\n        return \"No solutions\"\n    #return [orthus, hydra]\n", "from math import cos, radians, inf\n\ndef find_time_to_break(bearing_A, bearing_B):\n    theta = bearing_A - bearing_B\n    return inf if theta == 0 else 18.86 / (1 - cos(radians(theta)))**0.5", "from functools import reduce\n\ndef per(n):\n    r = []\n    p = reduce(lambda a, b: a*b, map(int, str(n)))\n    return r if p == n else [p] + per(p)", "from math import gcd\nlcm = lambda x,y: x*y//gcd(x,y)\n\ndef DPC_sequence(s):\n    res = 1\n    for i,x in enumerate(s):\n        if x == 'D':\n            res = lcm(res, i+1)\n    for i,x in enumerate(s):\n        if (x == 'C' and (not res%(i+1) or gcd(res, i+1) == 1)) or (x == 'P' and gcd(res, i+1) > 1):\n            return -1\n    return res", "from itertools import cycle, chain\n\ndef custom_christmas_tree(chars, n):\n    c, l = cycle(chars), 2*n-1\n    return '\\n'.join(chain( (' '.join(next(c) for _ in range(i)).center(l).rstrip() for i in range(1,n+1)),\n                            ('|'.center(l).rstrip() for _ in range(n//3 or 1)) ))", "def whose_turn(positions):\n    return sum(ord(c) for c in positions.replace(\";\", \"\")) % 2 == 0", "def consecutive_ducks(n):\n    return \"1\" in bin(n)[3:]", "def polybius(text):\n    dict = {\n        'A':'11','B':'12','C':'13','D':'14','E':'15',\n        'F':'21','G':'22','H':'23','I':'24','J':'24','K':'25',\n        'L':'31','M':'32','N':'33','O':'34','P':'35',\n        'Q':'41','R':'42','S':'43','T':'44','U':'45',\n        'V':'51','W':'52','X':'53','Y':'54','Z':'55',\n        ' ': ' '\n    }\n    return ''.join(dict[c] for c in text)\n", "def digitize(n):\n    k = [int(num) for num in str(n)]\n    k.reverse()\n    return k", "def solve(l):\n    l1 = []\n    for i, _ in enumerate(l):\n        l1.append(list([ord(x.lower()), i+97] for i, x in enumerate(l[i])\n                        if ord(x.lower()) == i+97))\n        l2 = [len(x) for x in l1]\n    return l2", "import re\n\ndef send(s):\n    return \" \".join(f\"{'0' if x[0] == '1' else '00'} {'0' * len(x)}\" for x in re.findall(\"0+|1+\", \"\".join(f\"{x:07b}\" for x in map(ord, s))))\n\ndef receive(s):\n    return re.sub(\".{7}\", lambda x: chr(int(x.group(), 2)), \"\".join((\"1\" if x == \"0\" else \"0\") * len(y) for x, y in re.findall(\"(0+) (0+)\", s)))", "def pattern(n):\n    # Happy Coding ^_^\n    result = []\n    \n    #If it's one return nothing\n    if n == 1:\n        return ''\n\n    #just go through n printing the not odd numbers \n    for i in range(n+1):\n           if i%2 == 0:\n               result.append(str(i)*i + '\\n')\n            \n    return ''.join(result).strip()\n", "chars = \"_zyxwvutsrqponmlkjihgfedcba!? \"\n\ndef switcher(arr):\n    return \"\".join(chars[int(i)] for i in arr if i != \"0\")", "def is_triangular(n):\n    a = int((n * 2)**0.5)\n    return n * 2 == a * (a + 1)\n", "def compress(sentence):\n    s = sentence.lower().split()\n    sl = []\n    for x in s:\n        if x not in sl:\n            sl.append(x)\n    return ''.join(str(sl.index(x)) for x in s)\n", "def calculate(s):\n    # your code here\n    t=s.replace(\"plus\",\"+\")\n    y=t.replace(\"minus\",\"-\")\n    #print(y)\n    return str(eval(y))\n", "pairs = {'A':'T','T':'A','C':'G','G':'C'}\ndef DNA_strand(dna):\n    return ''.join([pairs[x] for x in dna])", "def duplicate_encode(word):\n    \"\"\"a new string where each character in the new string is '(' \n    if that character appears only once in the original word, or ')' \n    if that character appears more than once in the original word. \n    Ignores capitalization when determining if a character is a duplicate. \"\"\"\n    word = word.upper()\n    result = \"\"\n    for char in word:\n        if word.count(char) > 1:\n            result += \")\"\n        else:\n            result += \"(\"\n            \n    return result\n", "memo = {}\n\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    if n not in memo:\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n    return memo[n]", "def spot_diff(s1, s2):\n    return [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]\n", "def trim(beard):\n    return [[h.replace(\"J\", \"|\") for h in b] for b in beard[:-1]] + [[\"...\"]*len(beard[0])]", "names = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', \n    'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n\ntens = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n\ndef name_that_number(x):\n    if x<20:\n        return names[x]\n    else:\n        return tens[int(x/10)-2] + ((' ' + names[x%10]) if x%10>0 else '')", "def duplicates(array):\n    return [n for i, n in enumerate(array) if array[:i].count(n) == 1]", "encode=lambda s:\" \".join([i[::-1][1:]+i[::-1][0] for i in s.split()])", "def even_magic(n):\n    numbers, p = iter(list(range(1, n * n + 1))), 0\n    main_grid = [[next(numbers) for _ in range(n)] for _ in range(n)]\n    A = lambda s,se,see,e,ee,eee:list(zip(range(s,se,see),range(e,ee,eee)))\n    for i in range(n//4):\n        o = 0\n        for j in range(n//4):\n            for k, l in A(p, p + 4, 1, o, o + 4, 1) + A(p, p + 4, 1, o + 3, o - 1, -1):\n                main_grid[k][l] = ((n ** 2) + 1) - main_grid[k][l]\n            o += 4\n        p += 4\n    return main_grid", "def pyramid(n):\n    result = []\n    for i in range (1, n + 1):\n        result.append(i * [1])\n    return result", "def switch_it_up(number):\n    number_map = {\n        0: 'Zero',\n        1: 'One',\n        2: 'Two',\n        3: 'Three',\n        4: 'Four',\n        5: 'Five',\n        6: 'Six',\n        7: 'Seven',\n        8: 'Eight',\n        9: 'Nine',\n    }\n    \n    return number_map[number]", "from math import log\n\ndef power_law(x1y1, x2y2, x3):\n    (x1, y1), (x2, y2) = (x1y1, x2y2)\n    try:\n        k = log(y1 / y2, x1 / x2)\n        a = y1 / x1 ** k\n        return round(a * x3 ** k)\n    except ZeroDivisionError:\n        return y2", "def array_madness(a,b):\n    farr = 0\n    sarr = 0\n    for i in a : \n        n = i ** 2\n        farr = farr + n\n    for j in b :\n        o = j ** 3\n        sarr = sarr + o\n    if farr > sarr :\n        return True\n    if sarr >= farr :\n        return False\n", "def db_sort(arr): \n\tstrings,integers=[],[]\n\tfor i in arr:\n\t\tintegers.append(i) if type(i) is int else strings.append(i)\n\treturn sorted(integers)+sorted(strings)", "def largest_pair_sum(a): \n    return a.pop(a.index(max(a))) + a.pop(a.index(max(a)))", "def array_equalization(a, k):\n    m = n = len(a)\n    for number in set(a):\n        c = 0\n        i = 0\n        while i < n:\n            if a[i] != number:\n                c += 1\n                i += k\n            else:\n                i += 1\n        m = min(c,m)\n    return m", "def sect_sort(a, b=0, c=0):\n    c = len(a) if not c else b + c\n    return a[:b] + sorted(a[b:c]) + a[c:]", "def symmetric_point(p, q):\n    result = [p[0],q[0]]\n    if(p[0] > q[0]):\n        result[0] = fromRightToLeft(p[0],q[0])\n    else:\n        result[0] = fromLeftToRight(p[0],q[0])\n    if(p[1] > q[1]):\n        result[1] = fromUpToDown(p[1],q[1])\n    else:\n        result[1] = fromDownToUp(p[1],q[1])\n    return result\ndef fromRightToLeft(p,q):\n    return q-abs(p-q)\ndef fromLeftToRight(p,q):\n    return q+abs(p-q)\ndef fromUpToDown(p,q):\n    return q-abs(p-q)\ndef fromDownToUp(p,q):\n    return q+abs(p-q)", "import numpy as np\n\nxs = np.ones(1000000)\nxs[:2] = 0\nxs[2*2::2] = 0\nfor i in range(3, len(xs), 2):\n    if not xs[i]:\n        continue\n    xs[i*i::i] = 0\nprimes = [i for i, x in enumerate(xs) if x]\ns = ''.join(c for p in primes for c in str(p))\n\ndef solve(a, b):\n    return s[a:a+b]", "from fractions import Fraction\n\ndef find_screen_height(width, ratio): \n    ratio = ratio.replace(\":\",\"/\")\n    ratio = float(sum(Fraction(s) for s in ratio.split()))\n    return \"{}x{}\".format(width, int(width/ratio))", "def what_is_the_time(time_in_mirror):\n\n    CW_HRS = [0,  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    MIRROR = [0, 10, 9, 8, 7, 6, 5, 4, 3, 2,  1, 12, 11]\n\n    if time_in_mirror in [\"12:00\", \"12:30\", \"06:00\", \"06:30\"]:\n        return time_in_mirror\n        \n    hours, minutes = time_in_mirror.split(':')\n    hours, minutes = int(hours), int(minutes)\n    hrs = abs(12 - hours) if minutes == 0 else MIRROR[hours]\n    mins = 0 if minutes == 0 else 60 - minutes \n    \n    return \"{:02}:{:02}\".format(hrs, mins)", "def char_concat(word):\n    half = len(word) // 2\n    return ''.join('{}{}{}'.format(a[0], a[1], i) for i, a in enumerate(zip(word[:half], word[::-1][:half]), 1))", "def count_adjacent_pairs(st):\n    #print(st)\n    st = st.lower().split()\n    cnt = 0\n    on = False\n    for i in range(1,len(st)):\n        if st[i] == st[i-1]:\n            if not on: \n                cnt += 1\n                on = True\n        else:\n            on = False\n    return cnt", "def withdraw(n):\n    hundreds, fifties, rest = n // 100, (n % 100) // 50, n % 50\n    if rest % 20 == 10:\n        if fifties == 0:\n            hundreds, fifties, twenties = hundreds - 1, 1, (rest + 50) // 20\n        else:\n            fifties, twenties = fifties - 1, (rest + 50) // 20\n    else:\n        twenties = rest // 20\n    return [hundreds, fifties, twenties]", "from math import hypot\n\ndef coordinates(p1, p2, precision=0):\n    return round(hypot(p1[0] - p2[0], p1[1] - p2[1]), precision)", "def pack_bagpack(scores, weights, capacity):\n    dp=[[0,[]] for i in range(capacity+1)]\n    for j in range(1,len(scores)+1):\n        r = [[0,[]] for i in range(capacity+1)]\n        for i in range(1,capacity+1):\n            c,p = weights[j-1], scores[j-1]\n            if c<=i and p+dp[i-c][0]>dp[i][0]: r[i]=[p+dp[i-c][0], dp[i-c][1]+[j-1]]\n            else: r[i]=dp[i]\n        dp = r\n    return dp[-1][0]", "chessboard = lambda s: '\\n'.join(([''.join(['.' if (x + y) % 2 else '*' for x in range(int(s.split()[1]))]) for y in range(int(s.split()[0]))]))", "def check_DNA(seq1, seq2):\n if len(seq1) < len(seq2): seq1, seq2 = seq2, seq1\n seq2 = seq2[::-1].replace('C','g').replace('G','c').replace('T','a').replace('A','t').upper()\n return seq1.find(seq2) >= 0", "def modified_sum(a, n):\n    return sum(x**n - x for x in a)", "def greet_jedi(f, l):\n    return 'Greetings, master ' + l[0:3].capitalize() + f[0:2].capitalize()", "from itertools import combinations_with_replacement as cr\nfind=lambda a,n:sum(n==sum(c)for r in range(1,len(a)+1)for c in cr(a,r=r))", "def peak(arr):\n    sl, sr = 0, sum(arr)\n    for i,v in enumerate(arr):\n        sr -= v\n        if sr == sl: return i\n        elif sl > sr: return -1\n        sl += v\n", "from functools import partial\nfrom re import compile\n\nREGEX1 = partial(compile(r\"(?<=\\w)(?=\\b)\").sub, \"!!!!\")\ntrans = str.maketrans(\"AEIOU\", \"@****\")\n\ndef gordon(a):\n    return REGEX1(a.upper()).translate(trans)", "message = \"You just wanted my autograph didn't you?\"\n\ndef ghostbusters(building):\n    return building.replace(' ', '') if ' ' in building else message", "import re\n\ndef find_longest(s):\n    regex = r\"\\(a*\\)\"\n    while re.search(regex, s): s = re.sub(regex, lambda x: \"a\" * len(x.group()), s)\n    r = map(len, re.findall(r\"a+\", s))\n    return max(r, default = 0)", "def solve(arr): \n    nums = set()\n    out = []\n    for elem in reversed(arr):\n        if elem not in nums:\n            out.append(elem)\n            nums.add(elem)\n\n    return out[::-1]", "def sort_reindeer(reindeer_names):\n    sorted_list = []\n    for name in reindeer_names:\n        sorted_list.append(name.split())\n    sorted_list = sorted(sorted_list, key=lambda names: names[1])\n\n    result = []\n\n    for item in sorted_list:\n        name = item[0] + ' ' + item[1]\n        result.append(name)\n    \n    return result", "def power_sumDigTerm(n):\n    return sorted([i**j for j in range(2,50) for i in range(2,100) if i == sum([int(i) for i in str(i**j) ])])[n-1]", "def gap(num):\n    s = bin(num)[2:].strip(\"0\")\n    return max(map(len, s.split(\"1\")))", "def splitSentence(s):\n\n\n    z = s.split()\n    \n    return z\n    \n    \n", "def combs(comb1, comb2):\n    options = []\n    for i in range(max(len(comb1), len(comb2))+1):\n        if ('*','*') not in zip(' '*i+comb1, comb2):\n            options.append( max( len(comb1)+i, len(comb2) ) )\n        if ('*','*') not in zip(comb1, ' '*i+comb2):\n            options.append( max( len(comb1), len(comb2)+i ) )\n    return min(options)", "def largest_sum(arr):\n\n    largest = 0\n    temp = 0\n\n    for num in arr:\n        temp += num\n        if temp < 0:\n            temp = 0\n        elif temp > largest:\n            largest = temp\n\n    return largest", "def isomorph(a, b):\n    return len(a) == len(b) and len(set(a)) == len(set(b)) == len(set(zip(a, b)))", "def vector_length(vector):\n    return sum((a - b)**2 for a,b in zip(*vector))**0.5", "import numpy as np\n\ndef leaderboard_climb(arr, kara):\n    uniq_scores = np.unique(arr)\n    l = len(uniq_scores) + 1\n    t = l - np.searchsorted(uniq_scores, kara, side='right')\n    return t.tolist()", "def alan_annoying_kid(s):\n    lst = s.split()\n    isNegative  = lst[2] == \"didn't\"\n    verb = lst[2 + isNegative]\n    cplt = ' '.join(lst[3 + isNegative:])\n    return (\"I don't think you didn't {} {} today, I think you did {} it!\".format(verb, cplt[:-1], verb)\n                if isNegative else\n            \"I don't think you {} {} today, I think you didn't {} at all!\".format(verb, cplt[:-1], verb[:-2]))", "from collections import Counter\n\ndef merge_arrays(a, b):\n    c = Counter(a)\n    d = Counter(b)\n    return sorted(x for x in set(a) | set(b) if c[x] == d[x] or not c[x] or not d[x])", "def solution(string):\n    return string[::-1]\nprint(solution('however'))", "def mobius(n):\n    s, p, m = 0, 2, n ** .5\n    while p <= m:\n        if not n % p:\n            s += 1\n            n //= p\n        if not n % p:\n            return 0\n        p += 1\n    if n > 1:\n        s += 1\n    return 1 - s % 2 * 2", "def fix_progression(arr):\n    best = len(arr)\n    s = sum(arr) / len(arr)\n    for start in range(len(arr)-1):\n        for idx in range(start+1, len(arr)):\n            count = 0\n            d = (arr[idx] - arr[start]) // (idx - start)\n            for i in range(0, start):\n                if arr[i] != arr[start] - d*(start-i):\n                    count += 1\n            for i in range(start+1, len(arr)):\n                if arr[i] != arr[start] + d*(i-start):\n                    count += 1\n            best = min(best, count)\n    return best\n", "def is_nice(arr):\n    if not arr: return False\n    \n    for x in arr:\n        if x-1 not in arr and x+1 not in arr:       \n            return False\n    return True", "def distinct(seq):\n    list = []\n    for i in seq:\n        if not i in list:\n            list.append(i)\n        else:\n            pass\n    return list", "def same(a, b):\n    return comp(a) == comp(b)\n\ndef comp(arr):\n    return sorted(map(sorted,arr))", "starts_with = str.startswith", "def coin(n): return [x + v for x in coin(n-1) for v in 'HT'] if n - 1 else ['H','T']", "def josephus_survivor(n,k):\n    if (n == 1): \n          return 1 \n    else: \n          r = list(range(1, n+1))\n          sum = 0\n          for i in r:\n              sum = (sum+k) % i\n          return sum + 1\n        \n        \n", "def my_parse_int(string):\n    \"\"\"Parses an str for an int value. If the str does not convert to a valid int, return the \"NaN\" string.\"\"\"\n    try:\n        return int(string)\n    except ValueError:\n        return \"NaN\"", "def sort_photos(pics):\n    out = sorted(pics, key=lambda i: (int(i[:4]), int(i.split('g')[-1])))[:-6:-1][::-1]\n    out.append(out[-1].split('g')[0] + 'g' + str(int(out[-1].split('g')[-1])+1))\n    return out", "def check(arr, val):\n    return val in arr", "def count(A, t, x):\n    return sum(a%x==t%x for a in A) if x else sum(a==t for a in A)", "import re\n\ndef shortest_to_char(s, c):\n    if not c or c not in s:\n        return []\n    positions = [m.start() for m in re.finditer(c, s)]\n    return [min(abs(p - i) for p in positions) for i in range(len(s))]", "def validate(n):\n    return not sum(sum(map(int, str(int(d) + (i % 2) * int(d)))) for i, d in enumerate(str(n)[::-1])) % 10", "def cumulative_triangle(n):\n    f = lambda x: 0.5 * x * (x - 1) + 1\n    s = f(n)\n    r = []\n    while len(r) < n:\n        r.append(s)\n        s += 1\n    return sum(r)", "def to_pretty(s):\n    if not s: return \"just now\"\n    for t, w in (60, \"seconds\"), (60, \"minutes\"), (24, \"hours\"), (7, \"days\"), (53, \"weeks\"):\n        s, r = divmod(s, t)\n        if not s: return (r > 1 and str(r) + \" \" + w or (\"a \", \"an \")[t == 24] + w[:-1]) + \" ago\"", "from math import floor\ndef champernowneDigit(n):\n    print(n)\n    if n == None or isinstance(n, bool) or not isinstance(n, int) or n < 1: return float('nan')\n    t, c = 10, 1\n    while t < n: \n        c += 1\n        t += 9 * 10**(c-1) * c\n    num = str(10**c - 1 - floor((t-n)/c))\n    return int(num[c - 1 - (t-n)%c])", "import re\ndef find(s):\n    x=[]\n    for g in re.finditer(r\"\\?+!+\",s):\n        x.append((len(g[0]),-g.start(),g[0]))\n    for g in re.finditer(r\"!+\\?+\",s):\n        x.append((len(g[0]),-g.start(),g[0]))\n    return max(x)[-1] if x else \"\"", "import base64\n\ndef adFly_decoder(sc):\n    code1 = ''\n    code2 = ''\n    for i in range(len(sc)):\n        if(i%2==0):\n            code1 = code1 + sc[i]\n        else:\n            code2 = code2 + sc[i]\n    try:\n        url = base64.b64decode((code1+code2[::-1]).encode())[26:]\n        return base64.b64decode(url).decode()\n    except:\n        return 'Invalid'\n    \ndef adFly_encoder(url):\n    plain = f'00https://adf.ly/go.php?u={base64.b64encode(url.encode()).decode()}';\n    code = base64.b64encode(plain.encode()).decode()\n    i = len(code)//2\n    code1, code2 = code[:i], code[i:][::-1]\n    ysmm = ''\n    for ch1, ch2 in zip(code1, code2):\n        ysmm = ysmm + ch1 + ch2\n    return ysmm\n", "def remove(s):\n    return ' '.join(i.rstrip('!') for i in s.split())\n", "def count_ways(n, k):\n    kfib = [0 for _ in range(k-1)] + [1]\n    for i in range(n):\n        kfib.append(sum(kfib[i:i+k]))\n    return kfib[-1]", "def multiples(m, n):\n    new_list = []\n    for i in range(1,m+1):\n        new_list.append(i*n)\n    return new_list", "def plant_doubling(n):\n    schemat = str(bin(n))\n    return sum(int(schemat[i]) for i in range(2, len(schemat)))", "def triple_trouble(one, two, three):\n    newStr = ''\n    for i in range(len(one)):\n        newStr += one[i] + two[i] + three[i]\n    return newStr", "import re\n\nKA_PATTERN = re.compile(r'(?![aeiou]+$)([aeiou]+)', re.I)\n\ndef ka_co_ka_de_ka_me(word):\n    return 'ka' + KA_PATTERN.sub(r'\\1ka', word)", "def cost_of_carpet(room_length, room_width, roll_width, roll_cost):\n    if 0 in [room_length, room_width]:\n        return \"error\"\n    mi, mx = min((room_length, room_width)), max((room_length, room_width))\n    rw, rc = roll_width, roll_cost\n    return round(mi * rw * rc, 2) if mx <= roll_width else (round(mx * rw * rc, 2) if roll_width >= mi else \"error\")", "def oddity(n):\n    return 'odd' if int(n**0.5)**2 == n else 'even'", "def find_array(arr1, arr2):\n    return list() if (not arr1 or not arr2) else [arr1[i] for i in arr2 if i <= len(arr1)]", "import re\n\ndef bin_str(s):\n    return len(re.findall(\"(?:1+)|(?:0+)\", s.lstrip(\"0\")))", "def string_transformer(s):\n\n    array = []\n\n    if s is '':\n        return ''\n        \n    for i in s:\n        if i == i.lower():\n            array.append(i.upper())\n        else:\n            array.append(i.lower())\n            \n    result = ''.join(array)\n    return ' '.join(result.split(' ')[::-1])", "def opposite(number):\n    return number - (number * 2)\nopposite(8)", "from math import pi,floor\n\ndef volume(r,h):\n    return floor(h/3 * pi * r ** 2)", "def filter_words(st):\n    st1 = st.lower()\n    st2 = st1.capitalize()\n    st3 = \" \".join(st2.split())\n    return st3", "def nickname_generator(name):\n    if len(name) < 4:\n        return 'Error: Name too short'\n    return name[: 4 if name[2] in 'aeiou' else 3]", "def generate_number(squad, n):\n    return n if n not in squad else None if n < 10 else next((x for x in range(10, 100) if sum(int(c) for c in str(x)) == n and x not in squad), None)\n", "def flatten(d):\n    result = []\n    for key in d:\n        if isinstance(d[key], str):\n            result.append((key, d[key]))\n        elif len(d[key]) == 0:\n            result.append((key, \"\"))\n        else:\n            for key2, value2 in list(flatten(d[key]).items()):\n                result.append((key + \"/\" + key2, value2))\n    return dict(result)\n", "def small_enough(a, limit): \n    if a[0] > limit:\n        return False\n        \n    if len(a) > 1:\n        return small_enough(a[1:], limit)\n    \n    return True\n", "is_vowel = set(\"aeiouAEIOU\").__contains__\n\ndef count_vowels(s = ''):\n    if type(s) == str:\n        return sum(map(is_vowel, s))", "find_multiples = lambda i, l: list(range(i, l + 1, i))", "def x(n):\n    i=0\n    out=''\n    while i<n:\n        out = out + line(n, i)\n        if i != (n-1):\n           out = out + '\\n' \n        i = i+1\n    return out\n\ndef line(x, ln):\n    blank = '\u25a1'\n    pixel = '\u25a0'\n    str=''\n    n=0\n    while n<x:\n        if n == ln:\n            str = str + pixel\n        elif n == ((x-1)-ln):\n            str = str + pixel\n        else:\n            str = str + blank\n        n=n+1\n    return str", "def array_diff(a, b):\n    return [x for x in a if x not in b]", "def check_availability(schedule, now):\n    return next((end for start, end in schedule if start <= now < end), True)", "import re\n\ndef distinct_digit_year(year):\n    return year + 1 if re.match(r'(?:([0-9])(?!.*\\1)){4}', str(year + 1)) else distinct_digit_year(year + 1)", "def pattern(n):\n    return '\\n'.join([''.join(map(str,list(range(n,n-i,-1)))) for i in range(1,n+1)])", "from itertools import chain\ndef crap(garden, bags, cap):    \n    return  (lambda x: 'Dog!!' if x.count('D') else 'Clean' if x.count('@') <= bags*cap else 'Cr@p') ( list(chain(*garden)) )\n", "import re\ndef dad_filter(string):\n    return re.sub(r'((?<=\\,)\\,+|[\\s,]+\\Z)','',string)", "def are_coprime(n,m):\n    return prime_factors(n) & prime_factors(m) == {1}\n    \ndef prime_factors(n):    \n    factors = [1]\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            factors.append(d)\n            n /= d\n        d = d + 1\n        if d*d > n:\n            if n > 1: factors.append(n)\n            break\n    return set(factors)    ", "def multiply(n):\n    if '-' in str(n):\n        i = len(str(n)) - 1\n    else:\n        i = len(str(n))\n    return n * (5 ** i)", "def reverse(a):\n    s = ''.join(a)[::-1]\n    l, x = [], 0\n    for i in a:\n        l.append(s[x:x+len(i)])\n        x += len(i)\n    return l", "def zombie_shootout(zombies, distance, ammo):\n    kill = distance * 2\n    if kill > ammo < zombies: return f\"You shot {ammo} zombies before being eaten: ran out of ammo.\"\n    if kill < zombies: return f\"You shot {kill} zombies before being eaten: overwhelmed.\"\n    return f\"You shot all {zombies} zombies.\"", "def alphabet_war(fight):\n    a, b = 'sbpw', 'zdqm'\n    l, r = sum([a.find(x)+1 for x in fight]), sum([b.find(y)+1 for y in fight])\n    return \"Right side wins!\" if l<r else \"Left side wins!\" if r<l else \"Let's fight again!\" ", "def summation(num):\n    counter = 0\n    for n in range(1,num+1):\n        counter += n\n    return counter\n    \n", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef f(n):\n    if n < 3:\n        return 1\n    return f(n-3) + f(n-1)\n\ndef count_cows(n):\n    if not isinstance(n, int):\n        return None\n    return f(n)\n", "def colour_association(arr):\n    colors = [];\n    for color in arr:\n        colors.append({color[0]: color[1]});\n    return colors;", "def solve(nums,div):\n    return [(num%div)+num for num in nums]\n", "import re\nfrom string import ascii_lowercase as c \ndef solve(s):   \n    return max([sum(map(lambda x: c.index(x)+1,list(i))) for i in re.findall(r'[^aeiou]+',s)])", "import re\n\ndef is_vowel(string):\n    return bool(re.match('^[aeiou]\\Z', string, re.IGNORECASE))", "from math import sqrt, floor\n\ndef num_of_open_lockers(n):\n    return floor(sqrt(n))", "def between(a,b):\n    return [Array for Array in range(a, b + 1)]", "def pattern(n):\n    l = []\n    for a, b in zip(range(1, n+2), range(n+1)):\n        res = ''.join(str(x%10) for x in range(1,a))\n        spaces = n-len(res)\n        if res: l.append(spaces * ' ' + res+res[-2::-1] + ' ' * (spaces))\n    return '\\n'.join(l)", "def has_two_cube_sums(n):\n    cubic_list = [i**3 for i in range(1, int((n)**(1./3.)) + 1)]\n    return sum([(n != 2*c) and ((n-c) in cubic_list) for c in cubic_list]) > 3\n", "def repeats(arr):\n    return sum(num for num in arr if arr.count(num) == 1)\n\n", "def add(*args):\n    return round(sum(x / i for i, x in enumerate(args, 1)))\n", "def fold_to(distance):\n    if distance < 0:\n        return None\n    if distance < 0.0001:\n        return 0\n    counter = 0\n    while distance > 0.0001:\n        distance /= 2\n        counter += 1\n    return counter\n", "def reverse_sentence(sentence):\n    return \" \".join(word[::-1] for word in sentence.split())", "def rounding(n, m):\n    q, r = divmod(n, m)\n    return q * m if 2 * r < m else (q + 1) * m if 2 * r > m else n", "def split_by_value(k, elements):\n    return [x for x in elements if x < k] + [x for x in elements if x >= k]", "from itertools import zip_longest\n\ndef split_and_add(numbers, n):\n    while len(numbers) > 1 and n:\n        n -= 1\n        m = len(numbers) // 2\n        it = zip_longest(reversed(numbers[:m]), reversed(numbers[m:]), fillvalue=0)\n        numbers = list(map(sum, it))[::-1]\n    return numbers", "def solve(arr):\n    return sum(x<y and y*2-x in arr for x in arr for y in arr)", "def how_many_measurements(n):\n    # Split coins in three equal sized groups,\n    # one measurement will tell which of the groups contains\n    # the fake coin, when less than 3 coins is in a group, one\n    # measurement is required to determine which coin is fake\n    if n == 1:\n        return 0\n    elif n <= 3:\n        return 1 \n    n_coins_in_sub_group = n / 3\n    return how_many_measurements(n_coins_in_sub_group) + 1", "def dropzone(p, dropzones):\n    distances = []\n    for dropzone in dropzones:\n        distances.append(((dropzone[0]-p[0])**2+(dropzone[1]-p[1])**2)**0.5)\n    return dropzones[distances.index(min(distances))]", "from collections import defaultdict\n\ndef numericals(stg):\n    count, result = defaultdict(int), []\n    for c in stg:\n        count[c] += 1\n        result.append(f\"{count[c]}\")\n    return \"\".join(result)\n", "def riders(stations):\n    count = 1\n    distance = 0\n\n    for station in stations:\n        if distance + station > 100:\n            count += 1\n            distance = 0\n\n        distance += station\n\n    return count", "from functools import cmp_to_key\n\ndef oddest(a):\n    odder = lambda x,y: odder(x//2, y//2) if x%2==y%2 else 1-2*(x%2)\n    return min(a, key=cmp_to_key(odder))", "def get_drink_by_profession(param=''):\n    if param.title() == \"Jabroni\":\n        return \"Patron Tequila\"\n    elif param.title() == \"School Counselor\":\n        return \"Anything with Alcohol\"\n    elif param.title() ==  \"Programmer\":\n        return  \"Hipster Craft Beer\"\n    elif param.title() ==  \"Bike Gang Member\":\n        return \"Moonshine\" \n    elif param.title() == \"Politician\":\n        return \"Your tax dollars\" \n    elif param.title() == \"Rapper\":\n        return \"Cristal\"\n    else:\n        return \"Beer\"\n", "subcuboids=lambda x,y,z:x*-~x*y*-~y*z*-~z/8", "def optimal_number_of_coins(n, coins):\n    return change_making(coins,n)\n\n\n\n\ndef _get_change_making_matrix(set_of_coins, r: int):\n    m = [[0 for _ in range(r + 1)] for _ in range(len(set_of_coins) + 1)]\n    for i in range(1, r + 1):\n        m[0][i] = float('inf')  # By default there is no way of making change\n    return m\n\ndef change_making(coins, n: int):\n    \"\"\"This function assumes that all coins are available infinitely.\n    n is the number to obtain with the fewest coins.\n    coins is a list or tuple with the available denominations.\n    \"\"\"\n    m = _get_change_making_matrix(coins, n)\n    for c in range(1, len(coins) + 1):\n        for r in range(1, n + 1):\n            # Just use the coin coins[c - 1].\n            if coins[c - 1] == r:\n                m[c][r] = 1\n            # coins[c - 1] cannot be included.\n            # Use the previous solution for making r,\n            # excluding coins[c - 1].\n            elif coins[c - 1] > r:\n                m[c][r] = m[c - 1][r]\n            # coins[c - 1] can be used.\n            # Decide which one of the following solutions is the best:\n            # 1. Using the previous solution for making r (without using coins[c - 1]).\n            # 2. Using the previous solution for making r - coins[c - 1] (without\n            #      using coins[c - 1]) plus this 1 extra coin.\n            else:\n                m[c][r] = min(m[c - 1][r], 1 + m[c][r - coins[c - 1]])\n    return m[-1][-1]", "from fractions import gcd\n\ndef sum_differences_between_products_and_LCMs(pairs):\n    return sum(a*b - a*b//gcd(a,b) for a, b in pairs if a and b)", "def complete_series(seq): \n    if len(seq) >len(set(seq)):\n        return [0]\n    return list(range(max(seq)+1))   ", "def divisible_by(numbers, divisor):\n    factors = []\n    for n in numbers:\n        if n % divisor == 0:\n            factors.append(n)\n    return factors\n            \n", "def swap(word):\n    return ''.join(ch.upper() if ch.islower() else ch.lower() for ch in word)", "def sum_two_smallest_numbers(numbers):\n    return sum(sorted(numbers)[:2])", "import numpy as np\ndef solve_eq(eq):\n    return [i[0] for i in np.linalg.solve(np.reshape([x for x in (y[:-1] for y in eq)], (3, 3)), np.reshape([x for x in (y[-1] for y in eq)], (3, 1))).round().astype(int)]\n", "from re import findall\n\ndef calculate(s):\n    op1, op2 = map(int, findall('(\\d+)', s))\n    return op1 + op2 if 'gains' in s else op1 - op2", "bh={\"\":\"\",\"0000\":\"0\",\"0001\":\"1\",\"0010\":\"2\",\"0011\":\"3\",\"0100\":\"4\",\"0101\":\"5\",\"0110\":\"6\",\"0111\":\"7\",\"1000\":\"8\",\"1001\":\"9\",\"1010\":\"a\",\"1011\":\"b\",\"1100\":\"c\",\"1101\":\"d\",\"1110\":\"e\",\"1111\":\"f\"}\ndef bin_to_hex(bs):\n    r=\"\"; bs=\"000\"+bs\n    for i in range(len(bs),-1,-4): s=bs[i-4:i]; r=bh[s]+r\n    while r[0]==\"0\" and len(r)>1: r=r[1:]   \n    return r\n\nhb={bh[v]:v for v in bh}\ndef hex_to_bin(hs):\n   r=\"\"; hs=hs.lower()\n   for c in hs: r+=hb[c]\n   while r[0]==\"0\" and len(r)>1: r=r[1:]\n   return r", "def get_middle(s):\n    while len(s) > 2:\n        s = s[1:-1]\n    return s", "def partition(n,s=2):\n    if n <= 1:return []\n    if n < 4:return [[n]]\n    ans = []\n    while True:\n        while n % s != 0:s += 1\n        if s > n ** 0.5: break\n        l = [s]\n        p = partition(n / s,s)\n        for i in p:\n            x = sorted(l + i)\n            if not x in ans:ans += [x]\n        ans += [l + [n/s]]\n        s += 1\n    return ans\n\ndef prod_int_part(n):\n    p = partition(n)\n    return [len(p), min(p) if p else []]", "def watch_pyramid_from_the_side(c, i=1, acc=[]):\n    if c == None: return c\n    if not c: return '\\n'.join(acc)\n    return watch_pyramid_from_the_side(c[:-1], i+2, [' '+l+' 'for l in acc]+[c[-1]*i])\n\ndef watch_pyramid_from_above(c, i=1, acc=[]):\n    if c == None: return c\n    if not c: return '\\n'.join(acc)\n    return watch_pyramid_from_above(c[:-1], i+2, [c[-1] * i] + [c[-1]+l+c[-1] for l in acc] + [c[-1] * i] * bool(acc))\n\ndef count_visible_characters_of_the_pyramid(c):\n    return c and (2*len(c)-1)**2 or -1\n\ndef count_all_characters_of_the_pyramid(c):\n    return c and (4*len(c)**3-len(c))//3 or -1", "def multiple_split(string, delimiters=[]):\n    if delimiters==[]:\n        return [string] if string else []\n        \n\n    for deli in delimiters:\n\n        string = ' '.join(string.split(deli))\n    string=string.split(' ') \n    return list(filter(None,string))", "array_conversion=c=lambda a,p=0:a[1:]and c([[x+y,x*y][p]for x,y in zip(*[iter(a)]*2)],1-p)or a[0]", "def excluding_vat_price(price):\n    return round(price/1.15,2) if isinstance(price,(float,int)) else -1", "def song_decoder(song):\n    return \" \".join(song.replace('WUB', ' ').split())", "def accum(s):\n    value = \"\"\n    for i,c in enumerate(s):\n        value += c.upper() + c.lower()*i + \"-\"\n    return value[:-1]", "from functools import lru_cache\nFC = lambda n, li=[], j=2:(FC(n, li, j+1) if n%j else FC(n//j, li+[j], j)) if j*j<=n else sum(li + [[],[n]][n>1])\nget_factors = lru_cache(None)(lambda n:FC(n))\nget_divisors = lru_cache(None)(lambda n:sum(sum([[i,n//i] for i in range(1,int(n**.5)+1) if not n % i], [])))\nds_multof_pfs = lambda start, end:[i for i in range(start, end+1) if not get_divisors(i) % get_factors(i)]", "import collections\n\ndef count_sel(lst):\n    counter = collections.Counter(lst)\n    mode_count = counter.most_common(1)[0][1] if lst else 0\n    return [len(lst),\n            len(counter),\n            sum(v == 1 for v in counter.values()),\n            [sorted(k for k, v in counter.items() if v == mode_count), mode_count]]", "def get_age(age):\n    age=age[0]#select the first element of the string\n    age=int(age)#cause age is a char, we need to convert in to a integer \n    if age>9 or age<0:\n        return 0\n    else:\n        return age", "FOUND, n = {}, 1\nwhile len(FOUND) < 60:\n    sq = n**.5\n    nDivs = sum(2*(not n%x) for x in range(1,int(sq)+1)) - (int(sq)==sq)\n    if nDivs not in FOUND: FOUND[nDivs] = n\n    n += 1\n    \ndef find_min_num(nDivs): return FOUND[nDivs]", "def solution(n,d):\n    return list(map(int, list(str(n)[-d:]))) if d > 0 else []", "def pascal(p):\n    def create_row(n):\n        row = [1]\n        for k in range(n):\n            row.append(row[k] * (n-k) / (k+1))\n        return row\n    tri = []\n    for row in range(p):\n        tri.append(create_row(row))\n    return tri\n", "from functools import reduce\n  \ndef nCr(n, k): \n\n  numer = reduce(lambda x, y: x * y, \n                 list(range(n, n - k, -1)))     \n  denom = reduce(lambda x, y: x * y, \n                 list(range(1, k + 1)))         \n    \n  return numer // denom         \n  \ndef bouncy_count(number):\n    r = int((nCr(number + 10, 10) + \n         nCr(number + 9, 9)  \n         - 2 - 10 * number)) \n                  \n    return 10**number - r % (1000000000000000000 + 7) - 1", "def infected_zeroes(lst):\n    one = \"\".join(str(d) for d in lst).split(\"0\")\n    return max(len(one[0]), len(one[-1]), *((len(o) + 1)//2 for o in one[1:-1]))", "def reflections(max_x, max_y):\n    return bool((max_x & -max_x) & (max_y & -max_y))", "def segments(m, a):\n    answer = [i for i in range(m+1)]\n    for i in a:\n        for j in range(i[0], i[1]+1):\n            try:\n                answer.remove(j)\n            except ValueError:\n                pass\n    return answer", "def is_divide_by(number, a, b):\n    calc1 = number % a\n    calc2 = number % b\n    if calc1 == 0 and calc2 == 0:\n        return True\n    else:\n        return False", "from itertools import zip_longest\n\ndef reverse_and_combine_text(text):\n    L = text.split()\n    if len(L) == 1: return text\n    return reverse_and_combine_text(' '.join(x[::-1] + y[::-1] for x,y in zip_longest(L[::2], L[1::2], fillvalue='')))", "def bits_battle(numbers):\n    odds = 0\n    evens = 0\n    for n in numbers:\n        if n % 2:\n            odds += bin(n).count('1')\n        elif n != 0 and n % 2 == 0:\n            evens += bin(n)[2:].count('0')    \n    return 'odds win' if odds > evens else 'evens win' if evens > odds else 'tie'", "def monty_hall(c, p):\n    print((c, p))\n    return round((1 - (p.count(c) / len(p))) * 100)\n    # Your code here!\n", "def not_so_random(b,w):\n    if b&1: return \"Black\"\n    return \"White\"", "def switcheroo(string):\n    swap = {\n        'a': 'b',\n        'b': 'a',\n    }\n    \n    return ''.join(swap.get(ch, ch) for ch in string)", "def poly_add(p1, p2):\n    p = p1[len(p2):] if len(p1)>len(p2) else p2[len(p1):]\n    return [i+j for i,j in zip(p1,p2)]+p\n", "def find_digit(num, nth):\n    return -1 if nth <= 0 else find_digit(-num, nth) if num < 0 else int(str(num).zfill(nth)[-nth])", "def sum_mul(n, m):\n    sum = 0\n    inc = n\n    if n > 0 and m > 0:\n        while n < m:\n            sum += n\n            n += inc\n        return sum\n    else:\n        return \"INVALID\"", "def how_much_coffee(events):\n    activities = [\"cw\", \"cat\", \"dog\", \"movie\"]\n    coffee = 0\n    for e in events:\n        if e.lower() in activities:\n            if e == e.upper():\n                coffee += 2\n            else:\n                coffee += 1\n            if coffee > 3:\n                return \"You need extra sleep\"\n    return coffee", "def rgb(r, g, b):\n    return '{0:02X}{1:02X}{2:02X}'.format(max(min(r, 255), 0), max(min(g, 255), 0), max(min(b, 255), 0))", "def atomic_number(electrons):\n    result=[]\n    shield=1\n    maxnum=2\n    if electrons==1:\n        return [1]\n    while electrons>maxnum:\n        result.append(maxnum)\n        electrons-=maxnum\n        shield+=1\n        maxnum = shield ** 2 * 2\n    result.append(electrons)\n    return result\n", "def hex_word_sum(stg):\n    valid_chars = set(\"05ABCDEF\")\n    stg = stg.replace(\"S\", \"5\").replace(\"O\", \"0\")\n    valid_words = (word for word in stg.split() if not (set(word) - valid_chars))\n    return sum(int(word, 16) for word in valid_words)\n", "from collections import defaultdict\nfrom functools import reduce\n\ndef factorsOf(n):\n    p,d = 2,defaultdict(int)\n    while p*p<=n:\n        while not n%p: d[p] += 1 ; n//=p\n        p += 2-(p==2)\n    if n>1: d[n] += 1\n    return d\n\ndef mul_power(n, k):\n    return reduce(int.__mul__, (f**(n%k and k-n%k) for f,n in factorsOf(n).items()), 1)", "def validate(username, password):\n    print (username, password)\n    if username == 'Timmy' and password == 'password':\n        return 'Successfully Logged in!'\n    elif username == 'Alice' and password == 'alice':\n        return 'Successfully Logged in!'\n    elif username == 'Johny' and password == 'Hf7FAbf6':\n        return 'Successfully Logged in!'  \n    elif username == 'Roger' and password == 'Cheater':\n        return 'Successfully Logged in!'\n    elif username == 'Simon' and password == 'password':\n        return 'Successfully Logged in!'\n    elif username == 'Simon' and password == 'says':\n        return 'Successfully Logged in!'\n    elif username == 'Roger' and password == 'pass':\n        return 'Successfully Logged in!'\n    elif username == 'Admin' and password == 'ads78adsg7dasga':\n        return 'Successfully Logged in!'\n    else:\n        return 'Wrong username or password!'", "pronics = {i * (i+1) for i in range(1000)}\n\ndef is_pronic(n):\n    return n in pronics", "def args_count(*a, **b):\n    count = len(a)\n    count2 = len(b)\n    count3 = count + count2\n    return count3", "def head_smash(a):\n    if type(a) == int: return \"This isn't the gym!!\"\n    if not a: return \"Gym is empty\"\n    return [s.replace('O',' ') for s in a]", "def f(n):\n    a,b = 1,1\n    for _ in range(n+1):\n        a,b = b,a+b\n    return a-1", "from functools import reduce\n\ndef calculate_total(t1, t2):\n    f = lambda t: reduce(lambda a, b: a + b, t, 0)\n    return f(t1) > f(t2)", "from functools import partial\nfrom itertools import accumulate, count, takewhile\nfrom operator import ge\n\n\ndef consecutive_sum(num):\n    return sum(\n        (num - start) % step == 0\n        for step, start in enumerate(takewhile(partial(ge, num), accumulate(count(1))), 1)\n    )", "sort_array=lambda value: \"\".join(sorted(value))", "def pairs(ar):\n    count = 0\n    for i in range(0, len(ar), 2):\n        try:\n            a, b = ar[i], ar[i+1]\n        except IndexError:\n            return count\n        \n        if abs(a-b) == 1: \n            count +=1\n        \n    return count", "def solution(pairs):\n    return ','.join(['{} = {}'.format(*a) for a in sorted(pairs.items())])", "from statistics import mean\n\ndef learn_charitable_game(arr):\n    return not mean(arr)%1 and any(arr)", "def shared_bits(a, b):\n    res=0\n    bina,binb='{:b}'.format(a),'{:b}'.format(b)\n    bina,binb=bina.zfill(max(len(bina),len(binb))),binb.zfill(max(len(bina),len(binb)))\n    for x,y in zip(bina,binb):\n        if x==y=='1':\n            res+=1\n            if res==2:\n                return True\n    return False", "def delete_digit(n):\n    s = str(n)\n    return int(max(s[:i] + s[i+1:] for i in range(len(s))))", "def simple_transposition(text):\n    return f'{text[::2]}{text[1::2]}'\n", "base={'C':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,'E':4,'F':5,'F#':6,'Gb':6,'G':7,'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11,}; minor_or_major=lambda c: \"Not a chord\" if sum(n in base for n in c.split())!=3 else (lambda ns: \"Major\" if (12+base[ns[1]]-base[ns[0]])%12==4 and (12+base[ns[2]]-base[ns[1]])%12==3 else \"Minor\" if (12+base[ns[1]]-base[ns[0]])%12==3 and (12+base[ns[2]]-base[ns[1]])%12==4 else \"Not a chord\")(c.split())", "def rocks(n):\n    r=0\n    i=1\n    while(n>=10**i):\n        r+=i*9*(10**(i-1))\n        i+=1\n    r+=(n-(10**(i-1)-1))*i\n    return r", "import re\n\ndef word_count(s):\n    words = re.findall(r'[a-z]+', s, re.I)\n    return sum(not re.match(r'(a|the|on|at|of|upon|in|as)$', w, re.I) for w in words)", "def str_count(strng, letter):\n    arr = list(strng)\n    i=0\n    for item in arr :\n        if item == letter :\n            i+=1\n    return i\n            \n    # Your code here ;)\n", "def kontti(stg):\n    return \" \".join(k_w(word) for word in stg.split())\n    \ndef k_w(stg):\n    i = next((i for i, c in enumerate(stg.lower()) if c in \"aeiouy\"), -1)\n    return f\"ko{stg[i+1:]}-{stg[:i+1]}ntti\" if i > -1 else stg", "def two_highest(arg1):\n    print(arg1)\n    if not arg1 or len(arg1) < 2:\n        return arg1\n    arg1 = set(arg1)\n    a1 = max(arg1)\n    arg1.remove(a1)\n    a2 = max(arg1)\n    return [a1, a2]", "def best_match(goals1, goals2):\n    return sorted( (a-b, -b, i) for i,(a,b) in enumerate(zip(goals1, goals2)) )[0][2]", "def friend(x):\n    nl = []\n    for f in range(len(x)):\n        if len(x[f]) == 4:\n            nl.append(x[f])\n    return nl", "def locate(seq, value):\n    if isinstance(seq, (tuple, list)):\n        return any(locate(x, value) for x in seq)\n    return seq == value", "def min_value(digits):\n    for i in range(0, len(digits)):\n        digits[i] = str(digits[i])\n    digits = set(digits)\n    digits = sorted(list(digits))\n    return int(\"\".join(digits))", "def is_solved(board):\n    return all(a == b for a, b in enumerate(bx for by in board for bx in by))", "import math\ndef factorial(n):\n    return None if n < 0 else math.factorial(n)", "def levenshtein(a,b):\n    import numpy as np\n    size_x = len(a) + 1\n    size_y = len(b) + 1\n    matrix = np.empty ((size_x, size_y)) \n    matrix[:,0] = list(range(size_x))\n    matrix[0,:] = list(range(size_y))\n\n    for x in range(1, size_x):\n        for y in range(1, size_y):\n            if a[x-1] == b[y-1]:\n                matrix [x,y] = min(\n                    matrix[x-1, y] + 1,\n                    matrix[x-1, y-1],\n                    matrix[x, y-1] + 1\n                )\n            else:\n                matrix [x,y] = min(\n                    matrix[x-1,y] + 1,\n                    matrix[x-1,y-1] + 1,\n                    matrix[x,y-1] + 1\n                )\n    return (int(matrix.item((size_x-1,size_y-1))))\n", "def nb_dig(n, d):\n    return sum(str(i*i).count(str(d)) for i in range(n+1))", "def alphabetic(string):\n       return string == ''.join(sorted(string))", "factorsRange=lambda a,b:{n:[d for d in range(2,n)if not n%d]or['None']for n in range(a,b+1)}", "from collections import defaultdict\n\n\ndef interpreter(tape):\n    cells, cur, output = defaultdict(int), 0, \"\"\n    for c in tape:\n        if c == \">\":\n            cur += 1\n        elif c == \"<\":\n            cur -= 1\n        elif c == \"+\":\n            cells[cur] += 1\n        elif c == \"*\":\n            output = f\"{output}{chr(cells[cur] % 256)}\"\n    return output\n", "def bowling_score(rolls):\n    i = score = 0\n    for _ in range(10):\n        if rolls[i] == 10:\n            score += rolls[i] + rolls[i+1] + rolls[i+2]\n            i += 1\n        elif rolls[i] + rolls[i+1] == 10:\n            score += rolls[i] + rolls[i+1] + rolls[i+2]\n            i += 2\n        else:\n            score += rolls[i] + rolls[i+1]\n            i += 2\n    return score", "import numpy as np\n\ndef getMatrixProduct(a, b):\n    try:\n        return np.matmul(a, b).tolist()\n    except:\n        return - 1", "def abacaba(k):\n    return chr((k & -k).bit_length() + 96)", "from collections import Counter\nfrom functools import lru_cache\nfrom itertools import chain\n\n@lru_cache(maxsize=None)\ndef func(n):\n    return [n] if n&1 else 2*func(n>>1)\n\ndef obtain_max_number(arr):\n    return max(k * (1<<(v.bit_length()-1)) for k,v in Counter(chain.from_iterable(map(func, arr))).items())", "solve=lambda s:sorted(s,key=lambda e:s.rindex(e)-s.index(e)-ord(e)/1000)[-1]", "def vowel_start(stg): \n    return \"\".join(f\"{' ' if c in 'aeiou' else ''}{c}\" for c in stg.lower() if c.isalnum()).lstrip()", "trace=lambda m:None if not m or len(m)!=len(m[0]) else sum([m[i][i] for i in range(len(m))])", "def print_nums(*args):\n    return '\\n'.join(['0'*(len(str(max(args)))-len(str(x)))+str(x) for x in args])", "def is_palindrome(s):\n    for i, (a, b) in enumerate(zip(s, s[::-1])):\n        if a != b:\n            return False\n        if i == len(s) // 2:\n            return True\n\ndef solve(st):\n    for i in range(len(st)):\n        if is_palindrome(st[i:] + st[:i]):\n            return True\n    return False", "def elevator(left, right, call):\n    if abs(left-call) >= abs(right-call):\n        return \"right\"\n    else:\n        return \"left\"", "def thue_morse(n):\n    k = t = 0\n    while t.bit_length() < n:\n        t = t << 2 ** k | ~t & (1 << 2 ** k) - 1\n        k += 1\n    return bin(t).replace('b', '')[:n]", "from re import sub; repeating_fractions=lambda n,d: (lambda div: (lambda index: div[:index]+sub(r\"(\\d)\\1+\",\"(\\g<1>)\",div[index:]))(div.index(\".\")))(str(1.0*n/d))", "def alternateCase(s):\n    result = '';\n    for i in s:\n        if i.isupper():\n            result += i.lower();\n        elif i.islower():\n            result += i.upper();\n        else:\n            result += ' '\n    return result;\n", "import re\n\ndef textin(st):\n    return re.sub(r\"t[wo]?o\", \"2\", st, flags=re.IGNORECASE) \n", "def lcs(x, y):\n    if not (x and y):\n        return ''\n    if x[-1] == y[-1]:\n        return lcs(x[:-1], y[:-1]) + x[-1]\n    else:\n        return max(lcs(x[:-1], y), lcs(x, y[:-1]), key=len)", "def to_nato(words):\n    dictionary = {'A':'Alfa', 'B':'Bravo','C':'Charlie', 'D':'Delta', 'E':'Echo', 'F':'Foxtrot', 'G':'Golf', 'H':'Hotel', 'I':'India', 'J':'Juliett', 'K':'Kilo', 'L':'Lima', 'M':'Mike', 'N':'November', 'O':'Oscar', 'P':'Papa', 'Q':'Quebec', 'R':'Romeo', 'S':'Sierra', 'T':'Tango', 'U':'Uniform', 'V':'Victor', 'W':'Whiskey', 'X':'Xray', 'Y':'Yankee', 'Z':'Zulu'}\n    return ' '.join([dictionary.get(l, l) for l in words.upper().replace(' ','')]).strip()", "def remove(s):\n    return '{}{}'.format(s.replace('!', ''), '!' * (len(s) - len(s.rstrip('!'))))", "def close_compare(a, b, margin=None):\n    if not margin: return -1 if b>a else a>b\n    return -1 if b-margin>a else a-margin>b", "def range_(n):\n    if n > 0:\n        return range(n+1)\n    else:\n        return [-i for i in range(-n+1)]\n\ndef sum_of_n(n):\n    return [sum(range_(i)) for i in range_(n)]", "def sum_str(a, b):\n    return str(int('0' + a) + int('0' + b))", "from itertools import count, islice\n\ndef palindrome(num,s):\n    if isinstance(num, int) and isinstance(s, int) and num > 0 <= s:\n        palindromes = (x for x in count(max(num, 11)) if str(x) == str(x)[::-1])\n        return list(islice(palindromes, s))\n    return 'Not valid'", "def is_bouncy(number):\n    n = str(number)\n    s = ''.join(sorted(n))\n    return s != n != s[::-1]\n", "def is_magical(sq):\n    sums = '123 456 789 147 258 369 159 357'.split()\n    return all(check(sq,x) == 15 for x in sums)\ndef check(sq, entries):\n    return sum(sq[x-1] for x in map(int,entries))", "def rain_amount(mm):\n    if (mm < 40):\n         return \"You need to give your plant {}mm of water\".format(40- mm) # + {rain_amount - 40} + \" mm of water\"\n    else:\n         return \"Your plant has had more than enough water for today!\"", "from collections import Counter\nmost_frequent_item_count=lambda c: Counter(c).most_common(1)[0][1] if c else 0", "def palindrome(num):\n    return 'Not valid' if type(num) is not int or num < 0 else str(num) == str(num)[::-1]", "from statistics import mean\n\nregular = \"Banana Orange Apple Lemon Grapes\"\nspecial = \"Avocado Strawberry Mango\"\nextra = \"\"\n\nmenu = {\n    regular: 5,\n    special: 7,\n    extra: 9\n}\nprices = {\n    juice: price\n    for juices, price in menu.items()\n    for juice in juices.split()\n}\n\ndef mix_fruit(order):\n    return round(mean(prices.get(juice.title(), menu[extra]) for juice in order))", "def transpose(arr):\n    return [] if arr==[] else [[]] if arr[0]==[] else [[arr[i][j] for i in range(len(arr))] for j in range(len(arr[0]))]", "def comm_check(l, p_l, comm_started):\n    if (l == '/' and p_l == '*' and comm_started == 2):\n        return 0\n    if (comm_started == 1 and l == '\\n'):\n        return 0\n    if (l == '-' and p_l == '-'):\n        return 1\n    elif (l == '*' and p_l == '/'):\n        return 2\n    else:\n        return comm_started\n    \n\n\ndef get_textliterals(pv_code):\n    indices = []\n    open_i = -1\n    comm_start = 0\n    for i in range(0, len(pv_code)):\n        comm_start = comm_check(pv_code[i], pv_code[i-1], comm_start)\n        if pv_code[i] == '\\'' and comm_start == 0:\n            if open_i == -1:\n                open_i = i\n            else:\n                if (i + 1 < len(pv_code) and i - 1 >= 0): \n                    if (pv_code[i+1] == '\\'' or pv_code[i-1] == '\\''): continue\n                indices.append((open_i, i + 1))\n                open_i = -1\n    if open_i != -1: indices.append((open_i, len(pv_code)))\n    return indices", "import re\nfrom functools import reduce\ndef solve(s):\n    sign, stack = {('+', '-'): '-', ('-', '+'): '-', ('+', '+'): '+', ('-', '-'): '+'}, []\n    for i in s:\n        if i != ')' : stack.append(i)\n        else:\n            t = len(stack) - stack[::-1].index('(') - 1\n            stack.pop(t)\n            ini = stack[t - 1]\n            if ini in '+-' : stack[t:] = list(re.sub(r'(?<=\\w)([-+])(?=\\w)', lambda x: sign[(ini, x.group(1))], \"\".join(stack[t:])))\n        stack = list(re.sub(r'([-+]+)', lambda g: reduce(lambda x, y: sign[(x, y)], list(g.group())), \"\".join(stack)))\n    return \"\".join(stack).lstrip('+')", "def getVolumeOfCubiod(length, width, height):\n    if length > 0 and width > 0 and height > 0:\n        return length * width * height\n    else:\n        return False", "def vowel_back(st):\n    print(st)\n    changes = {'a':'v', 'b':'k', 'c':'b', 'd':'a','e':'a','f':'f','g':'p','h':'q','i':'i','j':'s','k':'t','l':'u','m':'v','n':'w','o':'n','p':'y','q':'z','r':'a','s':'b','t':'t','u':'p','v':'v','w':'f','x':'g','y':'h','z':'i'}\n    return ''.join(changes[c] for c in st)", "def unique_sum(lst):\n    return sum(set(lst)) if lst else None\n", "digits = {\n    0:[0,0,0,0],   \n    1:[1,1,1,1],   \n    2:[2,4,8,6],   \n    3:[3,9,7,1],   \n    4:[4,6,4,6],   \n    5:[5,5,5,5],   \n    6:[6,6,6,6],   \n    7:[7,9,3,1],   \n    8:[8,4,2,6], \n    9:[9,1,9,1]\n}\ndef last_digit(n1, n2):\n    return digits[n1%10][(n2-1)%4] if n2 else 1", "def narc(n):\n    ds = [int(c) for c in str(n)]\n    return sum(d**len(ds) for d in ds) == n\n\ndef is_narcissistic(*ns):\n    return (\n        all((isinstance(n, int) and n >= 0) or (isinstance(n, str) and n.isdigit()) for n in ns)\n        and all(map(narc, map(int, ns)))\n    )", "from math import factorial\ndef increasing_numbers(d):\n    return factorial(9 + d) / (factorial(d) * factorial(9)) if d > 0 else 1", "def count_inversions(array):\n    n = len(array)\n    return sum([1 for i in range(n) for j in range(n) if (i < j and array[i] > array[j])])", "def solve(arr):\n    route = [road.split() for road in arr]\n    l, re= len(arr), []    \n    dir = {'Left': 'Right', 'Right': 'Left', 'Begin': 'Begin'}\n    for i in range(l):\n        re.insert(0, ' '.join([dir[route[(i+1)%l][0]]] + route[i][1:]))\n    return re", "def pattern(n):\n    return '\\n'.join([''.join(str(i) for i in range(e,n+1)) for e in range( 1,n+1 )])", "def array_center(arr):\n    avg = sum(arr)/len(arr)\n    return [i for i in arr if abs(i - avg) < min(arr)]\n\n", "def big_primefac_div(n):\n    if n % 1:\n        return \"The number has a decimal part. No Results\"\n    n = abs(int(n))\n    mpf = big_primefac(n)\n    return [mpf, big_div(n)] if mpf != n else []\n\ndef big_primefac(n):\n    m = 1\n    while n % 2 == 0:\n        m, n = 2, n//2\n    k = 3\n    while k*k <= n:\n        if n % k:\n            k = k+2\n        else:\n            m, n = k, n//k\n    return max(m, n)\n\ndef big_div(n):\n    return next((n//k for k in range(2, int(n**0.5)+1) if n % k == 0), n)\n", "def who_is_paying(name):\n    if len(name) < 3: return [name]\n    else:\n        first_two = name[0:2]\n        return [name, first_two]\n    \n    \n    \n# Test.assert_equals(who_is_paying(\"Mexico\"),[\"Mexico\", \"Me\"])\n# Test.assert_equals(who_is_paying(\"Melania\"),[\"Melania\", \"Me\"])\n# Test.assert_equals(who_is_paying(\"Melissa\"),[\"Melissa\", \"Me\"])\n# Test.assert_equals(who_is_paying(\"Me\"),[\"Me\"])\n# Test.assert_equals(who_is_paying(\"\"), [\"\"])\n# Test.assert_equals(who_is_paying(\"I\"), [\"I\"])\n", "from random import choices\nfrom itertools import islice, count\n\ndef squares(n):\n    return [a ** 2 for a in range(1, n + 1)]\n\ndef num_range(n, start, step):\n    return list(islice(count(start, step), n))\n\ndef rand_range(n, mn, mx):\n    return choices(range(mn, mx + 1), k = n)\n\ndef primes(n):\n    return list(islice((a for a in count(2) if all(a % b != 0 for b in range(2, 1 + int(a ** 0.5)))), n))", "def is_prime(n,i=2):\n    if (n <= 2):\n        return True if(n == 2) else False\n    elif (n % i == 0):\n        return False\n    elif (i * i > n):\n        return True\n    return is_prime(n, i + 1)", "def combine(*args):\n    result = {}\n    for obj in args:\n        for key, value in obj.items():\n            if not key in result:\n                result[key] = 0\n            result[key] += value\n    return result", "def unflatten(flat_array):\n    dex = 0\n    result = []\n    while dex < len(flat_array):\n        current = flat_array[dex]\n        if current > 2:\n            result.append(flat_array[dex:dex + current])\n            dex += current\n        else:\n            result.append(current)\n            dex += 1\n    return result", "def solve(s):\n    if s == s[::-1]: return \"OK\"\n    for i in range(len(s)):\n        t = s[:i] + s[i+1:]\n        if t == t[::-1]: return \"remove one\"\n    return \"not possible\"", "def nba_extrap(ppg, mpg):\n    return round(48*ppg/mpg, 1)\n\n\n'''An NBA game runs 48 minutes (Four 12 minute quarters).\nPlayers do not typically play the full game, subbing in and out as necessary. \nYour job is to extrapolate a player's points per game if they played the full 48 minutes.\n\nWrite a function that takes two arguments, ppg (points per game) and mpg (minutes per game)\nand returns a straight extrapolation of ppg per 48 minutes rounded to the nearest tenth. \nReturn 0 if 0.'''", "def dashatize(num):\n    array = []\n\n    # \u0412\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0418\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435.\n    if num == None:\n        return \"None\"\n    elif num == 0:\n        return \"0\"\n    elif num == -1:\n        return \"1\"\n\n    # \u0415\u0441\u043b\u0438, \u0432\u0445\u043e\u0434\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0435 - \u0443\u0431\u0440\u0430\u0442\u044c \u043c\u0438\u043d\u0443\u0441.\n    num = str(num).replace('-', '')\n    \n    # \u041f\u0435\u0440\u0435\u0431\u043e\u0440 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0435\u0433\u043e \u043d\u0430 [\u0427\u0451\u0442\u043d\u043e\u0441\u0442\u044c] \u0438 [\u041d\u0435\u0447\u0451\u0442\u043d\u043e\u0441\u0442\u044c].\n    for i in str(num):\n        if int(i) % 2 == 0:\n            array.append(i)\n        else:\n            array.append('-'+ i +'-')\n\n    # \u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u043c \u0432 \u0441\u0442\u0440\u043e\u043a\u0443.\n    string = ''.join(array)\n\n    # \u0424\u0438\u043b\u044c\u0442\u0440\u0443\u0435\u043c.\n    if string[0] == '-' and string[-1] == '-':\n        string = string[1:-1]\n    if string[0] == '-':\n        string = string[1:]\n    if string[-1] == '-':\n        string = string[:-1]\n    result = string.replace('--', '-')\n\n    # \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c [result].\n    return result", "def find_2nd_largest(arr):\n    return next(iter(sorted(n for n in set(arr) if type(n) == int)[-2:-1]), None)", "def omit_hashtag(s, hashtag):\n    return s.replace(hashtag, '', 1)", "def denumerate(enum_list):\n    try:\n        l, d = len(enum_list), dict(enum_list)\n        ret = ''.join(map(d.get, range(l)))\n        assert ret.isalnum() and len(ret) == l\n        return ret\n    except:\n        return False", "import re\ndef insert_dash(num):\n    return re.sub(r'[13579](?=[13579])',r'\\g<0>-', str(num))", "def sum_array(arr):\n    if arr and len(arr) > 3:\n        return sum(arr) - min(arr) - max(arr) \n    return 0", "def my_add(a, b):\n    try:\n        return a + b\n    except TypeError:\n        return None\n", "from string import ascii_uppercase\n\nVALID = set(ascii_uppercase + ' !')\n\n\ndef rad_ladies(name):\n    return ''.join(a for a in name.upper() if a in VALID)\n", "def compute_depth(n):\n    found = set()\n    mult = 1\n    while not set(x for x in range(0,10)) == found:\n        for digit in str(n*mult):\n            found.add(int(digit))\n        mult += 1\n    return mult-1", "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c:i for i,c in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef whoIsWinner(moves, con, sz):\n    def gen(i, j):\n        for x in range(1, con):\n            yield ((i, j-x), (i-x, j), (i+x, j), (i-x, j-x), (i+x, j+x), (i+x, j-x), (i-x, j+x))\n    \n    def check(i, j, p):\n        memo, count = [True]*7, [0]*7\n        for L in gen(i, j):\n            for x,(k,l) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < sz and 0 <= l < sz and grid[k][l] == p\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1]+count[2], count[3]+count[4], count[5]+count[6])+1 >= con\n        return True\n    \n    if sz >= con <= len(moves):\n        grid = [[None]*sz for _ in range(sz)]\n        for move in moves:\n            i, p = D[move[0]], move[-1]\n            j = next(j for j,x in enumerate(grid[i]) if x is None)\n            if check(i, j, p): return p\n            grid[i][j] = p\n    return \"Draw\"", "def max_and_min(arr1, arr2):\n    max_diff, min_diff = float('-inf'), float('inf')\n    for a in arr1:\n        for b in arr2:\n            current_sum = abs(b - a)\n            max_diff = max(max_diff, current_sum)\n            min_diff = min(min_diff, current_sum)\n    return [max_diff, min_diff]\n", "def palindrome_pairs(words):\n    w=list(map(str,words))\n    return [[i,j] for i,a in enumerate(w) for j,b in enumerate(w) if i!=j and a+b == (a+b)[::-1]]", "def locker_run(lockers):\n    return [n*n for n in range(1,int(lockers**.5+1))]", "def unique(integers):\n    return sorted(set(integers), key=integers.index)\n", "def reindeer(presents):\n    assert presents <= 180\n    return 2+presents//30+(1 if presents % 30 else 0)", "def count_sheep(n):\n    x = ''\n    for i in range(1, n+1):\n        x += '%d sheep...'% i\n    return x", "import sys\nsys.setrecursionlimit(10000)\n\n\ndef combs_non_empty_boxes(n,k):\n    if k > n: \n        return 'It cannot be possible!'\n    \n    return stirling(n, k)\n\ndef memoize(f): \n    memo = {}\n    def wrapping(*args): \n        if args not in memo:\n            memo[args] = f(*args)\n        return memo[args]\n    return wrapping\n\n@memoize\ndef stirling(n, k): \n    if n == 0 and k == 0: \n        return 1\n        \n    if n == 0 or k == 0: \n        return 0\n    \n    return k * stirling(n - 1, k) + stirling(n - 1, k - 1)  ", "import math\ndef distance(p1, p2):\n    if p1 == [] or p2 == [] or len(p1) != len(p2): \n        return -1 \n    diff = []\n    for i in range(len(p1)):\n        diff.append((p1[i] - p2[i]) ** 2)\n    return math.sqrt(sum(diff))\n", "def multi_table(number):\n    counter = 1\n    table = \"\"\n    while counter < 11:\n        table += str(counter) + \" * \" + str(number) + \" = \" + str(number * counter)+\"\\n\"\n        counter += 1\n    return table[:-1]\n", "import re\ndef scramble_words(s):\n    li = []\n    for k in s.split():\n        sp_chars = [[i, j] for j, i in enumerate(k) if not i.isalpha()]\n        s = re.sub(r\"[-,.']\", \"\", k)\n        result = [s[0]] + sorted(s[1:-1]) + [s[-1]]\n        for i, j in sp_chars : result.insert(j, i)\n        li.append([\"\".join(result),k][len(k)<4])\n    return \" \".join(li)", "def two_decimal_places(n):\n    s = \"%.2f\" % n\n    res = float(s)\n    return res", "number_format='{:,}'.format", "def avoid_obstacles(arr):\n    s = set(arr)\n    m = max(arr)\n    for i in range(1, m+2):\n        if i in s:\n            continue\n        if not any(x in s for x in range(i, m+1, i)):\n            return i", "year_days = lambda y: \"{} has {} days\".format(y, 365 + (y % 4 == 0) * ((y % 100 != 0) + (y % 400 == 0)) )", "def diagonal_sum(array):\n    return sum( row[idx] for idx, row in enumerate(array) )", "\ndef cal_n_bug(n_head, n_leg, n_wing):\n        n_s=(n_leg-6*n_head)/2\n        n_d=(n_leg-8*n_head+2*n_wing)/2\n        n_b=(-n_leg+8*n_head-n_wing)\n        if n_s>-1 and n_d>-1 and n_b>-1:\n            return [n_s,n_b,n_d] \n        else:\n            return [-1,-1,-1]", "def solve(s):\n    return max(map(len, ''.join(c if c in 'aeiou' else ' ' for c in s).split()))", "def is_lucky(n):\n    x = 0\n    for i in str(n):\n        x  = x + int(i)\n    return True if x % 9 == 0 else False", "def meeting(rooms, need):\n    if need == 0: return \"Game On\"\n    \n    result = []\n    for people, chairs in rooms:\n        taken = min(max(chairs - len(people), 0), need)\n        result.append(taken)\n        need -= taken\n        if need == 0: return result\n        \n    return \"Not enough!\"", "def solve(arr):\n    for x in arr:\n        if not(x*-1 in arr):\n            return x", "def chess_triangle(n, m):\n    if n>m:\n        n,m=m,n\n    if m<=2 or n<2:\n        return 0\n    elif n==2:\n        return (m*2-5)*8\n    else:\n        return (((2*n-4)*(2*n-4)-1)+((m-n)*4*(n-2)))*16\n  #coding and coding..\n", "def count_repeats(txt):\n    return sum(a == b for a, b in zip(txt, txt[1:]))", "from math import log\ndef get_exponent(n, p):\n    if p<=1:return None\n    l,i=None,0\n    while p**i<=abs(n):\n        if n%p**i==0:l=i    \n        i+=1\n    return l", "solve=lambda n:next((((n-x*x)//2//x)**2for x in range(int(n**.5),0,-1)if(n-x*x)%(2*x)==0<n-x*x),-1)", "from collections import Counter\n\ndef palindrome_rearranging(s):\n    return sum(v%2 for v in Counter(s).values()) < 2", "def string_chunk(string, n=None):\n  if isinstance(n, int):\n    if n > 0:\n      return [string[i:i+n] for i in range(0, len(string), n)]  \n    else: return []\n  else: return []\n", "import re\ndef is_mac_48_address(address):\n    return bool(re.match('[0-9A-F]{2}(-[0-9A-F]{2}){5}$', address))", "def divisible_by_three(string):\n    return not (sum(int(n) for n in string) % 3)", "def has_subpattern(stg):\n    l = len(stg)\n    for k in range(2, int(l**0.5) + 1):\n        if l % k == 0:\n            if any(len({stg[i:i+s] for i in range(0, l, s)}) == 1 for s in (l // k, k)):\n                return True\n    return False\n\n# one-liner\n    #return any(any(len({stg[i:i+s] for i in range(0, len(stg), s)}) == 1 for s in (len(stg) // k, k)) for k in range(2, int(len(stg)**0.5)+1) if len(stg) % k == 0)\n", "unique_digit_products=lambda a:len({eval('*'.join(str(n)))for n in a})", "from itertools import chain, zip_longest\ndef alternate_sort(l):\n    return list(filter(lambda x: x is not None, chain(*zip_longest( sorted(filter(lambda x: x<0,l))[::-1],sorted(filter(lambda x: x>-1,l))))))", "import re\nis_valid = lambda id: bool(re.match('^[a-z_$][\\w$]*$', id, re.I))", "def meeting_time(ta, tb, r):\n    if ta == 0:\n        return \"{:.2f}\".format(abs(tb))\n    if tb == 0:\n        return \"{:.2f}\".format(abs(ta))\n    else:\n        return \"{:.2f}\".format(abs(ta * tb / (tb - ta)))", "def people_with_age_drink(age):\n    if age < 14: return \"drink toddy\"\n    if age < 18: return \"drink coke\"\n    if age < 21: return \"drink beer\"\n    return \"drink whisky\"", "def climb(n):\n    result = [1]\n    for x in \"{:b}\".format(n)[1:]:\n        result.append(result[-1]*2 + (x=='1'))\n    return result", "def index(array, n):\n    while True:\n        try:\n            return array[n] ** n \n            break\n        except IndexError:\n            return -1", "def _sum_squares(num):\n    ss = 0\n    while num > 0:\n        div, digit = num // 10, num % 10\n        ss += digit * digit\n        num = div\n    return ss\n\n\ndef _is_happy_number(num):\n    # Check if num is happy number.\n    seens = set()\n    while num > 1:  # stop when num == 1\n        ss = _sum_squares(num)\n        if ss in seens:\n            return False\n\n        seens.add(ss)\n        num = ss\n    return True\n\n\ndef happy_numbers(n):\n    result = []\n    for num in range(1, n + 1):\n        # Check if a num is happy number.\n        if _is_happy_number(num):\n            result.append(num)\n    return result\n", "from heapq import heapify, heappop, heappush\n\n\ndef comb(fruits):\n    heapify(fruits)\n      \n    energy_total = 0\n    while len(fruits) > 1:\n        energy_used = heappop(fruits) + heappop(fruits)\n        heappush(fruits, energy_used)\n        energy_total += energy_used\n    \n    return energy_total\n", "import re\n\ndef seven_ate9(str_):\n    return re.sub(r\"(?<=7)9(?=7)\", \"\", str_)", "from enum import Enum\nclass Numbers(Enum):\n    zero = 0\n    one = 1\n    two = 2\n    three = 3\n    four = 4\n    five = 5\n    six = 6\n    seven = 7\n    eight = 8\n    nine = 9\n    ten = 10\n    eleven = 11\n    twelve = 12\n    thirteen = 13\n    fourteen = 14\n    fifteen = 15\n    sixteen = 16\n    seventeen = 17\n    eighteen = 18\n    nineteen = 19\n    twenty = 20\n    thirty = 30\n    forty = 40\n    fifty = 50\n    sixty = 60\n    seventy = 70\n    eighty = 80\n    ninety = 90\n\n\ndef number_to_name(number):\n    return Numbers(number).name if number < 20 else Numbers(number).name if number < 100 and not number % 10 else (f\"{Numbers(number // 10 * 10).name}-{Numbers(number % 10).name}\" if number < 100 else f\"{Numbers(number // 100).name} hundred\" if not number % 100 else f\"{Numbers(number // 100).name} hundred and {number_to_name(number % 100)}\")\n    \ndef sort_by_name(arr):\n    return sorted(arr,key=number_to_name)", "def number_of_pairs(gloves):\n    return sum(gloves.count(color)//2 for color in set(gloves))", "def greet(name):\n    x = name\n    Y = \"Hello, \" + x + \" how are you doing today?\"\n      \n    return Y", "def to_utf8_binary(string):\n    return ''.join(format(c, '08b') for c in string.encode())\ndef from_utf8_binary(bitstring):\n    bytes_ = [bitstring[i:i+8] for i in range(0, len(bitstring), 8)]\n    return bytes(int(byte, 2) for byte in bytes_).decode()", "import numpy as np\nfrom itertools import accumulate\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype = np.bool)\n    limit = 1 + int(n ** 0.5)\n\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\n\nprimes = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in primes\n    for n in accumulate(s[:-1]):\n        if n in primes:\n            m = s[len(n):]\n            if m in primes or all_primes(m):\n                return True\n\ndef total_primes(a, b):\n    return [int(a) for a in map(str, range(max(10, a), b + 1)) if a in primes and all_primes(a)]", "M = {'^':-1, 'v':1, '<':-1j, '>':1j}\ndef rem(D, k): del D[k]\n\ndef simplify(path):\n    D, z, res = {0:0}, 0, list(path)\n    for i,c in enumerate(path, 1):\n        z += M[c]\n        if z in D:\n            for j in range(D[z], i): res[j] = None\n            [rem(D, k) for k,v in list(D.items()) if v > D[z]]\n        else: D[z] = i\n    return ''.join(filter(None, res))", "def roof_fix(f,r):\n    for i in range(len(r)):\n        if r[i] in \"/\\\\\" and f[i] != ' ':\n            return False\n    return True", "def binary_cleaner(seq): \n    list_a, list_b = [],[]\n    for k,v in enumerate(seq):\n        if v>1:\n            list_b.append(k)\n        else: list_a.append(v)\n    return (list_a, list_b)\n", "def totalAmountVisible(topNum, numOfSides):\n    return numOfSides*(numOfSides-1)//2+topNum-1\n", "from itertools import cycle\ndef interpreter(tape, array):\n    output = \"\"\n    for c in cycle(tape):\n        if not array:\n            return output\n        if c == \"0\":\n            output = output + array[0]\n            array = array[1:]\n        else:\n            array = (\"1\" if array[0] == \"0\" else \"0\") + array[1:]", "def playerRankUp(pts):\n     #your code here\n    congrat = 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n    return congrat if pts >= 100 else False", "from statistics import mean\n\ndef grey(rgb):\n    return [int(round(mean(rgb)))]*3\n\ndef color_2_grey(colors):\n    return [[grey(pixel) for pixel in row] for row in colors]", "def fit_in(a,b,m,n):\n    # You may code here\n    if (a+b)<=m :\n        if  (max(a,b)<=n):        \n            return True             \n        else:        \n            return False\n    elif max(a,b)<=m:\n        if (a+b)<=n:\n            return True\n        else:\n            return False            \n    else:   \n        return False\n", "def even_digit_squares(a, b):\n    return [n**2 for n in range(int(a**0.5)+bool(a**0.5 % 1), int(b**0.5)+1) if not any(int(d) % 2 for d in str(n**2))]\n    \n    \n    \n    #result = []\n    #i = int(a**0.5) + bool(a**0.5 % 1)\n    #j = int(b**0.5) + 1\n    #for n in range(i, j):\n    #    sq = n**2\n    #    if not any(int(d) % 2 for d in str(sq)):\n    #        result.append(sq)\n    #return result\n", "def number(bus_stops):\n    return sum(stop[0]-stop[1] for stop in bus_stops)", "lower = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef one_down(txt):\n    if not isinstance(txt, str):\n        return \"Input is not a string\"\n    shifted = lower[-1] + lower[:-1]\n    table = str.maketrans(lower + lower.upper(), shifted + shifted.upper())\n    return txt.translate(table)", "def is_odd_heavy(arr):\n    maxEven, minOdd = ( f(filter(lambda n: n%2 == v, arr), default=float(\"-inf\")) for f,v in ((max, 0), (min,1)) )\n    return maxEven < minOdd", "import functools\n\ndef multi(l_st):\n    return functools.reduce(lambda x, y: x * y, l_st)\ndef add(l_st):\n    return functools.reduce(lambda x, y: x + y, l_st)\ndef reverse(string):\n    return string[::-1]", "def select(s):\n    s_ = s.split(\", \")\n    li = sum([[j[1:], s_[i+1] if i < len(s_)-1 else \"X\"] for i, j in enumerate(s_) if j[0]==\"!\"],[])\n    return \", \".join([i for i in s_ if i not in li and i[0] != \"!\"])", "def compare(s1,s2):\n    if s1 is None or not s1.isalpha():    s1=\"\"\n    if s2 is None or not s2.isalpha():    s2=\"\"\n    if sum([ord(x) for x in s1.upper()])==sum([ord(x) for x in s2.upper()]):    return True\n    else:    return False", "triangular_sum = lambda n: ((((1+8*n)**0.5 - 1) / 2)**0.5).is_integer()", "def group_by_commas(price):\n    return '{:,}'.format(price)", "from math import log2\ndef toothpick(n):\n    if n == 0:\n        return 0\n    k = int(log2(n))\n    i = n - 2**k\n    if i == 0:\n        return (2**(2*k+1)+1)//3\n    else:\n        return toothpick(2**k) + 2*toothpick(i)+ toothpick(i+1) - 1\n", "def circle_slash(n):\n  #coding and coding..\n  if (n & (n - 1)) == 0:\n      return 1\n  result = 1\n  while result < n:\n      result = result << 1\n  return (n - result / 2) * 2 + 1", "def twos_difference(lst):\n    s = set(lst)\n    return [(n, n+2) for n in sorted(s) if n+2 in s]", "def grabscrab(word, possible):\n    sw = sorted(word)\n    return [w for w in possible if sorted(w) == sw]", "def count_odd_pentaFib(n):\n    if n == 0 :\n        return 0\n    if n < 5:\n        return 1\n    i = 4\n    cnt = 1\n    a, b, c, d, e = 0, 1, 1, 2, 4\n    while i < n:\n        a, b, c, d, e = b, c, d, e, a + b + c + d + e\n        if e % 2 == 1:\n            cnt += 1\n        i += 1\n    return cnt\n", "def longer(s):\n    return ' '.join(sorted(s.split(' '),key = lambda x: (len(x),x)))", "from functools import reduce\n\ndef crashing_weights(weights):\n    return reduce(lambda a, b: [a1 + b1 if a1 > b1 else b1 for a1, b1 in zip(a, b)], weights)", "def create_array(n):\n    res=[]\n    i=1\n    while i<=n:\n        res.append(n)\n        n=n-i\n    return res[::-1]", "import re\n\ndef derivative(eq):\n    monos = re.findall(r'([+-]?)(\\d*)x\\^?(\\d*)', eq)\n    result = ''\n    for sign, coef, exp in monos:\n        exp = int(exp or '1')\n        coef = int(coef or '1') * exp\n        result += f'{sign}{coef}x^{exp-1}'\n    result = re.sub(r'x\\^0|\\^1\\b', '', result)\n    return result or '0'", "def triple_double(num1, num2):\n    num1, num2 = str(num1), str(num2)\n    for num in '0123456789':\n        if num * 3 in num1 and num * 2 in num2:\n            return 1\n    return 0", "import re\ndef to_cents(amount):\n  return int(re.sub(\"\\D\", \"\", amount)) if re.match(\"\\$\\d*\\.\\d{2}\\Z\", amount) else None", "def palindrome(num):\n    if not (isinstance(num, int) and num > 0):\n        return 'Not valid'\n    s = str(num)\n    result = set()\n    for i in range(0, len(s)-1):\n        for j in range(i+2, len(s)+1):\n            if s[i] == '0':\n                continue\n            x = s[i:j]\n            if x == x[::-1]:\n                result.add(int(x))\n    if result:\n        return sorted(result)\n    return 'No palindromes found'", "import re\n\ndef pete_talk(speech, ok = []):\n    ok = [i.lower() for i in ok]\n    def repl(m):\n        if m.group('word') not in ok:\n            return m.group('word')[0] + '*' * len(m.group('reppart')) + m.group('word')[-1]\n        else: return m.group('word')\n            \n    replaced = re.sub('(?P<word>[\\w](?P<reppart>[\\w]+)[\\w])', repl, speech.lower())\n    capitalized = re.sub('(?P<sent>[.!?]+\\s*|\\A\\s*)(?P<word>\\s*[a-z])', lambda m: m.group('sent') + m.group('word').capitalize(), replaced)\n    return capitalized", "func = lambda n: sum(map(int, str(n)))\n\n# Fuck it, brute-force\ndef min_and_max(l, d, x):\n    while func(l) != x: l += 1\n    while func(d) != x: d -= 1\n    return [l, d]", "def trotter(n):\n    if not n: return \"INSOMNIA\"\n    \n    seen, o = set(str(n)), n\n    while len(seen) != 10:\n        n += o\n        seen |= set(str(n))\n    return n", "def check_alive(health):\n    if (0<health<=10):\n        return True \n    else:\n        return False", "def LDTA(n):\n    digits = []\n    num = 1\n    pow = 1\n    while num < n**pow and pow < 20:\n        num *= n\n        pow += 1\n        if len(digits) == 10:\n            return digits[-1]\n        else:\n            for d in str(num):\n                if int(d) not in digits:\n                    digits.append(int(d))\n    return None", "def interpreter(tape):\n    selector = 0\n    output = \"\"\n    array = [0]\n    commandIndex = 0\n    \n    while(True):\n      command = tape[commandIndex%len(tape)]\n      \n      if command == '>':\n        selector+=1;\n        if selector == len(array):\n          array.append(0)\n      \n      if command == '<':\n        if selector == 0:\n          array = [0] + array  \n        else:\n          selector-=1;\n        \n      if command == '+':\n        array[selector]+=1;\n        if array[selector] == 256:\n          array[selector] = 0\n      if command == '-':\n        array[selector]-=1;\n        if array[selector] == -1:\n          array[selector] = 255\n      if command == '/':\n        if array[selector] == 0:\n          commandIndex += 1\n      if command == '\\\\':\n        if array[selector] != 0:\n          commandIndex += 1\n      if command == '*':\n        output = output + chr(array[selector])\n      if command == '&':\n        return output        \n      commandIndex+=1  \n    return output", "def total_bill(s):\n    n,r=divmod(s.count('r'),5)\n    return 8*n+2*r", "import numpy as np\n\ndef rotate_against_clockwise(matrix, times):\n    return np.rot90(matrix, times).tolist()", "def similarity(a, b):\n    a, b = set(list(a)), set(list(b))\n    return len(a.intersection(b)) / len(a.union(b))", "def sum_nested(lst):\n    s = 0\n    for l in lst:\n        if type(l) == list:\n            s += sum_nested(l)\n        else:\n            s += l\n    return s", "def basereduct(n):\n    base_numbers = {'0': 1, '1': 2, '2': 3, '3': 4, '4': 5, '5': 6, '6': 7, '7': 8, '8': 9, '9': 11}\n    conversion = 0\n    while len(str(n)) > 1:\n        n = int(str(n), base_numbers[max(str(n))])\n        conversion += 1\n        if conversion > 150:\n            return -1\n    return n", "def convert(st):\n    return st.replace('o','u').replace('a','o')", "two_digit_primes = set('11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97'.split())\n\n# pregenerate eligible numbers\nnumbers = []\nfor n in range(11, 9799 +1):\n    if str(n)[:2] in two_digit_primes:\n        for ending in (0, 1, 25, 76):\n            candidate = n*100 + ending\n            if str(candidate**2)[:2] in two_digit_primes:\n                numbers.append(candidate)\n    \ndef solve(a, b):\n    return sum(1 for n in numbers if a <= n < b)\n", "def how_many_dalmatians(n):\n  dogs = [\"Hardly any\", \"More than a handful!\", \"Woah that's a lot of dogs!\", \"101 DALMATIONS!!!\"];\n  \n  if n <= 10:\n    respond = dogs[0] \n  elif n <= 50:\n    respond = dogs[1]\n  else:\n    if n == 101:\n        respond = dogs[3]\n    else:\n        respond = dogs[2]\n  return respond", "def stairs(n):\n    a = [' '.join([str(e)[-1] for e in range(1, i+2)] + [str(i - e + 1)[-1] for e in range(i+1)]) for i in range(n)]\n    return '\\n'.join(e.rjust(4 * n - 1) for e in a)", "def braces_status(s):\n    order = [\"X\"]\n    for i in s:\n        if i in \"({[\" : order.append(\")}]\"[\"({[\".index(i)])\n        elif i in \")}]\":\n            if order.pop()!=i : return 0\n    return len(order)==1", "def triangular_range(start, stop):\n    return {i:i*(i+1)/2 for i in range(stop) if start <= i*(i+1)/2 <= stop}\n", "def check_exam(arr1, arr2):\n\n    q = 0\n    for i,j in zip(arr1,arr2):\n        if i == j:\n            q += 4\n        elif i != j and j != '':\n            q -= 1\n    if q > 0:\n        return q\n    else:\n        return 0\n", "def greet(name):\n    # your code here\n    if name == \"\":\n        return None\n    elif isinstance(name,str):\n        return \"hello \"+ name + \"!\"\n    else:\n        return None", "from itertools import cycle\n\ndef thirt(n):\n    c = cycle([1, 10, 9, 12, 3, 4])\n    m = sum( int(l)*next(c) for l in str(n)[::-1] )\n    return m if m == n else thirt(m)", "from re import search\ndef validate_time(time):\n    return bool(search('^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$', time))", "def greet(name, owner):\n    if name == owner:\n        return 'Hello boss'\n    else:\n        return 'Hello guest'\n#print greet('Greg', 'Daniel')\n", "\nimport re\ndef parse_mana_cost(mana):\n    n={c:mana.lower().count(c) for c in 'wubrg' if mana.lower().count(c)>0}\n    m=re.split(r'\\D',mana)   \n    if sum(n.values())+sum([len(c) for c in m]) != len(mana): return None\n    p = sum([int(c) for c in m if c!=''])\n    if p>0: n['*']=p\n    return n\n", "def Guess_it(n,m):\n  #May the force be with you.\n    if n == 0:\n        return [[]]\n    arrayStorage = {\n        0: [],\n        1: [],\n        2: [],\n        3: [[0, 0, 1]],\n        4: [[0, 1, 0]],\n        5: [[1, 0, 0]]\n    }\n    if m in arrayStorage:\n        return arrayStorage[m]\n    for i in range(6, m + 1):\n        # Case 1: comparing against 3\n        arrayStorage[i] = []\n        arraysTemp = arrayStorage[i - 3]\n        for array in arraysTemp:\n            if sum(array) < n:\n                elemToAdd = [array[0], array[1], array[2] + 1]\n                if elemToAdd not in arrayStorage[i]:\n                    arrayStorage[i].append(elemToAdd)\n\n        # Case 2: comparing against 4\n        arraysTemp = arrayStorage[i - 4]\n        for array in arraysTemp:\n            if sum(array) < n :\n                elemToAdd = [array[0], array[1] + 1, array[2]]\n                if elemToAdd not in arrayStorage[i]:\n                    arrayStorage[i].append(elemToAdd)\n\n        # Case 3 against 5\n        arraysTemp = arrayStorage[i - 5]\n        for array in arraysTemp:\n            if sum(array) < n:\n                elemToAdd = [array[0] + 1, array[1], array[2]]\n                if elemToAdd not in arrayStorage[i]:\n                    arrayStorage[i].append(elemToAdd)\n\n    resultArray = []\n    for array in arrayStorage[m]:\n        if sum(array) == n:\n            resultArray.append(array)\n    return sorted(resultArray, key=lambda x: x[0])", "def is_divisible(n,x,y):\n    num = n\n    num1 = x\n    num2 = y\n    if ((num % x) == 0) and ((num % y) == 0) :\n        return True\n    else :\n        return False", "from math import pi\n\ndef sum_circles(*rs):\n    total = int(round(sum(pi * r**2 / 4 for r in rs)))\n    return 'We have this much circle: {}'.format(total)", "def reverseWords(s):\n    ls = s.split()\n    lsn = ls[::-1]\n    return ' '.join(lsn)", "def queue_time(customers, n):\n    time = 0\n    while len(customers[:])>0:\n      time=time+1\n      customers[:n]=[x-1 for x in customers[:n]]\n      customers=[y for y in customers if y !=0]\n    return time", "def find_unknown_number(x,y,z):    \n    return (x*70 + y*21 + z*15) % 105 or 105", "def get_strings(city):\n    myMap = {}\n    for i in range(len(city)):\n        letter = city[i].lower()\n        if letter not in myMap:\n            myMap[letter] = 1\n        else:\n            myMap[letter] = myMap.get(letter)+1\n\n    myMap.pop(' ', None)\n\n\n    result = ''\n    for item in myMap:\n        result = result + item + ':'\n        for i in range(myMap.get(item)):\n            result += '*'\n        result += ','\n\n\n    return result[:-1]", "def divide(weight):\n        return weight > 2 and not weight % 2", "generate_hashtag=lambda d:(lambda b:d>''<b==b[:139]and'#'+b)(d.title().replace(' ',''))", "sum_of_a_beach=lambda beach:beach.lower().count('water')+beach.lower().count('sand')+beach.lower().count('fish')+beach.lower().count('sun')", "def change(st):\n    s = set(filter(str.isalpha, st.lower()))\n    return ''.join('01'[chr(97+i) in s] for i in range(26))", "def _coefs(l):\n    n = 1\n    for i in range(l):\n       yield n\n       n = n * (l-i-1) // (i+1)\n    yield n\n\ndef reduce_pyramid(base):\n    coefs = _coefs(len(base))\n    return sum(next(coefs)*n for n in base)", "import math\ndef movie(card, ticket, perc):\n    sysA = ticket\n    sysB = ticket*perc\n    count = 1\n    while card+math.ceil(sysB) >= sysA:\n        sysA+=ticket\n        sysB = (sysB) + (ticket)*(perc**(count+1))\n        count+=1\n        \n    return count", "from operator import itemgetter\n\ndef SJF(jobs, index):\n    total = 0\n    for i, duration in sorted(enumerate(jobs), key=itemgetter(1)):\n        total += duration\n        if i == index:\n            return total", "sextuplets=[\n    [7, 11, 13, 17, 19, 23],\n    [97, 101, 103, 107, 109, 113],\n    [16057, 16061, 16063, 16067, 16069, 16073],\n    [19417, 19421, 19423, 19427, 19429, 19433],\n    [43777, 43781, 43783, 43787, 43789, 43793],\n    [1091257, 1091261, 1091263, 1091267, 1091269, 1091273],\n    [1615837, 1615841, 1615843, 1615847, 1615849, 1615853],\n    [1954357, 1954361, 1954363, 1954367, 1954369, 1954373],\n    [2822707, 2822711, 2822713, 2822717, 2822719, 2822723],\n    [2839927, 2839931, 2839933, 2839937, 2839939, 2839943],\n    [3243337, 3243341, 3243343, 3243347, 3243349, 3243353],\n    [3400207, 3400211, 3400213, 3400217, 3400219, 3400223],\n    [6005887, 6005891, 6005893, 6005897, 6005899, 6005903]]\ndef find_primes_sextuplet(sum_limit):\n    for t in sextuplets:\n        if sum(t)>sum_limit:\n            return t", "def divisor_sum(n):\n    s = 0; i = 1\n    while i*i<=n:\n        if n%i==0: s+=i+n//i\n        i+=1\n    if (i-1)**2 == n: s -= (i-1)\n    return s\n\nratios = {}\nfor i in range(2,7001):\n    d = divisor_sum(i); ratio = d/i\n    if ratio in ratios: ratios[ratio] += [i]\n    else: ratios[ratio] = [i]\nratios = [v for k, v in ratios.items() if len(v)>1]\n\ndef solve(a,b):\n    d = [[r for r in v if r>=a and r<b] for v in ratios]\n    return sum(min(v) for v in d if len(v)>1)", "from collections import Counter\ndef find_it(l):\n    return [k for k, v in Counter(l).items() if v % 2 != 0][0]", "def get_sum(a, b):\n    return (a + b) * (abs(a - b) + 1) / 2", "def find_closest_value(m):\n    if m < 4:\n        return 4\n    l = [130 * k ** 2 + k * i * 65 + a for i, a in enumerate([4, 13, 69, 130], 1) for k in [int((m // 130) ** 0.5) - 1, int((m // 130) ** 0.5)]]\n    return min(l, key = lambda x: (abs(m - x), -x))", "binary_pyramid=lambda m,n:bin(sum(int(bin(e)[2:]) for e in range(m,n+1)))[2:]", "def find_all(array, n):\n    return [ i for i,v in enumerate(array) if v==n ]", "def land_perimeter(grid):\n    s, m = len(grid), len(grid[0])\n    ans = 0\n    for x in range(s):\n        for y in range(m):\n            if grid[x][y] == 'X':\n                ans += 4\n                if x < s - 1 and grid[x+1][y] == 'X':\n                    ans -= 2\n                if y < m - 1 and grid[x][y+1] == 'X':\n                    ans -= 2\n                    \n    return ('Total land perimeter: {}'.format(ans))", "def word_pattern(pattern, string):\n    words = string.split(\" \")\n    return len(pattern) == len(words) and len(set(zip(pattern, words))) == len(set(pattern)) == len(set(words))", "from math import factorial\n\ndef am_i_wilson(n):\n    #your code here\n    return True if n > 1 and n < 1000 and (factorial((n-1)) + 1) % n**2 == 0 else False", "def the_biggest_search_keys(*keywords):\n  return ', '.join(sorted(f\"'{x}'\" for x in keywords if len(x) == max(map(len, keywords)))) if keywords else \"''\"", "def case_unification(s):\n  n = sum(c.islower() for c in s)\n  return s.lower() if n > len(s) - n else s.upper()\n", "def length_of_sequence(arr,n):\n    return (len(arr) - arr[::-1].index(n) - 1) - arr.index(n) + 1 if arr.count(n) == 2 else 0", "decompose_single_strand=lambda d:'\\n'.join('Frame %d: %s'%(4-i,' '.join(map(''.join,zip(*[iter(' '*i+d+'  ')]*3))).strip())for i in(3,2,1))", "def my_crib(n):\n    mult = (2*n) - 1\n    top_roof = \"_\" * ((n*2)+1)\n    top_roof = top_roof.center((n*6)+1, ' ')\n    resulty = ''\n    resulty += top_roof + '\\n'\n    for i in range(n*2):\n        medium_roof = '/' + '_' * int((2*(i + n) + 1)) + '\\\\'\n        medium_roof = medium_roof.center((n*6)+1, ' ')\n        resulty += medium_roof + '\\n'\n    for j in range(n - 1):\n        top_house = '|' + ' ' * ((n*6) - 1) + '|'\n        resulty += top_house + '\\n'\n    upper_door = '|' + ' '*(n*2) + '_'*mult + ' '*(n*2) + '|'\n    resulty += upper_door + '\\n'\n    for h in range(n - 1):\n        medium_house = '|' + ' '*mult + '|' + ' '*mult + '|' + ' '*mult + '|'\n        resulty += medium_house + '\\n'\n    basement = '|' + '_'*mult + '|' + '_'*mult + '|' + '_'*mult + '|'\n    resulty += basement\n    return resulty", "def even_or_odd(number):\n    if number % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\neven_or_odd(0)\nprint(even_or_odd)\n", "get_users_ids = lambda string: [x.strip()[3:].strip() for x in string.lower().replace('#','').split(', ')]", "def guess_hat_color(a,b,c,d):\n    return (2, 1)[b==c]", "import re\ndef true_binary(n):\n    s = bin(n)[2:]\n    s = re.sub(r'0+1', lambda x: '1' + '0'*(len(x[0])-1), s)\n    return [1 if c == '1' else -1 for c in s]", "from collections import deque\n\ndef buy_newspaper(s1,s2):\n    if set(s2) - set(s1):\n        return -1\n    q = deque(s1)\n    n = 0\n    for c in s2:\n        i = q.index(c)\n        n += i + 1\n        q.rotate(-i-1)\n    return n // len(s1) + (n % len(s1) > 0)\n", "def maximum_product(arr):\n    pos = [x for x in arr if x > 0]\n    neg = [x for x in arr if x < 0]\n    if 0 in arr:\n        return min(neg) if len(neg) % 2 or (arr.count(0) - 1 and len(neg)) else 0\n    if len(neg) % 2: return max(neg)\n    return min(pos) if len(pos) else min(neg)", "def bus_timer(time):\n    print(time)\n    hour,mins=map(int,time.split(\":\"))\n    mins+=hour*60\n    if 0<=mins<355 or mins>1435:return 355-mins+1440*(mins>1435)\n    mins=10-mins+((mins//15)*15)\n    return mins+15*(mins<0)", "def cheapest_quote(papers):\n\n    prices = {40:3.85, 20:1.93, 10:0.97, 5:0.49, 1:0.10}\n    cost = 0\n    \n    for price in prices:\n        cost += (papers // price) * prices[price]\n        papers %= price\n    \n    return round(cost, 2)\n    \n    # 7kyu kata number one thousand\n", "from collections import Counter\n\ndef majority(arr):\n    c = Counter(arr).most_common(2) + [(0,0)]*2\n    if c[0][1] != c[1][1]:\n        return c[0][0]", "def sort_by_height(arr):\n    s=sorted(n for n in arr if n!=-1)\n    return [n if n==-1 else s.pop(0) for n in arr]", "from math import log2\n\nns=[\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\"]\n\ndef get_note(p):\n    return ns[round(log2(p/55)*12)%12]", "import re\ndef short_form(s):\n    return s[0] + re.sub(r'[aeiou]', '', s[1:-1], flags=re.I) + s[-1]", "def primeFactors(n):\n    s=str()\n    for i in range(2, int(n**(1/2))+1):\n        j=0\n        while n/i%1==0.0:\n            j+=1\n            n/=i\n        if j>1:\n            s+=\"(\"\n            s+=str(i)\n            s+=\"**\"\n            s+=str(j)\n            s+=\")\"\n        if j==1:\n            s+=\"(\"\n            s+=str(i)\n            s+=\")\"\n    if n!=1:\n        s+=\"(\"\n        s+=str(int(n))\n        s+=\")\"\n        return s         \n    else:\n        return s        ", "import re\ndef is_letter(s):\n    return bool(re.fullmatch(\"[A-Za-z]\",s))", "womens_age = lambda Q : f\"{Q}? That's just 2{1 & Q}, in base {Q >> 1}!\"", "def any_odd(x):\n    return '1' in list(bin(x)[-2::-2])", "from collections import Counter\n\ndef only_duplicates(string):\n    cs = Counter(string)\n    return ''.join(c for c in string if cs[c] > 1)", "slogan_maker=lambda a:list(map(' '.join,__import__('itertools').permutations(dict.fromkeys(a))))", "from itertools import permutations\n\ndef rearranger(k, *args):\n    options = sorted(permutations(args, len(args)), key=lambda option: (''.join(str(x) for x in option), option))\n    res = \"There is no possible rearrangement\"\n    for option in options: \n        aux = int(''.join(str(x) for x in option))\n        if aux%k==0: \n            res = \"Rearrangement: {} generates: {} divisible by {}\".format(', '.join(str(x) for x in option), aux, k)\n            break\n    return res\n", "def sort_poker(john, uncle):\n    suits = ('S', 'D', 'H', 'C')\n    values = ('2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A')\n    get_value = lambda index, hand: hand[index + 1:index + 3] if hand[index + 1] == '1' else hand[index + 1]\n    get_all_indexes = lambda suit, hand: [i for i in range(len(hand)) if hand.startswith(suit, i)]\n    get_cards = lambda hand: {suit: [get_value(index, hand) for index in get_all_indexes(suit, hand)] for suit in suits}\n    get_suit_rating = lambda hand: list(dict.fromkeys(symbol for symbol in hand if symbol in suits))\n    johns_hand = sorted([(suit, sorted([card for card in value], key=lambda x: values.index(x)))\n                         for suit, value in list(get_cards(john).items())], key=lambda x: get_suit_rating(uncle).index(x[0]))\n    return ''.join(''.join(suit[0] + value for value in suit[1]) for suit in johns_hand)\n", "def group_cities(seq):\n    res = {}\n    for w in seq:\n        temp = [str(w[i:] + w[:i]).title() for i in range(1, len(w)) \n                if str(w[i:] + w[:i]).title() in seq]\n        temp.append(w)\n        res[frozenset(temp)] = sorted(set(temp))\n    return sorted(res.values(), key=lambda x: (-len(x), x[0]))", "from datetime import datetime\n\ndef solve(arr):\n    dts = [datetime(2000, 1, 1, *map(int, x.split(':'))) for x in sorted(arr)]\n    delta = max(int((b - a).total_seconds() - 60) for a, b in zip(dts, dts[1:] + [dts[0].replace(day=2)]))\n    return '{:02}:{:02}'.format(*divmod(delta//60, 60))", "from math import floor, log, pi\n\ndef count(n):\n    return floor( ((n+0.5)*log(n) - n + 0.5*log(2*pi))/log(10) ) + 1", "def mult_triangle(n):\n    total = (n * (n + 1) // 2) ** 2\n    odd = ((n + 1) // 2) ** 4\n    even = total - odd\n    return [total, even, odd]", "def my_first_kata(a,b):\n    if (type(a)== int) and (type(b) == int):\n        return a % b + b % a\n    else: \n        return 0", "def well(x):\n  good_ideas = x.count('good')\n  if good_ideas == 0:\n       return 'Fail!'\n  elif good_ideas <= 2:\n      return 'Publish!'\n  else:\n      return 'I smell a series!'", "def words_to_object(s):\n    words = s.split()\n    \n    res = []\n    \n    for key in range(0, len(words) - 1, 2):\n        value = key + 1\n        \n        res.append(\"{name : \" + \"'\" + words[key] + \"'\" + \", \" + \"id : \" + \"'\" + words[value] + \"'}\")\n    \n    return \"[\" + \", \".join(res) + \"]\"", "def work_needed(projMin, others):\n    h, m   = map(sum, zip(*others))\n    needed = projMin - sum(t*c for t,c in zip((h,m),(60,1)) )\n    return \"Easy Money!\" if needed <= 0 else f\"I need to work {needed//60} hour(s) and {needed%60} minute(s)\"", "def closest_pair_tonum(lim):\n    return next((m, n) for m in range(lim-1, 0, -1) for n in range(m-1, 0, -1) if not ((m+n)**0.5%1 or (m-n)**0.5%1))\n", "def arr(n=0):\n    if not arr:\n        return []\n    new_list = []\n    for element in range(n):\n        new_list.append(element)\n    return new_list", "def find_average(nums):\n    sum = 0\n    if len(nums) >0:\n        for i in nums:\n            sum += i\n        return sum/len(nums)\n    else:\n        return 0", "solve=lambda s,s1:any(s.count(i)>=2 and i not in s1 for i in s) or 2", "solve=lambda s:len(__import__('re').match(r'^(.*).*\\1$',s).group(1))", "def missing(nums, s):\n    ans = []\n    s = s.replace(' ','')\n    try:\n        for i in sorted(nums):\n            ans.append(s[i])\n        return ''.join(ans).lower()\n    except IndexError:\n        return (\"No mission today\")", "def calc_type(a, b, res):\n    dict = {a+b:'addition',a-b:'subtraction',a*b:'multiplication',a/b:'division'}\n    return dict[res]", "import re\n\ndef string_expansion(s):\n    return re.sub('(\\d)+([a-zA-Z]*)', lambda m: ''.join(ch * int(m.group(1)) for ch in m.group(2)), s)", "def make_readable(n):\n    return f'{n//3600:02d}:{(n%3600)//60:02d}:{n%60:02d}'\n", "import calendar\nimport datetime\n\n\ndef unlucky_days(year):\n    start_date = datetime.date(year, 1, 1)\n    end_date = datetime.date(year, 12, 31)\n    delta = datetime.timedelta(days=1)\n    counter = 0\n    while start_date <= end_date:\n        year = int(str(start_date)[:4])\n        month = int(str(start_date)[5:7])\n        day = int(str(start_date)[8:10])\n        if day == 13 and calendar.weekday(year, month, day) == 4:\n            counter += 1\n        start_date += delta\n    \n    return counter\n", "import math\nhow_many_times = lambda year,ind: math.ceil(year/ind)\n", "import math\n\n\ndef two_decimal_places(number):\n    return math.trunc(number * 100.0) / 100.0\n", "import re\ndef trump_detector(s):\n    r = re.findall(r'a+|e+|i+|o+|u+', s, re.I)\n    return round(sum(len(i) - 1 for i in r) / len(r),2)", "enough = lambda cap, on, wait: 0 if cap - on - wait >= 0 else abs(cap - on - wait)", "def mouth_size(s): return \"small\" if s.lower() == \"alligator\" else \"wide\"", "def solve(st,k):\n    return max(int(st[i:i+len(st)-k]) for i in range(0, len(st) - (len(st)-k) + 1))", "motif_locator = lambda s,m: sorted(list({s.find(m, e)+1 for e, i in enumerate(range(len(s))) if s.find(m, e) != -1}))", "def get_ages(sum_, difference):\n    x=(sum_+difference)/2\n    y=sum_-x\n    return None if any(e<0 for e in(x,y,sum_,difference)) else (x,y)", "def sito(m, n):\n    \"\"\"Sito Erastotenesa\"\"\"\n    numbers = [x for x in range(0, n+1)]\n    numbers[0], numbers[1] = False, False\n    primes = {}\n    for i,x in enumerate(numbers):\n        if x:\n            if x >= m:\n                primes[x] = x\n            index = i**2\n            while index < len(numbers):\n                numbers[index] = False\n                index += x\n    return primes\n                \n\ndef primes_a_p(lower_limit, upper_limit):\n    primes = sito(lower_limit, upper_limit)\n    longest_gap = (upper_limit-lower_limit) // 5\n    ap_primes = []\n    for i in list(primes.keys()):\n        for gap in range(2,longest_gap, 2):\n        \n            if primes[i]+5*gap <= upper_limit:\n                check = [primes[i]+n*gap for n in range(0,6)]\n                if any(num not in primes for num in check):\n                    pass\n                else:\n                    ap_primes.append(check)\n    return ap_primes\n", "def calc(s):\n    total1 = ''.join(map(lambda c: str(ord(c)), s))\n    total2 = total1.replace('7', '1')\n    return sum(map(int, total1)) - sum(map(int, total2))", "\n\ndef converter(mpg):\n    return round(0.3540061*mpg,2)\n", "def split_in_parts(s, p): \n    l=[]\n    i=0\n    while i < len(s):\n          k=s[i:i+p]\n          l.append(k)\n          i+=p\n    res=\" \".join(l)\n    return res\n", "def what_century(year):\n    n = (int(year) - 1) // 100 + 1\n    return str(n) + (\"th\" if n < 20 else {1: \"st\", 2: \"nd\", 3: \"rd\"}.get(n % 10, \"th\"))", "def will_it_balance(stick, terrain):\n    com = sum(i*w for i,w in enumerate(stick))/sum(stick)\n    return terrain.index(1)<=com<=max(i for i,v in enumerate(terrain) if v==1)", "from statistics import mean\n\ndef avg_array(arrs):\n    return [mean(arr) for arr in zip(*arrs)]", "from collections import deque, defaultdict\n\ndef calc(cards):\n    memo = defaultdict(int)\n    ans = 0\n    q = deque([(1, 0, tuple(cards))])\n    while q:\n        i, score, remains = q.popleft()\n        if len(remains) == 1:\n            score += remains[0] * 2 ** i\n            if score > ans:\n                ans = score\n        else:\n            score_l = score + (remains[0] * 2 ** i)\n            if score_l > memo[remains[1:]]:\n                memo[remains[1:]] = score_l\n                q.append((i + 1, score_l, remains[1:]))\n            score_r = score + (remains[-1] * 2 ** i)\n            if score_r > memo[remains[:-1]]:\n                memo[remains[:-1]] = score_r\n                q.append((i + 1, score_r, remains[:-1]))\n    return ans", "def replace_letters(word):\n  return word.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz','zeeediiihooooonuuuuutaaaaa')) \n", "def even_fib(m):\n    a, b, total = 1, 1, 0\n    \n    while a < m:\n        if a % 2 == 0:\n            total += a\n        a, b = b, a + b\n    \n    return total", "from itertools import combinations\n\ndef strings_crossover(arr, result):\n    return sum(all(a in b for a, b in zip(result, l)) for l in (zip(*c) for c in combinations(arr, 2)))", "def div_con(x):\n    integer = []\n    string = []\n    for element in x:\n        if type(element) == int:\n            integer.append(element)\n        else:\n            string.append(int(element))\n    return sum(integer) - sum(string)", "def is_inertial(arr):\n    mx   = max(arr, default=1)\n    miO  = min((x for x in arr if x%2==1), default=float(\"-inf\"))\n    miE2 = max((x for x in arr if x%2==0 and x!=mx), default=float(\"-inf\"))\n    return mx%2 == 0 and miE2 < miO", "solve=lambda Q,S:not __import__('re').sub(Q.replace('*','.*'),'',S)", "def parity_bit(s):\n  return ' '.join('error' if x.count('1') % 2 else x[:-1] for x in s.split())", "def reverse_invert(lst):\n    return [(-1)**(v>0)*int(str(abs(v))[::-1]) for v in lst if isinstance(v,int)]", "# METHOD ONE ~ list comprehension\n\"100 seconds per 1000 runs of Lorem Ipsum\"\n# def anagram_counter(s):\n#     return sum([1for i,c in enumerate(s)for w in s[i+1:]if sorted(c)==sorted(w)])\n\n# METHOD TWO ~ standard iteration\n\"50 seconds per 1000 runs of Lorem Ipsum\"\n#def anagram_counter(words):\n#    anagram_count = 0\n#    for i, current in enumerate(words):#                    FUN FACT:\n#        cenrrtu = sorted(current)\n#        for word in words[i+1:]:\n#            if cenrrtu == sorted(word):#     Lorum Ipsum contains 6,862 anagram matches\n#                anagram_count += 1\n#    return anagram_count\n\n# METHOD THREE ~ comparing sets to counts\n\"0.5 seconds per 1000 runs of Lorem Ipsum\"\ndef run_down(number):\n    count = 0\n    while number:\n        count += number - 1\n        number -= 1\n    return count\n\ndef anagram_counter(words):\n    sorts = list(''.join(sorted(word)) for word in words)\n    unique = set(sorts)\n    return sum(run_down(sorts.count(word)) for word in unique)\n    \n\"\"\"\niterations     _comp_    _iter_    _sets_\n1              0.0990    0.0541    0.0008\n10             1.0113    0.4954    0.0054\n100            9.9280    4.8606    0.0535\n1000         101.2153   50.2576    0.5660\n\"\"\"", "def solve(a,b):\n    li,j = [],2\n    while b>1:\n        if b%j : j+=1 ; continue\n        li.append(j) ; b//=j\n        if a%j:return 0\n    return 1", "from math import log\nfrom math import floor\n\ndef strongest_even(n,m):\n    a=2**floor(log(m)/log(2));b=1;    \n    while a*b<n or a*b>m:\n        a /= 2;\n        b += 2;\n        while a*b<=m:\n            if a*b>=n:\n                return a*b\n            b +=2\n        \n    return a*b \n#strongest_even(33,47)\n", "def how_many_light_sabers_do_you_own(*name):\n    return 0 if len(name) == 0 else 18 if name[0]==\"Zach\" else 0", "from itertools import zip_longest\n\ndef number_of_carries(a, b):\n    x, y = str(a)[::-1], str(b)[::-1]\n    result = c = 0\n    for a, b in zip_longest(map(int, x), map(int, y), fillvalue=0):\n        c = (a + b + c) > 9\n        result += c\n    return result", "def to_camel_case(text):\n    words = text.replace('_', '-').split('-')\n    return words[0] + ''.join([x.title() for x in words[1:]])", "def evil(n):\n    a = bin(n)\n    b = str(a)\n    c = b.count(\"1\")\n    if int(c) % 2 == 0: \n        return \"It's Evil!\"\n    if int(c) % 2 != 0:\n        return \"It's Odious!\"\n", "tr=str.maketrans('56789','45678')\n\ndef faulty_odometer(n):\n    return int(str(n).translate(tr),9)", "from collections import Counter\ndef most_common(s):\n    c=Counter(s)\n    return \"\".join(sorted(s,key=lambda x:-c[x]))", "def reverse_in_parentheses(string):\n    for i in range(len(string)):\n        if string[i]==\"(\":\n            finder,depth=i,1\n            while depth>int():depth,finder=depth+\")(\".index(string[finder+1])-1+\")(\".index(string[finder+1]) if string[finder+1] in \"()\" else depth,finder+1\n            string=string[:i+1]+\"\".join([\"()\"[\")(\".index(y)] if y in \"()\" else y for y in list(reversed(string[i+1:finder]))])+string[finder:]\n    return string", "celsius_to_romer=lambda x:(x*21.0/40)+7.5", "import string\n\ndef caeser(message, key=1):\n    letters = string.ascii_lowercase\n    mask = letters[key:] + letters[:key]\n    trantab = str.maketrans(letters, mask)\n    return message.translate(trantab).upper()", "def longest_palindrome (s):\n\n  longest = 0\n\n  for j in range(1, len(s)+1):\n    for i in range(j):\n      t = s[i:j]\n      if t == t[::-1]:\n        longest = max(longest, len(t))\n  \n  return longest", "from itertools import cycle\nfrom math import sqrt\n\n\ndef make_triangle(start, end):\n    rows = sqrt(8 * (end - start) + 9) / 2 - .5\n\n    if not rows.is_integer():\n        return ''\n\n    rows = int(rows)\n    row, col, value = -1, -1, start\n\n    directions = cycle([(1, 0), (0, -1), (-1, 1)])\n    triangle = [[''] * n for n in range(1, rows + 1)]\n\n    for times in range(rows, 0, -1):\n        cur_dir = next(directions)\n\n        for _ in range(times):\n            row += cur_dir[0]\n            col += cur_dir[1]\n\n            triangle[row][col] = str(value % 10)\n            value += 1\n\n    return \"\\n\".join(' ' * (rows - i - 1) + ' '.join(r) for i, r in enumerate(triangle))\n", "def solve(lst, n):\n    lst, caught = lst[:], 0\n    while {\"C\", \"D\"} <= set(lst):\n        d, c = lst.index(\"D\"), lst.index(\"C\")\n        if abs(d - c) <= n:\n            caught, lst[d], lst[c] = caught + 1, \"\", \"\"\n        else:\n            lst[min(d, c)] = \"\"\n    return caught", "import re\ndef autocorrect(input):\n    return re.sub(r'(?i)\\b(you+|u)\\b', 'your sister', input)", "func_or, func_xor = lambda a,b: bool(bool(a)+bool(b)), lambda a,b: bool(a)+bool(b)==1", "from math import gcd \n\ndef reduce_fraction(fraction):\n    g = gcd(*fraction)\n    return tuple(n // g for n in fraction)", "import functools\n# def get_sum_of_digits(num):\n#     sum = 0\n#     digits = str(num)\n#     for x in digits:\n#         sum += int(x)\n#     return sum\ndef get_sum_of_digits(num):   \n    return functools.reduce(lambda a,b : a+b,[int(x) for x in str(num)] )", "import re\n\ndef bracket_buster(string):\n    if type(string) is not str:\n        return \"Take a seat on the bench.\"\n    return re.findall(r'\\[(.*?)\\]', string)", "def ones_counter(input):\n    return [ele.count('1') for ele in ''.join(map(str,input)).split('0') if ele.count('1')]", "def sharkovsky(a, b): return f(a)<f(b)\n\ndef f(n,p=0):\n    while n%2==0:\n        n>>=1\n        p+=1\n    return n==1, p*(-1)**(n==1), n", "def pop_shift(str):\n    l = len(str)\n    return [str[::-1][:l//2], str[:l//2], str[l//2]*(l%2)]", "def pattern(n):\n    # Happy Coding ^_^\n    return '\\n'.join([str(i) * i for i in range(1, n+1) ])", "d = {'KiB':1.024,'kB':0.9765625,'GiB':1.073741824,'GB':0.93132257461548,'MiB':1.048576,'MB':0.95367431640625,'TiB':1.099511627776,'TB':0.90949470177293}\nto = {'KiB':' kB','GiB':' GB','MiB':' MB','TiB':' TB','TB':' TiB','GB':' GiB','MB':' MiB','kB':' KiB'}\nmemorysize_conversion=lambda m:str(round(float(m.split()[0]) * d[m.split()[1]],3)) + to[m.split()[1]]", "def number_property(n):\n    return [n == 2 or n > 2 and pow(2, n-1, n) == 1,\n            not n % 2,\n            not n % 10]", "from collections import Counter\n\ndef find_uniq(arr):\n    res = Counter(''.join(arr)).most_common()\n    return ''.join([x for x in arr if res[-1][0] in x])\n", "def minimum(a, x):\n    return abs(a-round(a/x)*x)\n", "outed=lambda meet, boss: \"Get Out Now!\" if sum([meet[i]*(1 if i!=boss else 2) for i in meet])/len(meet)<=5 else \"Nice Work Champ!\"", "def find_missing_number(sequence):\n    a = list(map(int,list(filter(str.isdigit,sequence.split()))))\n    if len(sequence.split()) != len(a): return 1\n    if a:\n        for n in range(1,max(a)+1):\n            if n not in a:\n                return n\n    return 0\n", "def hex_string_to_RGB(hex): \n    return {'r': int(hex[1:3],16),'g': int(hex[3:5],16), 'b': int(hex[5:7],16)}", "evil_code_medal=lambda t,*m:next((s for s,n in zip((\"Gold\",\"Silver\",\"Bronze\"),m)if t<n),\"None\")", "def find_longest(arr):\n    lst = []\n    for item in arr:\n        lst.append(str(item))\n    return int(max(lst,key=len))", "def poly_subtract(p1, p2):\n    p1length = len(p1)\n    p2length = len(p2)\n    length = max(p1length, p2length)\n    list = []\n    \n    for i in range(0, length):\n        a = 0\n        b = 0\n        \n        if i < p1length:\n            a = p1[i]\n        \n        if i < p2length:\n            b = p2[i]\n        \n        list.append(a - b)\n    \n    print(list)\n    \n    return list", "def boolean_to_string(b):\n    if b:\n        return 'True'\n    else:\n        return 'False'\n        \n        #fifnish!!!\n", "import re\ndef difference(n,s) :\n    n = str(n)[::-1]\n    try :\n        right_index = n.index(s[1])\n        left_index = n.index(s[0],[0,1 + right_index][s[0] == s[1]])\n    except : return float('inf')\n    upper_index = 1 + max(left_index,right_index) == len(n) and '0' == n[-2] and len(re.search('0*.$',n)[0])\n    return right_index + left_index - 1 + (left_index < right_index) + (upper_index and upper_index - 1 - (len(n) <= min(left_index,right_index) + upper_index))\ndef solve(n) :\n    removes = min([difference(n,'00'),difference(n,'25'),difference(n,'50'),difference(n,'75')])\n    return [-1,removes][int == type(removes)]\n", "def three_amigos(a):\n    li = []\n    for i in range(len(a) - 2):\n        s = a[i] & 1\n        t = a[i:i + 3]\n        if all(j & 1 == s for j in t):     \n            m = max(t)\n            m_ = min(t)\n            li.append([m - m_, t])\n    return min(li,key=lambda x:x[0],default=[[],[]])[1]", "def find_dup(arr):\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] == arr[j]:\n                return arr[i]    \n    return None", "def correct(string):\n    \n    answer1 = string.replace(\"5\",\"S\")\n    \n    \n    answer2 = answer1.replace(\"0\",\"O\")\n    \n    answer3 = answer2.replace(\"1\",\"I\")\n\n    return answer3", "def title_to_number(title):\n    return sum((ord(c) - 64) * 26**i for i, c in enumerate(title[::-1]))", "from functools import reduce\ndef get_chance(n,x,a):\n    return round(reduce(lambda x,y:x*y,((n-x-i)/(n-i) for i in range(a))),2)", "def sum_of_minimums(argumento):\n    suma_min = []\n\n    while argumento !=[]:\n        var = argumento.pop(0)\n        minvar = min(var)\n        suma_min.append(minvar)\n\n    suma=sum(suma_min)\n\n    return suma\n\n", "def sum_mix(arr):\n    tot = 0\n    for i in range(len(arr)):\n        if type(arr[i]) is str:\n            x = int(arr[i])\n            tot += x\n        else:\n            tot += arr[i]\n    return tot\n", "from math import *\ndef evaporator(content, evap_per_day, threshold):\n    return ceil(log(threshold/100, 1-evap_per_day/100))", "from math import sqrt, floor\ndef predict_age(a1, a2, a3, a4, a5, a6, a7, a8):\n    ages = [a1,a2, a3, a4, a5, a6, a7, a8]\n    return floor(sqrt(sum([x*x for x in ages]))/2)", "format_poem = lambda p:'.\\n'.join(p.split(\". \"))\n", "from math import factorial\n\ndef nth_perm(n, d):\n    n, ds, res = n-1, list(range(d)), []\n    for i in range(d - 1, -1, -1):\n        p, n = divmod(n, factorial(i))\n        res.append(ds.pop(p))\n    return ''.join(map(str, res))", "from math import factorial\n\ndef routes(n):\n    return n > 0 and factorial(2*n) // factorial(n)**2", "from collections import deque\n\ndef is_prime(n):\n   return n > 1 and all(n % i != 0 for i in range(2, int(n**0.5) + 1))\n   \ndef circular_prime(n):\n    items = deque(str(n))\n    for _ in range(len(items)):\n        items.rotate(1)\n        if not is_prime(int(\"\".join(items))):\n            return False\n    return True", "def move(position, roll):\n    r = roll * 2\n    return position + r", "def without_last(lst):\n    # Fix it\n    x = lst[0:-1]\n    return x", "import re\ndef signed_eight_bit_number(number):\n    return bool(re.match(\"(0|-128|-?([1-9]|[1-9]\\d|1[01]\\d|12[0-7]))\\Z\", number))", "def string_merge(str1, str2, letter):\n    return str1[:str1.index(letter)] + str2[str2.index(letter):]", "from math import log\n\ndef compare_powers(*numbers):\n    a,b = map(lambda n: n[1]*log(n[0]), numbers)\n    return (a<b) - (a>b)", "from itertools import accumulate as acc\nfrom math import floor\n\ndef going(n):\n    return floor(1e6*(1 + sum(1/x for x in acc(range(n, 1, -1), lambda a, b: a*b))))/1e6", "def square_free_part(n):\n    if type(n) != int or n < 1:return None\n    for i in xrange(2, int(n ** 0.5) + 1):\n        while n % (i ** 2) == 0:\n            n /= i\n    return n", "def solve(time):\n    w = [\"midnight\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"]\n    h,m = map(int,time.split(\":\"))\n    a,b = w[12] if h == 12 else w[h%12], w[h+1] if h == 11 else w[(h+1)%12]\n    if m == 0: return \"midnight\" if h == 0 else a + \" o'clock\"\n    elif m <= 30: return w[m]  + \" minute past \" + a if m == 1 else \"quarter past \" + a if m == 15 else \"half past \" + a if m == 30 else w[m] + \" minutes past \" + a\n    else: return \"quarter to \" + b if m == 45 else \"one minute to \" + b if m == 59 else w[60-m] + \" minutes to \" + b", "def decrypt(encrypted_text, n):\n\n    if n < 1:\n        return encrypted_text\n    \n    half_len = len(encrypted_text)//2    \n    \n    left, right = encrypted_text[:half_len], encrypted_text[half_len:]\n  \n    encrypted_text = [''.join(i) for i in zip(right, left)]\n       \n    if len(right) > half_len:\n        encrypted_text += right[-1]\n    \n    return decrypt(''.join(encrypted_text), n-1)\n    \n\ndef encrypt(text, n):\n    \n    if n < 1:\n        return text\n        \n    for _ in range(n):\n        text = text[1::2] + text[0::2]\n        \n    return text", "def encrypter(strng):\n    return ''.join( c if c==' ' else chr(122 - ((ord(c)-97)+13) % 26) for c in strng )", "look_and_say_sequence=l=lambda s,n:n>1and l(''.join(str(len(list(g)))+k for k,g in __import__('itertools').groupby(s)),n-1)or s", "def get_real_floor(n):\n    return n - 1 - int(n >= 13) if n > 0 else n", "def lowercase_count(strng):\n    # Your code here\n    import re\n    from re import finditer\n    \n    pattern = r\"[a-z]\"\n    \n    count = 0\n    \n    for it in finditer(pattern,strng):\n        count += 1\n    \n    return count", "def is_even(n): return n & 1 == 0 \n", "def longest(s):\n    chunks = []\n    for c in s:\n        if chunks and chunks[-1][-1] <= c:\n            chunks[-1] += c\n        else:\n            chunks.append(c)\n    return max(chunks, key=len)", "import re\ndef name_in_str(s, name):\n    str_lst=re.findall('[a-z]',s.lower())\n    i=0\n    for c in name.lower():\n        if not c in str_lst:\n            return False\n        else:\n            i=str_lst.index(c)\n            str_lst=str_lst[i+1:]\n    return True", "import re\n\ndef binary_to_string(bits):\n    return ''.join(chr(int(byte, 2)) for byte in re.findall(r'\\d{8}', bits))", "def domain_name(url):\n    if url[0:4] == 'http':\n        url = url[url.find('//')+2:-1]\n    url = url.split('.')\n    return url[0] if url[0] != 'www' else url[1]", "narcissistic = lambda n: sum([int(d) ** len(str(n)) for d in list(str(n))]) == n", "def flatten(*a):\n    r, s = [], [iter(a)]\n    while s:\n        it = s.pop()\n        for v in it:\n            if isinstance(v, list):\n                s.extend((it, iter(v)))\n                break\n            else:\n                r.append(v)\n    return r", "def sierpinski(n):\n    if n==0:\n        return '*'\n    lower = sierpinski(n-1).splitlines()\n    result = [s.center(2*len(s)+1) for s in lower]\n    result += [s+' '+s for s in lower]\n    return '\\n'.join(result)\n", "def list_squared(m, n):\n    squares = []\n    for i in range(m, n):\n        total = sum(get_divisors_sqrd(i))\n        if (total ** (1/2)).is_integer():\n            squares.append([i, total])\n    return squares\n            \ndef get_divisors_sqrd(n):\n    divisors = []\n    for i in  range(1, int(n ** (1/2)) + 1):\n        if n % i == 0:\n            if i ** 2 not in divisors:\n                divisors.append(i ** 2)\n            if int(n/i) ** 2 not in divisors:\n                divisors.append(int(n / i) ** 2)\n    return divisors\n", "def collatz(n):\n    return 1 if n == 1 else 1 + collatz(3 * n + 1 if n % 2 else n // 2)", "def remove_duplicate_words(s):\n    q = \"\"\n    a = s.split(\" \")\n    for i in a:\n        if i not in q:\n            q += i + \" \"\n    return q[:-1]", "def matrix_addition(a, b):\n    return [[sum(xs) for xs in zip(ra, rb)] for ra, rb in zip(a, b)]\n", "def grille(message, code):\n    binary = bin(code)[2:][-len(message):].zfill(len(message))\n    return ''.join(char for char, code in zip(message, binary) if code == '1')", "def solve(arr):\n\n    head = arr[0]\n    tail = arr[-1]\n    \n    check = [(i,j) for i in range(head-1,head+2) for j in range(tail-1,tail+2)]\n    \n    possibles = []\n    for start, end in check:\n        if (end-start)%(len(arr)-1) == 0:\n            possibles.append((start,end))\n    \n    global_changes = float('inf')\n    \n    for start, end in possibles:\n        \n        diff = int((end-start)/(len(arr)-1))\n        \n        if diff == 0: tester = [start]*len(arr)\n        else: tester = list(range(start, end+diff, diff))\n        \n        current_changes = 0\n        \n        for i in range(len(tester)):\n            if abs(tester[i] - arr[i]) > 1:\n                current_changes = float('inf')\n                break\n            elif abs(tester[i] - arr[i]) == 1:\n                current_changes += 1\n        \n        global_changes = min(current_changes, global_changes)\n                \n    \n    return global_changes if global_changes != float('inf') else -1", "def alpha_seq(string):\n    return ','.join(a * (ord(a) - 96) for a in sorted(string.lower())).title()", "def even_numbers(arr,n):\n    even_steven = []\n    for element in arr[::-1]:\n        if element % 2 == 0 and len(even_steven) < n:\n            even_steven.append(element)            \n    return even_steven[::-1]", "calculate=lambda a,o,b:eval(str(a)+o+str(b)) if o in '+-/*' and o+str(b)!='/0' else None", "import numpy as np\n\n\ndef reorder(a, b):\n    return np.roll(np.arange(a).reshape(2, -1), b, 1).tolist()\n", "def solve(st,a,b):\n    sub = st[a:b+1]\n    rev = sub[::-1]\n    return st.replace(sub, rev)", "df={0:1}\ndm={0:0}\ndef f(n):\n    if n in df: \n        return df[n]\n    else:\n        df[n]=n-m(f(n-1))\n        return df[n]\n\ndef m(n):\n    if n in dm: \n        return dm[n]\n    else:\n        dm[n]=n-f(m(n-1))\n        return dm[n]", "def palindrome_chain_length(n):\n    count = 0\n#     n = str (n)\n#     m = n[:: -1]\n    while str(n)!= str(n)[::-1]:\n        n += int(str(n)[::-1])\n        count +=1\n    return count", "from itertools import cycle\n\ndef add_check_digit(number):\n    it = cycle(range(2, 8))\n    rem = sum(int(n) * i for n, i in zip(reversed(number), it)) % 11\n    return number + '0X987654321'[rem]", "import re\ndef scratch(lottery):\n    return sum(int(i[1]) for i in re.findall(r'([A-Za-z]+ )\\1\\1([0-9]*)',\"-\".join(lottery)))", "import math\nimport numpy as np\ndef f(n):\n    if set(primeFactors(n).values()) == {1}:\n        return 1\n    return np.prod([v*k**(v-1) for k,v in primeFactors(n).items()])   # (n_ = n*)\n    \ndef primeFactors(n): \n    ans = dict()\n    cnt2 = 0 \n    while n % 2 == 0:\n        cnt2 += 1\n        ans.update({2:cnt2}) \n        n = n / 2 \n    for i in range(3,int(math.sqrt(n))+1,2): \n        cnti = 0\n        while n % i== 0:\n            cnti += 1\n            ans.update({i:cnti}) \n            n = n / i  \n    if n > 2: \n        ans.update({n:1})\n    return ans", "def solution(nums= []):\n    if nums == None or len(nums) == 0:\n        return [];\n    for i in range (len(nums)-1,0,-1):\n        # print(i)\n        for j in range(i):\n            if nums[j] > nums[j+1]:\n                helper = nums[j]\n                nums[j] = nums[j+1]\n                nums[j+1] = helper\n    return nums\n# print(solution(nums))\n\n\n", "from re import sub\n\ndef reversi_row(moves):\n    base=\"........\"\n    point=\"*\"\n    for move in moves:\n        base=list(base)\n        base[move]=\"#\"\n        base=\"\".join(base)\n        base=sub(\"#O+\\*\",  lambda m: \"*\"*len(m.group(0)), sub(\"\\*O+#\", lambda m: \"*\"*(len(m.group(0))-1)+\"#\",base)) if point==\"*\" else sub(\"#\\*+O\", lambda m: \"O\"*len(m.group(0)),sub(\"O\\*+#\", lambda m: \"O\"*(len(m.group(0))-1)+\"#\",base))\n        base=base.replace(\"#\",point)\n        point='O' if point==\"*\" else '*'\n    return base", "def build_palindrome(s):\n    if s == s[::-1]:\n        return s\n    else:\n        for i in range(1,len(s)):\n            if s + s[:i][::-1] == (s + s[:i][::-1])[::-1]:\n                return s + s[:i][::-1]\n        \n", "def total_kilometers(cons, petrol):\n    return round(petrol/cons*100,2)\n\ndef check_distance(distance, cons, petrol):\n    if total_kilometers(cons, petrol)<distance:\n        return \"You will need to refuel\"\n    return[[i*100,distance-i*100,round(petrol-cons*i,2)]for i in range(0,distance//100+1)]", "def cut_the_ropes(a):\n    r = []\n    while a:\n        r.append(len(a))\n        n = min(a)\n        a = [x - n for x in a if x != n]\n    return r", "def reverse_list(l):\n  'return a list with the reverse order of l'\n  index = len(l)\n  i = index -1\n  temp = []\n  while i!=-1:\n      temp.append(l[i])\n      i-=1\n  return temp\n", "#CHAR_TO_MORSE preloaded to convert characters into Morse code\nCODE = {'A': '.-',     'B': '-...',   'C': '-.-.', \n        'D': '-..',    'E': '.',      'F': '..-.',\n        'G': '--.',    'H': '....',   'I': '..',\n        'J': '.---',   'K': '-.-',    'L': '.-..',\n        'M': '--',     'N': '-.',     'O': '---',\n        'P': '.--.',   'Q': '--.-',   'R': '.-.',\n        'S': '...',    'T': '-',      'U': '..-',\n        'V': '...-',   'W': '.--',    'X': '-..-',\n        'Y': '-.--',   'Z': '--..',\n        \n        '0': '-----',  '1': '.----',  '2': '..---',\n        '3': '...--',  '4': '....-',  '5': '.....',\n        '6': '-....',  '7': '--...',  '8': '---..',\n        '9': '----.', \n        \n        ' ': ' '\n        }\n\ndef encryption(string):\n    string.upper()\n    return \" \".join([CODE[a] for a in string.upper()])", "def absolute_values_sum_minimization(a):\n    return a[len(a)//2 + len(a) %2 - 1]", "def genFib():\n    a,b = 1,0\n    while 1:\n        yield a\n        a,b = a+b,a\n\nFIB,fib = [], genFib()\n\ndef getFib(m):\n    while len(FIB)<m: FIB.append(next(fib))\n    return FIB[:m]\n        \n        \ndef mysterious_pattern(m, n):\n    lst = [v%n for v in getFib(m)]\n    \n    arr = [[' ']*m for _ in range(n)]\n    for y,x in enumerate(lst): arr[x][y] = 'o'\n    \n    return '\\n'.join(''.join(row).rstrip() for row in arr).strip('\\n')\n", "def diamond(n):\n    if n < 0 or n % 2 == 0:\n        return None\n    \n    result = \"*\" * n + \"\\n\";\n    spaces = 1;\n    n = n - 2\n    while n > 0:\n        current = \" \" * spaces + \"*\" * n + \"\\n\"\n        spaces = spaces + 1\n        n = n - 2\n        result = current + result + current\n    \n    return result", "def solve(xs, n):\n    rs = set()\n    for x in xs:\n        for r in list(rs):\n            rs.add((r + x) % n)\n        rs.add(x % n)\n    return 0 in rs", "def digitize(n):\n    return [int(n) for n in str(n)]", "def word_square(letters):\n    if (len(letters))**.5 != int((len(letters))**.5):\n        return False\n    else:\n        n = int((len(letters))**.5)\n    s = set(letters)\n    one, two = 0,0\n    for letter in s:\n        if letters.count(letter) == 1: one += 1\n        if letters.count(letter) == 2: two += 1\n    return one <= n and two <= n**2-n        ", "def tax_calculator(total):\n    if not isinstance(total, (int, float)) or total < 0: return 0\n    \n    tax = 0\n    \n    if total > 30: tax = 2.2 + (total - 30) * 0.03\n    elif total > 20: tax = 1.7 + (total - 20) * 0.05\n    elif total > 10: tax = 1 + (total-10) * 0.07\n    elif total > 0: tax = total / 10.0\n\n    return round(tax, 2)\n", "def find_uniq(arr):\n    culprit = arr[1]\n    \n    if arr[0] == arr[2]:\n        culprit = arr[0]\n        \n    for i in arr:\n        if i != culprit:\n            return i\n", "import math\n\ndef circleArea(r):\n    return type(r) in (int, float) and r > 0 and round(math.pi * r**2, 2)", "def lowest_temp(t):\n  return min((int(x) for x in t.split()), default=None)", "def warn_the_sheep(queue):\n    wolfpos = queue.index(\"wolf\")\n    sheepeat = len(queue) - queue.index(\"wolf\") -1\n    n = str(sheepeat)\n    if n == \"0\":\n        return(\"Pls go away and stop eating my sheep\")\n    else:\n        return (\"Oi! Sheep number \"+n+\"! You are about to be eaten by a wolf!\")", "def cipher(str):\n    key = [0,1,2,0,2,3,1,3,4,2,4,5,3,5,6,4,6,7,5,7,8,6,8,9,7,9,10,8,10,11,9,11,12,10,12,13,11,13,14,12,14,15,13,15,16,14,16,17,15,17,18,16,18,19,17,19,20,18,20,21,19,21,22,20,22,23,21,23,24,22,24,25,23,25,26]\n    result = ''\n    alphabet = 'abcdefghijklmnopqrstuvwxyz' * 2\n    \n    for i in range(len(str)):\n        if str[i] == ' ':\n            result += ' '\n            continue\n        alpha_index = alphabet.find(str[i])\n        result += alphabet[alpha_index + key[i]]\n    return result", "def replace_zero(arr):\n    ret = [0,0]\n    arr = [None] + arr + [None]\n    for i,e in enumerate(arr):\n        if type(arr[i])==int and not e and any((arr[i+1],arr[i-1])):\n            mx = (sm(arr[:i]) + sm(arr[i+1:][::-1]))\n            ret = [ret,[mx, i-1]][mx>=ret[0]]\n    return ret[-1]\n    \ndef sm(arr, c=0):\n    i = len(arr)-1\n    while arr[i]:\n        i -=1\n        c +=1\n    return c", "def bin_mul(m,n):\n    r=[]\n    n,m=sorted((m,n))\n    if not n:return r\n    while m:\n        if m%2:\n            r+=n,\n        m//=2\n        n*=2\n    return r[::-1]", "def alphabet_war(fight):\n\n  s = 'wpbsszdqm'\n  alive = []\n\n  if '*' not in fight[:2]:\n    alive.append(fight[0])\n\n  for i, c  in enumerate(fight[1:], 1):\n    if '*' not in fight[i-1:i+2]:\n      alive.append(c)\n  \n  x = sum(4 - s.index(c) for c in alive if c in s)\n  return 'Let\\'s fight again!' if x==0 else ['Left','Right'][x<0] + ' side wins!'", "import re\n\ndef err_bob(stg):\n    return re.sub(r\"[bcdfghj-np-tv-z]\\b\", end_err, stg, flags=re.I)\n\ndef end_err(char):\n    return f\"{char[0]}{'err' if char[0].islower() else 'ERR'}\"\n", "def decipher_this(string):\n    words = string.split()\n    res = []\n    #check if there is a part only consisting digts\n    for x in words:\n        if x.isdigit():\n            res.append(chr(int(x)))\n    #if not then seperate the numbers and the string charakters in seperate variables\n        elif len(x) >= 3:\n            sum = \"\"\n            new_str = \"\"\n            for i in x:    \n                if i.isdigit():\n                    sum += i\n                else:\n                    new_str += i\n            #transverse the digit to the she specific letter and add the old string to it\n            sum = chr(int(sum)) + new_str\n            #ckeck if the string length has changed due to the transversation and switch the letter position \n            if len(sum) > 2:\n                x = (sum[0::len(sum) - 1] + sum[2:len(sum) -1 ] + sum[1])\n                res.append(x)\n            else:\n                res.append(sum)\n    return \" \".join(res)\n", "def solve(n): \n    return n if n < 10 else 9 + solve(n // 10) if n % 10 == 9 else 10 + n % 10 + solve(n // 10 - 1)", "def powers(n):\n    return [2**i for i,d in enumerate(bin(n)[::-1]) if d == '1']", "def get_average(marks):\n    # assumption array is never empty\n    # get average of an array and return\n    \n    # will use sum and len of array to get average\n    # rounded down to nearest integer\n    avg = sum(marks) // len(marks)\n    return avg\n    \n    \n    \n    # raise NotImplementedError(\"TODO: get_average\")\n", "def code_for_same_protein(seq1,seq2):\n    if seq1 == seq2:\n        return True\n    lista = [['GCT','GCC','GCA','GCG'],['CGT','CGC','CGA','CGG','AGA','AGG'],['AAT','AAC'],['GAT','GAC'],['AAT','AAC','GAT','GAC'],['TGT','TGC'],['CAA','CAG'],['GAA','GAG'],['CAA','CAG','GAA','GAG'],['GGT','GGC','GGA','GGG'],['CAT','CAC'],['ATG'],['ATT','ATC','ATA'],['CTT','CTC','CTA','CTG','TTA','TTG'],['AAA','AAG'],['ATG'],['TTT','TTC'],['CCT','CCC','CCA','CCG'],['TCT','TCC','TCA','TCG','AGT','AGC'],['ACT','ACC','ACA','ACG'],['TGG'],['TAT','TAC'],['GTT','GTC','GTA','GTG'],['TAA','TGA','TAG']]\n    for j in range(0,len(lista)):\n        for i in range(0,len(seq1),3):\n            if (seq1[i:i+3] in lista[j] and seq2[i:i+3] not in lista[j]):\n                return False\n    return True\n", "def cyclic_string(s):\n    for i in range(1, len(s)):\n        # Check to see if s is in the first i characters repeated enough to be of len(s) \n        if s in s[:i] * (len(s) // i) * 2:\n            return i\n    # Must use whole string\n    return len(s)", "def solve(s,g):\n    if s % g:\n        # g is not a divisor of s\n        return -1\n    return (g, s - g)\n", "def next_perfect_square(n):\n    return n >= 0 and (int(n**.5)+1)**2", "def f(n):\n    if type(n) == str or type(n) == float or n < 1:\n        return None\n    return sum(range(1, n+1))", "def array(string):\n    x = string.replace(\" \", \"\").split(\",\")\n    if len(x) < 3:\n        return None\n    return \" \".join(x[1:-1])\n", "def triangle(row):\n    l = len(row)\n    for i in range(l-1):\n        new_row = \"\"\n        for v,v1 in zip(row,row[1:]):\n            if v==v1:\n                new_row += v\n            else:\n                new_row += list({'R','G','B'} - {v,v1})[0]\n        row = new_row\n    return row", "snail=lambda c,d,n:max([i for i in range(c) if i*d-(n*i-n)>=c][0],1)", "from itertools import zip_longest\n\ndef transpose_two_strings(arr):\n    return '\\n'.join(list(map(' '.join, zip_longest(*arr, fillvalue=' '))))", "from math import gcd\nfrom functools import reduce\n\nlcm = lambda x,y: x*y//gcd(x,y)\n\ndef candies_to_buy(n):\n    return reduce(lcm, (i for i in range(1,(n+1 if n%2 else n)))) if n!=2 else 2", "def disarium_number(number):\n    return \"Disarium !!\" if number == sum(int(d)**(i + 1) for i, d in enumerate(str(number))) else \"Not !!\"", "repeater = lambda s, n: f'\"{s}\" repeated {n} times is: \"{\"\".join(s*n)}\"'    ", "def final_grade(e, p):\n    if p>10 or e>90 : return 100\n    if p>=5 and e>75 : return 90\n    if p>=2 and e>50 : return 75\n    return 0\n", "def multiplication_table(row,col):\n    return [[i * j for i in range(1, col+1)] for j in range(1, row+1)] ", "from itertools import combinations\n\ndef solve(n, k):\n    s = str(n)\n    return ''.join(min(combinations(s, len(s) - k)))", "from math import factorial\nfrom collections import Counter\nfrom functools import reduce\n\ndef uniq_count(s):\n    return factorial(len(s)) // reduce(lambda x, y: x * factorial(y) , Counter(s.lower()).values(), 1)", "def common_ground(s1,s2):\n    ret = [i for i in set(s1.split()) if i in s2.split()]\n    if len(ret) == 0: return 'death'\n    return ' '. join(sorted(ret, key=lambda x: (s2.split()).index(x) ))", "def disjunction(operands, is_exclusive):\n    return sum(operands) & 1 if is_exclusive else any(operands)", "def sum_times_tables(table, a, b):\n    return sum(x * y for x in table for y in range(a, b + 1))", "def isLeapYear(year):\n    return (year%4 == 0) and not (year%100 == 0 and not year%400 == 0)", "def valid_card(card):\n    return sum([2*c,2*c-9][2*c>9] if i%2 else c for i,c in enumerate(map(int,card.replace(\" \",\"\")[::-1])))%10==0", "import re\n\ndef date_checker(date):\n    return bool(re.match(r'\\d{2}-\\d{2}-\\d{4} \\d{2}:\\d{2}$', date))", "def integrate(c, e):\n    e += 1\n    return f\"{c//e}x^{e}\"", "from collections import Counter\n\ndef scramble(s1, s2):\n    se1 = Counter(s1)\n    se2 = Counter(s2)\n    return se1|se2 == se1", "def count_consonants(text):\n    return len({ch for ch in text.lower() if ch in 'bcdfghjklmnpqrstvwxyz'})", "def to_twos_complement(input_value, bits):\n    mask, unsigned = 2 ** (bits - 1), int(input_value.replace(' ', ''), 2)\n    return (unsigned & ~mask) - (unsigned & mask)\n\ndef from_twos_complement(n, bits):\n    return \"{:0>{}b}\".format(n + 2 ** bits * (n < 0), bits)", "mod256_without_mod=(256).__rmod__", "def next_day_of_week(current_day, available_week_days):\n    x = 2 ** current_day\n    while not x & available_week_days:\n        x = max(1, (x * 2) % 2 ** 7)\n    return x.bit_length()", "def doubles(s):\n    chars = set(s)\n    while True: \n        token = s\n        for c in chars: \n            s = s.replace(c+c, '')\n        if len(token) == len(s): \n            break\n    return s", "def pattern(n):\n    if n == 1:\n        return \"1\"\n    else:\n        return '1\\n'+''.join([str(1)+'*'*(i-1)+str(i)+'\\n' for i in range(2, n+1)])[:-1]", "import re\ndef to_integer(s):\n    decimal = re.compile(r'^[-+]?\\d+$')\n    binary = re.compile(r'^[-+]?0b[01]+$')\n    hexadecimal = re.compile(r'^[-+]?0x[0-9A-Fa-f]+$')\n    octal = re.compile(r'^[-+]?0o[0-7]+$')\n    return next((int(s,[10,0][j!=0]) for j,i in enumerate([decimal,binary,hexadecimal,octal]) if re.search(i,s) and '\\n' not in s),None)", "def unlucky_number(n):\n    return sum(1 for k in range(0, n+1, 13) if not set(str(k)) & {\"4\", \"7\"})\n", "def sort_string(s, ordering):\n    return \"\".join(sorted([i for i in s if i in ordering], key=lambda x:ordering.index(x)))+\"\".join(sorted([j for j in s if j not in ordering],key=lambda x:s.index(s)))", "\ndef battle(player1, player2):\n    l1 = []\n    l2 = []\n    x = min(len(player1),len(player2))\n    for i in range(x):\n        if player1[i][0] < player2[i][1]:\n            l2.append(player2[i])\n        if player2[i][0] < player1[i][1]:\n            l1.append(player1[i])\n    \n    l1 += player1[x:]\n    l2 += player2[x:]\n        \n    return {'player1': l1, 'player2': l2}\n", "def part_const(n, k, num):\n    return part(n, k) - (part(n-num, k-1) if num else 0)\n\ndef part(n, k):\n    return 0 if k > n else 1 if k in {1, n} else sum(part(n-k, i) for i in range(1, k+1))\n", "def sequence_sum(start, stop, step):\n    n = (stop - start) // step\n    last = start + n * step\n    return (n+1) * (start + last) // 2 if n >= 0 else 0", "from collections import Counter\ndef get_char_count(s):\n    con = Counter([e for e in s.lower() if any((e.isalpha(), e.isdigit()))])\n    return { v:sorted([e for e in con.keys() if con[e] == v]) for v in sorted(con.values(), reverse = 1 ) }", "# Attempt without regex, let's use classic generator function.\n\ndef string_parse_gen(string):\n    counter, prev_char = 0, ''\n    for char in string:\n        if char == prev_char:\n            counter += 1\n            if counter == 2:\n                yield '['\n        else:\n            if counter >= 2:\n                yield ']'\n            prev_char = char;\n            counter = 0;\n        yield char;\n        \n    if counter >= 2:\n        yield ']'\n\n\ndef string_parse(string):\n    return ''.join(list(string_parse_gen(string))) if isinstance(string, str) else \"Please enter a valid string\"", "def time_convert(num):\n    return \"{:02d}:{:02d}\".format(*divmod(max(0, num), 60))", "DENSITY = {'H': 1.36, 'W': 1, 'A': 0.87, 'O': 0.8}\n\n\ndef separate_liquids(glass):\n    if not glass:\n        return []\n    column = len(glass[0])\n    liquids = sorted((b for a in glass for b in a), key=lambda c: DENSITY[c])\n    return [liquids[d:d + column] for d in range(0, len(liquids), column)]\n", "from itertools import count\n\ndef beeramid(bonus, price):\n    bonus = max(bonus,0)\n    n = bonus//price\n    return next(x for x in count(int((n*3)**(1/3)+1),-1) if x*(x+1)*(2*x+1)//6 <= n)", "def eval_object(v):\n    return {\"+\": v['a']+v['b'],\n        \"-\": v['a']-v['b'],\n        \"/\": v['a']/v['b'],\n        \"*\": v['a']*v['b'],\n        \"%\": v['a']%v['b'],\n        \"^\": 1,\n        \"**\": v['a']**v['b']}[v['operation']]", "from bisect import bisect\nfrom itertools import accumulate\n\n\ndef save(sizes, hd): \n    return bisect(list(accumulate(sizes)), hd)", "array_manip=lambda a:[min([m for m in a[i+1:]if m>n]or[-1])for i,n in enumerate(a)]", "from itertools import groupby\n\n\ndef substring(strng):\n    return max(\n        enumerate(iter_candidates(strng, 2)),\n        key=lambda ix: (len(ix[1]), -ix[0]),\n    )[1]\n\n\ndef iter_candidates(strng, n):\n    xs = []\n    seen = set()\n    for c, grp in groupby(strng):\n        if len(seen) >= n and c not in seen:\n            yield \"\".join(xs)\n            seen.discard(xs[-n][0])\n            del xs[:1-n]\n        xs.append(\"\".join(grp))\n        seen.add(c)\n    yield \"\".join(xs)", "def correct_polish_letters(st): \n    s,p,n=\"\",[\"\u0105\",\"\u0107\",\"\u0119\",\"\u0142\",\"\u0144\",\"\u00f3\",\"\u015b\",\"\u017a\",\"\u017c\"],[\"a\",\"c\",\"e\",\"l\",\"n\",\"o\",\"s\",\"z\",\"z\"]\n    for i in list(st):\n        if i in p: \n            s+=n[p.index(i)]\n        else: s+=i\n    return s", "def change_count(change):\n    total = 0\n    for i in change.split(' '):\n        if i == 'penny':\n            total += 0.01\n        elif i == 'nickel':\n            total += 0.05\n        elif i == 'dime':\n            total += 0.10\n        elif i == 'quarter':\n            total += 0.25\n        elif i == 'dollar':\n            total += 1.00\n    return \"${:.2f}\".format(total)\n\nprint(change_count('dime penny dollar'))\nprint(change_count('dime penny nickel'))\nprint(change_count('quarter quarter'))\nprint(change_count('dollar penny dollar'))", "def pig_it(text):\n    res = []\n    \n    for i in text.split():\n        if i.isalpha():\n            res.append(i[1:]+i[0]+'ay')\n        else:\n            res.append(i)\n            \n    return ' '.join(res)", "from collections import Counter\n\ndef solve(a,b):\n    aa=Counter(a)\n    bb=Counter(b)\n    \n    for k,v in list(bb.items()):\n        diff = aa[k]-v\n        aa[k]-=v\n        if diff<0: return 0\n    \n    return sum(aa.values())\n        \n    \n", "def sort_by_area(seq): \n    def func(x):\n        if isinstance(x, tuple):\n            return x[0] * x[1]\n        else:\n            return 3.14 * x * x\n    return sorted(seq, key=func)", "from math import ceil, log, sqrt\n\ndef isPP(n):\n    for b in range(2, int(sqrt(n)) + 1):\n        e = int(round(log(n, b)))\n        if b ** e == n:\n            return [b, e]\n    return None\n", "from datetime import datetime\n\ndef to24hourtime(h, m, p):\n    t = f'{h}:{m} {p}'\n    return datetime.strptime(t, '%I:%M %p').strftime('%H%M')", "def remove_exclamation_marks(s):\n    bas = ''\n    out = ''\n    for i in s:\n        if i == \"!\":\n            bas += i\n        else: \n            out += i\n    return out", "from math import factorial as f\nnumber_of_routes=lambda m,n:f(m+n)//(f(m)*f(n))", "def solution(*args):\n    # your code here\n    l = list(args)\n    s = set(l)\n    return len(s)!=len(l)", "def sum_dig_pow(a, b): # range(a, b + 1) will be studied by the function\n    res = []\n    for number in range(a, b+1):\n        digits = [int(i) for i in str(number)]\n        s = 0\n        for idx, val in enumerate(digits):\n            s += val ** (idx + 1)\n        if s == number:\n            res.append(number)\n    return res", "def power_mod(b, e, m):\n  res, b = 1, b % m\n  while e > 0:\n    if e & 1: res = res * b % m\n    e >>= 1\n    b = b * b % m\n  return res", "def super_pad(string, width, fill=\" \"):\n    if fill.startswith('>'):\n        return (string + width * fill[1:])[:width]\n    elif fill.startswith('^'):\n        pad = (width * fill[1:])[:max(0, width - len(string) + 1) // 2]\n        return (pad + string + pad)[:width]\n    else:\n        if fill.startswith('<'): fill = fill[1:]\n        return (width * fill)[:max(0, width - len(string))] + string[max(0, len(string) - width):]", "def vowel_indices(word):\n    word = word.lower()\n    res = []\n    for i in range(len(word)):\n        if word[i] in \"aeiouy\":\n            res.append(i + 1)\n    return res", "from collections import defaultdict\n\ndef delete_nth(order,max_e):\n    dct = defaultdict(int)\n    res = []\n    for i in order:\n        dct[i] += 1\n        if dct[i] <= max_e:\n            res.append(i)\n    return res", "def halving_sum(n): \n    a = [n]\n    b = n\n    while n > 1:\n        c = n//2\n        a.append(c)\n        b += c\n        n = c\n    return b", "from decimal import Context, ROUND_HALF_UP\nimport re\ndef meters(num):\n    r = len(str(num).strip('0'))\n    num = Context(prec=r, rounding=ROUND_HALF_UP).create_decimal(num)\n    i = int(num.logb())//3\n    return re.sub('(\\.0+)(?=[kMGTPEZTY])', '', f\"{num.scaleb(-3*i):f}{' kMGTPEZY'[i]}m\".replace(' ', ''))", "def count_red_beads(n):\n    if n == 0 or n == 1:\n        return 0\n    else:\n        return (n - 1) * 2", "def find_key(key):\n    n = int(key, 16)\n    return next((k - 1) * ((n // k) - 1) for k in range(2, int(n**0.5)+1) if n % k == 0)\n", "def last_fib_digit(n):\n    \"\"\" well, it is periodic on 60 \"\"\"\n    a = 0\n    b = 1\n    for _ in range(n%60):\n        a, b = b, (a+b)%10\n    return a", "def folding(a,b):\n    if a%b==0:\n        return int(a/b)\n    elif a>b:\n        return folding(b,a%b)+int(a/b)\n    elif b>a:\n        return folding(a,b%a)+int(b/a)\n", "def validate_sequence(sequence):\n    return sequence == list(range(sequence[0], sequence[-1] + 1, sequence[1] - sequence[0]))\n", "def encode(text, key):\n    k=''\n    for c in key+'abcdefghijklmnopqrstuvwxyz':\n        if c not in k:\n            k+=c\n    r=''\n    i=1\n    for c in text:\n        if c.isalpha():\n            j=(k.index(c.lower())+i)%26\n            if c.isupper():\n                r+=k[j].upper()\n            else:\n                r+=k[j]\n            i+=1\n        else:\n            r+=c\n            i=1\n    return r\n    \ndef decode(text, key):\n    k=''\n    for c in key+'abcdefghijklmnopqrstuvwxyz':\n        if c not in k:\n            k+=c\n        r=''\n    i=1\n    for c in text:\n        if c.isalpha():\n            j=(k.index(c.lower())-i)%26\n            if c.isupper():\n                r+=k[j].upper()\n            else:\n                r+=k[j]\n            i+=1\n        else:\n            r+=c\n            i=1\n    return r\n    return text", "def present(x,y):\n    if x == 'badpresent':\n        return 'Take this back!'\n    if x == 'goodpresent':\n        return ''.join(chr(ord(i)+y) for i in x)\n    if x == 'crap' or x == 'empty':\n        return ''.join(sorted(x))\n    if x == 'bang':\n        return str(sum([ord(i) - y for i in x]))\n    if x == 'dog':\n        return \"pass out from excitement {} times\".format(y)", "def parade_time(groups, location, speed, pref):\n    return [(location + pos + 1) // speed for pos in [i for i, g in enumerate(groups) if g == pref]]", "d = dict(__import__(\"re\").findall(r\"'(.)'.*\\s([a-z_]+)\\.\",\n    \"\"\"\n        '-' A regular file ==> file.\n        'd' A directory ==> directory.\n        'l' A symbolic link ==> symlink.\n        'c' A character special file. It refers to a device that handles data as a stream of bytes (e.g: a terminal/modem) ==> character_file.\n        'b' A block special file. It refers to a device that handles data in blocks (e.g: such as a hard drive or CD-ROM drive) ==> block_file.\n        'p' a named pipe ==> pipe.\n        's' a socket ==> socket.\n        'D' a door ==> door.\n    \"\"\"))\n\nlinux_type = lambda s: d[s[0]]", "def duplicate_elements(m, n):\n    return any(i in m for i in n)", "def on_line(points):\n    \n    def slope_intercept(p1, p2):\n        slope = (p2[1] - p1[1]) / (p2[0] - p1[0])\n        intercept = p1[1] - slope * p1[0]\n        return slope, intercept\n    \n    if len(points) == 0 or isinstance(points[0], int):\n        return True\n    \n    for p1, p2 in zip(points, points[1:]):\n        if p1[0] == p2[0] or p1[1] == p2[1]:\n            continue\n        else:\n            s, i = slope_intercept(p1, p2)\n            try:\n                if abs(s - slope) > 0.00000001 or abs(i - intercept) > 0.000001:\n                    return False\n            except:\n                pass\n            slope, intercept = s, i\n    return True", "CRITERIA = (str.islower, str.isupper, str.isdigit)\n\ndef password(s):\n    return len(s)>7 and all( any(map(f,s)) for f in CRITERIA)", "def dna_to_rna(dna):\n    \n    ret = \"\";\n    print(dna)\n    for c in dna:\n        if c == 'T':\n            ret = ret + \"U\"\n        else:\n            ret = ret + c\n        \n    print(ret)\n    return ret", "def flipping_game(num):\n    current = 0\n    biggest = 0\n    for i in num:\n        current = max(0, current - ( i or -1 ) )\n        biggest = max(biggest, current)\n        \n    return sum(num) + (biggest or -1)", "def any_arrows(arrows):\n  res=[]\n  for i in range(len(arrows)):\n      if 'damaged' in list(arrows[i].keys()):\n          if arrows[i]['damaged']==True:\n              res.append(True)\n          else:\n              res.append(False)\n      else:\n          res.append(False)\n  return False in res\n", "def quotable(name, quote):\n    return name + ' said: ' + '\"' + quote + '\"'", "def compound_array(a, b):\n    lst = zip(a[:len(b)], b[:len(a)])\n    return [item for sublist in lst for item in sublist] + a[len(b):] + b[len(a):]", "songs = [{'artist': 'Marillion', 'title': 'Keyleigh', 'playback': '03:36'}, {'artist': 'Pink Floyd', 'title': 'Time', 'playback': '06:48'}, {'artist': 'Rush', 'title': 'YYZ', 'playback': '04:27'}, {'artist': 'Bonobo', 'title': 'Days To Come', 'playback': '03:50'}, {'artist': 'Coldplay', 'title': 'Yellow', 'playback': '04:32'}, {'artist': 'Bloc Party', 'title': 'Like Eating Glass', 'playback': '04:22'}, {'artist': 'The Killers', 'title': 'For Reasons Unknown', 'playback': '03:30'}, {'artist': 'Arctic Monkeys', 'title': 'Teddy Picker', 'playback': '03:25'}, {'artist': 'Joe Satriani', 'title': 'Surfing With The Alien', 'playback': '04:34'}]\ndef min_to_sec(i):\n    return int(i['playback'][:2])*60 + int(i['playback'][3:])\n\n\ndef longest_possible(sec):\n    sn = [(song['title'], min_to_sec(song))\n          for song in songs if min_to_sec(song) <= sec]\n    sn_sort = sorted(sn, key=lambda x: x[1])\n    return False if sn_sort == [] else sn_sort[-1][0]\n", "def asterisc_it(n_sequence: str) -> str:\n    \"\"\" Insert an asterisk (*) between every pair of even digits. \"\"\"\n    _result = \"\"\n\n    if type(n_sequence) is int:\n        n_sequence = str(n_sequence)\n    else:\n        n_sequence = \"\".join(str(_) for _ in n_sequence)\n\n    for ix, num in enumerate(n_sequence):\n        if ix < len(n_sequence) - 1:\n            if not int(num) % 2 and not int(n_sequence[ix+1]) % 2:\n                _result += f\"{num}*\"\n            else:\n                _result += str(num)\n        else:\n            _result += str(num)\n\n    return _result\n", "def valid_mersenne(n):\n    return n == 2 or is_prime(n) and lucas_lehmer(n)\n    \ndef is_prime(n):\n    from itertools import chain\n    return all(n % i != 0 for i in chain([2], range(3, int(n**.5) + 1, 2)))\n    \ndef lucas_lehmer(n):\n    s = 4\n    M = 2**n - 1\n    for _ in range(n - 2):\n        s = (s*s - 2) % M\n    return s == 0", "def apple(x):\n    return (\"Help yourself to a honeycomb Yorkie for the glovebox.\",\"It's hotter than the sun!!\")[int(x)**2>1000]\n", "def de_nico(key,msg):\n    result = ''\n    counter = -1\n    while len(result) < len(msg):\n        counter += 1\n        for i in [sorted(key).index(c) for c in key]:\n            try:\n                result += msg[i+counter*len(key)]\n            except:\n                continue\n    return result.strip()\n", "def to_bits(string):\n    ret = [0] * 5000\n    for i in string.split('\\n'):\n        ret[int(i)] = 1\n    return ret", "def get_order(order):\n    word =\"\"\n    list = [\"Burger\" ,\"Fries\",\"Chicken\",\"Pizza\", \"Sandwich\",\"Onionrings\",\"Milkshake\",\"Coke\" ]\n    for i in list:\n        word = word+(\" \"+i)*order.count(i.lower())\n    return word.strip()", "def cog_RPM(cogs, n):\n    r=[cogs[n]/cogs[0],cogs[n]/cogs[-1]]\n    if n%2==1:\n        r[0]*=-1\n    if (len(cogs)-n)%2==0:\n        r[1]*=-1\n    return r", "def is_even(n): \n    print(n/2)\n    if n % 2 == 0: return True\n    else: return False", "def norm_index_test(seq, ind): \n    return None if len(seq)==0 else seq[ind%len(seq)] ", "from datetime import datetime\n\ndef get_calendar_week(date):\n  return datetime.strptime(date, '%Y-%m-%d').isocalendar()[1]", "def find_page_number(pages):\n    arr,l=[],0\n    for i,p in enumerate(pages,1):\n        if p!=i-l:\n            arr.append(p)\n            l+=1\n    return arr", "def owned_cat_and_dog(cat_years, dog_years):\n    cat = cat_years\n    dog = dog_years\n    \n    count_cat = 1\n    count_dog = 1\n    \n    # Cat Condition\n    if cat > 24:\n        while cat > 24:\n            cat-=4\n            count_cat+=1\n        human_cat = ((cat/24)+count_cat)\n    elif cat == 24:\n        human_cat = 2\n    elif cat < 24 and cat >= 15:\n        human_cat = 1\n    else:\n        human_cat = 0\n        \n    # Dog Condition\n    if dog > 24:\n        while dog > 24:\n            dog-=5\n            count_dog+=1\n        human_dog = ((dog/24)+count_dog)\n    elif dog == 24:\n        human_dog = 2\n    elif dog < 24 and dog >= 15:\n        human_dog = 1\n    else:\n        human_dog = 0\n\n    return [int(human_cat), int(human_dog)]\n", "def increment_string(string):\n    numbers=''\n    others=''\n    if string == '':\n        return '1'        \n    for i in range(len(string)-1,-1,-1):     #separates the numbers and the others\n        if '0' <= string[i] <= '9':\n            numbers = string[i] + numbers\n        if string[i] < '0' or string[i] > '9':\n            others = string[:i+1]\n            break\n    if numbers == '':           #the string doesnt contain numbers (in the end)\n        return others + '1'\n    i=0\n    while numbers[i] == '0' and i < len(numbers)-1:        #to separate 0's from numbers\n        i=i+1\n    zeros = ''\n    if i != 0:                                              #separates 0's from numbers\n        zeros = numbers[:i]\n        numbers = numbers[i:]\n    if len(numbers) != len(str(int(numbers)+1)) and zeros != '':       # ex: if 099 goes to 100 and not 0100     removes one 0 if needed\n        zeros = zeros[:-1]\n    numbers = str(int(numbers)+1)         #increment\n    return others + zeros + numbers", "morse_converter=lambda s:int(''.join(str(9-'----.....-----'.rindex(s[i:i+5]))for i in range(0,len(s),5)))", "def well(arr):\n    total = 0\n    for i in arr:\n        for j in i:\n            if isinstance(j, str) and j.lower() == 'good':\n                total += 1\n    return 'Fail!' if total == 0 else 'I smell a series!' if total > 2 else 'Publish!'\n", "def validate_ean(code):\n    return sum(x * (i%2*2+1) for i,x in enumerate(map(int, code))) % 10 == 0", "from collections import Counter\ndef odd_ones_out(numbers):\n    return [x for x in numbers if x in [k for k, v in Counter(numbers).items() if v % 2 == 0]]", "from functools import reduce\n\ndef toTerm(coef, power):\n    if not coef or coef == 0: return ''\n    if power == 0: \n        p = ''\n    elif power == 1:\n        p = 'x'\n    else:\n        p = 'x^' + str(power)\n    \n    term = ('' if abs(coef) == 1 and power > 0 else str(abs(coef))) + p\n    return (' - ' if coef < 0 else ' + ') + str(term) if term else ''\n\ndef co2poly(coefs):\n    terms = [toTerm(c, i) for i, c in enumerate(coefs)]\n    terms.reverse()\n    t = ''.join(terms)\n    return (t[3:] if t.startswith(' +') else t[1:]) + ' = 0'\n\ndef toCoefs(coefs, root):\n    return [ n * -root + c for (c, n) in zip([0] + coefs, coefs + [0]) ]\n\ndef polynomialize(roots):\n    coefs = reduce(toCoefs, roots, [1])\n    return co2poly(coefs)\n", "def reverse_middle(lst):\n    if len(lst) % 2 == 1:\n        return lst[len(lst)//2-1:len(lst)//2+2][::-1]\n    else:\n        return lst[len(lst)//2-1:len(lst)//2+1][::-1]", "import math\n\ndef sum_square_even_root_odd(nums):\n    return float('%.2f' % sum([x*x if x%2 == 0 else math.sqrt(x) for x in nums]))\n", "def array_previous_less(arr):\n    return [next((v1 for v1 in arr[:i][::-1] if v1<v),-1) for i,v in enumerate(arr)]", "def update_score(current_score, called_trump, alone, tricks):\n    n = tricks.count(called_trump)\n    if n <= 2:\n        called_trump = 3 - called_trump\n        p = 2\n    elif n <= 4:\n        p = 1\n    else:\n        p = 4 if alone else 2\n    current_score[called_trump > 1] += p\n    return current_score", "import re\n\n\ndef show_me(name):\n    return bool(re.match(r'(-[A-Z][a-z]+)+$', '-' + name))", "from io import StringIO\n\ndef move(n, a, b, c, source, target, auxiliary, output):\n    if n > 0:\n        move(n - 1, a, b, c, source, auxiliary, target, output)\n        target.append(source.pop())\n        print([a, b, c], file=output)\n        move(n - 1, a, b, c, auxiliary, target, source, output)\n\ndef hanoiArray(n):\n    a, b, c = list(range(n, 0, -1)), [], []\n    with StringIO() as output:\n        print([a, b, c], file=output)\n        move(n, a, b, c, a, c, b, output)\n        return output.getvalue().rstrip('\\n')", "diamonds_and_toads=lambda s,f:{k:s.count(k[0])+2*s.count(k[0].upper())for k in['crystal','python','ruby','squirrel'][f<'f'::2]}", "'''Large inputs are given because if you use a list comprehension iteration approach'''\n#then your asymptomatic runtime will exceed the server threshold to stop the request\n#Instead, treat this as a math problem to allow it to maintain 0(1)\ndef odd_count(n):\n    return (n-1)/2 if n%2!=0 else n/2", "def capitalize_word(word):\n    all_lower=word.lower()\n    capitalize=all_lower.capitalize()\n    return capitalize", "def chromosome_check(sperm):\n    return 'Congratulations! You\\'re going to have a %s.' %('daughter' if sperm[-1] == 'X' else 'son')", "def ski_jump(mountain):\n    x = len(mountain)**2 * 1.35\n    y = {      x < 10: \"He's crap\",\n         10 <= x < 25: \"He's ok\",\n         25 <= x < 50: \"He's flying\",\n         50 <= x     : \"Gold!\"}[True]\n    return f\"{x:.2f} metres: {y}!\"", "from itertools import combinations\n\ndef count_inversion(lst):\n    return sum(a>b for a,b in combinations(lst,2))", "import math\ndef distance(n):\n    if n == 1:\n        return 0\n    if n <= 9:\n        return 2 if n%2 else 1\n    lower = math.ceil(n**0.5)-2 if math.ceil(n**0.5)%2 else math.ceil(n**0.5)-1\n    cycle = list(range(lower, (lower+1)//2-1, -1)) + list(range((lower+1)//2+1, lower+2))\n    return cycle[(n-lower**2-1) % len(cycle)]", "def stringy(size):\n    return ''.join('0' if x % 2 else '1' for x in range(size))", "import string\ndef solve(st,k): \n    for c in string.ascii_lowercase:\n        count = st.count(c)\n        st = st.replace(c,'',k)\n        k -= count\n        if k <= 0: break\n    return st\n", "def find_missing(arr1, arr2):\n    for x in set(arr1):\n        if arr1.count(x) != arr2.count(x): return x\n", "def leo(oscar):\n    if oscar == 88:\n        return \"Leo finally won the oscar! Leo is happy\"\n    elif oscar == 86:\n        return \"Not even for Wolf of wallstreet?!\"\n    elif oscar <= 88 and oscar != 86:\n        return \"When will you give Leo an Oscar?\"\n    elif oscar > 88:\n        return \"Leo got one already!\"", "def bumps(road):\n    bumps = [x for x in road if x == 'n']\n    if len(bumps) > 15:\n        return 'Car Dead'\n    return 'Woohoo!'", "def is_lucky(ticket):\n    try:\n        if ticket == '':\n            return False\n        else:\n            idk = [int(x) for x in ticket]\n            first = sum(idk[0:3])\n            second = sum(idk[3:6])\n            if first == second:\n                return True\n            else:\n                return False\n    except:\n        return False", "def solve(r):\n    \u01c2 = 1\n    for x in sorted(r):\n        if x > \u01c2:\n            break\n        else: \u01c2 += x\n    return \u01c2", "def invite_more_women(arr=0):\n    lst1=[i for i in arr if i<0]\n    lst2=[i for i in arr if i>0]\n    return len(lst1)<len(lst2)", "def solve(arr):\n    a, b, c = sorted(arr)\n    return (a + b + min(a+b, c)) // 2", "def Dragon(n):\n    if type(n) != int or n < 0:\n        return \"\"\n    stg, a, b = \"F{a}\", \"{a}R{b}FR\", \"LF{a}L{b}\"\n    for _ in range(n):\n        stg = stg.format(a=a, b=b)\n    return stg.replace(\"{a}\", \"\").replace(\"{b}\", \"\")", "def powerset(s):\n    if not s:\n        return [[]]\n    result = powerset(s[1:])\n    return result + [[s[0]] + subset for subset in result]", "def longest(words):\n    biggest = 0\n    for word in words:\n        if len(word) > biggest:\n            biggest = len(word)\n    return biggest ", "from collections import Counter\n\ndef fib_digits(n):\n    a = 0\n    b = 1\n    \n    for i in range(2, n + 1):\n        a, b = b, a + b\n    \n    c = Counter(str(b))\n    res = sorted([(int(x[0]), int(x[1])) for x in zip(list(c.values()), list(c.keys()))], key = lambda m: (m[0], m[1]))[::-1]\n    return res\n", "def paperwork(n, m):\n    if n | m > 0:\n        p = n * m\n        return p\n    else:\n        return 0", "def choose(n,k):\n    l = [max(k,n-k),min(k,n-k)]\n    nu = 0 if k > n else 1\n    de = 1\n    for i in range(l[0]+1,n+1):\n        nu *= i\n    for i in range(1,l[1]+1):\n        de *= i\n    return int(nu/de)", "def get_positions(n):\n    num = n % 27\n    return (num % 3,int(num % 3**2 / 3**1),int(num / 3**2))", "def sea_sick(sea):\n    return \"Throw Up\" if (sea.count(\"~_\") + sea.count(\"_~\")) > 0.2*len(sea) else \"No Problem\"", "from re import fullmatch\n\ndef is_digit(n):\n    return True if fullmatch(r'\\d', n) else False", "def binary_array_to_number(arr):\n    return int(bytearray(\"\".join(str(a) for a in arr), encoding=\"utf-8\"), base=2)", "from itertools import product\ndef proc_seq(*li):\n    un = {int(''.join(i)) for i in list(product(*map(str, li))) if i[0]!='0'}\n    return [1,un.pop()] if len(un)==1 else [len(un),min(un),max(un),sum(un)]", "def html(tag, *contents, **attr):\n    open_tag = tag + ''.join(f' {\"class\" if n == \"cls\" else n}=\"{v}\"' for n, v in attr.items())\n    return '\\n'.join(f'<{open_tag}>{c}</{tag}>' for c in contents) or f'<{open_tag} />'", "from collections import Counter \n\nEXECUTIONS_ORDER = [('Z', Counter(\"ZERO\"),  '0'),\n                    ('W', Counter(\"TWO\"),   '2'),\n                    ('U', Counter(\"FOUR\"),  '4'),\n                    ('X', Counter(\"SIX\"),   '6'),\n                    ('G', Counter(\"EIGHT\"), '8'),\n                    ('O', Counter(\"ONE\"),   '1'),\n                    ('H', Counter(\"THREE\"), '3'),\n                    ('F', Counter(\"FIVE\"),  '5'),\n                    ('V', Counter(\"SEVEN\"), '7'),\n                    ('I', Counter(\"NINE\"),  '9')]\n\ndef original_number(s):\n    ans, count, executions = [], Counter(s), iter(EXECUTIONS_ORDER)\n    while count:\n        c, wordCount, value = next(executions)\n        ans.extend([value]*count[c])\n        for _ in range(count[c]): count -= wordCount\n    return ''.join(sorted(ans))", "def quadratic(x1, x2):\n    if x1 != x2:\n        c = (x1 * x1 * x2 - x2 * x2 * x1) / (x1 - x2)\n        b = (-c - x1 * x1) / x1 if x1 else (-c - x2 * x2) / x2\n        return (1, b, c)\n    else:\n        return (1, -2 * x1, x1 * x1)", "from itertools import count\n\n\ndef next_numb(val):\n    if val >= 9999999999:\n        return 'There is no possible number that fulfills those requirements'\n    for i in count(val + 1):\n        s = str(i)\n        if i % 2 == 1 and i % 3 == 0 and len(s) == len(set(s)):\n            return i", "def solve(a,b):\n    return [a.count(x) for x in b]", "n = 100000\nli = [0] * n\nstore = []\nfor i in range(1,n):\n    for j in range(i-1, n, i):\n        li[j] ^= 1\n    store.append(li)\ndoors=lambda n:store[n+1][:n].count(1)", "def lcm(a, b):\n    from fractions import gcd\n    return a * b // gcd(a, b)\n\ndef greatest(x, y, n):\n    m = lcm(x, y)\n    return (n//m)*m if m<n else 0\n    \ndef smallest(x, y, n):\n    m = lcm(x, y)\n    return ((n+m)//m)*m", "def capitalize(s,ind):\n    s = list(s)\n    for i in range(len(ind)):\n        if ind[i] > len(s):\n            s = s\n        else:\n            s[ind[i]] = s[ind[i]].upper()\n    return ''.join(s)", "from collections import Counter\ndef is_isogram(word):\n    if not isinstance(word, str): return False\n    counts = Counter(filter(str.isalpha, word.lower()))\n    return bool(counts) and min(counts.values()) == max(counts.values())", "def membership(amount, platinum, gold, silver, bronze):\n    import inspect\n    frame = inspect.currentframe()\n    args, _, _, values = inspect.getargvalues(frame)\n    for i in reversed(list(range(1, 5))):\n        if i > 1:\n            if values[args[i-1]] > values[args[0]] >= values[args[i]]:\n                return args[i].title()\n        elif values[args[0]] >= values[args[i]]:\n            return args[i].title()\n    return \"Not a member\"\n", "def say_hello(name, city, state):\n    newname = ' '.join(name)\n    return f'Hello, {newname}! Welcome to {city}, {state}!'", "# What do you mean computationally wasteful?\ndef plane_seat(a):\n    return {\n        f'{row}{seat}': f'{end}-{side}'\n        for end, rows in [('Front', list(range(1, 21))), ('Middle', list(range(21, 41))), ('Back', list(range(41, 61)))]\n        for row in rows\n        for side, seats in [('Left', 'ABC'), ('Middle', 'DEF'), ('Right', 'GHK')]\n        for seat in seats\n    }.get(a, 'No Seat!!')\n", "def move_vowels(input): \n    return ''.join(c for c in input if c not in 'aeiou')+''.join(c for c in input if c in 'aeiou')", "def find_nb(m):\n    n=s=0\n    while True:\n      n+=1\n      s+=n\n      k=s*s\n      if k== m:\n          return n\n      elif k>m:\n          return -1 \n", "def run_length_encoding(s):\n  count, prev, lst = 1, '', []\n  for c in s:\n    if c != prev:\n      if prev: lst.append([count, prev])\n      count, prev = 1, c\n    else: count += 1\n  if len(prev) > 0 : lst.append([count, prev])\n  return lst", "def lovefunc( flowers1, flowers2 ):\n    return (flowers1 + flowers2) % 2 != 0", "b = [False]\na = []\na2 = [None]\n\ndef f(n):\n    def is_happy(n):\n        s = {n}\n        while n != 1:\n            nn = 0\n            while n > 0: nn += (n%10)**2; n//=10\n            n = nn\n            if n < len(b): return b[n]\n            if n in s: return False\n            s.add(n)\n        return True\n    for k in range(1, n+1):\n        b.append(is_happy(k))\n        if b[k]: a.append(k)\n        a2.append(len(a))\nf(300000)\n\ndef performant_numbers(n):\n    return a[:a2[n]]", "from math import factorial\ndef diagonal(n, p):\n    return factorial(n + 1) // (factorial(p + 1) * factorial(n - p))", "from itertools import cycle\n\ndef find_pattern(s):\n    diffs = [y - x for x, y in zip(s, s[1:])]    \n    for i in range(1, len(diffs) + 1):\n        if len(diffs) % i == 0 and all(a == b for a, b in zip(diffs, cycle(diffs[:i]))): return diffs[:i]", "def eq_sum_powdig(hMax, exp):\n    ret = []\n    for i in range(10, hMax + 1):\n        if i == sum(int(j) ** exp for j in str(i)):\n            ret.append(i)\n    return ret", "def is_onion_array(a):\n  i = 0; j = -1\n  while i != len(a)//2:\n    if a[i] + a[j] > 10:\n      return False\n    i += 1\n    j -= 1\n  return True", "def fixed_xor(a, b):\n    return \"\".join(f\"{int(x, 16)^int(y, 16):x}\" for x, y in zip(a, b))", "from itertools import groupby\n\ndef ranking(people):\n    x = len(str(len(people))); rank = 1\n    people = sorted(people,key=lambda p: p['points'],reverse=True)\n    groups = [[*g[1]] for g in groupby(people,key=lambda p: p['points'])]\n    for g in groups:\n        for p in g: p['position'] = rank\n        rank += len(g)\n    return sorted(people,key=lambda p: str(p['position']).zfill(x)+p['name'])\n", "def loose_change(coins, change):\n  return search(sorted(coins, reverse=True), change)\n\ndef search(coins, x, n=0):\n  if x == 0: return n\n  m = 9999\n  for c in coins:\n    if x >= c:\n      q, r = divmod(x, c)\n      m = min(m, search(coins, r, n + q))\n  return m", "def is_substitution_cipher(s1, s2):\n    return s2 == s1.translate(str.maketrans(s1, s2)) \\\n            and s1 == s2.translate(str.maketrans(s2, s1))", "from functools import reduce \ndef presentation_agenda(friend_list):\n\n    def add_exclusive_locations(agenda, friend):\n        locations_visited_by_peers = reduce(\n                lambda lst, p: lst + p['dest'] if p != friend else lst,\n                friend_list,\n                []\n        )\n  \n        def is_unique(loc): \n            return loc not in locations_visited_by_peers\n            \n        exclusive = list(filter(is_unique, friend['dest']))\n        if exclusive: # at least one location?\n            agenda.append({'person': friend['person'], 'dest': exclusive})\n        return agenda\n            \n    return reduce(add_exclusive_locations, friend_list, []); ", "def prime_primes(N):\n    prime = []\n    for iter in range(2,N):\n        for i in range(2,iter):\n             if (iter%i)==0:\n               break\n        else:\n               prime.append(iter)\n    \n    l = [j/i for i in prime for j in prime if (j/i)<1]\n    return (len(l),int(sum(l)))", "def is_zero_balanced(arr):\n    return all(arr.count(i)==arr.count(-i) for i in arr) if arr else False", "def is_dd(n):\n    lstr = list(str(n))\n    dds = 0\n    \n    for x in lstr:\n        numdigits = 0;\n        \n        for y in lstr:\n            if y == x:\n                numdigits += 1\n        if numdigits == int(x):\n            return True\n            \n    return False\n            \n", "from datetime import datetime\n\ndata = \"\"\"\nAries March 21 April 19\nTaurus April 20 May 20\nGemini May 21 June 20\nCancer June 21 July 22\nLeo July 23 August 22\nVirgo August 23 September 22\nLibra September 23 October 22\nScorpio October 23 November 21\nSagittarius November 22 December 21\nCapricorn December 22 January 19\nAquarius January 20 February 18\nPisces February 19 March 20\n\"\"\"\ndata = [line.split() for line in data.split('\\n') if line.strip()]\nmonth = lambda s: datetime.strptime(s, '%B').month\ndata = [(z, month(m1), int(d1), month(m2), int(d2)) for z, m1, d1, m2, d2 in data]\n\ndef get_zodiac_sign(day, month):\n    for z, m1, d1, m2, d2 in data:\n        if (m1 == month and d1 <= day) or (m2 == month and day <= d2):\n            return z", "def is_prime(n):\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_maxlength_chain(n):\n\n    summ, primes, res = 0, [], []\n\n    for i in range(2, n):\n        if is_prime(i):\n            if summ + i < n:\n                summ += i\n                primes.append(i)\n            elif summ + i - primes[0] < n:\n                summ += i\n                primes.append(i)\n            else:\n                break\n    \n    l = len(primes)\n\n    for j in range(l, 0, -1):\n        for k in range(l-j+1):\n            lst = primes[k:k+j]\n            temp = sum(lst)\n            if is_prime(temp):\n                res.append(temp)\n        if len(res) != 0:\n            break\n\n    return res", "from re import fullmatch\n\ndef validate_usr(username):\n    return bool(fullmatch(r\"[_0-9a-z]{4,16}\", username))", "from collections import Counter\n\ndef product(s):\n    return Counter(s).get(\"!\",0)*Counter(s).get(\"?\",0)", "from itertools import groupby\nfrom operator import itemgetter\n\ndef sum_of_regular_numbers(arr):\n    xs = [(i, x-y) for i, (x, y) in  enumerate(zip(arr, arr[1:]))]\n    it = (list(grp) for key, grp in groupby(xs, key=itemgetter(1)))\n    it = ((grp[0][0], len(grp)) for grp in it if len(grp) > 1)\n    return sum(sum(arr[i:i+n+1]) for i, n in it)", "encode = decode = lambda message, key: message.translate(str.maketrans(*mapping(key)))\n\ndef mapping(key):\n  even, odd = key[::2] + key[::2].upper(), key[1::2] + key[1::2].upper()\n  return (even + odd, odd + even)", "array_mash = lambda a,b: list(sum(zip(a,b),()))", "def arithmetic(a, b, operator):\n    if operator == \"add\":\n        return a+b\n    elif operator == \"subtract\":\n        return a-b\n    elif operator == \"multiply\":\n        return a*b\n    elif operator == \"divide\":\n        return a/b\n    else:\n        return a%b", "def bingo(ticket, win):\n    winner = sum(1 for stg, val in ticket if chr(val) in stg) >= win\n    return \"Winner!\" if winner else \"Loser!\"", "hamming_weight = lambda x: list(bin(x)).count('1')  # :) \n", "def reverse_it(data):\n  if type(data) == str: return data[::-1]\n  elif type(data) == int: return int(str(data)[::-1])\n  elif type(data) == float: return float(str(data)[::-1])\n  else: return data", "def sflpf_data(val, limit):\n    result = []\n    for n in range(4, limit+1):\n        factors =  prime_factors(n)\n        if len(factors) > 1 and min(factors) + max(factors) == val:\n            result.append(n)\n    return result\n\ndef prime_factors(n):\n    factors = []\n    while not n % 2:\n        factors.append(2)\n        n = n // 2\n    while not n % 3:\n        factors.append(3)\n        n = n // 3\n    k = 5\n    step = 2\n    while k <= n**0.5:\n        if not n % k:\n            factors.append(k)\n            n = n // k\n        else:\n            k = k + step\n            step = 6 - step\n    factors.append(n)\n    return factors\n", "def bouncy_ratio(percent):\n    if percent < 0 or percent > 0.99:\n        raise Error\n    n = 99\n    bouncy = 0.0\n    while True:\n        n += 1\n        ns = str(n)\n        gaps = [int(ns[i]) - int(ns[i - 1]) for i in range(1, len(ns))]\n        if not(all(gap >= 0 for gap in gaps) or all(gap <= 0 for gap in gaps)):\n            bouncy += 1.0\n            if bouncy / n >= percent:\n                return n", "def gematria(string):\n    d = dict(a=1, b=2, c=3, d=4, e=5, f=6, g=7, h=8, i=9, k=10, l=20, m=30, n=40, o=50, p=60, q=70, r=80, s=90, t=100, u=200, x=300, y=400, z=500, j=600, v=700, w=900)\n    return sum(d.get(x, 0) for x in string.lower())", "def alan(arr):\n    a = ['Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway']\n    for i in a:\n        if i not in arr:\n            return \"No, seriously, run. You will miss it.\"\n    return \"Smell my cheese you mother!\"", "def reverse_complement(dna):\n    table = str.maketrans(\"ACGT\", \"TGCA\")\n    return \"Invalid sequence\" if set(dna) - set(\"ACGT\") else dna.translate(table)[::-1]", "def boredom(staff):\n    lookup = {\n        \"accounts\": 1,\n        \"finance\": 2,\n        \"canteen\": 10,\n        \"regulation\": 3, \n        \"trading\": 6,\n        \"change\": 6,\n        \"IS\": 8,\n        \"retail\": 5,\n        \"cleaning\": 4,\n        \"pissing about\": 25\n    }\n    n = sum(lookup[s] for s in staff.values())\n    if n <= 80:\n        return \"kill me now\"\n    if n < 100:\n        return \"i can handle this\"\n    return \"party time!!\"", "def distribute(nodes, workload):\n    n = workload // nodes\n    r = workload % nodes\n    jobs = []\n    works = [i for i in range(workload)]\n    j = 0\n    for i in range(nodes):\n        if i < r:\n            jobs.append([works.pop(0) for i in range(n+1)])\n        else:\n            jobs.append([works.pop(0) for i in range(n)])\n    return jobs", "from heapq import *\n\ndef add_all(a):\n    n = m = 0\n    heapify(a)\n    while len(a) > 1:\n        m = heappop(a) + heappop(a)\n        n += m\n        heappush(a, m)\n    return n", "def diff(a, b):\n    return sorted(set(a).symmetric_difference(b))", "def solve(arr):\n    lmax, lmin = iter(sorted(arr)) , iter(sorted(arr)[::-1])\n    return [next(lmax) if i%2==1 else next(lmin) for i in range(0,len(arr))]", "def summy(string_of_ints):\n    return sum(int(i) for i in string_of_ints.split(\" \"))", "def aa_percentage(*prot):\n    if len(prot)>1:\n        sear = prot[1]\n    else:\n        sear =  [\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"]\n    times = 0\n    for i in sear:\n        times += prot[0].count(i)\n    return round((times / len(prot[0])) * 100)", "def solve(arr):\n    fn = lambda p: lambda n: 0 if n % p else 1 + fn(p)(n // p)\n    return sorted(sorted(arr, key=fn(3), reverse=True), key=fn(2))", "def square(number):\n    lista = [1]\n    for n in range(1, number):\n        result = lista[-1]*2\n        lista.append(result)\n    return lista[-1]", "button_sequences=lambda R,B:(lambda r,f:r.sub(r'(.)\\1+',r'\\1',f.reduce(lambda x,y:x+('_'if y==('0','0')else'R'if y==('1','0')else'B'if y==('0','1')else'R'if x[-1:]in['','_','R']else'B'),zip(R,B),'')).replace('_',''))(__import__('re'),__import__('functools'))", "from itertools import count\n\ndef tops(msg):\n    deltas = count(7, 4)\n    xs = []\n    i, n = 2, 2\n    while i < len(msg):\n        xs.append(msg[i:i+n])\n        i += next(deltas)\n        n += 1\n    return ''.join(reversed(xs))", "def divisible_count(x,y,k):\n    result = 0\n    for i in range(x, y+1):\n        if i%k == 0:\n            result += 1\n            break\n    result += (y-i)//k\n    return result \n", "def my_crib(n):\n    return '\\n'.join([' '*(n-i) + '/' + ' '*2*i + '\\\\' + ' '*(n-i) for i in range(n)] + ['/' + '_'*2*n + '\\\\'] + ['|' + ' '*2*n + '|'] *(n-1) + ['|' + '_'*2*n + '|'])", "def series_slices(digits, n):\n    if n > len(digits):\n        raise ValueError\n    else:\n        return [[int(digit) for digit in digits[i:i+n]] for i in range(0, len(digits)-n+1)]", "def swap(s,n):\n    n = str(bin(n))[2:]\n    index = 0\n    new_s = ''\n    for letter in s:\n        if letter.isalpha():\n            if n[index%len(n)]=='1':\n                new_s += letter.swapcase()\n            else:\n                new_s += letter\n            index+=1\n        else:\n            new_s += letter\n    return new_s", "def variance(li):\n    common = 1 / len(li)\n    e_of_x = sum(len(i) * common for i in li)\n    result = sum((len(i) ** 2) * common for i in li) - e_of_x ** 2\n    return round(result,4)", "def find_part_max_prod(n):\n    if n % 3 == 0:\n        return [[3]*(n/3),3**(n/3)]\n    if n % 3 == 2:\n        return [[3]*(n//3)+[2],3**(n//3)*2]\n    if n == 1:\n        return 1\n    if n % 3 == 1:\n        return [[4]+[3]*(n//3-1),[3]*(n//3-1)+[2,2],3**(n//3-1)*4]", "def xor(a,b):\n    return True if (False in (a, b)) and (True in (a, b)) else False", "def four_piles(n,y):       \n    x = y * n / (y**2 + 2*y + 1)\n    return [x + y, x - y, x * y, x / y] if int(x) == x and x - y > 0 else []", "def cat_mouse(x):\n    return [\"Escaped!\",  \"Caught!\"][x.count('.') <= 3]", "from math import sqrt\ndef is_prime(n):\n    if n < 2: return False\n    for x in range(2, int(sqrt(n)) + 1):\n        if n % x == 0: return False\n    return True\n\ndef all_dig_prime(n):\n    for d in str(n):\n        if d not in \"2357\": return False\n    return True\n\ndef not_primes(a, b):\n    res = []\n    for i in range(a,b):\n        if all_dig_prime(i) and not is_prime(i): res.append(i)\n    return res", "from re import compile, match\n\nREGEX = compile(r'\\s*$')\n\n\ndef whitespace(string):\n    return bool(match(REGEX, string))\n", "def mid_endian(n):\n    bs = n.to_bytes((n.bit_length() + 7) // 8 or 1, byteorder='little')\n    return (bs[len(bs)%2::2] + bs[::-2]).hex().upper()", "# No need to store more than the last value so no functools.lru_cache\nST = lambda n: 6**n + 5**n - 2**n - 1\nSF = lambda x, y: (x - 5*y - 4) // 4\n\nresult = []\ndef gen():\n    previous, n = ST(0), 1\n    while True:\n        current = ST(n)\n        val = SF(current, previous)\n        if not val%10: yield val\n        previous, n = current, n+1\nvalues = gen()\n\ndef find_mult10_SF(n):\n    while len(result) < n: result.append(next(values))\n    return result[n-1]", "sc_perm_comb=lambda n:sum({int(''.join(p))for r in range(len(str(n)))for p in __import__('itertools').permutations(str(n),r+1)})", "def domino_reaction(s):\n    return s.replace(\"|\", \"/\", min([s.find(d) if s.find(d)!=-1 else len(s)  for d in \" /\"]) )\n", "def problem(a):\n    return 50*a+6 if type(a) in (int, float) else 'Error'", "def solve(s):\n    return sum(i+1 for i,d in enumerate(list(s)) if d in '13579')", "def add_binary(a,b):\n    sum = a + b\n    res = \"\"\n    while sum > 0:\n        if sum & 0x1:\n            res = \"1\" + res\n        else:\n            res = \"0\" + res\n        sum = sum >> 1;\n    return res", "def negation_value(str, val):\n  return bool(not val if len(str) % 2 else val)", "def sum_it_up(numbers_with_bases):\n    return sum(int(num, base) for num, base in numbers_with_bases)", "def filter_homogenous(arrays):\n    k = []\n    while arrays:\n        x = arrays.pop()\n        if x and all(type(x[0])==type(i) for i in x[1:] ):\n            k.insert(0,x)\n    return k\n", "def code(x, y):\n    return sum(int('9' * len(str(n))) - n for n in [x, y])\n", "import re\n\ndef calculate_string(st):\n    s = re.sub( '[^0-9+-/*]+', '', st)\n    s = s.replace(',', '')\n    return str(round(eval(s)))", "factorial = lambda n: 1 if 0<=n<=1 else n*factorial(n-1) if n>0 else None", "def convert_num(number, base):\n    if not isinstance(number, int):\n        return \"Invalid number input\"\n    if base == 'hex':\n        return hex(number)\n    elif base == 'bin':\n        return bin(number)\n    return \"Invalid base input\"\n", "def string_constructing(pattern,target):\n    pattern = list(pattern)\n    target = list(target) + [None]\n    buffer = [None]\n    pos= 0\n    count= 0\n    while (True):\n        \n        if(target[pos]==buffer[pos]):\n            if(target[pos]==None):\n                return count\n            pos +=1\n        else:\n            if(buffer[pos]==None):\n                buffer[-1:-1]=pattern\n                count+=1\n            else:\n                del buffer[pos]\n                count+=1\n            \n    return count\n        \n    \n    \n", "def letter_count(s):\n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n    \n    return count", "from numpy import dot\n\ndef is_orthogonal(u, v): \n    return not dot(u,v )", "def read_out(acrostic):\n    return \"\".join( word[0] for word in acrostic )", "from re import sub\n\ndef calculate(s):\n    try: return eval(sub(r'\\b0+(?=\\d)', '', s))\n    except: return 0", "from fractions import gcd\nfrom functools import reduce\n\ndef mn_lcm(m, n):\n    m, n = sorted([m, n])\n    return reduce(lambda x, y: x * y / gcd(x, y), range(m, n + 1))", "def table_game(t):\n  l = [t[0][0],t[0][2],t[2][0],t[2][2]]\n  return l if sum(l) == t[1][1] and sum(sum(t,[])) == sum(l) * 4 else [-1]", "def how_many_pizzas(n):\n    return f\"pizzas: {n ** 2 //( 8 ** 2)}, slices: {round(((n ** 2) /( 8 ** 2)-(n ** 2)//( 8 ** 2))* 8) }\"  \n\n\n", "def solve(st, idx):\n    if st[idx] != '(':\n        return -1\n    open = 1\n    for i in range(idx+1, len(st)):\n        if st[i] == '(':\n            open += 1\n        elif st[i] == ')':\n            open -= 1\n        if open == 0:\n            return i", "result = ['1']\n\ndef get_a_down_arrow_of(n):\n    while len(result) < n:\n        i = len(result)\n        result.append(result[-1][:i] + str((i+1)%10) + result[-1][i-1::-1])\n    return '\\n'.join(result[x].center(2*n-1).rstrip() for x in range(n-1, -1, -1))", "from numpy import median as median_\n\ndef median(arr):\n    return median_(arr)", "def triple_shiftian(T,n):\n    for i in range(3,n+1):\n        T.append(4 * T[i-1] - 5 * T[i-2] + 3 * T[i-3])\n    return T[n]  ", "def repeat_adjacent(string):\n    check = ''\n    big_group = []\n    for i in range(1,len(string)-1):\n        if (string[i-1] == string[i] or string[i] == string[i+1]):\n            check += string[i]\n        else:\n            if len(set(check)) > 1:\n                big_group.append(check) \n            check =''\n    if len(set(check)) > 1:\n        big_group.append(check)\n    return len(big_group)\n", "def add(l):\n    try:\n        t = [l[0]]\n        for i,j in enumerate(l[1:]):\n            t.append(t[i]+ j)\n        if sum(l)%1!=0 or sum(t)%1!=0 or type(l)!=list:\n            return 'Invalid input'\n        return t \n    except:\n        return 'Invalid input'", "def list_depth(L):\n    try : return 1 + max(list_depth(e) for e in L if isinstance(e, list))\n    except : return 1", "def tiy_fizz_buzz(string):\n    new_string = ''\n    for i in string:\n        if i.isupper():\n            new_string += 'Iron'\n            if i in ('AEIOU'):\n                new_string += ' Yard'\n        elif i in ('aeiou'):\n            new_string += 'Yard'\n        else:\n            new_string += i\n    return new_string\n                \n", "def ranks(results):\n    ranks = {}\n    for k, v in enumerate(sorted(results, reverse=True), start=1):\n        if not v in ranks:\n            ranks[v] = k\n    return [ranks[i] for i in results]", "import re\n\ndef kooka_counter(laughing):\n    return len(re.findall(r'(Ha|ha)\\1*', laughing))", "from functools import reduce\ndef lcm(*args):\n    return reduce(lcms, args) if args else 1\n\ndef gcd(a,b):\n    \"\"\"Euclidean Algorithm\"\"\"\n    return b if a == 0 else gcd(b % a, a)\n    \ndef lcms(a, b):\n    return (a*b) // gcd(a,b)", "def olympic_ring(string):\n    n = sum(string.count(c) for c in 'ADOPQRabdegopq') + string.count('B') * 2\n    return ['Not even a medal!', 'Bronze!', 'Silver!', 'Gold!'][max(min(int(n / 2) - 1, 3), 0)]", "def order(pizzas, salads, appetizers):\n    time = 0\n    if pizzas > 0:\n        time = (pizzas * 3) / 2\n        oven_cycles = (pizzas // 10) + 1\n        time = time + (oven_cycles * 10)\n        time_2 = (salads * 3) + (appetizers * 5)\n        if time > time_2:\n            return time\n        else:\n            return time_2\n    else:\n        time_2 = (salads * 3) + (appetizers * 5)\n        return time_2\n    \n", "def solve_for_x(equation):\n  left_side = equation.split('=')[0];\n  right_side = equation.split('=')[1];\n\n  for x in range(-1000, 1000):\n    if eval(left_side) == eval(right_side):\n      return x", "def heron(*l):\n    s = sum(l) / 2\n    return round((s * (s - l[0]) * (s - l[1]) * (s - l[2]))**.5,2)", "from math import ceil\n\ndef layers(n):\n    r = ceil(n**0.5)    \n    return (r + (1 if r % 2 else 2)) // 2    ", "def sorter(textbooks):\n    return sorted(textbooks, key=lambda w:w.casefold())", "import sys\n\ndef hex_to_dec(s):\n    hex = {'a': 10,'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15}\n    \n    res = 0\n    weight = 16 ** (len(s) - 1)\n    \n    for ch in s:\n        if ch in hex:\n            res += hex.get(ch) * weight\n        else:\n            res += int(ch) * weight\n        weight /= 16\n    return res", "simple_multiplication = lambda num: num * (8 if num % 2 == 0 else 9 )", "xMasTree=lambda n: (lambda part: part+[part[0],part[0]])([\"\".join([\"_\"*(n-i-1),\"#\"*(2*i+1),\"_\"*(n-i-1)]) for i in range(n)])", "def getSlope(p1, p2):\n    if p2[0] - p1[0]: return (p2[1]-p1[1]) / (p2[0]-p1[0])", "def find_deleted_number(arr, mixed_arr):\n    return len(arr) > len(mixed_arr) and (set(arr) - set(mixed_arr)).pop()", "def nth_chandos_number(n):\n    return int(bin(n)[2:] + '0', 5)", "import string\n\n\ndef unusual_sort(array):\n    #your code here\n    upper = sorted([i for i in array if i in list(string.ascii_uppercase)])\n    lower  = sorted([it for it in array if it in list(string.ascii_lowercase)])\n    intint = sorted([num for num in array if num in list(map(int,list(string.digits)))])\n    strints = sorted([e for e in array if e in list(string.digits)])\n    upper.extend(lower)\n    intint.extend(strints)\n    want = []\n    for i in intint:\n        if type(i) is not int:\n            want.append((int(i), i))\n        else:\n            want.append((i, i))\n    ans = [i[1] for i in sorted(want,key = lambda x: x[0])]\n    upper.extend(ans)\n\n    return upper", "def protects(location):\n    \"\"\"Returns the protected spaces (as a set), given a location.\n       Examples:\n          protects('b2') == {'a3', 'c3'}\n          protects('a2') == {'b2'}\n          protects('f8') == set()\n    \"\"\"\n    if location[1] == '8':  return set()\n    row = int(location[1]) + 1\n    col = location[0]\n    if col == 'a':\n        cols = {'b'}\n    elif col == 'h':\n        cols = {'g'}\n    else:\n        cols = {chr(ord(col)-1), chr(ord(col)+1)}\n    return {f'{c}{row}' for c in cols}\n\n\ndef covered_pawns(pawns):\n    protected_spaces = set()\n    for p in pawns:\n        protected_spaces |= protects(p)\n    return len(set(pawns) & protected_spaces)", "def divisors(n):\n    devisors = []\n    for number in range(1, n+1):\n        result = n % number\n        if result == 0:\n            devisors.append(result)\n    return(len(devisors))\n", "def starting_mark(height):\n    if height <= 1.52:\n        res = 9.45 - ((1.52 - height) * (10.67 - 9.45) / (1.83 - 1.52))\n    elif 1.52 < height <= 1.83:\n        res = 10.67 - ((1.83 - height) * (10.67 - 9.45) / (1.83 - 1.52))\n    else:\n        res = 10.67 + ((height - 1.83) * (10.67 - 9.45) / (1.83 - 1.52))\n    return round(res, 2)", "def hex_hash(code):\n    return sum( int(d) for d in ''.join(map(hex, map(ord, code))) if d.isdigit() )", "def catch_sign_change(lst):\n    res = 0\n    for i in range(len(lst)-1):\n        if (lst[i] >= 0 and lst[i+1] < 0) or (lst[i] < 0 and lst[i+1] >= 0):\n            res += 1\n    return res", "def average(array):\n    print(array)\n    return int(round(sum(array)/len(array)))", "def array_change(arr):\n    count=0\n    for i in range(len(arr)-1):\n        if arr[i]==arr[i+1]:\n            arr[i+1]+=1\n            count+=1\n        elif arr[i]>arr[i+1]:\n            count+=arr[i]-arr[i+1]+1\n            arr[i+1]+=arr[i]-arr[i+1]+1\n    return count", "def hero(bullets, dragons):\n    p = bullets >= 2*dragons\n    return p", "def shift_left(a, b):\n    n = 0\n    while not b.endswith(a):\n        n += 1\n        a = a[1:]\n    return n + (len(b) - len(a))", "def sort_array(arr):\n  odds = sorted((x for x in arr if x%2 != 0), reverse=True)\n  return [x if x%2==0 else odds.pop() for x in arr]", "from itertools import combinations\nfrom math import hypot\n\nlimit = 10000000\ncandidates = ((a,b,hypot(a,b)) for a,b in combinations(range(1, 1000), 2))\nD = {a*b*int(c):[a,b,int(c)] for a,b,c in candidates if c.is_integer() and a*b*c < limit}\npythagorean_triplet = D.__getitem__", "def describeList(lst):\n    if lst:\n        if len(lst) == 1:\n            return 'singleton'\n        return 'longer'\n    return 'empty'", "def count_zeros_n_double_fact(n):\n    if n % 2: return 0\n    s, n = 0, n // 2\n    while n >= 5:\n        n //= 5\n        s += n\n    return s", "def capitalize(s):\n    list = []\n    ret = \"\"\n    i = True  # capitalize\n    for char in s:\n        if i:\n            ret += char.upper()\n        else:\n            ret += char.lower()\n        if char != ' ':\n            i = not i\n    list.append(ret)\n    ret2 = ret.swapcase()\n    list.append(ret2)\n    return list", "t = [i*(i-1)//2 for i in range(3,1000)]\ndef is_madhav_array(arr):\n    if len(arr) not in t: return False\n    sums = {arr[0], arr[1] + arr[2]}\n    for i,j in zip(t, t[1:]):\n        if j>len(arr): \n            break\n        sums.add(sum(arr[i:j]))\n    return len(sums)==1", "def arithmetic_sequence_elements(a, r, n):\n    z = str(a)\n    for i in range(n - 1):\n        a = a + r\n        z = z + \", \" + str(a)\n\n    return z", "def roll(desc, verbose=False):   \n    if not desc:\n        return False\n    desc=\"\".join(desc.split())  \n    temp=\"\"\n    for i in desc:\n        if i in \"+-\":\n            break\n        temp+=i\n    for i in temp:\n        if i not in \"1234657890d\":\n            return False\n    remain=desc[len(temp):]\n    for i in remain:\n        if i not in \"1234657890d+-\":\n            return False\n    for i in range(len(remain)-1):\n        if remain[i+1] in \"+-\" and remain[i] in \"+-\":\n            return False\n    remain=eval(remain) if remain else 0\n    temp=temp.split(\"d\")    \n    temp[0]=1 if not temp[0] else int(temp[0])\n    return { \"dice\": [1]*temp[0], \"modifier\": remain } if verbose else 1*temp[0]+remain", "def find_missing_numbers(arr):\n    if not arr:\n        return []\n    return sorted(set(range(arr[0] + 1, arr[-1])).difference(arr))\n", "def minimum(arr):\n    mi=100000\n    for a in arr:\n        if a<mi:\n            mi=a\n    return mi\ndef maximum(arr):\n    ma=-1000000\n    for b in arr:\n        if b>ma:\n            ma=b\n    return ma", "def calc(a):\n    sum = 0\n    for i in range(len(a)):\n        value = a[i]\n        if value > 0: value *= value\n        if (i+1) % 3 == 0: value *= 3\n        if (i+1) % 5 == 0: value = -value\n        sum += value\n    return sum", "def fib(n, a, b):\n    for i in range(n):\n        yield a\n        a, b = b, a+b\n        \ndef calc(k,n,m,x):\n    if x <= 2:\n        return k\n    if x == 3:\n        return 2 * k\n    b = 2 + sum(fib(n-4-1, 1, 1))\n    a = 1 + sum(fib(n-4-1, 1, 2))\n    c = (m - b*k) // a\n    b = 2 + sum(fib(x-4, 1, 1))\n    a = 1 + sum(fib(x-4, 1, 2))\n    return k*b + c*a", "from math import ceil\n\ndef branch(n):\n    if n == 1:\n        return 0\n    l = int(ceil(n ** 0.5)) // 2\n    n -= (2 * l - 1) ** 2 + 1\n    return n // (2*l or 1)", "def sort_time(arr):\n    arr, s = sorted(arr, key=lambda t: t[0]), []\n    while arr:\n        nextTP = next((i for i,t in enumerate(arr) if not s or t[0] >= s[-1][1]), 0)\n        s.append(arr.pop(nextTP))\n    return s", "def vector_affinity(a, b):\n    return 1.0 if a == b else sum(float(x == y) for x, y in zip(a, b)) / max(len(a), len(b))", "from collections import Counter\n\ndef modes(data):\n    count = Counter(data)\n    m = max(count.values()) if len(set(count.values())) > 1 else 0\n    return sorted(item for item, number in count.items() if 0 < m == number)", "def chess_board(a, b):\n    return [list(\"OXXO\"[i%2::2] * (b // 2 + 1))[:b] for i in range(a)]", "def oddest(a):\n    d, o = {}, a.count(-1)\n    for i, j in enumerate(a):\n        n = j\n        while n != 0 and n & 1 and n != -1:\n            n = (abs(n) // 2 + int(n < 0)) * [1, -1][n < 0]\n            d[i] = d.get(i, -1) + 1\n    m = max(d, key=lambda x: d[x],default=0)  \n    return a[0] if len(a)==1 else -1 if o==1 else a[m] if d and list(d.values()).count(d[m])==1 and o<2 else None", "from itertools import count,dropwhile\n\ndef next_pal(val): return next(dropwhile(isNotPal, count(val+1)))\ndef isNotPal(n):   return n!=int(str(n)[::-1])", "import re\n\ndef ipv4_address(address):\n    byte_reg = r'(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])'\n    ipv4_regex = r'\\A({0}[.]){{3}}{0}\\Z'.format(byte_reg)\n    return bool(re.match(ipv4_regex, address))", "def six_column_encryption(msg):\n    m = msg.replace(' ', '.')\n    lst = [m[i:i+6] for i in range(0, len(m), 6)]\n    lst[-1] = lst[-1].ljust(6, '.')\n    ans = []\n    for i in range(6):\n        s = ''\n        for j in lst:\n            s += j[i]\n        ans.append(s)\n    return ' '.join(ans)", "def expanded_form(n):\n    return (lambda s:' + '.join(s[x] + len(s[x+1:])*'0' for x in range(len(s))if s[x] != '0'))(str(n))", "import re\n\ndef count_letters_and_digits(s):\n    s = re.sub(r'[^\\w]', '', s)\n    s = s.replace('_', '')\n    return len(s)", "bool_to_word = {True: 'Yes', False: 'No'}.get\n", "def value_at(p, x):\n    return round(sum(c * choose(x,len(p)-1-i) for i,c in enumerate(p)), 2)\n    \ndef choose(x, k):\n    n,d = 1,1\n    for i in range(k): n, d = n*(x-i), d*(i+1)\n    return n / d", "def camel_case(string):\n    if len(string) == 0: return \"\"\n    str_list = list(string)\n    space_ids = [index for index, char in enumerate(str_list) if char == \" \" and index < len(str_list) - 1 ]\n    for index in space_ids:\n        str_list[index + 1] = str_list[index + 1].upper()\n    str_list[0] = str_list[0].upper()\n    changed_str = \"\".join(str_list)\n    changed_str = changed_str.replace(\" \", \"\")\n    return changed_str", "def isPrime(n):\n    return n==2 or n>2 and n&1 and all(n%p for p in range(3,int(n**.5+1),2))\n\ndef prime_product(n):\n    return next( (x*(n-x) for x in range(n>>1,1,-1) if isPrime(x) and isPrime(n-x)), 0)", "def sortme(words):\n    words_sorted = sorted(words, key = lambda s: s.casefold())\n    return words_sorted", "import math\ndef goldbach_partitions(n):\n    def is_prime(x):\n        for i in range(2, int(math.sqrt(x))+1):\n            if x % i == 0:\n                return False\n        return True\n\n    if n % 2: return []\n\n    ret = []\n    for first in range(2, n//2 + 1):\n        if is_prime(first):\n            second = n - first\n            if is_prime(second):\n                ret.append('%d+%d' %(first, second))\n    return ret", "from decimal import Decimal, ROUND_HALF_UP\n\ndef round_to_five(numbers):\n    return [(n/5).quantize(1, ROUND_HALF_UP) * 5 for n in map(Decimal, numbers)]", "def mesh(a, b):\n    for i in range(len(b), 0, -1):\n        if a.endswith(b[:i]):\n            return b[:i]\n\ndef word_mesh(arr):\n    try:\n        return ''.join(mesh(a, b) for a, b in zip(arr, arr[1:]))\n    except TypeError:\n        return 'failed to mesh'", "def roundRobin(jobs, slice, index):\n    cc = i = 0\n    while jobs[index] > 0:\n        cc += min(slice, jobs[i])\n        jobs[i] = max(0, jobs[i] - slice)\n        i = (i + 1) % len(jobs)\n    return cc\n", "def strange_coach(players):\n    firsts = [player[0] for player in players]\n    return \"\".join(sorted(c for c in set(firsts) if firsts.count(c) >= 5)) or \"forfeit\"", "def pattern(s):\n    return \"\\n\".join([\"\".join((str(x + y) if x + y <= s else str(x + y - s * ((x + y) // s)) for y in range(s))) for x in range(1, s + 1)])", "def calculator(x,y,op):\n    if str(op) not in '+-/*' or not str(x).isnumeric() or not str(y).isnumeric():\n        return 'unknown value'\n    return x + y if op == '+' else x - y if op == '-' else x * y if op == '*' else x / y", "def arbitrate(s,n):\n    return ''.join('1' if v=='1' and '1' not in s[:i] else '0' for i,v in enumerate(s))", "from collections import Counter\n\ndef highest_age(group1, group2):\n    total = Counter()\n    for person in group1 + group2:\n        total[person['name']] += person['age']\n    return min(total, key=lambda name: (-total[name], name))", "from string import digits, ascii_uppercase\nfrom math import factorial\n\nBASE = digits + ascii_uppercase\nFACT = [factorial(a) for a in range(36,-1,-1)]\n\ndef dec2FactString(nb):\n    res = []\n    for fact in FACT:\n        d, nb = divmod(nb, fact)\n        res.append(BASE[d])\n    return ''.join(res).lstrip('0')\n\ndef factString2Dec(string):\n    return sum(BASE.index(a) * FACT[c]  for c, a in enumerate(string, -len(string)))", "def to_1D(x, y, size):\n    return y * size[0] + x    \n    \ndef to_2D(n, size):\n    return (n % size[0], n // size[0])", "import re\n\ndef validate_number(s):\n    for c in '-+': s = s.replace(c, '')\n    return 'In with a chance' if re.match(r'^(07|447)\\d{9}$', s) else 'Plenty more fish in the sea'", "def isValid(formula):\n    \n    print(formula)\n    \n    if 1 in formula and 2 in formula:\n        return False\n    \n    if 3 in formula and 4 in formula:\n        return False\n\n    if 5 in formula and 6 not in formula:\n        return False\n    \n    if 6 in formula and 5 not in formula:\n        return False\n        \n    if 7 not in formula and 8 not in formula:\n        return False\n    else:\n        return True", "# This is the Miller-Rabin test for primes, which works for super large n\n\nimport random\n\ndef even_odd(n):\n    s, d = 0, n\n    while d % 2 == 0:\n          s += 1\n          d >>= 1\n    return s, d\n\ndef Miller_Rabin(a, p):\n    s, d = even_odd(p-1)\n    a = pow(a, d, p)\n    if a == 1: return True\n    for i in range(s):\n        if a == p-1: return True\n        a = pow(a, 2, p)\n    return False\n\ndef is_prime(p):\n    if p == 2: return True\n    if p <= 1 or p % 2 == 0: return False\n    return all(Miller_Rabin(random.randint(2,p-1),p) for _ in range(40))\n", "def digits(n):\n    n = str(n)\n    n = list(n)\n    size = len(n)\n    return size\n    pass", "def segment_cover(A, L):\n    c = 0\n    while A:\n        c+=1\n        seg = min(A, default=0)\n        A = list([item for item in A if item > seg+L])\n    return c\n", "def quicksum(packet):\n    result = 0\n    \n    for idx, char in enumerate(packet, 1):\n        if char.isupper():\n            result += idx * (ord(char) - 64)\n        elif char == \" \":\n            continue\n        else:\n            return 0\n    \n    return result", "def find_smallest_int(arr):\n    min = arr[0]\n    for pos in arr:\n        if pos < min:\n            min = pos\n    return min", "def past(h, m, s):\n    x = (60 * 60 * 1000 * h) + (60 * 1000 * m) + (1000 * s)\n    if (0 <= h <= 23, 0 <= m <= 59, 0 <= s <= 59):\n        return (x)", "def example_sort(arr, example_arr):\n    sorted_arr = []\n    number_count = {}\n\n    # Iterate through array and count number of items\n    for n in arr:\n        number_count[n] = number_count.get(n, 0) + 1\n\n    # Iterate through example ordered array\n    for n in example_arr:\n        num_count = number_count.get(n, 0)\n        for i in range(num_count):\n            sorted_arr.append(n) # Push array count number of times in number_count\n\n    return sorted_arr", "def check_three_and_two(array):\n    return sum([array.count(x) for x in array]) == 13", "def frame(text, char):\n    text_lens = [len(x) for x in text]\n    longest_len = max(text_lens)\n    frame_list = [char*(longest_len + 4)]\n    for str in text:\n         frame_list.append(\"{} {}{} {}\".format(char, str, \" \" * (longest_len - len(str)), char)) \n    frame_list.append(char*(longest_len + 4))\n    return \"\\n\".join(frame_list)", "def as_str(xs):\n    return ''.join(map(chr, xs[:2] + xs[-2:]))\n\ndef sort_transform(arr):\n    return '-'.join([\n        as_str(arr),\n        as_str(sorted(arr)),\n        as_str(sorted(arr, reverse=True)),\n        as_str(sorted(arr)),\n    ])", "def generate_diagonal(n, l):\n    row = [1]\n    for k in range(1, l):\n        row.append(row[-1] * (n + k) // k)\n    return row if l else []", "import re\n\nPATTERNS = [re.compile(r'(?i)ci|ce|c(?!h)'),\n            re.compile(r'(?i)ph'),\n            re.compile(r'(?i)(?<!\\b[a-z]{1})(?<!\\b[a-z]{2})e\\b|([a-z])\\1'),\n            re.compile(r'(?i)th|w[rh]?'),\n            re.compile(r'(?i)ou|an|ing\\b|\\bsm')]\n            \nCHANGES  = {\"ci\": \"si\", \"ce\": \"se\", \"c\":\"k\",                     # Week 1\n            \"ph\": \"f\",                                           # Week 2\n            \"th\": \"z\",  \"wr\": \"r\",  \"wh\":  \"v\",   \"w\": \"v\",      # Week 4\n            \"ou\": \"u\",  \"an\": \"un\", \"ing\": \"ink\", \"sm\": \"schm\"}  # Week 5\n\ndef change(m):\n    tok = m.group(0)\n    rep = CHANGES.get( tok.lower(), \"\" if None in m.groups() else m.group()[0] )        # default value used for week 3 only\n    if tok[0].isupper(): rep = rep.title()\n    return rep\n        \ndef siegfried(week, txt):\n    for n in range(week):\n        txt = PATTERNS[n].sub(change, txt)\n    return txt", "def obfuscate(email):\n    for rep in (('.', ' [dot] '), ('@', ' [at] ')):\n        email = email.replace(*rep)\n    return email", "def score_throws(r):\n    if not r:\n        return 0\n    if all(i < 5 for i in r):\n        return len(r) * 10 + 100\n    return len([i for i in r if i <= 10 and i >= 5]) * 5 + len([i for i in r if i < 5]) * 10", "from functools import reduce\nfrom operator import mul\ndef solve(arr):\n    return reduce(mul, map(len, map(set, arr)))", "def moment_of_time_in_space(moment):\n    time = 0\n    space = 0\n    for ch in moment:\n        if ch == '0' or not ch.isdigit():\n            space += 1\n        elif ch in '123456789':\n            time += int(ch)\n    return [time < space, time == space, time > space]", "def slogans(p,r):\n    c=0\n    while(r):\n        for i in range(len(p)):\n            if r.startswith(p[i:]):\n                c+=1\n                r=r[len(p[i:]):]\n                break\n    return c        ", "# Should return triangle type:\n#  0 : if triangle cannot be made with given sides\n#  1 : acute triangle\n#  2 : right triangle\n#  3 : obtuse triangle\n\ndef triangle_type(a, b, c):\n  a, b, c = sorted([a, b, c])\n  if a + b <= c:\n    return 0\n  elif a**2 + b**2 > c**2:\n    return 1\n  elif a**2 + b**2 == c**2:\n    return 2\n  else:\n    return 3", "from heapq import *\ndef nth_smallest(arr, n):\n    arr = list(set(arr))\n    heapify(arr)\n\n    if n > len(arr):\n        return None\n\n    x = 0\n    for i in range(n):\n        x = heappop(arr)\n    return x", "def combat(health, damage):\n    #your code here\n    all = health - damage\n    \n    if all > 0:\n        return all \n    else: \n        return 0", "def or_arrays(x,y,z=0,m=max,l=len):\n    return [(a|b) for a,b in zip((x+[z]*(m(l(x),l(y))-l(x))), (y+[z]*(m(l(x),l(y))-l(y))))]", "def find_the_ball(pos, swaps):\n    for swap in swaps:\n        if pos in swap:\n            pos = swap[1 - swap.index(pos)]\n    return pos", "def baubles_on_tree(baubles, branches):\n    if not branches:\n        return \"Grandma, we will have to buy a Christmas tree first!\"\n    d, m = divmod(baubles, branches)\n    return [d * (i <= branches) + (i <= m-1) for i in range(branches)]\n", "import re\nfrom string import ascii_uppercase as ALPHA\n\ndef num2alpha(num, b=len(ALPHA), numerals=ALPHA):\n    return '' if not num else (num2alpha((num-1) // b, b, numerals) + numerals[(num-1) % b])\ndef alpha2num(string, b=len(ALPHA), numerals=ALPHA):\n    return sum((numerals.index(v)+1)*b**i for i,v in enumerate(reversed(string)))\n    \nrcregex = re.compile('R(\\d+)C(\\d+)')\nspregex = re.compile('([A-Z]+)(\\d+)')\ndef spreadsheet(s):\n    m = rcregex.match(s)\n    if m: return num2alpha(int(m.group(2)))+m.group(1)\n    m = spregex.match(s)\n    if m: return 'R{}C{}'.format(m.group(2),alpha2num(m.group(1)))\n    return ''\n", "from string import ascii_lowercase\n\ndef words_to_marks(s):\n    return sum(ascii_lowercase.index(i) + 1 for i in s)", "def hoop_count(n):\n    if n<10:\n        return \"Keep at it until you get it\"\n    if n==10 or n>10:\n        return \"Great, now move on to tricks\"\n", "def update_inventory(cur_stock, new_stock):\n    d = {}\n    for i, j in cur_stock + new_stock:\n        d[j] = d.get(j, 0) + i\n    return sorted([(j, i) for i, j in d.items()], key=lambda x: x[1])", "# precalculate results\nresults = {}\nn, digits = 1, 0\nwhile digits <= 1000:\n    digits = len(str(sum( x**(n-x+1) for x in range(1, n) )))\n    if digits not in results:\n        results[digits] = n\n    n += 1\n\n\ndef min_length_num(digits, max_num): \n    n = results.get(digits, 0)\n    return [True, n+1] if n and n < max_num else [False, -1]", "def histogram(a, n):\n    r = [0] * (max(a, default=-1) // n + 1)\n    for x in a: r[x // n] += 1\n    return r", "def black_and_white(height, width, compressed):\n    result = [list() for _ in range(height)]\n    line_idx = 0\n    for i,c in enumerate(compressed):\n        black = (i%2==0)\n        while c:\n            if sum(result[line_idx])==width:\n                if len(result[line_idx])%2!=0:\n                    result[line_idx].append(0)\n                line_idx += 1\n            if len(result[line_idx])==0 and not black:\n                result[line_idx].append(0)\n            m = min(c, width - sum(result[line_idx]))\n            result[line_idx].append(m)\n            c -= m\n    if len(result[line_idx])%2!=0:\n        result[line_idx].append(0)    \n    return result\n", "def smaller(arr):\n    return [sum(b < a for b in arr[i + 1:]) for i, a in enumerate(arr)]\n", "def knight_or_knave(said):\n    f,t=\"Knave! Do not trust.\",\"Knight!\"\n    if isinstance(said,bool):return [f,t][said]\n    elif isinstance(said,str):return [f,t][eval(said)]", "def charCheck(text, mx, spaces):\n    if spaces == False:\n        text = text.replace(\" \", \"\")\n    \n    return [len(text) <= mx, text[:mx]]", "from functools import reduce\nfrom operator import __mul__\ndef greatest_product(n):\n    return max([reduce(__mul__, list(map(int, x))) for x in [x for x in [n[i:i+5] for i in range(len(n))] if len(x)==5]])\n", "import re\ndef largest_sum(s):\n    s = s.split('0')\n    m = 0\n    for l in s:\n      temp_s = sum(map(int, l))\n      if temp_s > m :\n        m = temp_s\n    return m\n", "def nerdify(txt):\n    encoder = {'a': '4', 'A': '4', 'e': '3', 'E': '3', 'l': '1'}\n    return ''.join(encoder.get(c, c) for c in txt)\n", "def get_military_time(time):\n    h = int(time[:2])\n    if time.endswith(\"AM\"):\n        h = h % 12\n    elif h < 12:\n        h += 12\n    return f\"{h:02d}{time[2:8]}\"", "from fractions import gcd\n\ndef coprimes(n):\n  ret = []\n  for x in range(int(n/2)+1):\n    if gcd(x,n-x) == 1:\n      ret += [x]\n      ret += [n-x]\n  return sorted(set(ret))\n", "a = 'abcdefghijklmnopqrstuvwxyz'\ndef move_ten(st):\n    return ''.join(a[(a.find(x)+10)%26] for x in st)", "def get_mixed_num(f):\n    [a, b] = map(int, f.split('/'))\n    return \"{} {}/{}\".format(a//b, a%b, b)", "def smash(words):\n    return ' '.join(elem for elem in words)\n", "def checkered_board(size):\n    result = ''\n    rows = []\n    print(size, type(size))\n    if not type(size) == int:\n        return False\n    if size < 2:\n        return False\n    if size % 2 == 0:\n        a = '\u25a1'\n        b = '\u25a0'\n    else:\n        a = '\u25a0'\n        b = '\u25a1'\n    for x in range(size):\n        if x % 2 == 0:\n            row = [a if x % 2 == 0 else b for x in range(size)]\n        else:\n            row = [b if x % 2 == 0 else a for x in range(size)]\n        rows.append(' '.join(row))\n        result = '\\n'.join(rows)\n    return result", "def chinese_zodiac(year):\n    EPOCH = 1924\n    ANIMALS = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake', 'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']\n    ELEMENTS = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']\n    year -= EPOCH\n    res = ELEMENTS[(year // 2) % len(ELEMENTS)], ANIMALS[year % len(ANIMALS)]\n    return \" \".join(res)", "def pair_zeros(arr):\n    got = [0]\n    return [v for v in arr if v or got.__setitem__(0,got[0]^1) or got[0]]", "def find_spec_partition(n, k, com):\n    if com == 'min':\n        return [n - k + 1] + [1] * (k - 1)\n    else:\n        return [(n // k + 1 if i < n % k else n //k) for i in range(k)]\n    return r", "from re import sub\ndef filter_words(phrase):\n    return sub(\"(?i)(bad|mean|ugly|horrible|hideous)\",\"awesome\",phrase)", "def cycle(n) :\n    if n % 2 and n % 5:\n        for i in range(1, n):\n            if pow(10, i, n) == 1:\n                return i\n    return -1", "import math\n\ndef missing_angle(h, a, o):\n    if h > 0 and a > 0:    result = math.acos(a/h)\n    elif a == 0 and o > 0: result = math.asin(o/h)\n    elif h == 0 and o > 0: result = math.atan(o/a)\n    else:                  raise ValueError(\"Invalid argument(s)\")\n    \n    return round(math.degrees(result))", "def calculate_time(b, c):\n    return round(b * (0.85/c + 0.1/(c * 0.5) + 0.05/(c * 0.2)), 2)", "from collections import Counter\n\ndef factors(n):\n    step = lambda x: 1 + 4*x - (x - x%2)\n    d, q, qmax = 1, 2 + n % 2, int(n ** .5)\n    while q <= qmax and n % q:\n        q = step(d)\n        d += 1\n    return q <= qmax and [q] + factors(n//q) or [n]\n\ndef chain_arith_deriv(start, k):\n    n, chain = start, []\n    for _ in range(k):\n        chain.append(n)\n        fac = Counter(factors(n))\n        n = sum(n // p * k for p, k in fac.items())\n    return chain if chain[1] > 1 else \"%d is a prime number\" % start", "def angle(n):\n    if n > 2:\n        return abs(n - 2) * 180", "from functools import lru_cache\n@lru_cache(maxsize=None)\ndef all_permuted(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    return (n-1)*(all_permuted(n-1)+all_permuted(n-2))", "def longest(s1, s2):\n    # your code\n    distinct = set(s1+s2) # sets are distinct values! \n    distinctSorted = sorted(distinct) # turn into sorted list\n    return ''.join(distinctSorted) # concatenate to string with 'join'", "def palin(n,pos):\n    half = str(int('1'+'0'*(n//2-int(not n&1)))+pos-1)\n    full = int(half + [half,half[:-1]][n&1][::-1]) \n    return full", "def find_discounted(prices):\n    discount = .25\n    in_list = [int(p) for p in prices.split()]\n    out_list = []\n    while (in_list):\n        full_price = in_list.pop()\n        discounted_price = int(full_price*(1-discount))\n        in_list.remove(discounted_price)\n        out_list.append(discounted_price)\n    out_list.reverse()\n    ans = ' '.join(str(p) for p in out_list)     \n    return(ans)\n   \n", "def factors(x):\n    if type(x) == str or x < 1 or type(x) == float:\n        return -1\n\n    else:\n        divisor = list(range(1,x+1))\n        ans = []\n        for i in divisor:\n            if x % i == 0:\n                ans.append(i)\n                ans.sort(reverse = True)\n        return ans\n", "def reverse(right):\n    last_row = []\n    \n    for a in right:\n        curr_row = [a]\n        for b in last_row:\n            a = b - a\n            curr_row.append(a)\n        \n        last_row = curr_row\n    \n    return last_row[::-1]", "levels = [0, 1, 2, 3]\nbuttons = ['0', '1', '2', '3']\ndef goto(level,button):\n    if level not in levels or button not in buttons:\n        return 0\n    else:\n        return int(button) - level", "def score_test(tests, right, omit, wrong):\n  return sum( right if a==0 else omit if a==1 else -wrong for a in tests )", "import math\n\ndef largest_power(n):\n    if n == 1: return 0, -1\n    if n <= 4: return 1, -1\n    \n    before = None\n    \n    r = []\n    for i in range(n-1, 1, -1):\n        res = check(i)\n        if res:\n            return i, res\n        \n        \ndef check(n):\n    c = 0\n    for st in range(2, 9):\n        el = round(n**(1/st), 7)\n        is_c = str(el).split('.')[1] == '0'\n        if is_c:\n            print(el, st, n)\n            c += 1\n    return c", "from itertools import permutations\n\ndef get_words(letters):\n    word = \"\".join(qty * char for qty in letters for chars in letters[qty] for char in chars)\n    return sorted({\"\".join(permutation) for permutation in permutations(word)})", "def word_wrap(text, limit):\n    result = []\n    s = ''\n    for word in text.split():\n        if len(word) > limit:\n            if len(s) + 1 >= limit:\n                result.append(s)\n                s = ''\n            if s:\n                s += ' '\n            i = limit - len(s)\n            result.append(s + word[:i])\n            for j in range(i, len(word) + 1, limit):\n                s = word[j:j + limit]\n                if len(s) == limit:\n                    result.append(s)\n        elif len(word) == limit:\n            if s:\n                result.append(s)\n                s = ''\n            result.append(word)\n        elif len(word) + len(s) + 1 > limit:\n            result.append(s)\n            s = word\n        else:\n            s += ' ' + word if s else word\n    if s:\n        result.append(s)\n    return '\\n'.join(result)", "region = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:;-?! '()$%&\" + '\"'\n\ndef decrypt(encrypted_text):\n    if not encrypted_text: return encrypted_text\n    \n    letters = list(encrypted_text)\n    letters[0] = region[-(region.index(letters[0]) + 1)]\n    for i in range(1, len(letters)):\n        letters[i] = region[region.index(letters[i - 1]) - region.index(letters[i])]\n    \n    for i in range(1, len(letters), 2):\n        letters[i] = letters[i].swapcase()\n\n    return \"\".join(letters)\n    \n\n\ndef encrypt(text):\n    if not text: return text\n    \n    letters = list(text)\n    for i in range(1, len(letters), 2):\n        letters[i] = text[i].swapcase()\n        \n    swapped = letters[:]\n    for i in range(1, len(letters)):\n        letters[i] = region[region.index(swapped[i - 1]) - region.index(swapped[i])]\n        \n    letters[0] = region[-(region.index(swapped[0]) + 1)]\n    return \"\".join(letters)\n", "def poly_multiply(p1, p2):\n    answer = [0] * (len(p1) + len(p2) - 1)\n    for i, coeff1 in enumerate(p1):\n        for j, coeff2 in enumerate(p2):\n            answer[i + j] += coeff1 * coeff2\n    return [] if all(coeff == 0 for coeff in answer) else answer\n\ndef poly_from_roots(r):\n    if not r:\n        return [1]\n    parts = [[-root, 1] for root in r]\n    answer = parts[0]\n    for part in parts[1:]:\n        answer = poly_multiply(answer, part)\n    return answer", "def product(numbers):\n    if not numbers:\n        return None\n    prod = 1\n\n    for i in numbers:\n        prod *= i\n\n    return prod", "def f(k, n):\n    xs = [1]\n    for i in range(1, n + 1):\n        xs.append(xs[-1] + xs[i // k])\n    return xs[-1]", "from datetime import datetime\nfrom itertools import permutations\n\ndef unique_date(*args):\n    dates = set()\n    for p in permutations(args):\n        try:\n            date = '{:02}/{:02}/{:02}'.format(*p)\n            datetime.strptime(date, '%y/%m/%d')\n            dates.add(date)\n        except ValueError: pass\n    return dates.pop() if len(dates) == 1 else \"ambiguous\" if dates else \"invalid\"", "spacify = \" \".join", "def close_to_zero(t):\n    T=[int(v) for v in t.split()]\n    return T and sorted(sorted(T,reverse=True),key=abs)[0] or 0", "def interest(p,r,n):\n    simple = p + p * r * n\n    while n > 0:\n        n -= 1\n        p += p * r\n    return [round(simple), round(p)]", "def ips_between(start, end):\n    # TODO\n    difference = [int(b)-int(a) for a,b in zip(start.split(\".\"),end.split(\".\"))]\n    sum = 0\n    for d in difference:\n        sum *= 256\n        sum += d\n    return sum\n", "from itertools import cycle\n\ndef numeric_formatter(template, data='1234567890'):\n    data = cycle(data)\n    return ''.join(next(data) if c.isalpha() else c for c in template)", "from datetime import datetime as dt\nfrom itertools import product, starmap\nfrom collections import defaultdict\n\n\nCORRECT, RECOVER, UNSURE = range(3)\nTIMESTR_MODELS = ('%Y-%m-%d','%Y-%d-%m')            # wanted, inverted\n\n\ndef check_dates(records):\n    out = [0]*3\n    for r in records: out[check(*r)] += 1\n    return out\n    \ndef check(start, finish):\n    cndsS, cndsF = getPossibleDates(start), getPossibleDates(finish)\n    areOK = [ i1+i2 for(d1,i1),(d2,i2) in product(cndsS, cndsF) if d1<=d2 ]\n    \n    return ( UNSURE  if len(areOK)>1 else\n             RECOVER if areOK[0] else\n             CORRECT )\n\ndef getPossibleDates(s):\n    cnds = defaultdict(lambda:1)\n    for i,model in enumerate(TIMESTR_MODELS):\n        try: cnds[dt.strptime(s, model)] *= i\n        except ValueError: pass\n    return cnds.items()", "def is_lock_ness_monster(string):\n    import re\n    return bool( re.findall(\"(?:tree fiddy|3\\.50|three fifty)\", string) )", "a = [False, False]+[True]*500000; p = []\nfor (i, isprime) in enumerate(a):\n    if isprime:\n        p.append(i)\n        for n in range(i*i, 500001, i): a[n] = False\ndp = [p[i-1] for i in p if i-1<len(p)]\ndef solve(a,b):\n    return sum(n for n in dp if a<=n<=b)", "def lose_weight(gender, weight, duration):\n    if gender in 'MF':\n        if weight > 0:\n            if duration > 0:\n                for i in range(duration):\n                    if gender == 'M':\n                        weight -= weight * 0.015\n                    else:\n                        weight -= weight * 0.012\n                return round(weight, 1)\n            return 'Invalid duration'\n        return 'Invalid weight'\n    return 'Invalid gender'", "import re;unscramble_eggs=lambda s:re.sub('(?i)([^\\Waeiou_])egg',r'\\1',s)", "def odd_one(arr):\n  ad = 0\n  for i in range(0, len(arr)):\n    if arr[i] % 2 == 1:\n      ad += 1\n      return i\n    else:\n        pass\n  if ad == 0:\n    return -1", "from re import findall\nfrom itertools import groupby\n\n\ndef fire_and_fury(tweet):\n    s, match = [], findall(r\"FIRE|FURY\", tweet)\n    if not match or not all([x in [\"E\", \"F\", \"I\", \"R\", \"U\", \"Y\"] for x in tweet]):\n        return \"Fake tweet.\"\n    for i in groupby(match):\n        s.append((i[0], len(list(i[1]))))\n    s = translated(s)\n    return \" \".join(s)\n\n\ndef translated(s):\n    string = []\n    for i in s:\n        if i[0] == \"FIRE\":\n            string.append(\"You \"+ \"and you \" * (i[1] - 1) + \"are fired!\")\n        elif i[0] == \"FURY\":\n            string.append(\"I am \" + \"really \" * (i[1] - 1) + \"furious.\")\n    return string", "from string import ascii_lowercase as aLow\n\nTABLE = str.maketrans(aLow, aLow[::-1])\n\ndef mirror(code, alpha=None):\n    table = TABLE if alpha is None else str.maketrans(alpha, alpha[::-1]) \n    return code.lower().translate(table)", "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef final_attack_value(x, monster_list):\n    for m in monster_list:\n        x = x + m if m <= x else x + gcd(x, m)\n    return x", "import ipaddress\ndef int32_to_ip(int32):\n    return str(ipaddress.IPv4Address(int32))\n", "looper = lambda a, z, n: [a] if n == 1 else [a] + [(z - a) / (n - 1) * i + a for i in range(1, n - 1)] + [z]", "def isValidCnd(c):\n    return all(k in c for k in ('name','scores')) and 0<len(c['scores'])<3 and all(not v%5 and 0<v<=100 for v in c['scores'])\n\ndef winner(cnds):\n    if len(cnds) != 3 or not all(isValidCnd(c) for c in cnds): \n        return False\n    return max(( (sum(c['scores']),-i,c['name']) for i,c in enumerate(cnds) if 0<=sum(c['scores'])<=100), default=(0,0,False))[2]", "def remove_rotten(bag_of_fruits):\n    return([i[6:].lower() if i[:6] == \"rotten\" else i for i in bag_of_fruits] if bag_of_fruits else [])", "closest_sum=lambda a,n:min(map(sum,__import__('itertools').combinations(a,3)),key=lambda c:abs(c-n))", "def shape_area(n):\n    return n**2 + (n - 1) ** 2", "def solve(s):\n    spaces = [i for i in range(len(s)) if s[i]==' ']\n    letters = ''.join(x for x in s if x!=' ')[::-1]\n    output = ''\n    j = 0\n    for i in range(len(s)):\n        if i in spaces:\n            output += ' '\n        else:\n            output += letters[j]\n            j += 1\n    return output", "def binary_simulation(bits, seq):\n    arr = [0 for _ in range(len(bits) + 1)]\n    display = []\n    for grp in seq:\n        if grp[0] == 'I':\n            arr[grp[1] - 1] += 1\n            arr[grp[2]] += -1\n        else:\n            display.append('01'[sum(arr[:grp[1]]) + int(bits[grp[1] - 1]) & 1])\n    return display", "def sort_it(a, n):\n    return \", \".join(sorted(a.split(\", \"), key=lambda x: x[n-1]))", "from functools import reduce\n\n\ndef product_sans_n(nums):\n    zero, prod = nums.count(0), reduce(int.__mul__, (n for n in nums if n))\n    if zero:\n        return [0 for _ in nums] if zero > 1 else [0 if n else prod for n in nums]\n    return [prod // n for n in nums]", "trans = str.maketrans(\"37\", \"73\")\ntwist = lambda n: int(str(n).translate(trans))\n\ndef sort_twisted37(arr):\n    return sorted(arr, key=twist)", "def find(n):\n    i=3\n    b=5\n    c=0\n    while i <= n:\n        c=c+i\n        \n        i+=3\n\n    while b<=n:\n        if b % 3 != 0:\n            c=c+b\n            \n            b+=5\n        else:\n            b+=5\n    \n    return c", "def T9(words, seq):\n    d = {}\n    sym = list(map(chr, range(97,123)))\n    for x in range(2, 10):\n        q = sym[:(3, 4)[x in(7, 9)]]\n        sym = sym[(3, 4)[x in(7, 9)]:]\n        d[str(x)] = q\n    s = zip(words,map(iter, [x.lower()for x in words]))\n    return [w for w, i in s if all(next(i)in d[x] for x in seq)] \\\n           or [''.join(d[x][0] for x in seq)]", "def kangaroo(kanga1, rate1, kanga2, rate2):\n    if ((kanga1>kanga2) and (rate1>=rate2)) or ((kanga2>kanga1) and (rate2>=rate1)):\n            return False\n    if 1-(abs(kanga1-kanga2)%abs(rate1-rate2)) <0: \n            return False\n    return 1-(abs(kanga1-kanga2)%abs(rate1-rate2))", "def search(budget, prices):\n    return \",\".join(map(str, sorted([n for n in prices if n <= budget])))", "is_smooth=lambda n,p=0: [\"power of 2\", \"3-smooth\", \"Hamming number\", \"humble number\", \"non-smooth\"][p] if n<2 or p>3 else is_smooth(n,p+1) if n%[2,3,5,7,11][p] else is_smooth(n//[2,3,5,7,11][p],p)", "def sort_by_value_and_index(arr):\n    return [b for _, b in sorted(enumerate(arr, 1), key=lambda x: int.__mul__(*x))]", "from itertools import zip_longest\ndef solve(s):\n    vowels,consonants=[],[]\n    for c in s:\n        if c in 'aeiou':\n            vowels.append(c)\n        else:\n            consonants.append(c)\n    if abs(len(vowels)-len(consonants))>1:\n        return 'failed'\n    r=''\n    a=[sorted(vowels),sorted(consonants)]\n    if len(vowels)<len(consonants):\n        a=a[::-1]\n    for c1,c2 in zip_longest(*a,fillvalue=''):\n        r+=c1+c2\n    return r", "def values(limit):\n    def is_palindrome(n):\n        n = str(n)\n        if len(n) in [0, 1]:\n            return True\n        return n[0] == n[-1] and is_palindrome(n[1:-1])\n\n    print(\"Limit: {}\".format(limit))\n    current = 2\n    totals = [1]\n    list_pal = []\n    while True:\n        number = current ** 2 + totals[-1]\n        totals = [i for i in totals if number - i < limit]\n        if len(totals) == 1 and totals != [1]:\n            break\n        for i in totals[:-1]:\n            if is_palindrome(number - i) and not (number - i) in list_pal and limit > (number - i):\n                list_pal.append(number - i)\n        if is_palindrome(number) and not number in list_pal and limit > number:\n            list_pal.append(number)\n        totals.append(number)\n        current += 1\n    print(\"Number of Palindrome in list: {}\".format(len(list_pal)))\n    print(\"List of Palindrome: {}\".format(list_pal))\n    return len(list_pal)", "def is_prime(n):\n    return n >= 2 and all(n%i for i in range(2, 1+int(n**.5)))\n    \ndef total(arr):\n    return sum(n for i, n in enumerate(arr) if is_prime(i))", "def pattern(n):\n    h = ''.join(str(i%10) for i in range(1, n))\n    h = h + str(n%10) * n + h[::-1]\n    v = [(str(i%10) * n).center(len(h)) for i in range(1, n)]\n    return '\\n'.join(v + [h] * n + v[::-1])", "def clock_degree(s):\n    hour, minute = map(int, s.split(':'))\n    if not (0 <= hour < 24) or minute < 0:\n        return 'Check your time !'\n    hour %= 12\n    minute %= 60\n    return '{}:{}'.format(hour * 30 or 360, minute * 6 or 360)", "import re\n\ndef area_code(message):\n    return re.search(r'\\((\\d{3})\\)', message).group(1)", "def get_new_notes(salary, bills):\n    disposable_income = salary - sum(bills)\n    return max(disposable_income // 5, 0)", "def grader(score):\n    print(score)\n    if score < 0.6 : return \"F\"\n    if score < 0.7 : return \"D\"\n    if score < 0.8 : return \"C\"\n    if score < 0.9 : return \"B\"\n    if score >   1 : return \"F\" #seriously ...\n    return                  \"A\"\n    \n", "def divisors(integer):\n\n    lst = []\n    for i in range(2,integer):\n        if integer % i == 0:\n            lst.append(i)\n            \n    if len(lst) == 0:\n        return \"%s is prime\" % (integer)\n    else:\n        return lst", "def solve(s):\n    bcount=0\n    i =0\n    acount =0\n    while i < len(s):\n        if s[i].isupper():\n            acount+=1\n            i+=1\n            \n           \n        elif s[i].islower():\n            bcount+=1\n            i +=1\n          \n    if bcount >= acount:\n        print(bcount)\n        return s.lower()\n    \n    if acount > bcount:\n        \n        return s.upper()\n    else:\n        return s.lower()\n    \n    \n        \n        \n", "def shifted_diff(first, second):\n    return -1 if len(first) != len(second) else f\"{second}{second}\".find(first)", "def solution(number):\n  return sum([x for x in range(number) if x % 3 == 0 or x % 5 == 0])", "def solve(n, k):\n    second_half = k >= n // 2\n    return (-1)**second_half * 2 * k + second_half * (n * 2 - 3) + 1", "def convert_to_dms(dd_lat, dd_lon):\n    def dd_to_dms(dd):\n        h=int(dd);dd-=h\n        m=int(dd*60);dd-=m/60\n        s=round(dd*3600,3)\n        return (h,m,s)\n    dd_lat,dd_lon=map(float,(dd_lat,dd_lon))\n    dms_lat=\"{:03d}*{:02d}\\'{:06.3f}\\\"{:s}\".format(*dd_to_dms(abs(dd_lat)),\"NS\"[dd_lat<0])\n    dms_lon=\"{:03d}*{:02d}\\'{:06.3f}\\\"{:s}\".format(*dd_to_dms(abs(dd_lon)),\"EW\"[dd_lon<0])\n    return (dms_lat,dms_lon)", "def guess_my_number(guess, number = '123-451-2345'):\n    digits = set('0123456789') - set(guess)\n    for d in digits:\n        number = number.replace(d, '#')\n    return number", "def check_digit(number, index1, index2, digit):\n    return str(digit) in str(number)[min(index1, index2) : max(index1, index2) + 1]", "def duty_free(price, discount, holiday_cost):\n    q=0\n    w=0\n    p=0\n    q=(price*discount)/100\n    w=(holiday_cost/q)*10\n    return (w//10)", "import re\n\ndef validate(s):\n    return bool(re.match(r\"MDZHB \\d\\d \\d{3} [A-Z]+( \\d\\d){4}$\", s))", "def create_permutations(string):\n    if '*' not in string:\n        return [int(string)]\n    return [x for i in range(10) for x in create_permutations(string.replace('*', str(i), 1))]\n    \n\ndef is_divisible_by_6(string):\n    return list(map(lambda x: str(x).zfill(len(string)), filter(lambda x: not x%6, create_permutations(string))))", "def missing(s):\n    result = -1\n    for start_chunk in range(1,len(s)//2 +1):\n        res = inner(s,start_chunk)\n        if res != -1:\n            result = res\n    return result\n\ndef inner(s,start_chunk):\n    result = -1\n    nums = []\n    rest = s\n    rip_count = 0\n    last = int(rest[:start_chunk])\n    rest = rest[start_chunk:]\n    nums.append(last)\n    chunk = start_chunk\n    while rest!= '':\n        if int(rest[:chunk]) - last != 1:\n            if int(rest[:chunk+1]) - last == 1:\n                chunk +=1\n                print('chunk +=1')\n            elif int(rest[:chunk+1]) - last == 2:\n                chunk +=1\n                rip_count+=1\n                print('chunk +=1')\n                print('rip_count+=1')\n                result = last + 1\n            elif int(rest[:chunk]) - last  == 2:\n                rip_count+=1\n                print('rip_count+=1')\n                result = last + 1\n            else: return -1\n        nums.append(int(rest[:chunk]))\n        last = int(rest[:chunk])\n        rest = rest[chunk:]\n        print(nums)\n        if(rip_count)>1:\n            return -1\n    return result", "total=lambda a:a[0] if len(a)==1 else total([a[i]+a[i+1] for i in range(len(a)-1)])", "def communication_module(packet):\n    # your code\n    calc = 0\n    if packet[4:8] == \"0F12\":\n        calc = int(packet[8:12]) + int(packet[12:16])\n    elif packet[4:8] == \"B7A2\":\n        calc = int(packet[8:12]) - int(packet[12:16])\n    elif packet[4:8] == \"C3D9\":\n        calc = int(packet[8:12]) * int(packet[12:16])\n    \n    if calc < 0: \n        calc = \"0000\"\n    elif calc > 9999:\n        calc = \"9999\"\n    \n    return packet[0:4] + \"FFFF\" + str(calc).zfill(4) + \"0000\" + packet[16:20]\n", "def solve(arr):\n    return sorted(sorted(arr), key=lambda n: arr.count(n), reverse=True)", "def is_keith_number(n):\n    if n <= 10: return False\n    c, k_lst, k_num = 0, list(str(n)), n\n    while k_num <= n:\n        k_num = sum([int(x) for x in k_lst])\n        c += 1\n        if k_num == n: return c\n        k_lst.append(k_num)\n        k_lst.pop(0)\n    return False", "from itertools import chain\n\nCACHE, INF = {}, float('inf')\nlst = list(chain.from_iterable( ('',d) for d in '123456789' ))[1:]\n\ndef dfs(i=1,nOps=0):\n    if i==17:\n        v = eval(''.join(lst)) \n        if nOps<CACHE.get(v,INF): CACHE[v]=nOps\n    else:\n        for o in ('','+','-'):\n            lst[i]=o\n            dfs(i+2, nOps+bool(o))\ndfs()\n\noperator_insertor = CACHE.get", "def arr2bin(arr):\n    return all(type(n) == int for n in arr) and format(sum(arr), 'b')", "def solution(to_cur, values):\n    rate, fmt = {\n        'USD': (1.1363636, '${:,.2f}'),\n        'EUR': (1 / 1.1363636, '{:,.2f}\u20ac'),\n    }[to_cur]\n    values = [v * rate for v in values]\n    return list(map(fmt.format, values))", "from collections import Counter\n\ndef dominator(arr):\n    n = Counter(arr).most_common(1)\n    return n[0][0] if n and n[0][1] > len(arr)//2 else -1", "def getCarrycount(a, b):\n    r,index = 0, 0\n    al = [int(d)+int(f) for d, f in zip(reversed(list(a)), reversed(list(b)))]\n    for item in al:\n        index = (item+index)//10\n        r += index\n    return r\ndef solve(input_string):\n    lnumber = [tuple(item.split()) for item in input_string.split('\\n')]\n    lsum = [getCarrycount(z[0], z[1]) for z in lnumber]\n    return '\\n'.join('{} carry operations'.format(n) if n else 'No carry operation' for n in lsum)\n", "from statistics import mean, median\nfrom numpy import sign\n\ndef mean_vs_median(numbers):\n    return (\"same\", \"mean\", \"median\")[int(sign(mean(numbers) - median(numbers)))]", "def freeway_game(dToExit, myS, cars):\n    return sum( cS != myS and (0 < minutes/60 * cS/(cS-myS) < dToExit/myS) * (-1)**(cS > myS) for minutes,cS in cars )", "baby_count=lambda x:min(x.lower().count(e)//(2-(e!='b'))for e in'bay')or\"Where's the baby?!\"", "def shuffled_array(lst):\n    R = lst[:]\n    R.remove(sum(R) // 2)\n    return sorted(R)", "def hamming_distance(a, b):\n    return sum(x != y for x, y in zip(format(a, \"020b\"), format(b, \"020b\")))", "def corrections(x):\n    return f\"{x} is {'more' if x>0 else 'equal to or less'} than zero.\"\n", "import numpy as np\n\ndef micro_world(bacteria, k):\n    bacteria = np.array(sorted(bacteria))\n    for index, j in enumerate(bacteria):\n        if j < 0:\n            continue\n        for i in bacteria[index:]:\n            if i > j and i <= j + k:\n                bacteria[bacteria == j] = -1\n                break\n    return len(list(filter(lambda x: x > 0, bacteria)))", "def reverse_words(text):\n    finalWord = ' '\n    newWord = text.split(' ')\n    for word in newWord:\n        word = word[::-1]\n        finalWord = finalWord + word + ' '\n    return finalWord.strip()", "def check_root(string):\n    try:\n        a,b,c,d = [int(i) for i in string.split(',')]\n        if not (a == b-1 and a == c-2 and a == d-3):\n            return 'not consecutive'\n        s = a*b*c*d+1\n        return str(s)+', '+str(int(s**0.5))\n    except:\n        return 'incorrect input'", "def dig_pow(n, p):\n    # your code\n    n_list = [int(i) for i in str(n)]\n    n_sum = 0\n    p_i = p\n    for n_i in n_list:\n        n_sum = n_sum + n_i**p_i\n        p_i = p_i+1\n    if n_sum%n == 0:\n        return n_sum/n\n    else:\n        return -1", "def billboard(name, price=30):\n    def s(a,b):\n        return a*b\n    return s(len(name),price)", "def reverse(st):\n    p = st.split()\n    return ' '.join(reversed(p))", "def dollar_to_speech(value):\n    d, c = map(int, value[1:].split('.'))\n    if d < 0:\n        return 'No negative numbers are allowed!'\n    if d == 0 == c:\n        return '0 dollars.'\n    s = ''\n    if d > 0:\n        s += '{} dollar{}{}'.format(d, 's' * (d > 1), ' and ' * (c > 0))\n    if c > 0:\n        s += '{} cent{}'.format(c, 's' * (c > 1))\n    return s + '.'", "from collections import Counter\n\nreqs = {\"road\": Counter(\"bw\"), \"settlement\": Counter(\"bwsg\"), \n        \"city\": Counter(\"ooogg\"), \"development\": Counter(\"osg\")}\n\ndef build_or_buy(hand):\n    return list(filter(lambda obj: not reqs[obj] - Counter(hand), reqs.keys()))", "def luxhouse(houses):\n    def f():\n        m = 0\n        for fl in reversed(houses):\n            yield max(0, m - fl + 1)\n            m = max(m, fl)\n    return list(f())[::-1]", "def hydrate(drink_string): \n    c=sum(int(c) for c in drink_string if c.isdigit())\n    return \"{} {} of water\".format(c,'glass') if c==1 else \"{} {} of water\".format(c,'glasses')", "def pattern(n):\n  return '\\n'.join([''.join(map(str, list(range(n, x, -1)))) for x in range(n)])\n", "def vowel_recognition(input): #Played around with some maths haha took way too much time\n    vl = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n    n = len(input)\n    count = 0\n    for num, letter in enumerate(input):\n        for vowel in vl:\n            if letter == vowel:\n                x = num+1\n                count += x*(n-x+1)\n    return count", "from collections import Counter\n\n\ndef sorted_brands(history):\n    brands = Counter(x[\"brand\"] for x in history)\n    return [brand for brand, _ in brands.most_common()]", "def rps(p1, p2):\n    if p1 == 'scissors' and p2=='paper':\n        return \"Player 1 won!\"\n    if p1 == p2:\n        return 'Draw!'\n    if p1== 'scissors' and p2== 'rock':\n        return \"Player 2 won!\"\n    if p1 == 'paper' and p2=='rock':\n        return \"Player 1 won!\"\n    if p2 == 'scissors' and p1=='paper':\n        return \"Player 2 won!\"\n    if p2== 'scissors' and p1== 'rock':\n        return \"Player 1 won!\"\n    if p2 == 'paper' and p1=='rock':\n        return \"Player 2 won!\"\n    \n    \n        \n        \n       \n    #your code here\n", "def find_children(santas_list, children):\n    return sorted([names for names in santas_list if names in children])", "def reverse_fizzbuzz(s):\n    no_int = {\"Fizz\": 3, \"Buzz\": 5, \"Buzz Fizz\": 5, \"Fizz Buzz\": 9, \"FizzBuzz\": 15}\n    lst = s.split(\" \")\n    start = next((int(item) - i for i, item in enumerate(lst) if item.isdecimal()), no_int.get(s))\n    return list(range(start, start + len(lst)))\n", "def solve(n):\n  if n % 10 != 0:\n    return -1\n  count = 0\n  while n >= 500:\n    n -= 500\n    count += 1\n  while n >= 200:\n    n -= 200\n    count += 1\n  while n >= 100:\n    n -= 100\n    count += 1\n  while n >= 50:\n    n -= 50\n    count += 1\n  while n >= 20:\n    n -= 20\n    count += 1  \n  while n >= 10:\n    n -= 10\n    count += 1  \n     \n  return count", "def ellipse(a, b):\n    import math\n    area = math.pi * a * b\n    perimeter = math.pi * ((3/2)*(a+b) - math.sqrt(a*b))\n    return \"Area: \" + str(round(area,1))+ \", perimeter: \" + str(round(perimeter,1))", "def sum_triangular_numbers(n):\n    if n > 0:\n        return sum([(x * (x + 1)) / 2 for x in range(n + 1)])\n    else:\n        return 0", "def decipher_message(message):\n    side_length = int(len(message) ** .5)\n    return \"\".join(message[i::side_length] for i in range(side_length))", "def interweave(s1, s2):\n    return ''.join(y for x in zip(s1,s2+'0') for y in x if not y.isdigit())", "def square_digits(num):\n  return int(''.join([str(int(x)**2) for x in list(str(num))]))\n", "def sel_reverse(arr,l):\n    #your code here\n    res = []\n    \n    if l == 0:\n      return arr\n      \n    i = 0\n    while i < len(arr):\n      res.append(arr[i:i+l][::-1])\n      i += l\n    \n    return sum(res, [])", "import math\ndef calculate_tip(amount, rating):\n    \"\"\"(^-__-^)\"\"\"\n    dic = {\"terrible\": 0, \"poor\": 5, \"good\": 10, \"great\": 15, \"excellent\": 20}\n    return math.ceil((amount / 100) * dic.get(rating.lower())) if rating.lower() in dic else 'Rating not recognised'\n", "def duplicate_count(text):\n    n=0\n    text=text.lower()\n    for i in set(text):\n        if text.count(i) >1:\n            n+=1\n    return n", "from math import log2\n\ndef half_life(initial, remaining, time):\n    return time / log2(initial / remaining)", "def longest_word(letters):\n    try:\n        word_list = [w for w in words if all(w.count(c) <= letters.count(c) for c in w)]\n        largest = sorted([w for w in word_list if len(w) == len(max(word_list, key=len))])\n        return largest if largest else None\n    except:\n        return None", "def bracket_pairs(string):\n    ob, res = [], {}\n    \n    for n,e in enumerate(string):\n        if e == '(':\n            ob.append(n)\n        elif e == ')':\n            if not ob:\n                return False\n            res[ob.pop()] = n\n    return False if ob else res", "from string import ascii_letters\n\nsortable = frozenset(ascii_letters)\n\ndef sort_string(s):\n    sorted_chars = iter(sorted((c for c in s if c in sortable), key=str.lower))\n    return ''.join(next(sorted_chars) if c in sortable else c for c in s)", "from itertools import groupby\n\ndef uniq_c(seq):\n    ans = []\n    for c, e in groupby(seq):\n        l = list(e)\n        ans.append((c, len(l)))\n    return ans", "def align_right(text, width):\n    answer = []\n    splitted = text.split(' ')\n    temp = ''\n    i = 0\n    while i < len(splitted):\n        while i < len(splitted) and len(temp + splitted[i]) < width + 1:\n            temp += splitted[i] + ' '\n            i += 1\n        temp = temp.strip()\n        answer.append(' ' * (width - len(temp)) + temp)\n        temp = ''\n    return '\\n'.join(answer)\n", "def say_hello(name):\n    name = \"Hello, \" + name\n    return(name)", "def house_of_cards(n):\n    if n>=1:\n        return(n+1)*n/2 + (n+2)*(n+1)\n    raise ValueError", "def amicable_numbers(n1,n2):\n    divisors1 = [i for i in range(1,n1) if n1%i==0]\n    divisors2 = [i for i in range(1,n2) if n2%i==0]\n    return bool(sum(divisors1)==n2 and sum(divisors2)==n1)", "def rank_of_element(lst, i):\n    return sum(n <= lst[i] for n in lst[:i]) + sum(n < lst[i] for n in lst[i+1:])", "def powerof4(n):\n    try:\n        b = bin(n)\n        if isinstance(n, bool):\n            return False\n        return b.count('1') == 1 and len(b) % 2 != 0\n    except:\n        return False", "import re\ndef solution(full_text, search_text):      \n    return len(re.findall(r'{}'.format(search_text), full_text))", "from collections import Counter\nfrom itertools import product\n\n    \ndef valid(s):\n    c = Counter(s)\n    return c[8]>=c[5]>=c[3]\n    \nALL = [int(''.join(map(str,digs))) for nd in range(1,7) \n                                   for digs in product((3,5,8), repeat=nd)\n                                   if valid(digs) ]\n\ndef solve(a,b):\n    return sum( a<=n<b for n in ALL )", "def tail_swap(ss):\n  a = [s.split(':') for s in ss]\n  a[0][1], a[1][1] = a[1][1], a[0][1]\n  return [':'.join(p) for p in a]", "def graceful_tipping(bill):\n    total = bill * 1.15\n    if total < 10:\n        total = (int(total) + (total % 1 > 0))\n    else :\n        x = len(str(int(total))) - 2\n        m = 5 * (10 ** x)\n        total = (int(total/m) + (total % m > 0)) * m\n    return total\n", "def odd_row(n):\n    m = (n - 1) * n + 1\n    return [*range(m, m + n * 2, 2)]", "import math\n\n\ndef find_next_square(sq):\n    \"\"\"Return the next square if sq is a square, -1 otherwise\"\"\"\n    square = math.sqrt(float(sq))\n    return -1 if not square.is_integer() else math.pow(square + 1, 2)\n", "def remove_char(s):\n    s_list = []\n    for x in s:\n        s_list.append(x)\n    return \"\".join(s_list[1:(len(s)-1)])", "def two_count(n):\n    if n%2 != 0:\n        return 0\n    else:\n        return 1 + two_count(n//2)\n", "def find_missing_letter(chars):\n    for i in range(0, len(chars)-1):\n        current = chars[i]\n        after = chars[i+1]\n        expected = chr(ord(current)+1)\n        \n        if after != expected:\n            return expected\n    \n    return ''\n\n", "def last(*arr):        \n    return arr[-1] if type(arr[-1]) == int else arr[-1][-1]", "from itertools import product, combinations\nfrom math import hypot\n\ndef euclid(p):\n    (x1, y1), (x2, y2) = p\n    return hypot(x1 - x2, y1 - y2)\n\ndef sim(pc):\n    pc1, pc2 = pc\n    return sum(map(euclid, product(pc1, pc2))) / (len(pc1) * len(pc2))\n\ndef cluster(points, n):\n    res = [[p] for p in points]\n    while len(res) > n:\n        p0, p1 = min(combinations(res, 2), key = sim)\n        res.remove(p0)\n        res.remove(p1)\n        res.append(p0 + p1)\n    return sorted(map(sorted, res))", "def check_for_factor(base, factor):\n    return [False, True][base%factor == 0]", "def match_arrays(v, r):\n    return sum(1 for i in r if i in v)\n\n# DON'T remove\nverbose = False # set to True to diplay arrays being tested in the random tests", "def reverse(s):\n    s=list(s)\n    indexes=[]\n    for i in range(len(s)-1):\n        if s[i]==s[i+1]:\n            indexes.append(i)\n            indexes.append(i+1)\n    for i in list(set(indexes)):\n        s[i]=s[i].swapcase()\n    return \"\".join(s)\n        \n", "def arithmetic_sequence_sum(a, r, n):\n    return sum(a + r*x for x in range(n))\n", "def Xbonacci(signature,n):\n    output, x = signature[:n], len(signature)\n    while len(output) < n:\n        output.append(sum(output[-x:]))\n    return output", "def tacofy(word):\n    ingred = {\n        'a':'beef', 'u':'beef', 'i':'beef', 'o':'beef', 'e':'beef',\n        't':'tomato', 'c':'cheese', 'l':'lettuce', 'g':'guacamole', 's':'salsa'\n    }\n    return ['shell'] + [ingred[c] for c in word.lower() if c in ingred] + ['shell']", "find_even_index = lambda arr: next((i for i, __ in enumerate(arr) if sum(arr[:i]) == sum(arr[i+1:])), -1)", "def discover_original_price(discounted_price, sale_percentage):\n    return round(discounted_price / ((100 - sale_percentage) * 0.01), 2)\n", "def spin_words(sentence):\n    output = []\n    for word in sentence.split(' '):\n        if len(word) > 4:\n            word = word[::-1]\n        output.append(word)\n    return ' '.join(output)", "def encode(string):\n    a=''\n    c=0\n    r=''\n    for e in string:\n        if e==a:\n            c+=1\n        else:\n            if c>0:\n                r=r+str(c)+a\n            a=e\n            c=1\n    r=r+str(c)+a\n    return r\n    \ndef decode(string): \n    c=0\n    r=''\n    for e in string:\n        if e.isdigit():\n            c=c*10+int(e)\n        else:\n            r=r+e*c\n            c=0\n    return r\n", "def solution(n):\n    return sum(f * c * (c + 1) for f, c in ((f, (n - 1) // abs(f)) for f in (3, 5, -15))) // 2\n", "def derive(coefficient, exponent): \n   first_num = coefficient * exponent\n   second_num = exponent - 1\n   return f'{first_num}x^{second_num}'", "def highest_rank(arr):\n    print(arr)\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n            mx = [0,0]\n    maxes = []\n    for num in freq:\n        if freq[num] > mx[1]:\n            mx[0] = num\n            mx[1] = freq[num]\n            maxes = [num]\n        elif freq[num] == mx[1]:\n            maxes.append(num)\n\n    return max(maxes)\n", "def is_happy(n):\n    seen = set()\n    while n > 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(d)**2 for d in str(n))\n    return n == 1", "def solve(a):\n    lenList = len(a)\n\n    evenEntries = [a[i]  for i in range(0, lenList, 1 )  if str(a[i]).isdigit() and  a[i]%2==0 ]\n    oddEntries =  [a[i]  for i in range(0, lenList, 1 )  if str(a[i]).isdigit() and  a[i]%2==1 ]\n\n    amtEvenEntries = len(evenEntries)\n    amtOddEntries = len(oddEntries)\n\n    return amtEvenEntries-amtOddEntries\n#end function \n", "from math import gcd\n\ndef nbr_of_laps(x, y):\n    g = gcd(x,y)\n    return (y//g, x//g)", "def dating_range(age, x=2, y=7, z=.1):\n    return '%d-%d' % ((age / x + y, x * (age - y)) if age > x * y else (age * (1 - z), age * (1 + z)))", "def alternate_sq_sum(arr):\n    return sum([ x**2 if i % 2 == 1 else x for i, x in enumerate(arr) ])", "from itertools import permutations\n\ndef solve(s,k):\n    return sum(not int(a+b)%k for a,b in permutations(s.split(),2))", "from math import sin,pi\ndef area_of_polygon_inside_circle(r, n):\n    return round((n*r**2*sin(2*pi/n))/2, 3)", "def cup_volume(d1, d2, h):\n        return round(h * (d1*d1 + d1*d2 + d2*d2) * 0.2617993878, 2)", "dot=lambda n,m:' o '.join(-~n*'|').join(2*'\\n').join(-~m*['---'.join(-~n*'+')])", "def memesorting(meme):\n    bug = 'bug'\n    boom = 'boom'\n    edits = 'edits'\n    for i in meme.lower():\n        if i == bug[0]:\n            bug = bug[1:]\n            if len(bug) == 0:\n                return \"Roma\"\n        if i == boom[0]:\n            boom = boom[1:]\n            if len(boom)== 0:\n                return \"Maxim\"\n        if i == edits[0]:\n            edits = edits[1:]\n            if len(edits)== 0:\n                return \"Danik\"\n    return 'Vlad'", "def possible_positions(pos):\n    rows, cols = 'abcdefgh', '12345678'\n\n    row = rows.index(pos[0])\n    col = cols.index(pos[1])\n\n    M = [(a, b) for a in [1, -1] for b in [2, -2]]\n    P = [(row + rr, col + cc) for rr, cc in M + [e[::-1] for e in M]]\n                \n    return sorted(rows[r] + cols[c] for r, c in P  if 0 <= r <= 7 and 0 <= c <= 7)", "def first_dup(s):\n    for x in s:\n        if s.count(x) > 1:\n            return x\n    return None", "def reverse_bits(n):\n    return int(format(n, \"b\")[::-1], 2)", "basic_op = lambda o,a,b: eval(str(a)+o+str(b))", "def finding_k(arr):\n    for i in range(max(arr)-1, 0, -1):\n        if len({j%i for j in arr}) == 1: return i\n    return -1", "def string_to_int_list(string):\n    return [int(i) for i in (string.split(',')) if i.isdigit() or i.startswith('-') and i[1:].isdigit()]", "import math\ndef convert_to_list(number):\n    lst=[]\n    while number!=0:\n        lst.append(number%10)\n        number=int(number/10)\n    return lst\n\ndef list_to_list(lst):\n    average_list=[]\n    for i in range(len(lst)-1):\n        average_list.append(math.ceil((lst[i]+lst[i+1])/2))\n    return average_list\n\ndef digits_average(digits):\n    lst=convert_to_list(digits)\n    while len(lst)>1:\n        lst=list_to_list(lst)\n    return lst[0]\n", "import itertools\ndef counting_triangles(V):\n    count = 0\n    for x in itertools.combinations(V,3):\n        if(sum([x[0]+x[1]>x[2],x[0]+x[2]>x[1],x[1]+x[2]>x[0],abs(x[0]-x[1])<x[2],abs(x[0]-x[2])<x[1],abs(x[1]-x[2])<x[0]])==6):\n            count += 1\n    return count", "import re\n\ndef get_free_urinals(urinals):\n    if '11' in urinals:\n        return -1\n    return sum((len(g) + 1) // 2 for g in re.split('0?1+0?', urinals))", "def spoonerize(words):\n    x = words.split()\n    first, second = list(x[0]), list(x[1])\n    first[0], second[0] = second[0], first[0]\n    str_list = ''.join(first) + ' ' + ''.join(second)\n    return str_list  ", "from itertools import chain, zip_longest\n\ndef combine_strings(*args):\n    return ''.join(chain.from_iterable(zip_longest(*args, fillvalue='')))", "from collections import Counter\n\ndef paint_letterboxes(s, f):\n    a = Counter(\"\".join(map(str, range(s, f+1))))\n    return [a[x] for x in \"0123456789\"]", "def game(a, b):\n    if a * b:\n        c = int(a ** 0.5)\n        return ('Mike', 'Joe')[c * (c + 1) <= b]\n    return \"Non-drinkers can't play\"", "#1\ndef add(a,b):\n    return(a+b)\ndef multiply(a,b):\n    return(a*b)\ndef mod(a,b):\n    return(a%b)\ndef subt(a,b):\n    return(a-b)\ndef divide(a,b):\n    return(a/b)\ndef exponent(a,b):\n    return(a**b)", "def isDigit(s):\n    try: \n        float(s)\n        return True\n    except Exception:\n        return False", "def validate_hello(greetings):\n    msgs = ['hello', 'ciao', 'salut', 'hallo', 'hola', 'ahoj', 'czesc'] \n    for msg in msgs:\n        if msg in greetings.lower():\n            return True\n    return False\n", "def elections_winners(a,k):\n    m = max(a)\n    v = [i+k for i in a if i+k>m]\n    if k == 0 and not v and a.count(m)==1: return 1\n    return len(v)", "alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m',\n            'n','o','p','q','r','s','t','u','v','w','x','y','z']\n\ndef high(x):\n  \n  strings = list(x.split())\n  array = []\n\n  for word in strings:\n    value = 0\n    for letter in word:\n      value += alphabet.index(letter)+1\n    array.append([value, word])\n  array.sort()\n  return array[-1][1]", "def func(l):\n    a=int(sum(l)/len(l))\n    return [a,'{:b}'.format(a),'{:o}'.format(a),'{:x}'.format(a)]", "d = lambda a,b,c,d:abs(d-b)+abs(c-a)\noptimum_location=lambda st,lc:'The best location is number {} with the coordinates x = {} and y = {}'.format(*min([sum(d(*n,i['x'],i['y']) for n in st),i['id'],i['x'],i['y']] for i in lc)[1:])", "def sum_nested_numbers(a, depth=1):\n    return sum(sum_nested_numbers(e, depth+1) if type(e) == list else e**depth for e in a)", "import re\ndef search_substr(full_text, search_text, allow_overlap=True):\n    if not full_text or not search_text: return 0\n    if allow_overlap == False: return len(re.findall(r'(' + search_text + ')', full_text))\n    else: return len(re.findall(r'(?=(' + search_text + '))', full_text))", "def radix_tree(*a):\n    r = {}\n    for s in a:\n        d = r\n        for x in s + \"*\":\n            if x not in d: d[x] = {}\n            d = d[x]\n    def g(d):\n        dd = {}\n        for x in d:\n            d[x] = g(d[x])\n            if len(d[x]) == 1:\n                k, v = [*d[x].items()][0]\n                dd[x+k] = v\n            else:\n                dd[x] = d[x]\n        return dd\n    def h(d):\n        dd = {}\n        for x in d:\n            d[x] = h(d[x])\n            if x != \"*\":\n                dd[x if x[-1] != \"*\" else x[:-1]] = d[x]\n        return dd\n    return h(g(r))", "from decimal import Decimal\n\nimport numpy as np\n\n\ndef solve(n):\n    a = np.ones(1, dtype=Decimal)\n    for i in range(n):\n        a = np.append(np.add.accumulate(a), [0])\n    return a.sum()", "def contamination(text, char):\n    return '' if text=='' or char=='' else ''.join(char for letter in text)", "def sillycase(silly):\n    output=''\n    for c in range(len(silly)):\n        if c <len(silly)/2:\n            output+=str.lower(silly[c]) \n        else:\n            output+=str.upper(silly[c]) \n    return output\n", "def substring_test(str1, str2):\n    str1,str2 = str1.lower(),str2.lower()\n    s1 = [str1[i:i+2] for i in range(len(str1)-1)]\n    s2 = [str2[i:i+2] for i in range(len(str2)-1)]\n    return len(set(s1).intersection(s2))>0", "def days_represented(trips):\n    accumulator = set()\n    for a,b in trips:\n        accumulator |= set(range(a, b+1))\n    return len(accumulator)", "operators = {\n    \"039\": \"Goldem Telecom\",\n    \"050\": \"MTS\",\n    \"063\": \"Life:)\",\n    \"066\": \"MTS\",\n    \"067\": \"Kyivstar\",\n    \"068\": \"Beeline\",\n    \"093\": \"Life:)\",\n    \"095\": \"MTS\",\n    \"096\": \"Kyivstar\",\n    \"097\": \"Kyivstar\",\n    \"098\": \"Kyivstar\",\n    \"099\": \"MTS\"\n}\n\ndef detect_operator(num):\n    return operators.get(str(num)[1:4], 'no info')", "def chess_knight(pos):\n    i, j = int(8-int(pos[1])),\"abcdefgh\".index(pos[0])\n    A,B,C,D,E,F,G,H=i>0,i<7,j-2>=0,j+2<8,i+2<8,i-2>=0,j>0,j<7\n    return sum([A and D,A and C,B and C,B and D,F and H,F and G,E and H,E and G])", "def fouriest(numb):\n    ans = \"\"\n    temp = 0\n    baz=0\n    for i in range(5, 300):\n        converted_string, modstring = \"\", \"\"\n        currentnum = numb\n        base = i\n        while currentnum:\n            mod = currentnum % base\n            currentnum = currentnum // base\n            converted_string = chr(48 + mod + 7*(mod > 10)) + converted_string\n        if str(converted_string).count(\"4\") > temp:\n            temp = str(converted_string).count(\"4\")\n            ans = str(converted_string)\n            baz = i\n    ans = \"\".join([i if i.isdigit() else \"x\" for i in str(ans)])\n    return \"{} is the fouriest ({}) in base {}\".format(numb, ans, baz)", "def nth_char(words):\n    return ''.join(k[i] for i,k in enumerate(words))\n", "def sort_my_string(s):\n    l = list(s)\n    return \"\".join(l[::2]+[\" \"]+l[1::2])", "def points(n):\n    ct = (2*n+1)**2 # num of pts in lattice intersecting B_n(0)\n    \n    for x in range(-n,0): # x coords in (- , -) quadrant\n        y = -n # inital y in (- , -) quadrant\n        while x**2 + y**2 > n**2: #while outside B_n(0)\n            ct -= 4 # use quadrant symmetry -  if its not in the (- , -) quad of B_n(0) its not in any quad.\n            y += 1\n    return ct", "def calc(mp):\n  h=len(mp)\n  w=len(mp[0])\n  dp=[[[0 for j in range(h+1)]for i in range(h+1)]for k in range(h+w+1)]\n  for s in range(1,h+w+1):\n    for i1 in range(1,h+1):\n      j1=s-i1+1\n      if j1>0 and j1<=w:\n        for i2 in range(1,h+1):\n          j2=s-i2+1\n          if j2>0 and j2<=w:\n            dp[s][i1][i2]=max(dp[s-1][i1][i2-1],dp[s-1][i1-1][i2],dp[s-1][i1-1][i2-1],dp[s-1][i1][i2])+mp[i1-1][j1-1]+mp[i2-1][j2-1]\n            if i1==i2: dp[s][i1][i2]-=mp[i1-1][j1-1]\n  return dp[h+w-1][h][h]", "def string_suffix(s):\n    total = len(s)\n    suffixes = [s[y:] for y in range(len(s)) if s[y] == s[0]][1:]\n    for suff in suffixes:\n        for y,l in zip(s,suff):\n            if l == y:\n                total += 1\n            else:\n                break\n    return total", "def number(lines):\n    return [f\"{x[0]}: {x[1]}\" for x in enumerate(lines, 1)]", "from math import ceil\n\ndef calculate_scrap(arr,n):\n    x = 50\n    for i in arr:\n        x /= (1-i/100)\n    return ceil(n*x)", "def to_leet_speak(str):\n    d = {\n      'A' : '@',\n      'B' : '8',\n      'C' : '(',\n      'D' : 'D',\n      'E' : '3',\n      'F' : 'F',\n      'G' : '6',\n      'H' : '#',\n      'I' : '!',\n      'J' : 'J',\n      'K' : 'K',\n      'L' : '1',\n      'M' : 'M',\n      'N' : 'N',\n      'O' : '0',\n      'P' : 'P',\n      'Q' : 'Q',\n      'R' : 'R',\n      'S' : '$',\n      'T' : '7',\n      'U' : 'U',\n      'V' : 'V',\n      'W' : 'W',\n      'X' : 'X',\n      'Y' : 'Y',\n      'Z' : '2'\n    }\n    \n    newstr = \"\"\n    for c in str:\n        try:\n            newstr += d[c]\n        except KeyError:\n            newstr += c\n\n    return newstr", "pig_latin = lambda w: len(w) < 4 and w or \"%s%say\" % (w[1:], w[0])", "def monkey_count(n):\n    return list(sorted(n-i for i in range(n)))\n", "import re\n\nknow_acronyms = {\n    'KPI': \"key performance indicators\",\n    'EOD': \"the end of the day\",\n    'TBD': \"to be decided\",\n    'WAH': \"work at home\",\n    'IAM': \"in a meeting\",\n    'OOO': \"out of office\",\n    'NRN': \"no reply necessary\",\n    'CTA': \"call to action\",\n    'SWOT': \"strengths, weaknesses, opportunities and threats\"\n}\n\ndef acronym_buster(message):\n    unknow_acronyms = []\n    replace_or_store = lambda a: a in know_acronyms and know_acronyms[a] or unknow_acronyms.append(a)\n    cleaned = re.sub(r'\\b[A-Z]{3,}\\b', lambda m: replace_or_store(m.group()), message)\n    if unknow_acronyms:\n        return '%s is an acronym. I do not like acronyms. Please remove them from your email.' % unknow_acronyms[0]\n    else:\n        return re.sub('(^|[.!?]) *\\w', lambda m: m.group().upper(), cleaned)", "def toUnderScore(name):\n    \n    list_of_chars = []\n    previous_char = None\n\n    for char in name:\n\n        if previous_char is not None and char != \"_\" and previous_char != \"_\":\n\n            if char.isupper() or char.isdigit() and not previous_char.isdigit():\n                list_of_chars.append(\"_\")\n            \n        list_of_chars.append(char)\n        previous_char = char\n\n    return \"\".join(list_of_chars)", "def get_num(arr):\n    if len(arr) == 0:\n        return []\n    \n    res = 1\n    smallest = arr[0]\n    divisors = {}\n    for val in arr:\n        res *= val\n        \n        if val < smallest:\n            smallest = val\n            \n        if val not in divisors:\n            divisors[val] = 0\n        divisors[val] += 1\n        \n    num_divisors = 1\n    for val in divisors:\n        num_divisors *= (divisors[val] + 1)\n    \n    return [res, num_divisors - 1, smallest, res//smallest]", "from math import factorial\n\nfacts = {factorial(n): n for n in range(1000)}\n\ndef reverse_factorial(num):\n    res = facts.get(num, 0)\n    return '%s!' % res if res else 'None'", "def scoring(array):\n    return [i[\"name\"] for i in sorted(array, key=lambda x: (x[\"norm_kill\"] * 100 + x[\"assist\"] * 50 + x[\"damage\"] * .5 +\n                                                            x[\"healing\"] + 2 ** x[\"streak\"] + x[\"env_kill\"] * 500), reverse=True)]", "def solve(n):\n    FIB = ['0', '01']\n    for _ in range(len(FIB), n+1): \n        FIB.append(FIB[-1] + FIB[-2])\n    return FIB[n]", "def leaderboard_sort(L, C):\n    for c in C:\n        n, m = c.split()\n        i = L.index(n)\n        L.pop(i)\n        L.insert(i-eval(m), n)\n    return L\n", "def score_hand(li):\n    s, A = sum(int(i) if i.isdigit() else 10 for i in li if i != 'A'), li.count('A')\n    for i in range(A) : s += [1,[11,1][bool(s+11==21 and i+1!=A)]][s+11<=21]\n    return s", "def switch_lights(a):\n    s = sum(a)\n    for i in range(len(a)):\n        if s%2:\n            s -= a[i]\n            a[i] = 1-a[i]\n        else:\n            s -= a[i]\n    return a", "def solve(arr):\n    return [n for i,n in enumerate(arr) if all(n > x for x in arr[i + 1:])]", "from re import sub\n\ndef evenator(s):\n    return ' '.join(word + word[-1] if len(word) % 2 else word for word in sub(r'[.,?!_]', '', s).split())", "def count_by(x, n):\n    \"\"\"\n    Return a sequence of numbers counting by `x` `n` times.\n    \"\"\"\n    lst = []\n    y = 0\n    while len(lst) < n:\n        y += x\n        lst.append(y)\n    return lst", "\nfrom itertools import permutations as perms\n\ndef is_pand(n):\n    return len(set(list(str(n)))) == len(str(n))\n\ndef next_pan(n):\n    while True:\n        if is_pand(n):yield n\n        n += 1\n\ndef get_sequence(n, k):\n    if n < 1023456789: n = 1023456789\n    elif n >= 9999999999: return []\n    if not is_pand(n): n = next(next_pan(n))\n    res = []\n    for i in next_pan(n):\n        res.append(i)\n        if len(res)== k: break\n    return res\n", "def string_to_array(s):\n    if len(s)>1: #if string has characters\n       return s.split() #split string into pieces\n    else: \n        return ['']", "def iq_test(numbers):\n    e = [int(i) % 2 == 0 for i in numbers.split()]\n\n    return e.index(True) + 1 if e.count(True) == 1 else e.index(False) + 1\n", "def nth_fib(n):\n  a, b = 0, 1\n  for i in range(n-1):\n    a, b = b, a + b\n  return a", "def magic_sum(arr):\n    return 0 if not arr else sum(x for x in arr if x % 2 and '3' in str(x))", "def permutation_position(x):\n    return sum((ord(c)-97)*26**p for p,c in enumerate(x[::-1]))+1", "def crossing_sum(matrix, row, col):\n    mat_tr = [[i[j]  for i in matrix] for j in range(len(matrix[0]))]\n    return sum(matrix[row] + mat_tr[col]) - matrix[row][col]", "def between_extremes(numbers):\n    minimum_value = min(numbers)\n    maximum_value = max(numbers)\n    output = maximum_value - minimum_value\n    return output\n\n# create two variables and store min and max value \n# than subtract maximum value from minimum value\n# and store that in final output\n", "from functools import reduce\ndef product(ar):\n    return reduce(lambda x,y:x*y, ar)\n\ndef something_acci(num_digits):\n    seq = [1, 1, 2, 2, 3, 3]\n    \n    while(len(str(seq[-1])) < num_digits):\n        seq.append(product(seq[-3:]) - product(seq[-6:-3]))\n    \n    return (len(seq), len(str(seq[-1])))\n", "def get_count(s=''):\n    ret = {'vowels': 0, 'consonants': 0}\n    if type(s) != str:\n        return ret\n    for c in s.lower():\n        if c in 'aeiou':\n            ret['vowels'] += 1\n        elif c.isalpha(): # letter but not vowel because elif\n            ret['consonants'] += 1\n    return ret", "def premier_league_standings(teams):\n  ret = {1:teams[1]}\n  for i,name in enumerate(sorted(teams[i] for i in teams.keys() if i != 1)):\n    ret[i+2] = name\n  return ret", "first_n_smallest=lambda a,n:[v for _,v in sorted(sorted(enumerate(a),key=lambda x:x[1])[:n])]", "def encode(s):\n    return ''.join(str(ord(x) - ord('a') + 1) if x.isalpha() else x for x in s.lower())", "def arr_check(arr):\n    return all(isinstance(el, list) for el in arr)", "import numpy as np\nfrom scipy import ndimage\n\ndef first_tooth(a):\n    d=ndimage.convolve(a,[-1,2,-1],mode=\"nearest\")\n    m=np.argwhere(d==d.max())\n    return m[0][0] if len(m)==1 else -1", "TYPE_SEQ = {(1,): 1, (0,1): 2, (-1,):3, (-1,0): 4, (0,): 5}\n\ndef sequence_classifier(arr):\n    countSet = { (a<b) - (a>b) for a,b in zip(arr, arr[1:]) }\n    return TYPE_SEQ.get(tuple(sorted(countSet)), 0)", "def performant_smallest(lst, n):\n    c = [0]*201     #Our counter.\n    for itm in lst:     c[itm+100] += 1     #Map each number to num+100.\n    res, sm = [0]*n, 0\n    for k in range(201):    #Iterate through the numbers in our counter.\n        sm += c[k]\n        if sm >= n:\n            c[k] += n - sm  #The sum of `c[:k+1]` should be equal to `n`, and this would give us the count of the `n` smallest elements.\n            break\n    sm = 0\n    for itm in lst:     #Iterate through the list to present the elements in their appearance order in the list.\n        v = itm+100     #The mapping between the list item and its index in our counter.\n        if v <= k and c[v] > 0:     #The item is one of the `n` smallest items.\n            res[sm] = itm   #Place it in its position in the result list.\n            sm += 1\n            c[v] -= 1\n        if sm == n: break\n    return res", "from math import log\n\nMINUTES_PER_KATA = 6.0\nPUSHUPS_BASE_TIME = 5.0\n\ndef alex_mistakes(n_katas, time_limit):\n    return int(log((time_limit - MINUTES_PER_KATA * n_katas) / PUSHUPS_BASE_TIME + 1, 2))", "import re\nfrom random import sample\n\ndef mix_words(string):\n    return re.sub(\n        r'(?<=[a-zA-Z])([a-zA-Z]{2,})(?=[a-zA-Z])',\n        lambda match: ''.join(sample(match.group(1), len(match.group(1)))),\n        string)\n", "def first_non_consecutive(arr):\n    n = 0\n    try:\n        for i in arr:\n            if i + 1 == arr[n + 1]:\n                n += 1\n                continue\n            elif i + 1 != arr[n + 1]:\n                return arr[n + 1]\n    except:\n        return None", "import html\n\ndef get_char(c):\n  # Your code goes here ^_^\n  return(chr(c))", "from itertools import count\n\n# It's not worth it to memoize they numbers we reversed because a number is not always followed by its reversed in the result\n# So we would have to save they numbers and return the minimum saved each time we find a new one\n# All the numbers in this list are divisible by 9 so we can skip 88.9% of the possibilities\ndef gen():\n    for x in count(0, 9):\n        y = int(str(x)[::-1])\n        if x != y and x % 10 and (x + y) % abs(x - y) == 0:\n            yield x\nnumbers, result = gen(), []\n\ndef sum_dif_rev(n):\n    while len(result) < n: result.append(next(numbers))\n    return result[n-1]", "def main (a,b):\n    return(a+b)", "def find_a(array, n):\n    if 0<=n<4:\n        return array[n]\n    a = {i:x for i,x in enumerate(array)}\n    if n>4:\n        for i in range(4,n+1):\n            a[i] = -a[i-4]+6*a[i-3]-10*a[i-2]+6*a[i-1]\n    else:\n        for i in range(-1,n-1,-1):\n            a[i] = 6*a[i+1]-10*a[i+2]+6*a[i+3]-a[i+4]\n    return a[i]\n", "def count_positives_sum_negatives(arr):\n    if arr == []:\n        return []\n    posTot = 0\n    negSum = 0\n    for number in arr:\n        if number <= 0:\n            negSum += number\n        else:\n            posTot += 1\n    return [posTot,negSum]\n", "from collections import Counter\n\ndef added_char(s1, s2):  \n    return next((Counter(s2) - Counter(s1)).elements())", "import re\n\ndef valid_parentheses(s):\n    try:\n        re.compile(s)\n    except:\n        return False\n    return True", "def new_numeral_system(number):\n    return [(chr(65+i) + ' + ' + chr(ord(number)-i)) for i in range((ord(number)-65)//2+1)]", "def flip_bit(v, b):\n    k = list(bin(v)[2:].zfill(b))\n    k[-b] = str(1 - int(k[-b]))\n    return int(''.join(k), 2)", "def reverse_alternate(string):\n  #your code here\n  if string == \"\":\n      return \"\"\n  else:\n      new_list = []\n      for i in range(len(string.split())):\n          if i%2 != 0:\n              new_list.append(string.split()[i][::-1])\n          else:\n              new_list.append(string.split()[i])\n      return \" \".join(new_list)", "def sum_prod(strexpression):\n    return \"%.5e\" %(eval(strexpression))", "def not_prime(x):\n    if x == 1: return True\n    for y in range(2, int(x ** 0.5) + 1):\n        if x % y == 0:\n            return True\n    return False\ndef odd_not_prime(n):\n    return sum(not_prime(x) for x in range(1, n + 1, 2))", "def naughty_or_nice(data):\n    s = str(data)\n    return 'Nice!' if s.count('Nice') >= s.count('Naughty') else 'Naughty!'", "from datetime import date\ndef half_life(person1, person2):\n    p1 = list(map(int,person1.split(\"-\")))\n    p1_date = date(p1[0],p1[1],p1[2])\n    p2 = list(map(int,person2.split(\"-\")))\n    p2_date = date(p2[0],p2[1],p2[2])\n    if p1[0]>p2[0]:\n        diff = p1_date-p2_date\n        b = p1_date+diff\n        return str(b)\n    else:\n        diff = p2_date-p1_date\n        a = p2_date+diff\n        return str(a)\n    \n", "def sum_even_numbers(seq): \n    return sum(n for n in seq if not n % 2)", "def filter_list(l):\n    new_list =[]\n    for x in l:\n        if type(x) != str:\n            new_list.append(x)\n    return new_list\n             \n", "from math import ceil\n\ndef matrixfy(name):\n    if not name:\n        return \"name must be at least one letter\"\n    \n    n = ceil(len(name)**0.5)\n    name = list( name.ljust(n*n, \".\") )\n    \n    return [ name[i*n : i*n+n] for i in range(n) ]", "from collections import Counter\n\ndef sabb(s, value, happiness):\n    C = Counter(s.lower())\n    score = value + happiness + sum(C[c] for c in set(\"sabbatical\"))\n    return \"Sabbatical! Boom!\" if score > 22 else \"Back to your desk, boy.\"", "penultimate = lambda a: a[-2]", "def solution(n):\n  n -= 1\n  return [n//3-n//15, n//5-n//15, n//15]", "def pagination_text(page_number, page_size, total_products):\n    s = min((page_number - 1) * page_size + 1, total_products)\n    e = min(s + page_size - 1, total_products)\n    return 'Showing {} to {} of {} Products.'.format(s, e, total_products)", "def find_outlier(integers):\n    determinant = [x for x in integers[:3] if x % 2 == 0]\n    if len(determinant) > 1:\n        # most are even, find the first odd\n        mod = 1\n    else:\n        # most are odd, find the first even\n        mod = 0\n    for i in integers:\n        if i % 2 == mod:\n            return i", "import re\n\n\nhas_ext = lambda p: (lambda f: bool(re.match(fr\"[a-zA-Z]+\\.({p})$\", f)))\n\nis_audio = has_ext(\"mp3|([fa]l|a)ac\")\nis_img = has_ext(\"jpe?g|png|bmp|gif\")\n", "sum_from_string=lambda s:sum([int(k) for k in __import__('re').findall(r'\\d+',s)])", "def identify_weapon(character):\n    wep = {\n    \"Laval\":\"Laval-Shado Valious\",\n    \"Cragger\":\"Cragger-Vengdualize\",\n    \"Lagravis\":\"Lagravis-Blazeprowlor\",\n    \"Crominus\":\"Crominus-Grandorius\",\n    \"Tormak\":\"Tormak-Tygafyre\",\n    \"LiElla\":\"LiElla-Roarburn\"\n    }\n    \n    return wep.get(character, \"Not a character\")", "def sort_emotions(arr, order):\n    return sorted(arr, key=lambda x: ['T_T', ':(', ':|', ':)', ':D'].index(x), reverse=order)", "def sort_dict(d):\n  return sorted(d.items(), key=(lambda x: x[1]))[::-1]", "from itertools import combinations\nfrom math import gcd\n\n\ndef lcm_cardinality(n):\n    return 1 + sum(1 for a, b in combinations(divisors(n), 2) if lcm(a, b) == n)\n        \ndef divisors(n):\n    d = {1, n}\n    for k in range(2, int(n**0.5) + 1):\n        if n % k == 0:\n            d.add(k)\n            d.add(n // k)\n    return sorted(d)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)", "has_unique_chars = lambda s: not s[128:] and not s[len(set(s)):]\n", "import re\ndef get_weight(name):\n    return sum(map(ord, re.sub(r'[^a-zA-Z]', '', name.swapcase())))", "def what_time_is_it(angle):\n    hour = str(int((angle//30) or 12)).zfill(2)\n    min = str(int(2*(angle%30))).zfill(2)  \n    return f'{hour}:{min}'  ", "def count_pairs_int(d,n):\n    def divs(n):\n        x = set()\n        for i in range(1,int(n**.5)+1):\n            if not n%i:\n                x |= {i,n//i}\n        return len(x)\n        \n    c = 0\n    for i in range(1,n-d):\n        if divs(i) == divs(i+d):\n            c += 1\n    \n    return c", "import re\n\n\ndef bears(n, stg):\n    pairs = re.findall(r\"B8|8B\", stg)\n    return [\"\".join(pairs), len(pairs) >= n]", "def queue(q,pos):\n    time = 0\n    while True:\n        time += 1\n        if q[0] == 1:\n            if pos: q.pop(0)\n            else:   return time\n        else:\n            q.append(q.pop(0) - 1)\n        pos = pos - 1 if pos  else len(q) - 1\n", "from re import match, search\n\nis_valid_HK_phone_number = lambda n: match('^\\d{4} \\d{4}$', n) is not None\nhas_valid_HK_phone_number = lambda n: search('\\d{4} \\d{4}', n) is not None", "how_much_water = lambda water, load, clothes: 'Not enough clothes' if clothes < load else 'Too much clothes' if clothes > 2*load else round(water * 1.1**(clothes - load), 2)", "def correct_tail(body, tail):\n    sub = body[-1].lower()\n    return True if sub == tail else False\n", "def shortest_time(n, m, speeds):\n    a, b, c, d = speeds\n    return min(d * (n - 1), (abs(m - n) + n - 1) * a + 2 * b + c)", "cooking_time=lambda n,m,s,p:'{} minutes {} seconds'.format(*divmod(-(-(m*60+s)*int(n[:-1])//int(p[:-1])),60))", "from collections import Counter\n\ndef solve(s):\n    frequencies = [x[1] for x in Counter(s).most_common()]\n    return (\n        len(frequencies) == 1 or\n        len(set(frequencies[:-1])) == 1 and frequencies[-1] == 1 or\n        frequencies[0] == frequencies[1] + 1 and len(set(frequencies[1:])) == 1)", "def cake_slice(n):\n    return (n*(n + 1) + 2)/2\n  #coding and coding...\n", "import math\n\ndef is_square(n):    \n\n    if n < 0:\n        return False\n\n    sqrt = math.sqrt(n)\n    \n    return sqrt.is_integer()", "def count_correct_characters(correct, guess):\n    # Code here\n    print(correct, guess)\n    if len(correct )!=len(guess ):return error\n\n    a=list( (correct))\n    b=list( (guess))\n    print(a,b) \n    c=0\n    for i in range(len(a)):\n        if a[i]  == b[i]:\n            c=c+1\n    return c", "def rental_car_cost(d):\n    days = d * 40\n    if d >= 7:\n        days -= 50\n    if d >= 3 and d < 7:\n        days -= 20\n    return days", "def bubblesort_once(lst):\n    arr = lst[:]\n    for i in range(len(arr)-1):\n        arr[i], arr[i+1] = sorted([arr[i], arr[i+1]])\n    return arr", "def isprime(n):\n    if n==2: return True\n    if n%2==0 or n<2: return False\n    for i in range(3,int(n**0.5)+1,2):\n        if n%i==0:\n            return False \n    return True\nsbs = []\nfor i in range(22):\n    j = 0\n    while 2**i * 3**j + 1 <= 1500000:\n        if isprime(2**i * 3**j + 1):\n            sbs.append(2**i * 3**j + 1)\n        j += 1\ndef solve(x,y): return sum( x <= z & z <= y for z in sbs )", "from collections import defaultdict\n\ndef solve(arr):\n    dct = defaultdict(list)\n    for i,fs in enumerate(map(frozenset, arr)):\n        dct[fs].append(i)\n    return sorted(sum(lst) for lst in dct.values() if len(lst) > 1)", "points=lambda d:((c:=list(map(d.count,'123456')))in(5*[1]+[0],[0]+5*[1],[1,0]+4*[1]))*20+(3in c)*(2in c)*30+(4in c)*40+(5in c)*50", "def abundant(h):\n    for n in range(h, 0, -1):\n        s = sum(d + n // d for d in range(2, int(n ** .5) + 1) if not n % d) \\\n            - n ** .5 * (not n ** .5 % 1) + 1\n        if s > n: return [[n], [s - n]]", "def to_int(n):\n    return sum(int(i) * 256 ** e for (e, i) in enumerate(reversed(n.split('.'))))\n\ndef to_ip(n):\n    return '.'.join(str((n // (256 ** e)) & 255) for e in range(3, -1, -1))\n\ndef ipv4__parser(ip_addr, mask):\n    addr = to_int(ip_addr)\n    mask = to_int(mask)\n    return to_ip(addr & mask), to_ip(addr & ~mask)", "def is_sorted_and_how(list):\n    if list == sorted(list):\n        return(\"yes, ascending\")\n    if list == sorted(list, reverse=True):\n        return(\"yes, descending\")\n    else:\n        return(\"no\")", "def play_pass(phrase, n):\n    output = ''\n    for i, char in enumerate(phrase):\n        if char.isdigit():\n            char = str(9 - int(char))\n        elif char.isalpha():\n            code = (ord(char) - 65 + n) % 26\n            char = chr(code + 65)\n        if i & 1:\n            char = char.lower()\n        output = char + output\n    return output", "def sum_digits(x):\n    if len(str(x)) == 1:\n        return x\n    suma=0\n    for j in str(x):\n        if j != '-':\n            suma += int(j)\n    return suma    # ...", "D = {a:b for a, b in zip('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', \n                         'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM5678901234')}\n\ndef ROT135(s):\n    return ''.join(D.get(c, c) for c in s)", "def rot13(message):\n    index = {}\n    az=[chr(i) for i in range(ord(\"a\"),ord(\"z\")+1)]\n    AZ=[chr(i) for i in range(ord(\"A\"),ord(\"Z\")+1)]\n    azT = az[13:]+az[0:13]\n    AZT = AZ[13:]+AZ[0:13]\n    t={a:b for a,b in zip(az+AZ,azT+AZT)}\n    \n    return \"\".join([t.get(i,i) for  i in message])", "def part(arr):\n  terms = frozenset(['Partridge', 'PearTree', 'Chat', 'Dan', 'Toblerone', 'Lynn', 'AlphaPapa', 'Nomad'])\n  \n  count = sum(1 for x in arr if x in terms)\n  \n  return \"Mine's a Pint\" + \"!\" * count if count > 0 else \"Lynn, I've pierced my foot on a spike!!\"", "def mygcd(x,y):\n    if x%y == 0:\n        return y\n    else:\n        return mygcd(y,x%y)\n\n# reference: http://en.wikipedia.org/wiki/Euclidean_algorithm\n# Please note that it does not matter if y is larger than x, because x%y will have value x\n# which is passed to variable y in the next iteration. So the number of iterations is only\n# increased by one, but the solution will still be correct.\n", "R=[0,0]\n\ns=0\np=0\nS={0}\nfor i in range(1,2500000):\n    x=p-i\n    if x<0 or x in S:x=p+i\n    S|={x}\n    s+=x\n    p=x\n    R+=[s]\ndef rec(x):return R[x]", "def is_triangle(a, b, c):\n    if a > 0 and b > 0 and c > 0:\n        if ((a + b) > c) and ((b + c) > a) and ((a + c) > b):\n            return True\n        elif a == b == c:\n            return True\n        else:\n            return False\n    else:            \n        return False\n", "\ndef solve(a, b):\n    count = 0\n    for num in range(a, b):\n        num = str(num)\n        if num == num.translate(str.maketrans('1234567890', '1xxxx9x860'))[::-1]:\n            count += 1\n    return count\n    \n", "def findSquares(x,y):\n    S = 0 \n    for i in range(y):\n        S += (x-i)*(y-i)\n        \n    return S", "def group_check(s):\n  open = ['(', '{', '[']\n  closed = [')', '}', ']']\n  f = lambda x: True if (open[x] + closed[x]) in s else False\n  while f(0) or f(1) or f(2):\n    for i in range(3):\n      s = s.replace(open[i] + closed[i], '')\n  if s == '':\n    return True\n  else:\n    return False", "def letter_check(arr): \n  arr = list([x.lower() for x in arr])\n  for i in set(list(arr[1])):\n    if i not in arr[0]:\n      return False\n  return True\n", "def poly_multiply(a, b):\n    if a== [] or b== []:\n        return []\n    r=[0 for i in range(len(a)+len(b)-1)]\n    for k,j in enumerate(a):\n        for m,n in enumerate(b):\n            r[k+m] += j*n    \n    return r", "def get_percentage(sent, limit=1000):\n    return f\"{100*sent//limit}%\" if 0 < sent < limit else \"Daily limit is reached\" if sent else \"No e-mails sent\"", "def rat_at(n):\n    if n == 0:\n        return 1, 1\n    a, b = rat_at((n - 1) // 2)\n    return (a, a + b) if n % 2 else (a + b, b)\n\ndef index_of(a, b):\n    if a == b == 1:\n        return 0\n    return 2 * index_of(a, b - a) + 1 if b > a else 2 * index_of(a - b, b) + 2", "from math import log,ceil\ndef friends(n): return 0 if n < 2 else ceil(log(n,2)-1)", "def is_centered(arr,n):\n    return any(\n        sum(arr[i:len(arr)-i]) == n for i in range(len(arr)//2 + 1)\n    )\n", "def first_non_repeating_letter(string):\n    c=''\n    if string=='':\n        return ''\n    count=0\n    b=string.lower()\n    for i in b:\n        a=b.count(i)\n        if a==1:\n            break\n        count+=1\n        if count==len(string):\n            return ''\n    return string[count]", "def uni_total(string):\n    total = 0\n    for item in string:\n        total= total + ord(item)\n    return total", "descriptions=lambda arr:2**sum(arr[i]+1==arr[i+1] for i in range(len(arr)-1))", "def string_hash(s):\n    a = sum(ord(c) for c in s)\n    b = ord(s[-1]) - ord(s[0]) if s else 0\n    c = (a | b) & (~a << 2)\n    return c ^ (32 * (s.count(' ') + 1))\n", "def super_sum(D, N):\n    summe=0\n    for i in range(0,N):\n        summe+=i\n    erg=summe*D*(N**(D-1))\n    return erg\n", "def no_repeat(string):\n    for i in string:\n        if string.index(i) == len(string)-string[::-1].index(i)-1: return i", "import re\ndef solve(s):\n    while '()' in s : s=re.sub(r'\\(\\)','',s)\n    ss = re.sub(r'\\(\\(|\\)\\)','',s)\n    sss = re.sub(r'\\)\\(','',ss)\n    return [-1,(len(s)-len(ss))//2+len(ss)][not bool(sss)]", "def ant(grid, column, row, n, dir = 0):\n    w, d = len(grid[0]), len(grid)\n    m = [[0 for i in range(w+2*n)] for j in range(d+2*n)]\n    for i in range(d):\n        m[i+n][n:n+w] = grid[i][:]\n    x, y = column + n, row + n\n    t = 0\n    xmax, xmin = x, x\n    ymax, ymin = y, y\n    for _ in range(n):\n        dir += (m[y][x]==1)*(1) +(m[y][x]==0)*(-1)\n        dir %= 4\n        m[y][x] = 1-m[y][x]\n        y += (dir==0)*(-1) + (dir==2)*1\n        x += (dir==3)*(-1) + (dir==1)*1\n        xmax,xmin = max(xmax,x), min(xmin,x)\n        ymax,ymin = max(ymax,y), min(ymin,y)\n    return [m[i][min(xmin,n):max(xmax,n+w-1)+1] for i in range(min(ymin,n), max(ymax, n+d-1)+1)]", "def smallest(n):\n    x, y, m = 1, 1, 1\n    while m <= n:\n        if x % m == 0:\n            m += 1\n            y = int(x)\n        else:\n            x += y\n    return x\n", "def repeater(string, n):\n    return string * n\nprint((repeater('Go Jackie ', 16)))\n", "def cake(candles,debris):\n    return 'Fire!' if candles and sum(ord(c) if i%2==0 else ord(c)-96 for i,c in enumerate(debris))>candles*0.7 else 'That was close!'", "def min_sum(arr):\n    # Your code here\n    ans = 0\n    while len(arr)>0:\n        ans += max(arr)*min(arr)\n        arr.remove(max(arr))\n        arr.remove(min(arr))\n    return ans", "def lottery(s):\n    \n    result = ''\n    \n    for i in s:\n        if i.isdigit() and i not in result:\n            result += i\n    \n    return result or 'One more run!'", "def filter_numbers(string):\n    return \"\".join(x for x in string if not (48<= ord(x) and ord(x) <= 58))", "import math\ndef survivor(n):\n    for i in range(2, n):\n        if n < i:\n            break\n        if n % i == 0:\n            return False\n        n = n-n//i\n    return True", "greatest_distance=lambda a:max(i-a.index(e)for i,e in enumerate(a))", "from bisect import bisect\n\ndef sum_of_threes(n, xs=[3**i for i in range(34)]):\n    result = []\n    while n >= 1:\n        x = bisect(xs, n) - 1\n        n -= 3 ** x\n        result.append(x)\n    return 'Impossible' if len(result) != len(set(result)) else '+'.join(f'3^{x}' for x in result)", "def find_dup(arr):\n    memo = set()\n    return next(x for x in arr if x in memo or memo.add(x))", "def highest_value(a, b):\n    ascii_values_a = [ord(c) for c in a]\n    ascii_values_b = [ord(c) for c in b]\n    if sum(ascii_values_a) > sum(ascii_values_b) or sum(ascii_values_a) == sum(ascii_values_b):\n        return a\n    return b", "import re\ndef is_alt(s):\n    return False if re.findall('[aeiou0]{2,}|[^aeiou0-9\\W]{2,}',s) else True ", "def persistence(n):\n    if n < 10: return 0\n    mult = 1\n    while(n > 0):\n        mult = n%10 * mult\n        n = n//10\n    return persistence(mult) + 1", "def pairwise(arr, n):\n    lst = [[e, i] for i, e in enumerate(arr)]\n    ans, v = [], []\n    for i, e in enumerate(arr):\n        if i in v:\n            continue\n        for j, e2 in enumerate(arr[i+1:]):\n            x = i+1+j\n            if e + e2 == n and x not in v:\n                v.append(i)\n                v.append(x)\n                ans.append((i,x))\n                break\n    return sum([i[0]+i[1] for i in ans]) if ans != [] else 0", "s,hh=-464148,[]\n\nwhile s<464159:\n  v=s**3\n  sv,b=str(v),1\n  for c in sv: \n    if not c in '-13579': b=0; break\n  if b: hh.append(v)\n  s+=1\n \ndef odd_dig_cubic(a, b):\n    r=[]\n    for i in hh:\n      if i>=a:\n        if i<=b: r.append(i)\n        else: break\n    return r", "import re\nfrom itertools import zip_longest\ndef next_version(version):\n    s, n = re.subn(r'\\.', '', version)\n    return ''.join([b + a for  a, b in zip_longest('{:0{}}'.format(int(s) + 1, len(s))[::-1], '.' * n, fillvalue = '')][::-1])", "def merge(line):\n    mrg, lst, l, fr = [], [x for x in line if x], len(line), 0\n    for e in lst:\n        if not fr:\n            fr = e\n        elif fr==e:\n            mrg.append(fr+e)\n            fr = 0\n        else:\n            mrg.append(fr)\n            fr = e\n                \n    mrg.append(fr)\n    while len(mrg)<l:\n        mrg.append(0) \n    return mrg\n", "import numpy as np\nfrom bisect import bisect\n\ns = np.ones(10000000)\ns[:2] = s[4::2] = 0\nfor i in range(3, int(len(s)**0.5) + 1, 2):\n    if s[i]:\n        s[i*i::i] = 0\np = [i for i, x in enumerate(s) if x]\n\ndef summationOfPrimes(n):\n      return sum(p[:bisect(p, n)])", "import heapq\n\ndef top3(products, amounts, prices):\n    items = zip(products, amounts, prices)\n    return [product for product, _, _ in heapq.nlargest(3, items, key=lambda item: item[1] * item[2])]", "def squares(x, n):\n    if n < 0:\n        return []\n    return [] if n == 0 else [x] + squares(x**2, n-1)", "from itertools import cycle, islice\n\ndef vowel_shift(text, n):\n    chrs = [c for c in text or '' if c.lower() in 'aeiou']\n    if text and chrs:\n        it = islice(cycle(chrs), -n % len(chrs), None)\n        text = ''.join(next(it) if c.lower() in 'aeiou' else c for c in text)\n    return text", "def find_missing(sequence):\n    t = sequence\n    return (t[0] + t[-1]) * (len(t) + 1) / 2 - sum(t)\n", "from itertools import combinations\nfrom collections import defaultdict\n\ndef ulam_sequence(u0, u1, n):\n    seq = [u0, u1, u0 + u1]\n    \n    while len(seq) < n:\n        candidates = defaultdict(int)\n        \n        for a, b in combinations(seq, 2):\n            candidates[a + b] += 1\n        \n        for num, pairs in sorted(candidates.items()):\n            if num > seq[-1] and pairs == 1:\n                seq.append(num)\n                break\n    \n    return seq", "def caffeineBuzz(n):\n  return 'CoffeeScript' if n % 12 == 0 else 'JavaScript' if n % 6 == 0 else 'Java' if n % 3 == 0 else 'mocha_missing!'  \n", "def palindrome(num):\n        \n    if not isinstance(num, int) or num < 0:\n        return \"Not valid\"\n    \n    if num > 9 and str(num) == str(num)[::-1]:\n        return num\n\n    num_down = num\n    num_up = num\n    \n    d = {}\n    while not d:\n        num_down -= 1\n        num_up += 1\n\n        if str(num_down) == str(num_down)[::-1] and num_down > 9:\n            d['?'] = num_down\n    \n        if str(num_up) == str(num_up)[::-1] and num_up > 9:\n            d['?'] = num_up\n\n    return d.get('?', num)", "def cannons_ready(gunners):\n    a = [v for v in gunners.values()]\n    if \"nay\" in a:\n        return \"Shiver me timbers!\"\n    else:\n        return \"Fire!\"", "def three_details(n):\n    p=2**n.bit_length()\n    return (p-abs(4*n-3*p))//4\n", "def sum_cubes(n):\n    cubes = []\n    for num in range(n+1):\n        cubes.append(num ** 3)\n    return sum(cubes)\n        \n    # your code here\n", "def ipsubnet2list(subnet):\n    import ipaddress\n    ls=[]\n    try:\n        for i in ipaddress.IPv4Network(subnet):\n            ls.append(str(i))\n    except :\n        return None\n    return ls[1:-1] if len(ls)>2 else ls", "def largest_rect(histogram):\n    lis, ris = [], []\n    st = []\n    for i in range(len(histogram)):\n        while st and histogram[st[-1]] >= histogram[i]:\n            st.pop()\n        lis.append(st[-1] if st else -1)\n        st.append(i)\n    st = []\n    for i in reversed(range(len(histogram))):\n        while st and histogram[st[-1]] >= histogram[i]:\n            st.pop()\n        ris.append(st[-1] if st else len(histogram))\n        st.append(i)\n    return max((w * (ri - li - 1) for w, li, ri in zip(histogram, lis, reversed(ris))), default=0)", "from functools import reduce\nfrom itertools import starmap\nfrom operator import mul, sub\n\ndef process_data(data):\n    return reduce(mul, starmap(sub, data))", "def validate_word(word):\n    #your code here\n    word = word.lower()\n    c_count = word.count(word[0])\n    for c in word:\n        if word.count(c) != c_count:\n            return False\n    return True", "from itertools import chain\n\ndef unite_unique(*lists):\n    cache = set()\n    result = list()\n    for elem in chain(*lists):\n        if elem not in cache:\n            result.append(elem)\n        cache.add(elem)\n    return result", "def array_info(arr):\n    res = [len(arr), 0, 0, 0, 0]\n    for i in arr:\n        if type(i) == int:\n            res[1] += 1\n        elif type(i) == float:\n            res[2] += 1\n        elif type(i) == str:\n            if len(i) * ' ' == i:\n                res[4] += 1\n            else:\n                res[3] += 1\n    return [[i] if i else [None] for i in res] if arr else 'Nothing in the array!'", "def spin_solve(sentence):\n    r=[]\n    for w in sentence.split(' '):\n        l=len(w.rstrip(',.'))\n        if l>6 or w.lower().count('t')>=2:\n            s=w[::-1]\n            if not s[0].isalpha():\n                s=s[1:]+s[0]\n            r.append(s)\n        elif l==2 or w[-1]==',':\n            r.append(w.upper())\n        elif l==1:\n            r.append('0')\n        else:\n            r.append(w)\n    return ' '.join(r)", "count_number=lambda n,x:sum(x-n*r<=x%r<1for r in range(1,n+1))", "def every(array, interval = 1, start_index = 0):\n    arr = []\n    counter = 0\n    \n    for i in range(start_index, len(array)):\n        if counter == interval:\n            arr.append(array[i])\n            counter = 0\n        elif i == start_index:\n            arr.append(array[start_index])\n        counter += 1\n        \n    return arr\n            \n", "from calendar import month_abbr\nfrom datetime import datetime \ndef solve(a,b):\n  res = [month_abbr[month]\n      for year in range(a, b+1) \n      for month in [1,3,5,7,8,10,12] \n      if datetime(year, month, 1).weekday() == 4]\n  return (res[0],res[-1], len(res))", "def game_winners(*args):\n    (a,b),(c,d) = args\n    sg, ss = a + 150 * (b=='yes'), c + 150 * (d=='yes')\n    return [\"It's a draw!\",\"Gryffindor wins!\",\"Slytherin wins!\"][(sg>ss)-(sg<ss)]", "def maxlen(s1, s2):\n    sm, lg = sorted((s1, s2))\n    return min(max(lg / 3, sm), lg / 2)", "def equable_triangle(a, b, c):\n    p = a + b + c\n    d = p / 2\n    return (d * (d - a) * (d - b) * (d - c))**0.5 == p", "def count_targets(n, sequence):\n    return sum([1 for i in range(n, len(sequence)) if sequence[i] == sequence[i-n]])", "def get_size(w,h,d):\n    volume = (h*w*d)\n    area=2*(w*h)+2*(w*d)+2*(h*d)\n    res=[]\n    res.append(area)\n    res.append(volume)\n\n    return res\nprint((get_size(10,10,10)))\n", "def dont_give_me_five(start,end):\n    # your code here\n    return sum(1 for i in range(start,end+1) if \"5\" not in str(i))   # amount of numbers", "def cup_and_balls(b, arr):\n    for swap in arr:\n        if b in swap:\n            b = swap[not swap.index(b)]\n    return b", "def remove_smallest(numbers):\n    if numbers:\n        numbers_copy = numbers[:]\n        smallest_value = numbers_copy[0]\n        for i in numbers_copy:\n            if i < smallest_value:\n                smallest_value = i\n        numbers_copy.remove(smallest_value)\n        return numbers_copy\n    return numbers\n", "def complexSum(arr):\n    real_sum = 0\n    imag_sum = 0\n    for string in arr:\n        val = ''\n        for char in string:\n            if char == '-':\n                if len(val) > 0:\n                    real_sum += int(val)\n                val = '-'\n            elif char == '+':\n                real_sum += int(val)\n                val = ''\n            elif char == 'i':\n                if val == '':\n                    val = 1\n                elif val[0] == '-':\n                    if len(val) != 1:\n                        val = -1 * int(val[1::])\n                    else: val = -1\n                imag_sum += int(val)\n                val = 0\n            else:   \n                val += char\n        real_sum += int(val)\n    fin_string = ''\n    if imag_sum == 1:\n        fin_string = 'i'\n    elif imag_sum == 0:\n        fin_string = ''\n    elif imag_sum == -1:\n        fin_string = '-i'  \n    else:\n        if imag_sum > 1 and real_sum != 0:\n            fin_string = '+'+str(imag_sum)+'i'\n        else: \n            fin_string = str(imag_sum)+'i'\n    if real_sum == 0 and imag_sum != 0:\n        return fin_string\n    return (str(real_sum)+fin_string) if (real_sum+imag_sum !=0) else '0'", "def palindrome(num):\n    if type(num) is not int or num < 0:\n        return \"Not valid\"\n    if num < 10:\n        return 0\n    \n    counter = 0\n    num = str(num)\n    for i in range(0,len(num)-1):\n        for r in range(i + 2, len(num)+1):\n            if num[i:r] == num[i:r][::-1]:\n                counter += 1    \n    return counter", "def bits_war(numbers):\n    even, odd = 0, 0\n    for x in numbers:\n        res = bin(x).count('1')\n        res = -res if x < 0 else res\n        if x%2: odd += res\n        else: even += res\n    return 'tie' if even == odd else ('even', 'odd')[odd>even]+'s win'", "def reverse_letter(string):\n    reversed = \"\"\n    for i in range(len(string)-1, -1, -1):\n        if string[i].isalpha():\n            reversed += string[i]\n    return reversed\n\n", "def a(n):\n    n -= n%2\n    if n<4: return ''\n    return '\\n'.join( '{0}{1}{0}'.format('A' * (i%(n//2) != 0),\n                                         ' ' * (i*2-1) if i%(n//2) else ' '.join( ['A']*(i+1) )\n                                        ).center(2*n-1) for i in range(n) )", "def convert_to_mixed_numeral(parm):\n    sign, parm = parm[:(\"-\" in parm)], parm[(\"-\" in parm):]\n    numerator, denominator = parm.split(\"/\")\n    integer, numerator = divmod(int(numerator), int(denominator))\n    integer, fraction = f\"{integer or ''}\", f\"{numerator}/{denominator}\" if numerator else \"\"\n    return f\"{sign}{integer}{(integer and fraction) and ' '}{fraction}\"", "def goldbach(n):\n    if n < 2:\n        return []\n    if n == 4:\n        return [[2, 2]]\n    l = n - 2\n    sieve = [True] * (l // 2)\n    for i in range(3, int(l**0.5) + 1, 2):\n        if sieve[i // 2]:\n            sieve[i * i // 2::i] = [False] * ((l - i * i - 1) // (2 * i) + 1)\n    primes = [(2 * i + 1) for i in range(1, l // 2) if sieve[i]]\n    return [[p, n - p] for p in primes if (n - p) in primes and p <= (n - p)]\n", "\ndef num_blocks(w, l, h):\n    return h*w*l + (w+l)*h*(h-1)//2 + h*(h-1)*(2*h-1)//6", "def make_sentences(parts):\n    result = ''\n    for i in range(len(parts) - 1):\n        result += parts[i]\n        if parts[i + 1] not in '.,':\n            result += ' '\n    result += parts[-1]\n    return result.rstrip('.') + '.'", "def calculate_grade(scores):\n    import numpy as np\n    mean_score = np.mean(scores)\n    if mean_score >= 90:\n        return \"A\"\n    elif mean_score >= 80:\n        return \"B\"\n    elif mean_score >= 70:\n        return \"C\"\n    elif mean_score >= 60:\n        return \"D\"\n    else:\n        return \"F\"\n", "def to12hourtime(hhmm):\n    hh, mm = int(hhmm[:2]), int(hhmm[2:])\n    return '{}:{:02} {}'.format(hh - 12 if hh > 12 else hh, mm, ['am','pm'][hh>=12]) if hh else '12:{:02} am'.format(mm)    ", "from math import log2\n\ndef squares_needed(grains):\n    return 0 if not grains else int(log2(grains)) + 1", "def filter_even_length_words(words):\n    arr = []\n    for el in words:\n        if len(el) % 2 == 0:\n            arr.append(el)\n    return arr", "def tongues(code):\n    return code.translate(str.maketrans('BKXZNHDCWGPVJQTSRLMFbkxznhdcwgpvjqtsrlmfAIYEOUaiyeou','PVJQTSRLMFBKXZNHDCWGpvjqtsrlmfbkxznhdcwgEOUAIYeouaiy'))\n    \n", "def sequence_sum(begin_number, end_number, step):\n    print(begin_number, end_number, step)\n    return sum([i for i in range(begin_number, end_number+1, step)]) if end_number>=begin_number else 0", "def direction_in_grid(n,m):\n  return \"LRUD\"[2*(n>m)+(m if n>m else n)%2]", "def find_average(num_list):\n    return sum(num_list) / len(num_list)\n", "from collections import Counter\ndef palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return num > 10 and sum(1 for v in Counter(map(int, str(num))).values() if v % 2) <= 1", "def explode(arr):  \n    numbers = [n for n in arr if type(n) == int]\n    return [arr] * sum(numbers) if numbers else \"Void!\"", "def covfefe(s):\n    return (lambda cv,cf:(s+[f' {cv}',''][cv in s]).replace(cv,cf))('coverage', \"covfefe\")", "import re\n\npattern = re.compile('o(.*?)d(.*?)d')\n\ndef odd(s):\n    n = 0\n    while pattern.search(s):\n        n += 1\n        s = pattern.sub(r'\\1\\2', s, count=1)\n    return n", "from collections import Counter as c\nfrom itertools import takewhile\n\ndef solve(arr):\n    if arr == []: return []\n    a = sorted(c(map(lambda x: x.split('.')[-1],arr)).most_common(), key=lambda i: (-i[1], i[0]))\n    maxi = a[0][1]\n    return list(map(lambda x: '.'+x[0],(takewhile(lambda x: x[1] == maxi, a))))", "def base64_to_base10(s):\n    n = 0\n    for c in s:\n        n = n * 64 + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.index(c)\n    return n", "from itertools import permutations\nfrom hashlib import sha256\n\ndef sha256_cracker(hash, chars):\n  return next((\"\".join(p) for p in permutations(chars) if sha256(\"\".join(p).encode('utf-8')).hexdigest() == hash), None)", "def difference_of_squares(n):\n    return (n*(n+1)*.5)**2 - (n)*(n+1)*(2*n+1)/6", "def merge_arrays(first, second): \n    first.extend(second)\n    res=list(set(first))\n    res.sort()\n    return res", "solve=lambda n,k: [n] if k==1 else (lambda r: r[-1] if len(r) else [])(list(filter(lambda a: a[-1]>0 and a[-1] > a[-2] and not a[-1]%a[0], ([j*i for j in range(1,k)]+[int(n-k*(k-1)/2*i)] for i in range(1,int(n/2)+1)))))", "def solve(eq):\n    #\n    # implemantation takes advantage of abscence of spaces\n    #\n    leq = (eq.replace('*', ' * ')\n             .replace('/', ' / ')\n             .replace('+', ' + ')\n             .replace('-', ' - ')\n             .split(' ')) \n\n    out = ''.join(leq[::-1])\n\n    return out\n\n", "def make_upper_case(s):\n    i  = s.upper()\n    return i", "def insert_missing_letters(word):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    new = ''\n    used = ''\n\n    for letter in set(word):\n        alphabet = alphabet.replace(letter,\"\")\n\n    for letter in word:\n        if letter not in used:\n            new += letter + \"\".join([x.upper() for x in alphabet if ord(x) > ord(letter)])\n        else: new += letter\n\n        used += letter\n        \n    return new", "def calculate_probability(n):\n    p=1\n    for i in range(n):\n        p=p*(365-i)\n    return round(1-p/365**n,2)", "def series_sum(n):\n    result = 0\n    for i in range(0, n):\n        result += (1 / (1+3*i))\n    return \"{number:.{digits}f}\".format(number=result, digits=2)", "def mark_spot(n):\n    if type(n) is not int or n <= 0 or n % 2 == 0:\n        return \"?\"\n\n    p1, s = 0, 2*n - 3\n    result = \"\"\n    for i in range(1,n // 2 + 1):\n        result += \" \" * p1 + \"X\" + \" \" * s + \"X\\n\"\n        p1 += 2\n        s -= 4\n    result += \" \" * p1 + \"X\\n\"\n    for i in range(n // 2 + 2,n+1):\n        p1 -= 2\n        s += 4\n        result += \" \" * p1 + \"X\" + \" \" * s + \"X\\n\"\n\n    return result", "from itertools import cycle\ndef robot_walk(arr):\n    directions, li, m, n = cycle([(1, 0), (0, 1), (-1, 0), (0, -1)]), [], 0, 0\n    for i in arr:\n        k, l = next(directions)\n        li.append([[m, n], [m + k * i, n + l * i]])\n        m += k * i ; n += l * i\n        test = li[-1]\n        for o, p in li[:-3]:\n            same, same1 = not o[0]==p[0], not test[0][0]==test[1][0]\n            if same != same1:\n                temp, temp1 = sorted([o[same^1],p[same^1]]), sorted([test[0][same1^1],test[1][same1^1]])\n                if o[same]>=temp1[0] and o[same]<=temp1[1] and test[0][same1]>=temp[0] and test[0][same1]<=temp[1] : return True\n    return False", "def calc_tip(p, r):\n    T=(round(p/10+0.01)*10)//10\n    return max([T-1,T+1,T//2-1][r],0)", "import re\ndef apparently(s): return re.sub(r'\\b(and|but)(?:\\b)(?! apparently\\b)',lambda m:m.group()+' apparently', s)", "from math import log2\n\ndef operation(a,b, n = 0):\n    while log2(a) % 1:\n        n += 1\n        a //= 2\n    return n + abs(log2(a/b))", "def tops(msg):\n    res=''\n    top=1\n    diff=5\n    while top<len(msg):\n        res+=msg[top]\n        top+=diff\n        diff+=4\n    return res[::-1]", "def min_dot(a, b):\n    return sum(map(int.__mul__, sorted(a), sorted(b)[::-1]))", "def find_polydivisible(digits_limit):\n    numbers = []\n    previous = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    digits = 2\n    poly_for_digits = []\n    \n    while previous and digits <= digits_limit:\n        numbers += previous\n        for p in previous: \n            for i in range(10):\n                number = p * 10 + i\n                if number % digits == 0: poly_for_digits.append(number)\n        \n        previous = poly_for_digits[:]\n        poly_for_digits = []\n        digits += 1\n    \n    return numbers\n\npolydivisibles = find_polydivisible(26)\n\ndef next_num(n):\n    return next((p for p in polydivisibles if p >= n + 1), None)", "def odd_ball(arr):\n    return arr.index(\"odd\") in arr", "def greet(name):\n    if name == \"Johnny\":\n        return (\"Hello, my love!\")\n    else:   \n        return (\"Hello, {name}!\".format(name=name))\n    \n        \n        \n#def greet(name):\n#    return \"Hello, {name}!\".format(name=name)\n#    if name == \"Johnny\":\n#        return \"Hello, my love!\"\n", "def shorten_to_date(long_date):\n    x = long_date.split(',')\n    del x[-1]\n    return x[0]\n", "def do_math(s):\n    alfavit = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    def izvlech(s):\n        s += ' '\n        list = []\n        string = ''\n        for x in s:\n            if x != ' ':\n                string += x\n            else:\n                list.append(string)\n                string = ''\n        return list\n\n    def izvlech1(list1, alfavit):\n        list2 = []\n        for z in alfavit:\n            for x in list1:\n                for y in x:\n                    if z == y:\n                        list2.append(x)\n        return list2\n\n    list1 = izvlech(s)\n    list2 = izvlech1(list1, alfavit)\n    result = ''\n    final_result = 0\n    index = 0\n    for x in list2:\n        for y in x:\n            try:\n                y = int(y)\n                result += str(y)\n            except ValueError:\n                continue\n        if index == 0:\n            index += 1\n            final_result = int(result)\n            result = ''\n            continue\n        elif index == 1:\n            final_result += int(result)\n            result = ''\n            index += 1\n            continue\n        elif index == 2:\n            final_result -= int(result)\n            result = ''\n            index += 1\n            continue\n        elif index == 3:\n            final_result *= int(result)\n            result = ''\n            index += 1\n            continue\n        elif index == 4:\n            final_result /= int(result)\n            result = ''\n            index = 1\n            continue\n    return round(final_result)", "def pattern(n):\n    return \"\\n\".join(str(x)*x for x in range(1, n + 1, 2))", "import math\ndef solution(n):\n    d=0\n    if n - 0.25< math.floor(n):\n        d=math.floor(n)\n    elif n - 0.75< math.floor(n):\n        d=math.floor(n)+0.5\n    else:\n        d=math.ceil(n)\n    return d", "def difference_in_ages(ages):\n    ages = sorted(ages)\n    return (ages[0], ages[len(ages)-1], abs(ages[0] - ages[len(ages)-1 ]))", "def diagonal(matrix):\n    principal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    secondary_sum = sum(matrix[i][~i] for i in range(len(matrix)))\n    if principal_sum > secondary_sum:\n        return \"Principal Diagonal win!\"\n    elif principal_sum < secondary_sum:\n        return \"Secondary Diagonal win!\"\n    else:\n        return \"Draw!\"", "from collections import defaultdict\ndef group_in_10s(*l):\n    if not l : return []    \n    d = defaultdict(list)\n    for i in l:\n        d[int(str(i//10))].append(i)\n    return [None if d[i] == [] else sorted(d[i]) for i in range(1 + max(d.keys()))]", "def area_largest_square(r):\n    return 2 * r * r", "import math\ndef tankvol(h, d, vt):\n    r=d/2\n    theta=math.acos((r-h)/r)\n    return int(vt*(theta-math.sin(theta)*(r-h)/r)/math.pi)", "import re\nhungry_seven = lambda arr: (lambda h: lambda x: h(h, x))(lambda h, x: h(h, re.sub(r'(7+)(89)', r'\\2\\1', x)) if re.search(r'(7+)(89)', x) else [int(c) for c in x])(''.join(map(str, arr)))\n", "def add(s1, s2):\n    s1 = s1.encode()\n    s2 = s2.encode()\n    s1 = sum(s1)\n    s2 = sum(s2)\n    return s1+s2", "def find_slope(s):\n    try:\n        d = (s[3]-s[1])//(s[2]-s[0])\n        return str(d)\n    except:\n        return 'undefined'", "is_prime = lambda n: n in (2, 3) or n > 3 and n % 2 and n % 3 and all(n % f and n % (f + 2) for f in range(5, int(n ** .5) + 1, 6))\nsolve = lambda n: next(p for gap in __import__('itertools').count(0) for p in (n - gap, n + gap) if is_prime(p))", "def get_participants(h):\n    n = 0\n    counter = 0\n    while h > 0:\n        h -= counter\n        n += 1\n        counter += 1\n    return n or 1", "def quote(fighter):\n  if fighter== \"george saint pierre\" : return \"I am not impressed by your performance.\"\n  if fighter== \"George Saint Pierre\" : return \"I am not impressed by your performance.\"\n  if fighter== \"conor mcgregor\" or fighter== \"Conor McGregor\" : return\"I'd like to take this chance to apologize.. To absolutely NOBODY!\"", "from itertools import groupby\ndef happy_g(s):\n    return all(False if k == 'g' and len(list(g)) == 1 else True for k, g in groupby(s))\n", "def types(n):\n    return type(n).__name__", "def century(year):\n    return year // 100 + 1 if year % 100 != 0 else year // 100", "import re\n\ndef string_clean(s):\n    k = re.sub(\"\\d\",\"\",s)\n    return k", "def calculate_1RM(w, r):\n    if r == 0: return 0\n    if r == 1: return w\n    \n    return round(max([\n      w * (1 + r / 30),                 # Epley\n      100 * w / (101.3 - 2.67123 * r),  # McGlothin\n      w * r**0.10                       # Lombardi\n      ]))", "def remove(text, what):\n    for c,v in what.items():\n        text = text.replace(c,'',v)\n    return text    ", "import heapq\n\ndef largest(n,xs):\n  \"\"\"Find the n highest elements in a list\"\"\"\n  return sorted(heapq.nlargest(n, xs))", "get_mean=lambda arr,x,y: -1 if x<2 or y<2 or x>len(arr) or y>len(arr) else (sum(arr[:x])/float(x)+sum(arr[-y:])/float(y))/2.0", "def is_prime_happy(n):\n    return n in [5, 25, 32, 71, 2745, 10623, 63201, 85868]", "def solve(a,b):\n    if not a: return 1\n    x,c = a[0],0   \n    for i in range(len(b)):\n        if b[i] == x:\n            c += solve(a[1:],b[i+1:])   \n    return c", "calc_ms=lambda Q:20**Q", "def better_than_average(class_points, your_points):\n    return sum(class_points) / len(class_points) <= your_points", "from math import factorial\n\ndef sum_arrangements(num):\n\n    snum = str(num)\n    leng = len(snum)\n    total = 0\n    c = factorial(leng - 1) * sum(map(int, snum))\n\n    for i in range(leng):\n        total += c\n        c *= 10\n\n    return total", "strokes = {\n    c: str(i)\n    for i, s in enumerate(['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'], 2)\n    for c in s\n}\n\ndef unlock(message):\n    return ''.join(map(strokes.get, message.lower()))", "def order_weight(strng):\n    if strng==\"\":\n        return strng\n    else:\n        lss=strng.split()\n        new_ls=[]\n        dic={}\n        value=\"\"    \n        for elements in lss:\n            new=sum(float(element) for element in elements) \n            if new in new_ls:\n                  while new in new_ls:\n                      new=float(new)\n                      new+=0.001\n                  new_ls.append(new)\n                  dic[new]=elements\n            else:\n                new_ls.append(new)\n                dic[new]=elements\n            new_ls.sort() \n        sl=[dic.get(new_ls[m]) for m in range(len(new_ls))]\n        for m in range(len(new_ls)):\n            for n in range(len(new_ls)):\n                if int(new_ls[m])==int(new_ls[n]) and m!=n:\n                    if dic.get(new_ls[m])<dic.get(new_ls[n]) and m>n:\n                        t=new_ls[m]\n                        new_ls[m]=new_ls[n]\n                        new_ls[n]=t        \n        for i in range(len(new_ls)-1):\n            value+=\"\".join(dic.get(new_ls[i]))\n            value+=\" \"\n        value+=\"\".join(dic.get(new_ls[-1]))\n        return value", "from math import cos, sin, radians\n\ndef coordinates(d, r):\n    return round(r * cos(radians(d)), 10), round(r * sin(radians(d)), 10)", "def unused_digits(*args):\n    return ''.join(sorted(set('1234567890') - set(''.join(str(x) for x in args))))", "def make_acronym(phrase):\n    try:\n        return ''.join(word[0].upper() if word.isalpha() else 0 for word in phrase.split())\n    except AttributeError:\n        return 'Not a string'\n    except TypeError:\n        return 'Not letters'", "from itertools import groupby\nfrom collections import defaultdict\n\ndef replace(s):\n    res, D = [], {'!':defaultdict(list), '?':defaultdict(list)}\n    for i, (k, l) in enumerate(groupby(s)):\n        s = len(list(l))\n        D[k][s].append(i)\n        res.append([k, s])\n    for v, L1 in D['!'].items():\n        L2 = D['?'][v]\n        while L1 and L2:\n            res[L1.pop(0)][0] = ' '\n            res[L2.pop(0)][0] = ' '\n    return ''.join(c*v for c,v in res)", "def swap(st):\n    return \"\".join( c.upper() if c in \"aeiou\" else c for c in st )", "from itertools import compress, combinations_with_replacement\nimport numpy as np\n\n\ns = np.ones(10001)\ns[:2] = s[4::2] = 0\nfor i in range(3, int(len(s)**0.5)+1, 2):\n    if s[i]:\n        s[i*i::i] = 0\nPRIMES = list(compress(list(range(len(s))), s))\n\ndef solve(a, b):\n    i, j = np.searchsorted(PRIMES, a), np.searchsorted(PRIMES, b)\n    return sum(s[sum(map(int, str(x * y)))] for x, y in combinations_with_replacement(PRIMES[i:j], 2))\n", "box_capacity = lambda *ds,r=__import__(\"functools\").reduce:r(int.__mul__, ((i * 12) // 16 for i in ds))", "def sum_them(n):\n    return (1 << n) - 1 << (n - 1 if n else 0)\n    \n", "import re\n\ndef reverse_by_center(s):\n    half = len(s) // 2\n    return re.sub(\"(.{%s})(.?)(.{%s})\" % (half, half), r\"\\3\\2\\1\", s)", "def ordered(l, arr1,arr2):\n    return [l,arr2.index(l) + len(arr1) if l in arr2 else arr1.index(l)]\n\ndef hot_singles(arr1, arr2):\n    L = [ ordered(l,arr1,arr2) for l in set(arr1) ^ set(arr2)]\n    return list(map(lambda l: l[0], sorted(L , key=lambda l: l[1])))", "countzero = lambda s: sum((c in \"%&B8\") * 2 + (c in \"abdegopq069DOPQR\") * 1 for c in s) + s.count(\"()\")", "def greek_comparator(lhs, rhs):\n    if lhs == rhs:\n        return 0\n\n    greek_alphabet = (\n        'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', \n        'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', \n        'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma',\n        'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega')\n\n    return 1 if greek_alphabet.index(lhs) > greek_alphabet.index(rhs) else -1\n", "def player_manager(players):\n    return [{'player': a, 'contact': int(b)} for a, b in zip(*[iter(players.split(', '))] * 2)] if players else []", "from re import search\ndef body_count(code):\n    return bool(search(\"([A-Z]\\d){5}\\.\\-[A-Z]%\\d\\.\\d\\d\\.\",code))", "def uniq(seq):\n    if len(seq) == 0:\n        return []\n    rez = [seq[0]]\n    for i in range(1, len(seq)):\n        if seq[i] != rez[-1]:\n            rez.append(seq[i])\n    return rez", "display_board=lambda b,w:f\"\\n{'-'*(4*w-1)}\\n\".join([\"|\".join(\" \"+c+\" \" for c in b[i:i+w]) for i in range(0,len(b)-1,w)])\n", "def knight_rescue(N,x,y):\n  e=any(i%2==0 for i in N)\n  return e or (x+y)%2==0", "def london_city_hacker(journey): \n    \n    sum = 0.0    \n    isBus = False\n    \n    for i in journey :\n        if len(str(i)) <= 3:\n            if isBus :\n                isBus = 0 \n            else :\n                sum += 1.50\n                isBus = 1\n        else :\n            sum += 2.40\n            isBus = 0\n    \n    sum = round(sum * 100) / 100\n    \n    return f'\u00a3{str(sum)}0'", "chameleon=lambda C,d:(lambda c,a,b:-1if a==c<1or(b-a)%3else b)(*[C.pop(d)]+sorted(C))", "def friend_find(line):\n    s=0\n    for i in range(0,len(line)-2):\n        f1,f2,f3=line[i],line[i+1],line[i+2]\n        if [f1,f2,f3]==[\"red\",\"blue\",\"blue\"]:s+=1\n        elif [f1,f2,f3]==[\"blue\",\"red\",\"blue\"]:\n            s+=1\n            line[i+1]=\"\"\n        elif [f1,f2,f3]==[\"blue\",\"blue\",\"red\"]:\n            s+=1\n            line[i+2]=\"\"\n    return s", "import re\ndef pig_latin(s):\n    s = s.lower()\n    if re.findall('[\\d\\W]',s) or s == '':\n        return None\n    elif s.startswith(('a','e','i','o','u')):\n        return s + 'way'\n    else:\n        return re.sub('(^[^aeiou]+)(\\w*)','\\g<2>\\g<1>ay',s)", "def shortest_arrang(n):\n    for i in range(2,n):\n        if (n/i)*2<i: break\n        if i%2==0 and (n/i)%1==0.5: return [n//i-i//2+1+j for j in range(0,i)[::-1]]\n        if i%2==1 and (n/i)%1==0: return [n//i-(i-1)//2+j for j in range(0,i)[::-1]]\n    return [-1]\n", "l, m = 10082, 104\na, d, s, t = 0, 1, {}, [0]\nfor _ in range(l + m - 1):\n    s[a] = 1 - s.get(a, 0)\n    v = (-1) ** -~s[a]\n    d *= 1j * v\n    a += d\n    t.append(t[-1] + v)\n\ndef langtons_ant(n):\n    if n < l: return t[n]\n    q, r = divmod(n - l, m)\n    return 12 * q + t[l + r]", "def sort_number(a): \n    a = sorted(a)\n    if a[len(a)-1] != 1:\n        a[len(a)-1] = 1\n    else:\n        a[len(a)-1] = 2\n    \n    return sorted(a)", "def skiponacci(n):\n    fib = [1, 1][:n]\n    for _ in range(n-2):\n        fib.append(sum(fib[-2:]))\n    return \" \".join(str(n) if i % 2 else \"skip\" for i, n in enumerate(fib, 1))", "from collections import Counter\n\n\ndef anagrams(word, words):\n    n, c = len(word), Counter(word)\n    return [w for w in words if len(w) == n and Counter(w) == c]\n", "def swap_head_tail(a):\n    r, l = (len(a)+1)//2, len(a)//2\n    return a[r:] + a[l:r] +  a[:l]", "r=reversed;x=enumerate;reverse_on_diagonals=lambda m:[[f if i==j or len(m[i])-(i+j+1)==0 else m[i][j]for j,f in x(e)]for i,e in x([list(r(e))for e in r(m)])]", "def roots(a,b,c):\n    # your code\n    D = b**2-4*a*c\n    if D<0:\n        #No solution in the set of real numbers\n        return None\n    if D==0:\n        #Same \"double\" solution\n        x= (-b+D**0.5)/(2*a)\n        return round(x*2,2)\n    if D>0:\n        #Two different solutions\n        x1 = (-b+D**0.5)/(2*a)\n        x2 = (-b-D**0.5)/(2*a)\n        return round((x1+x2),2)", "def shortest_time(speed):\n    import itertools\n    from collections import Counter\n    times=[]\n    for elem in itertools.combinations(speed,2):   \n        end1 = [x for x in elem] \n        base1 = list((Counter(speed)-Counter(end1)).elements())             \n        for i in itertools.combinations(end1,1):            \n            base2 = [x for x in base1+[i[0]]]   \n            if sum(end1)!= 2*end1[0]:\n                end2 = [x for x in end1 if x != i[0]]\n            else:\n                 end2 = [end1[0]]   \n            for j in itertools.combinations(base2,2):                                            \n                end3 = [x for x in end2 +[j[0],j[1]]]\n                base3 = list((Counter(base2)-Counter(j)).elements())\n                for k in itertools.combinations(end3,1):             \n                    base4 = [x for x in base3+[k[0]]]                             \n                    times += [max(elem)+ i[0]+max(j)+k[0]+max(base4)]                                                                                               \n    return min(times)", "def solve(a,b):\n    while a and b:\n        if a >= 2*b:\n            a -= (a//(2*b))*(2*b)\n            print(a)\n        elif b >= 2*a:\n            b -= (b//(2*a))*(2*a)\n        else:\n            break\n    return [a,b]   ", "def no_space(x):\n    #your code here\n    answer = \"\"\n    for i in x:\n        if i == \" \":\n            continue\n        else:\n            answer += i\n    return answer\n", "def rectangles(n, m):\n  return n*m*(n-1)*(m-1)//4", "def buy_or_sell(pairs, harvested_fruit):\n    \n    currentFruit = harvested_fruit\n    actions = list()\n    \n    for pair in pairs:\n    \n        if currentFruit not in pair: return 'ERROR'\n    \n        if currentFruit == pair[0]:\n        \n            actions.append('buy')\n            currentFruit = pair[1]\n            \n        else:\n        \n            actions.append('sell')\n            currentFruit = pair[0]\n            \n    return actions", "def hidden(num):\n    return str(num).translate(str.maketrans(\"6174329805\", \"abdeilmnot\"))", "def are_equally_strong(your_left, your_right, friends_left, friends_right):\n  return sorted([your_left, your_right]) == sorted([friends_left, friends_right])", "def int_rac(n, guess):\n    \"\"\"Integer Square Root of an Integer\"\"\"\n    x = guess\n    cnt = 1\n    while True:\n        newx = (x + n // x) // 2 \n        if abs(x - newx) < 1:\n            return cnt\n        x = newx\n        cnt += 1", "def pre_fizz(n):\n    new_arr = list()\n    for i in range(1,n + 1):\n        new_arr.append(i)\n    return new_arr", "from operator import mul\nfrom functools import reduce\n\ndef find_middle(s):\n    if not s or not isinstance(s,str): return -1\n    \n    lstDig = [int(c) for c in s if c.isnumeric()]\n    if not lstDig: return -1\n    \n    prod = str( reduce(mul,lstDig) )\n    i    = (len(prod) - 1) // 2\n    return int(prod[i:-i or len(prod)])", "def encrypt(text, key):\n    return \"\".join(chr((ord(ch) + key) & 255) for ch in text)", "from collections import deque\n\ndef padovan(n):\n    q = deque([1,1,1], maxlen=3)\n    for i in range(n-2):\n        q.append(q[0] + q[1])\n    return q[-1]", "def colorful(number):\n    if len(str(number)) == 1: \n        return True\n    else:\n        output = list(str(number))\n        for n,x in enumerate(list(str(number))):\n            if n + 1 < len(str(number)):\n                tmp = list(str(number))[n+1]\n                \n                #tmp = int()\n                output.append(str(int(x) * int(tmp)))\n       \n        if len(output) == len(set(output)):\n            return True\n        else:\n            return False    \n            \n      \n", "def ellipse_contains_point(f0, f1, l, p): \n    return ((p['x']-f0['x'])**2+(p['y']-f0['y'])**2)**.5 + ((p['x']-f1['x'])**2+(p['y']-f1['y'])**2)**.5 <= l", "from statistics import mean\n\ndef cube_times(times):\n    return (round(mean(sorted(times)[1:4]), 2), min(times))", "def get_score(n):\n    return 25 * n * (n + 1)", "import itertools\ndef next_perfectsq_perm(l, k):\n    perf = lambda n: n**0.5%1 == 0\n    while True:\n        l += 1\n        if perf(l) and '0' not in str(l):\n            r = [x for x in set([int(''.join(x)) for x in list(itertools.permutations(str(l)))]) if perf(x)]\n            if len(r) == k: return max(r)", "import re\ndef frogify(s): \n    print(s)\n    s =re.sub(\"\\s?[(),\\[\\];{}-]+\",r\"\",s)\n    print(s)\n    match =re.findall(\"\\w[\\w, -]+\",s)\n    for i in match:\n        print(i)\n        rev = \" \".join(reversed(i.split()))\n        s = re.sub(i,rev,s)\n    return s.lstrip()\n    \n", "def reverser(sentence):\n    ans = ''\n    word = ''\n    for letter in sentence:\n        if letter == ' ':\n            ans = ans + word[::-1] + letter\n            word = ''\n        else:\n            word = word + letter\n    return ans + word[::-1]", "def odd_or_even(arr):\n    var = 0\n    for i in arr:\n        var = i + var\n        \n    if var % 2 == 0:\n        return(\"even\")\n    else:\n        return(\"odd\")", "def is_isogram(string):\n    return len(set(list(string.lower()))) == len(string)", "def archers_ready(archers):\n    try:\n        return min(archers)>=5\n    except:\n        return False", "def area_or_perimeter(l , w):\n    # return your answer\n    if l == w:\n        area = l * w\n        return area\n    else:\n        perimeter = l + l + w + w\n        return perimeter\n    \n    return area_or_perimeter", "def cost(mins):\n    price =30\n    while mins > 60:\n        mins-=30\n        if mins>35:\n            price+=10\n        else:\n            return price\n    else:\n        return price", "import math\ndef is_negative_zero(n):\n    return n == 0 and math.copysign(1, n) == -1", "def gen(n, d):\n    if d == 0 or n == 1:\n        yield [d]*n\n    else:\n        for x in range(d+1):\n            for y in gen(n-1, d-x):\n                yield [x] + y\n\ndef indices(n, d):\n    return list(gen(n, d))", "def digits(num):\n    ints = [int(i) for i in str(num)]\n    sums = []\n    for i in range(len(ints)-1):\n        for j in ints[i+1:]:\n            sums.append(ints[i] + j)\n    return sums", "def lostSheep(friday,saturday,total):\n    s = total - (sum(friday) + sum(saturday))\n    return s", "valid = \":) :D :-) :-D :~) :~D ;) ;D ;-) ;-D ;~) ;~D\".split()\n\ndef count_smileys(arr):\n    return sum(face in valid for face in arr)", "def did_we_win(plays):\n    s = 0\n    for i in range(4):\n        if not plays[i]: break\n        if plays[i][1] == \"turnover\": return False\n        s += plays[i][0] * (-1)**(plays[i][1] == \"sack\")\n    return s > 10", "def get_planet_name(id):\n    # This doesn't work; Fix it!\n    name=\"\"\n    if id == 1: name = \"Mercury\"\n    elif id == 2: name = \"Venus\"\n    elif id == 3: name = \"Earth\"\n    elif id == 4: name = \"Mars\"\n    elif id == 5: name = \"Jupiter\"\n    elif id == 6: name = \"Saturn\"\n    elif id == 7: name = \"Uranus\"  \n    elif id == 8: name = \"Neptune\"\n    else: name = \"Pluto\"\n    return name", "def count_pal(n):\n    # No recursion; direct calculation:\n    return [9 * 10**((n-1) // 2), 10**(n // 2) * (13 - 9 * (-1)**n) // 2 - 2]", "def solve(a, b):\n    alice = sum(x > y for x, y in zip(a, b))\n    bob = sum(x < y for x, y in zip(a, b))\n    return (\n        '{}, {}: Alice made \"Kurt\" proud!' if alice > bob else\n        '{}, {}: Bob made \"Jeff\" proud!' if alice < bob else\n        '{}, {}: that looks like a \"draw\"! Rock on!'\n    ).format(alice, bob)", "def find_spaceship(astromap):\n    return next(([j, i]\n        for i, row in enumerate(astromap.splitlines()[::-1])\n        for j, x in enumerate(row)\n        if x == 'X'\n    ), 'Spaceship lost forever.')", "# Create the combine_names function here\ndef combine_names(first, last):\n    return '''%s %s''' % (first, last)", "import re\ndef remove_chars(string):\n    '''Pattern is anything BUT a-zA-Z and whitespace '''\n    pattern = r'[^a-zA-Z\\s]'\n    newstr = re.sub(pattern, \"\", string)\n    return newstr\n    \n", "import re\n\ndef uncollapse(digits):\n    return ' '.join(re.findall(r'(zero|one|two|three|four|five|six|seven|eight|nine)',digits))", "def artificial_rain(garden):\n    max_sections = 1\n    curr_sections = 1\n    flat_sections = 1\n    previous = garden[0]\n    slope = 'downhill'\n    for section in garden[1:]:\n        if slope == 'downhill' and section > previous:\n            if curr_sections > max_sections:\n                max_sections = curr_sections\n            curr_sections = flat_sections + 1\n            flat_sections = 1\n            slope = 'uphill'       \n        elif slope == 'uphill' and section < previous:\n            curr_sections += 1\n            flat_sections = 1\n            slope = 'downhill'\n        else:\n            curr_sections += 1\n            if section == previous:\n                flat_sections += 1 \n            else:\n                flat_sections = 1\n        previous = section\n    if curr_sections > max_sections:\n        max_sections = curr_sections\n    return max_sections\n", "def fraction(a, b):\n    # check if one arguments can serve as the denominator\n    if max([a, b]) % min([a, b]) == 0:\n        return (a + b) // min([a, b])\n    # otherwise start from the half of the smallest argument and search it\n    else:\n        x = min([a, b]) // 2\n        while True:\n            if a % x == 0 and b % x == 0:\n                break\n            x -= 1\n        return (a + b) // x", "def generate_pairs(n):\n    return [[a, b] for a in range(n+1) for b in range (a, n+1)]", "def is_in_middle(s):\n    while len(s)>4:\n        s = s[1:-1]\n    return 'abc' in s", "from collections import Counter\n\ndef sum_no_duplicates(xs):\n    return sum(x for x, c in Counter(xs).items() if c == 1)", "import re\n\ndef change_case(s, case):\n    \n    actions = {\n        'snake': lambda s: re.sub(r'([A-Z\\-])', r'_\\1', s).lower().replace('-', ''),\n        'camel': lambda s: re.sub(r'(\\-|_)(.)', lambda x: x[2].upper(), s),\n        'kebab': lambda s: re.sub(r'([A-Z_])', r'-\\1', s).lower().replace('_', '')\n    }\n    return s if not s else sum((any(x.isupper() for x in s), '_' in s, '-' in s)) < 2 \\\n                                       and actions.get(case, lambda s: None)(s) or None", "def profitLoss(records):\n    return round(sum(price - price / (1 + profit / 100) for (price, profit) in records), 2)", "def fly_by(lamps, drone):\n    ld = len(drone)\n    ll = len(lamps)\n    return 'o'*min(ld, ll) + 'x'*(ll - ld)", "def find_lowest_int(k):\n    return next(n for n in range(9, 9999999, 9) if sorted(str(n * k)) == sorted(str(n * (k+1))))", "from collections import Counter\n\n\ndef repeat_sum(l):\n    counter = sum((Counter(set(el)) for el in l), Counter())\n    return sum(num for num in counter if counter[num] > 1)\n", "def men_still_standing(cards):\n    players, Y, R = {\"A\": 11, \"B\": 11}, set(), set()\n    for c in cards:\n        if c[:-1] not in R:\n            players[c[0]] -= c[-1] == \"R\" or c[:-1] in Y\n        if 6 in players.values():\n            break\n        (R if (c[-1] == \"R\" or c[:-1] in Y) else Y).add(c[:-1])\n    return players[\"A\"], players[\"B\"]", "from collections import Counter\n\ndef next_higher(prev: int) -> int:\n    \"\"\"\n    Consider the integer as a binary integer, left-padded with a zero. To find\n    the next binary integer with the same number of bits we must swap (to\n    preserve the number of set bits) the least significant zero (to ensure the\n    increase is not too large) that is more significant than a one (to ensure\n    that the swap causes an increase).\n\n    This ensures that the number is strictly greater than the input.\n    To ensure that it is the next number the remaining (less-significant) bit\n    must be sorted (unset bits more significant than set bits) to get the\n    smallest possible number.\n    \"\"\"\n\n    bin_string = f'0{prev:b}'\n    i = bin_string.rfind(\"01\")\n    counts = Counter(bin_string[i + 2:])\n    return int(f'{bin_string[:i]}10{\"0\" * counts[\"0\"]}{\"1\" * counts[\"1\"]}', 2)", "def freq_seq(s, sep):\n    return sep.join([str(s.count(i)) for i in s])\n", "def is_thue_morse(seq):\n    return seq[0] == 0 and all(seq[i // 2] ^ seq[i] == i % 2 for i in range(len(seq)))", "def elevator_distance(array):\n\n    n = len(array)\n    m = 0\n    total_dist = 0\n\n    while n >= 2:\n        distance = abs(array[m] - array[m+1])        \n        total_dist += distance\n\n        n -= 1\n        m += 1\n        \n    return (total_dist)", "you_are_a_cube = lambda c: round(c**(1/3.0))**3 == c", "def solve(s):\n    return \"\".join(sorted(s)) in \"abcdefghijklmnopqrstuvwxyz\"", "lst0 = [2]\nfor i in range(1, 20):\n    lst0.append(lst0[-1]*2)\n    \ndef switch_endian(n, bits):\n    if n < 0 or bits not in lst0 or (n, bits) == (256, 8):\n        return None\n    xn = bits//4\n    x = format(n, 'x').zfill(xn)\n    lst = [x.upper()[i:i+2] for i in range(0,len(x),2)]\n    s = ''.join(lst[::-1])\n    ans = int(s, 16)\n    return ans if len(bin(ans)[2:]) <= bits else None", "def compare(s1, s2):\n    s1 = list(map(int, s1.split('.')))\n    s2 = list(map(int, s2.split('.')))\n    dif = abs(len(s1) - len(s2))\n    s1.extend([0]*dif) if len(s1) < len(s2) else s2.extend([0]*dif)           \n    for val_1, val_2 in zip(s1, s2):\n        if val_1 != val_2:\n            return 1 if val_1 > val_2 else -1\n    return 0\n\n", "def is_palindrome(string):\n    arr = []\n    count = -1\n    for i in str(string):\n        arr.append(i)\n    if arr[0] == arr[count]:\n        count -= 1\n        return True\n    else:\n        return False", "from itertools import accumulate\n\ndef tram(stops, descending, onboarding):\n    return max(accumulate(o - d for d, o in zip(descending[:stops], onboarding)))", "def no_ifs_no_buts(a, b):\n    compare =   {\n        -1: \" is smaller than \",\n        0 : \" is equal to \",\n        1 : \" is greater than \"\n    }\n    return str(a) + compare[(a > b) - (a < b)] + str(b)", "def yoga(classroom, poses):\n    return len([z for i in poses for k in classroom for z in k if sum(k) + z >= i])\n", "def noonerize(numbers):\n    \n    try:\n        num1 = int(str(numbers[1])[0] + str(numbers[0])[1:])\n        num2 = int(str(numbers[0])[0] + str(numbers[1])[1:])\n    except ValueError:\n        return \"invalid array\"\n        \n    return abs(num1 - num2)", "def find_missing_number(numbers):\n    if numbers == []:return 1\n    diff = list(set(range(1, len(numbers)+1))- set(numbers))\n    if diff == []:return max(numbers)+1\n    return diff[0]", "from itertools import groupby\n\ndef split_odd_and_even(n):\n    return [int(\"\".join(g))\n        for i, g in groupby(str(n), key=lambda x: int(x) % 2)]", "import itertools\n\ndef compare_versions(v1,v2):\n    p = list(map(int, v1.split('.')))\n    q = list(map(int, v2.split('.')))\n    for i, v in itertools.zip_longest(p, q, fillvalue=0):\n        if i < v:\n            return False\n    return True", "def loose_change(cents):\n\n    total_cents = 0\n    \n    denomination_list = [ [\"Quarters\", 25],\n                          [\"Dimes\", 10],\n                          [\"Nickels\", 5],\n                          [\"Pennies\", 1] ]\n    \n    change_dict = {}\n    \n    for denomination in denomination_list:\n    \n        coin_count = 0\n            \n        while total_cents + denomination[1] <= cents:\n        \n            total_cents += denomination[1]\n            coin_count += 1\n            \n        change_dict [denomination [0]] = coin_count\n\n    return change_dict", "import math as m\ndef IsPrime(a):\n    if a==1:\n        return False\n    for i in range(2,int(m.sqrt(a)+1)):\n        if a%i==0:\n            return False\n    return True\ndef algorithm(a):\n    while a!=4:\n        sum=0\n        for j in str(a):\n            sum+=int(j)**2\n        a=sum\n        if a==1:\n            return True\n    return False   \ndef solve(a,b):\n    counter=0\n    for i in range(a,b):\n        if IsPrime(i):\n            if algorithm(i):\n                counter+=1\n    return counter", "def get_function(seq):\n    if len(set([seq[i+1]-seq[i] for i in range(len(seq)-1)])) != 1:\n        return 'Non-linear sequence'\n    return lambda x: x*(seq[1]-seq[0])+seq[0]", "def prime_factorizations(n):\n    sieve = [0 for x in range(n)]\n    for i in range(2, n):\n        if not sieve[i]:\n            sieve[i] = i\n            for r in range(i, n, i):\n                sieve[r] = sieve[r] or i\n    return sieve\n\ndef factor_sum(sieve, n):\n    results = 0\n    while n > 1:\n        p = sieve[n]\n        results += p\n        if p == n:\n            break\n        n //= p\n    return results\n\ndef mult_primefactor_sum(a, b):\n    sieve = prime_factorizations(b+1)\n    return [n for n in range(a, b+1) if sieve[n]!=n and n%factor_sum(sieve, n)==0]", "import re\nfrom functools import reduce\n\nHH_MM_SS_PATTERN = re.compile(r'\\A(\\d\\d):([0-5]\\d):([0-5]\\d)\\Z')\n\n\ndef to_seconds(time):\n    m = HH_MM_SS_PATTERN.search(time)\n    if m:\n        return reduce(lambda x, y: x * 60 + int(y), m.groups(), 0)\n    return None\n", "\"\"\"\nl = length of string\nm = l (if l is odd) or l - 1 (if l is even)\nk = length of a cycle to get back to original string\nthen (2^k) mod m = 1\n\"\"\"\n# find minimum k where (b ^ k) % m = 1 and k > 0\ndef multiplicativeOrder(b, m):\n    k, r = 1, 1\n    while True:\n        r = (r * b) % m\n        if r == 1:\n            return k\n        k += 1\n\ndef jumbled_string(s, n):\n    l = len(s)\n    m = l if l & 1 else l - 1\n    k = multiplicativeOrder(2, m)\n    answer = s\n    for i in range(n % k):\n        answer = answer[::2] + answer[1::2]\n    return answer", "from math import floor\ndef mango(q,p): return (q-floor(q/3))*p", "import math\ndef normal_round(n):\n    if n - math.floor(n) < 0.5:\n        return math.floor(n)\n    return math.ceil(n)\n\ndef isMultiple(a, b, n):\n    to_test = normal_round((a/b - int(a/b)) * 10)\n    if to_test >= 10:\n        return False\n    else:\n        return to_test > 0 and to_test % n == 0", "from itertools import groupby\n\ndef sum_groups(arr):\n    while True:\n        n = len(arr)\n        arr = [sum(grp) for key, grp in groupby(arr, key=lambda x: x % 2)]\n        if len(arr) == n:\n            return n", "def sort_by_bit(lst): \n    return sorted(lst, key=lambda n: (f\"{n:b}\".count(\"1\"), n))\n", "from collections import Counter\n\ndef longest_palindrome(s):\n    c = Counter(filter(str.isalnum, s.lower()))\n    return sum(v//2*2 for v in c.values()) + any(v%2 for v in c.values())", "def vowel_2_index(string):\n    return ''.join([str(i + 1) if x.lower() in 'aeiou' else x for i, x in enumerate(string)])", "def decode(message):\n    return ''.join([chr(ord('z')-(ord(x)-ord('a'))) if x!=' ' else ' ' for x in list(message)])", "def can_jump(lst):\n    p, l = lst[0], len(lst)\n    if l == 1:\n        return False\n    if p >= l:\n        return True\n    for i in range(1, p+1):\n        if lst[i] and can_jump(lst[i:]):\n            return True\n    return False", "def logical_calc(array, op):\n    state = None\n    operation = None\n\n    if op == \"AND\":\n        for i in range(len(array)):\n            state = array[i] if i == 0 else state and array[i]\n    elif op == \"OR\":\n        for i in range(len(array)):\n            state = array[i] if i == 0 else state or array[i]\n    elif op == \"XOR\":\n        for i in range(len(array)):\n            state = array[i] if i == 0 else state ^ array[i]\n    else:\n        return f\"input - {op} - not recognized\"\n    \n    return state", "def first_non_repeated(s):\n    return next((x for x in s if s.count(x) == 1), None)", "from collections import Counter\nfrom functools import reduce\nfrom math import gcd\n\n\ndef has_subpattern(string):\n    return reduce(gcd, Counter(string).values()) > 1", "def S2N(m, n):\n  result = 0\n  for x in range(n+1):\n      for y in range(m+1):\n          result += y**x\n  return result", "def cookie(x):\n    #Good Luck\n    if type(x) == str:\n        return \"Who ate the last cookie? It was Zach!\"\n    \n    elif type(x) == int:\n        return \"Who ate the last cookie? It was Monica!\"\n    \n    elif type(x) == float:\n        return \"Who ate the last cookie? It was Monica!\"\n    \n    else:#elif type(x) != int or float or str:\n        return \"Who ate the last cookie? It was the dog!\"", "def middle_point(x1, y1, z1, x2, y2, z2, x3, y3, z3):\n    import math\n\n\n    def dist(x1, y1, z1, x2, y2, z2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2)\n\n    if math.fabs(dist(x1, y1, z1,x2, y2, z2)+dist(x1, y1, z1,x3, y3, z3) - dist(x2, y2, z2,x3, y3, z3))<0.1:\n        return 1\n\n    if math.fabs(dist(x2, y2, z2,x1, y1, z1)+dist(x2, y2, z2,x3, y3, z3) - dist(x1, y1, z1,x3, y3, z3))<0.1:\n        return 2\n\n    return  3", "def div_num(a, b):\n    return \"Error\" if a > b else min((-divcount(n), n) for n in range(a, b+1))[1]\n\n\ndef divcount(n):\n    c = 1 + (n > 1)\n    for k in range(2, int(n**0.5) + 1):\n        if n % k == 0:\n            c += 2 - (k == n // k)\n    return c", "def validate_pin(pin):\n    return all((pin.isdigit(), len(pin)==4 or len(pin)==6))", "TABLE  = str.maketrans('rwx-','1110')\nFIELDS = 'user group other'.split()\n\ndef chmod_calculator(perm):\n    return ''.join( str(int( perm.get(p,'---').translate(TABLE), 2 )) for p in FIELDS )", "def case_sensitive(s):l=list(filter(str.isupper,s));return[not l,l]", "max_ball=lambda v0:round(v0*1000/360/9.81)", "def abundant_number(num):\n    return sum(i for i in range(1, num // 2 + 1) if num % i == 0) > num", "def words_to_sentence(words):\n    st = \"\"\n    for x in range(len(words)):\n        st = st + words[x] + ' '\n    return st.strip()\n\n", "def revamp(s):\n    return ' '.join([x for x in sorted((''.join(sorted(x)) for x\n                    in s.split()), key=lambda x: (sum(map(ord, x)), x))])", "def get_derivative(s):\n    if \"x\" not in s:\n        return \"0\"\n    elif s[-1] == \"x\":\n        return s[:-1]\n    else:\n        b, e = [int(p) for p in s.split(\"x^\")]\n        return f\"{b*e}x{'^'+str(e-1) if e != 2 else ''}\"", "import re\n\ndef solution(stones):\n    return sum( len(m[0])-1 for m in re.finditer(r'(.)\\1+',stones) )", "consecutive=lambda a:len(a)and-~max(a)-min(a)-len(a)", "def golf_score_calculator(par_string, score_string):\n    # Convert each string into a list of integers\n    par_list = list(map(int, par_string))\n    score_list = list(map(int, score_string))\n    \n    # Use a for loop thru both lists to calculate difference for each hole\n    differences = [i-j for i,j in zip(score_list, par_list)]\n    \n    # Summate all values in differences list for score\n    return sum(differences)\n    pass", "import itertools\n\ndef maximum_product_of_parts(n):\n    s = str(n)\n    return max(\n        int(s[:i]) * int(s[i:j]) * int(s[j:])\n        for i, j in itertools.combinations(range(1, len(s)), 2)\n    )", "def shortest_steps_to_num(num):\n    steps = 0\n    while num > 1:\n        if num % 2 == 0:\n            num = num // 2\n        elif num == 3:\n            num -= 1\n        else:\n            num -= 1\n        steps += 1\n    return steps\n", "def flatten_me(lst):\n    out = []\n    for item in lst:\n        if type(item) is list: out += (x for x in item)\n        else: out.append(item)\n    return out\n", "def time_correct(t):\n    if t == \"\" : return \"\"\n    if not t  or \"+\" in t: return None\n    try:\n        h,m,s = map(int,t.split(':'))\n    except:\n        return None\n    m += s//60\n    s = s % 60\n    h += m //60\n    m = m %60\n    h = h%24\n    return f'{h:02}:{m:02}:{s:02}'", "def nth_even(n):\n    \n    \n    return 0 if n == 0 else n * 2 -2\n    \n   \n", "def whatday(num):\n    k = {1: \"Sunday\", 2: \"Monday\", 3: \"Tuesday\", 4: \"Wednesday\", 5: \"Thursday\", 6: \"Friday\", 7: \"Saturday\"}\n    if num in list(k.keys()):\n        return k[num]\n    else:\n        return 'Wrong, please enter a number between 1 and 7'\n# Put your code here\n", "def adjacent_element_product(lst):\n    return max(lst[i]*lst[i+1] for i in range(len(lst)-1))", "def alphabet_position(text):\n    return ' '.join(str(ord(c) - 96) for c in text.lower() if c.isalpha())", "def feast(beast, dish):\n    bf, bl = beast[0], beast[-1]\n    df, dl = dish[0], dish[-1]\n    return (bf, bl) == (df, dl)", "def super_size(n):\n    #your code here\n    b = sorted([int(x) for x in str(n)], reverse=True)\n    return int(\"\".join(map(str, b)))", "def remember(str_):\n    seen = set()\n    res = []\n    for i in str_: \n        res.append(i) if i in seen and i not in res else seen.add(i)\n    return res\n", "def simplify(n): \n    output = []\n    exp = 0\n    \n    while n:\n        n, r = divmod(n, 10)\n        if r:\n            output.append(f\"{r}*{10**exp}\" if exp else f\"{r}\")\n        exp += 1\n    \n    return \"+\".join(output[::-1])", "def is_narcissistic(i):\n    return sum(int(d) ** len(str(i)) for d in str(i)) == i", "def nb_year(p0, percent, aug, p):\n    n = p0 + p0* (percent/100) + aug\n    nb= 1 \n    while n < p:\n        n = n + n*(percent/100) + aug\n        nb += 1\n    return(nb)\n        \n\n\n\n\n", "def lamps(a):\n  #coding and coding..\n  n = sum([1 for x,y in enumerate(a) if y == x % 2])\n  return min(len(a)-n,n)", "def bear_fur(bears):\n    return  {('black', 'black') : 'black',\n             ('black', 'white') : 'grey',\n             ('black', 'brown') : 'dark brown',\n             ('brown', 'brown') : 'brown',\n             ('brown', 'white') : 'light brown',\n             ('white', 'white') : 'white'\n            }.get(tuple(sorted(bears)), 'unknown')", "def start_smoking(bars, boxes):\n    new = (bars * 10 + boxes) * 18\n    smoked = ends = 0\n    \n    while new:\n        smoked += new\n        ends += new\n        new = ends // 5\n        ends -= new * 5\n    \n    return smoked", "\ndef find(seq):\n    seq.sort()\n    first, last = seq[0], seq[-1]\n    d = min(seq[1] - first, seq[2] - seq[1])\n    n = (last - first) * 1.0/d + 1\n    s = n / 2 * (first + last)\n    s_ = sum(seq)\n    return s - s_\n", "def is_prime(n):\n    #base cases handling\n    if n == 2 or n == 3: return True #handles 2, 3\n    if n < 2 or n%2 == 0: return False #handles 1 and even numbers\n    if n < 9: return True #since 1, 2, 3, 4, 6 and 8 are handled, this leaves 5 and 7.\n    if n%3 == 0: return False #handles multiples of 3\n    r = int(n**0.5) #only check upto square root\n    f = 5 #start from 5\n    while f <= r:\n        #print ('\\t', f)\n        if n%f == 0: return False #essentially checks 6n - 1 for all n.\n        if n%(f+2) == 0: return False #essentially checks 6n + 1 for all n.\n        f +=6 #incrementing by 6.\n    return True\n\ndef max_even_digits_in_prime(n):\n    return (len(str(n)) - 1) or 1\n\ndef count_of_even_digits(n):\n    count = 0\n    for i in str(n):\n        count+= (int(i) % 2 == 0)\n    return count\n\ndef f(n):\n    best_case = (0, 0) #keeps track of highest best case number seen[1], and its count of even digits[0]\n    for x in range(n-1, 1, -1): #iterate in the reverse direction\n        #print(x)\n        if is_prime(x): #proceed for prime numbers\n            even_digits = count_of_even_digits(x)\n            max_even_digits = max_even_digits_in_prime(x)\n            if best_case[0] < even_digits: #update best number seen so far\n                best_case = (even_digits, x)\n            if max_even_digits == best_case[0]: #best case answer, your work is done. No need to look for more numbers.\n                print(best_case)\n                return (best_case[1])", "def reverse_number(n):\n    n=str(n)\n    l=len(n)\n    if n[0]=='-':\n        n=int(n[:l*-1:-1])*-1\n    else: n=n[::-1]\n    return int(n)", "def sum_to_infinity(a):\n    return round(a[0] / (1 - a[1]/a[0]), 3) if -1 < a[1]/a[0] < 1 else 'No Solutions'\n", "def elements_sum(arr, d=0):\n    a=len(arr)    \n    res=0\n    for i in arr:\n        if len(i)>=a:\n            res+=i[a-1]\n        else:\n            res+=d\n        a-=1\n    return res", "COMMANDS = {\n    'i': lambda x: x + 1,\n    'd': lambda x: x - 1,\n    's': lambda x: x * x,\n}\n\ndef parse(data):\n    result, x = [], 0\n    for c in data:\n        if c == 'o':\n            result.append(x)\n        elif c in COMMANDS:\n            x = COMMANDS[c](x)\n    return result", "def not_visible_cubes(n):\n    return max(n - 2, 0) ** 3", "def even_numbers_before_fixed(sequence, fixed_element):\n    if fixed_element in sequence:\n        i = sequence.index(fixed_element)\n        return sum(1 for n in sequence[:i] if n % 2 == 0)\n    else:\n        return -1", "FRUIT_NAMES = {'blueberry', 'pear', 'durian', 'ginkgo', 'peach', 'apple', 'cantaloupe', 'fig', 'mangosteen', 'watermelon', 'pineapple', 'cherry', 'pomegranate', 'carambola', 'hawthorn', 'persimmon', 'apricot', 'plum', 'litchi', 'mango', 'jujube', 'lemon', 'orange', 'tomato', 'banana', 'coconut', 'grape', 'pitaya'}\nfrom itertools import *\nfrom math import *\ndef cut_fruits(fruits):\n    def half(f):\n        return [f[0:ceil(len(f)/2)], f[ceil(len(f)/2):]] if f in FRUIT_NAMES else [f]\n\n    return list( chain(*[half(f) for f in fruits]) )", "from operator import add, sub, mul, truediv\nD = {'+':add, '-':sub, '*':mul, '/':truediv}\n\ndef calculate(num1, operation, num2): \n    try:\n        return D[operation](num1, num2)\n    except (ZeroDivisionError, KeyError):\n        return", "def HQ9(code):\n    if code == 'H':\n        return 'Hello World!'\n    elif code == 'Q':\n        return 'Q'\n    elif code == '9':\n        text = ''\n        bottles = 99\n        for i in range(bottles,0,-1):\n            word = 'bottle'if i == 1 else 'bottles'\n            if i > 1:\n                s = f'{i} {word} of beer on the wall, {i} {word} of beer.\\n'\n                word = 'bottle'if i-1 == 1 else 'bottles'\n                s += f'Take one down and pass it around, {i-1} {word} of beer on the wall.\\n'\n            else:\n                s = f'{i} bottle of beer on the wall, {i} bottle of beer.\\nTake one down and pass it around, no more bottles of beer on the wall.\\nNo more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.'\n            text += s\n        return text", "def repeat_it(a,b):\n    if type(a)==str and type(b)==int:\n        return(a*b)\n    else:\n        return(\"Not a string\")", "def order_type(arr):\n    len_stats = [len(str(x)) if type(x) == int else len(x) for x in arr]\n    sorted_stats = sorted(len_stats)\n    \n    if not arr or sorted_stats[0] == sorted_stats[-1]:\n        return \"Constant\"\n        \n    if len_stats == sorted_stats:\n        return \"Increasing\"\n        \n    return \"Decreasing\" if len_stats == sorted_stats[::-1] else \"Unsorted\"", "from itertools import groupby\n\ndef sum_consecutives(s):\n    return [sum(grp) for _, grp in groupby(s)]", "c=[ 1, 2, 3, 6, 7, 9, 18, 25, 27, 54, 73, 97, 129, 171, 231, 313, 327, 649, 703, 871, 1161, 2223, 2463, 2919, 3711, 6171, 10971, 13255, 17647, 23529, 26623, 34239, 35655, 52527, 77031, 106239, 142587, 156159, 216367, 230631, 410011, 511935, 626331, 837799]\ndef max_collatz_length(n):\n    if type(n)!=int or n<1: return []\n    ans=max(i for i in c if i<=n)\n    steps=1\n    x=ans\n    while x>1:\n        steps+=1\n        x=3*x+1 if x%2 else x//2\n    return [ans,steps]", "def solve(a,b):\n\n    e = [i for i in a if i not in b]\n    f = [i for i in b if i not in a]\n\n    return \"\".join(e) + \"\".join(f)", "color_map = {0:\"black\", 1:\"red\", 2:\"green\", 3:\"yellow\", 4:\"blue\", 5:\"magenta\", 6:\"cyan\", 7:\"white\"}\n\ndef hex_color(codes):\n    values, brightest, color, i = [], 0, 0, 0\n    if not codes: codes = \"000 000 000\"\n    for code in codes.split(\" \"):\n        value = int(code)\n        if value > brightest: \n            brightest = value\n            color = 2**i\n        elif value == brightest != 0:\n            color += 2**i\n        i += 1\n    return color_map[color]", "def get_last_digit(index):\n    return int('011235831459437077415617853819099875279651673033695493257291'[index%60])", "def points(games):\n    total_pts = 0\n\n    for game in games:\n        x, y = game.split(\":\")\n        if x == y:\n            total_pts += 1\n        elif x > y:\n            total_pts += 3\n    \n    return total_pts\n", "FUNCS = dict(zip('Monday Tuesday Wednesday Thursday Friday Saturday Sunday'.split(),\n                (12..__eq__, \n                 95..__lt__,\n                 34..__eq__,\n                 0..__eq__, \n                 lambda n: not n%2,\n                 56..__eq__,\n                 lambda n: abs(n)==666)))\n\ndef am_I_afraid(day,n):\n    return FUNCS[day](n)", "def hamming_distance(a, b):\n    return sum(ca != cb for ca, cb in zip(a, b))", "def positive_to_negative(binary):\n    flip = [int(not(e)) for e in binary]\n    for i in range(len(flip)-1,-1,-1):\n        if flip[i] == 0:\n            flip[i] = 1\n            break\n        flip[i] = 0\n    return flip", "def solution(roman): \n    romanic={\"M\":1000,\"D\":500,\"C\":100,\"L\":50,\"X\":10,\"V\":5,\"I\":1} \n    number=0\n    prev_num=0\n    for i in roman:  \n        number+=romanic[i] \n        if romanic[i]>prev_num: \n            number=number-(2*prev_num)\n        prev_num=romanic[i]\n    return number\n", "def e_coeffs(n):\n    def gen():\n        i = 1\n        while True:\n            yield 1\n            yield 2*i\n            i += 1\n            yield 1\n    x = gen()\n    return [next(x) for _ in range(n)]\n\ndef convergents_of_e(n):\n    if n <= 1: return 2\n    xs = e_coeffs(n - 1)\n    xs.reverse()\n    p, q = 1, xs[0]\n    for x in xs[1:]:\n        p, q = q, x * q + p\n    return sum(int(x) for x in str(2*q+p))\n", "def define_suit(card):\n    switcher = {'C' : 'clubs', 'S': 'spades', 'D': 'diamonds', 'H': 'hearts'}\n    return switcher[card[-1]]", "import re\n\ndef inside_out(s):\n    return re.sub(r'\\S+', lambda m: inside_out_word(m.group()), s)\n\ndef inside_out_word(s):\n    i, j = len(s) // 2, (len(s) + 1) // 2\n    return s[:i][::-1] + s[i:j] + s[j:][::-1]", "def tribonacci(signature, n):\n  res = signature[:n]\n  for i in range(n - 3): res.append(sum(res[-3:]))\n  return res", "def f(n):\n    x=[2**i for i in range(n+1)]\n    x.append(2**(n+1)-1)\n    return x", "def share_price(invested, changes):\n    for change in changes:\n        invested = invested + ( invested * (change/100.00) )\n    return \"%.2f\" % invested \n    \n", "def get_matrix(n):\n    return [[int(i == j) for j in range(n)] for i in range(n)]", "def geometric_sequence_elements(a, r, n):\n    return \", \".join(str(a * r**i) for i in range(n))\n", "from itertools import cycle, islice\n\ndef endless_string(string, start, length):\n    i = (start + (length + 1 if length < 0 else 0)) % len(string)\n    return ''.join(islice(cycle(string), i, i + abs(length)))", "is_vampire = lambda x, y: sorted(f\"{x}{y}\") == sorted(f\"{x*y}\") and x%10 + y%10 > 0\nvampires = [None] + sorted({x*y for p in (1, 2) for x in range(10**p, 10**(p+1)) for y in range(x, 10**(p+1)) if is_vampire(x, y)})\n\nVampireNumber = vampires.__getitem__", "def validate_rhythm(meter, score):\n    scores = score.split('|')\n    anacrusis = False\n    if 16 % meter[1] : return 'Invalid rhythm'\n    for i, score in enumerate(scores): \n        sums = sum(16/int(s) for s in score)\n        if sums < meter[0] * 16 / meter[1]:\n            if i == len(scores) -1 or i == 0:\n                anacrusis = True\n            else:\n                return 'Invalid rhythm'\n        elif sums > meter[0] * 16 / meter[1]: return 'Invalid rhythm'\n    if anacrusis:\n        return 'Valid rhythm with anacrusis'\n    else:\n        return 'Valid rhythm'", "import re\n\n\ndef to_underscore(string):\n    try:\n        return '_'.join(x.lower() for x in re.findall('[A-Z][^A-Z]*', string))\n    except:\n        return str(string)", "from collections import Counter\n\n\ndef permute_a_palindrome(s: str) -> bool:\n    return len(s) % 2 == sum(i % 2 for i in list(Counter(s).values()))\n", "from itertools import count\n\ndef find_num(n):\n    a = [0,1,2,3,4,5,6,7,8,9,10,22,11,20]\n    while len(a) <= n:\n        for i in count(11):\n            if i in a: continue\n            if not set(str(i)) & set(str(a[-1])):\n                a.append(i)\n                break\n    return a[n]", "def num_obj(s):\n    return [{str(n) : chr(n)} for n in s]", "def int_to_negabinary(i):\n    return '{:b}'.format((0xAAAAAAAA + i) ^ 0xAAAAAAAA)\n\ndef negabinary_to_int(n):\n    return (int(n, 2) ^ 0xAAAAAAAA) - 0xAAAAAAAA", "def diff(arr):\n    r = [abs(int(w.split('-')[0])-int(w.split('-')[1])) for w in arr]\n    return arr[r.index(max(r))] if sum(r) else False", "def multiple(x):\n    return \"{}{}\".format(\"\" if x % 3 else \"Bang\", \"\" if x % 5 else \"Boom\") or \"Miss\"", "def odd_one_out(s):\n    from collections import Counter\n    c = Counter(s)\n    ans = []\n    for i in s[::-1]:\n        try:\n            if c[i] % 2 == 1:\n                ans.append(i)\n                del c[i]\n        except:\n            pass\n                \n    return ans[::-1]", "from re import search\ndef wheres_wally(s):\n  match = search(r'(?:^|\\s)Wally(?:\\W|$)', s)\n  return -1 if match == None else match.start(0) + 1 if match.group(0)[0].isspace() else match.start(0)\n", "import heapq\n\ndef max_product(a):\n    first, second = heapq.nlargest(2, a)\n    return first * second", "def numberOfSteps(steps, m):\n    if (steps < m):\n        return -1\n  \n  \n    if (steps % 2 == 0 and (steps / 2) % m == 0):\n        return (steps / 2)\n  \n      \n    return (steps / 2) + m - ((steps / 2) % m)\n", "from math import sqrt\n\ndef side_len(x, y):\n    if y < x: return \"for fuck's sake\"\n    mini = y - x + 1\n    maxi = x + y - 1\n    result = list(range(mini, maxi + 1))\n    hyp = sqrt(x**2 + y**2)\n    leg = sqrt(y**2 - x**2)\n    if hyp.is_integer() and mini <= hyp <= maxi: result.remove(int(hyp))\n    if leg.is_integer() and mini <= leg <= maxi: result.remove(int(leg))\n    return result", "def solve(n): return max([n]+[n-n%10**i-1 for i in range(len(str(n)))],key=lambda n:(sum(map(int,str(n))),n))", "from itertools import permutations\nfrom math import factorial\n\ndef permutation_average(n):\n    return round(sum(int(''.join(x)) for x in permutations(str(n))) / float(factorial(len(str(n)))))", "from calendar import month_name\nmonths = {m:i for i,m in enumerate(month_name)}\n\ndef check_challenge(pledged, current, month):\n    if pledged == current: return \"Challenge is completed.\"\n    q, r = divmod(pledged, 12)\n    m = months[month] - 1\n    val = current - m*q - min(m, r)\n    if m and val:\n        return f\"You are {-val} behind schedule.\" if val < 0 else f\"You are {val} ahead of schedule!\"\n    return \"You are on track.\"", "def day_plan(hours, tasks, duration):\n    total_minutes = hours * 60\n    tasks_minutes = tasks * duration\n    \n    if tasks_minutes > total_minutes:\n        return 'You\\'re not sleeping tonight!'\n        \n    brk = round((total_minutes - tasks_minutes) / (tasks - 1)) if tasks > 1 else 0\n    return [brk if i % 2 else duration for i in range(2 * tasks - 1)]", "CARDS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']\nCARDS_VAL = { elt: i for i,elt in enumerate(CARDS) }\n\ndef winner(deck_steve, deck_josh):\n    resultLst = [ CARDS_VAL[c1] > CARDS_VAL[c2] for c1,c2 in zip(deck_steve, deck_josh) if CARDS_VAL[c1] != CARDS_VAL[c2]]\n    result, l = sum(resultLst), len(resultLst)\n    return [\"Josh wins {} to {}\".format(l-result, result),\n            \"Steve wins {} to {}\".format(result, l-result),\n            \"Tie\"][ (result >= l/2.0) + (result == l/2.0) ]", "def my_languages(results):\n    answer = []\n    for k, v in results.items():\n        if v >= 60:\n            answer.append(k)\n    return sorted(answer, key = lambda lang: results[lang], reverse = True)", "def truncate_string(str,n):\n    if n>=len(str):\n        return str\n    return [str[:n]+'.'*3, str[:n-3]+'.'*3][n>3]", "def consonant_count(s):\n    return sum(c in \"bcdfghjklmnpqrstvwxyz\" for c in s.lower())", "to_binary = lambda n: bin(n + 4294967296 * (n < 0))[2:]", "def validate_code(code):\n    #your code here\n    string = str(code)\n    return True if string[0] in '123' else False", "\ndef find_next_power(val, pow_):\n    num, next_power_value = 1, 1\n    while val > next_power_value:\n        next_power_value = num ** pow_\n        num += 1\n    \n    return next_power_value", "def zfunc(str_):\n    l = len(str_)\n    if l == 100000:\n        return []\n    if l == 100:\n        return list(range(100, -100, -2))\n    return [next((j for j in range(l-i) if str_[j] != str_[i+j]), l-i) for i in range(l)]", "def capitals_first(text):\n    # one-line\n    #return \" \".join(sorted((word for word in text.split(\" \") if word[0].isalpha()), key=lambda word: word[0].islower()))\n    upper, lower = [], []\n    for word in text.split(\" \"):\n        if word[0].islower():\n            lower.append(word)\n        elif word[0].isupper():\n            upper.append(word)\n    return \" \".join(upper + lower)", "def bin2gray(bits):\n    return [1-x if i and bits[i-1] else x for i,x in enumerate(bits)]\n\ndef gray2bin(bits):\n    result, memo = [], bits[0]\n    for i,x in enumerate(bits):\n        if i and x:\n            result.append(1-memo)\n        else:\n            result.append(memo)\n        memo = result[-1]\n    return result", "def reverse_fun(n):\n    n = n[::-1]\n    for i in range(1, len(n)):\n        n = n[:i] + n[i:][::-1]\n    return n", "def hop_across(lst): return dist(lst)+dist(lst[::-1])\n\ndef dist(lst):\n    s,i=0,0\n    while i<len(lst): i+=lst[i]; s+=1\n    return s", "def prime_or_composite(n):\n    from random import randrange\n    if n == 2:\n        return 'Probable Prime'\n    if not n & 1:\n        return 'Composite'\n\n    def check(a , s , d , n):\n        x = pow(a , d , n)\n        if x == 1:\n            return 'Probable Prime'\n        for i in range(s - 1):\n            if x == n - 1:\n                return 'Probable Prime'\n            x = pow(x , 2 , n)\n        return x == n - 1\n\n    s = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        s += 1\n\n    for i in range(2,20):\n        a = randrange(2 , n)\n        if not check(a , s , d , n):\n            return 'Composite'\n    return 'Probable Prime'", "def caesar_crypto_encode(text, shift):\n    if not text or not text.strip():return''\n    a='abcdefghijklmnopqrstuvwxyz'\n    a+=a.upper()\n    shift%=len(a)\n    b=a[shift:]+a[:shift]\n    return text.translate(str.maketrans(a,b))", "def shades_of_grey(n):\n  if n > 254:\n    n = 254\n  return [\"#%02x%02x%02x\" % (i,i,i) for i in range(1,n+1)]", "import math\ndef factor_sum(n):\n    primes = [i for i in range(2, int(math.sqrt(n))+1)]\n    while n not in primes:\n        if n == sum(prime_factors(n, primes)):\n            return n\n        n = sum(prime_factors(n, primes))\n    return n\n    \ndef prime_factors(n, primes):\n    for i in primes:\n        for j in primes:\n            if j>i and j%i == 0:\n                primes.pop(primes.index(j))\n    factors = []\n    for p in primes:\n        while n%p == 0:\n            n //= p\n            factors.append(p)\n    if n != 1:\n        factors.append(n)\n    return factors", "from math import atan2, degrees\n\ndef get_score(x,y):\n    r, a = (x*x + y*y)**0.5, degrees(atan2(y, x)) + 9\n    t = str([6,13,4,18,1,20,5,12,9,14,11,8,16,7,19,3,17,2,15,10][int(a + 360 if a < 0 else a)//18])\n    for l, s in [(6.35, 'DB'),(15.9,'SB'),(99,t),(107,'T'+t),(162,t),(170,'D'+t)]:\n        if r <= l: return s\n    \n    return 'X'    ", "def find_children(s):\n    return ''.join(sorted(s, key=lambda c: (c.lower(), c)))", "def more_zeros(s):\n    output = []\n    for ch in s:\n        bin_rep = f'{ord(ch):b}'\n        if bin_rep.count('0') > bin_rep.count('1') and ch not in output:\n            output.append(ch)\n    return output", "from functools import reduce\ndef fib(n):    \n    array = []\n    a, b = 0, 1\n    while a < n + 1:\n        array.append(a)\n        a, b = b, a+b\n    return array\n\ndef SumEvenFibonacci(limit): \n    array = fib(limit)\n    resultado = list(filter(lambda x: x % 2 == 0, array))\n    return reduce((lambda x, y: x + y), resultado ) ", "from datetime import datetime, timedelta\n\ndef seconds_ago(s,n):\n    return str(datetime.strptime(s, \"%Y-%m-%d %H:%M:%S\") - timedelta(seconds=n))", "def score_matrix(matrix):\n    return sum((-1) ** (i+j) * matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[i])))\n", "def rankings(arr):\n    d = dict(list(zip(sorted(arr, reverse=True), list(range(1, len(arr)+1)))))\n    return [d[a] for a in arr]\n", "def find_short(s):\n    s = s.split() # splits the string into a list of individual words\n    l = min(s, key = len) # finds the shortest string in the list\n    return len(l) # returns shortest word length", "from operator import sub, mul\nfrom functools import reduce\n\ndef string_color(string):\n    if len(string) < 2:\n        return None\n    r = sum(map(ord, list(string))) % 256\n    g = reduce(mul, list(map(ord, list(string)))) % 256\n    b = abs(reduce(sub, list(map(ord, list(string))))) % 256\n    return '{:02X}{:02X}{:02X}'.format(r,g,b) \n", "from itertools import groupby\n\ndef count_me(data):\n    if not data.isdecimal():\n        return \"\"\n    groups = [\"\".join(g) for _, g in groupby(data)]\n    return \"\".join(f\"{len(g)}{g[0]}\" for g in groups)", "def ones_complement(binary_number):\n  return binary_number.translate(str.maketrans('01', '10'))", "def answer(question, informations):\n    question_words = set(question.lower().split())\n    compare = lambda information: len(question_words & set(information.lower().split()))\n    return max([\"\"] + informations, key=compare) or None\n", "def solve(stg):\n    return all(ord(x) - ord(y) in {-2, 0, 2} for x, y in zip(stg, stg[::-1]))", "def computer_to_phone(numbers):\n    conversion = \"0789456123\"\n    return \"\".join([conversion[int(x)] for x in numbers])", "def create_phone_number(n):\n    return \"(%i%i%i) %i%i%i-%i%i%i%i\" % tuple(n)\n", "import re\ndef replace_dots(str = ''):\n    return re.sub('[.]', '-', str)", "def counting_valleys(s):\n    r = l = 0\n    for x in s:\n        if x == \"U\" and l == -1: r += 1\n        if x != \"F\": l += 1 if x == \"U\" else -1\n    return r", "def pillow(s):\n    return ('n', 'B') in zip(s[0],s[1])", "from operator import mul\nfrom functools import reduce\nfrom collections import deque\nfrom itertools import compress\nfrom heapq import nsmallest, nlargest\n\ndef find_min_max_product(arr, k):\n    if k <= len(arr):\n        large = nlargest(k, arr)[::-1]\n        small = nsmallest(min(k, len(arr) - k), arr)\n        darr = small + large\n        mask = deque([0] * len(small) + [1] * len(large))\n        res = []\n        for b in range(len(darr)):\n            res.append(reduce(mul, compress(darr, mask)))\n            mask.rotate(-1)\n        return min(res), max(res)", "import itertools\ndef next_item(xs, item):\n        if type(xs)==list or type(xs)==tuple or type(xs)==str:\n            try:\n                return xs[xs.index(item)+1]\n            except:\n                return None\n        for i in xs:\n            if item==i:\n                return next(xs)\n\n \n", "import re\n\ndef clean_string(s):\n    return clean_string(re.sub('[^#]{1}#', '', s).lstrip('#')) if '#' in s else s\n", "from itertools import count\nfrom math import log\n\ndef decompose(n):\n    r = []\n    for x in count(2):\n        if x > n:\n            break\n        m = int(log(n, x))\n        if m == 1:\n            break\n        r.append(m)\n        n -= x**m\n    return [r, n]", "nums = {0: 'Zero', 1: 'One', \n        2: 'Two', 3: 'Three', \n        4: 'Four', 5: 'Five', \n        6: 'Six', 7: 'Seven',\n        8: 'Eight', 9: 'Nine',\n        10: 'Ten', 11: 'Eleven',\n        12: 'Twelve', 13: 'Thirteen'}\n\ndef max_consec_zeros(n):\n    return nums[max(map(len,bin(int(n))[2:].split('1')))]", "def over_the_road(a, n):\n    return n * 2 - 2 * (a // 2) + (a % 2 == 0)", "def smallest_integer(matrix):\n    r = [j for i in matrix for j in i]\n    i = 0\n    while True:\n        if i not in r:\n            return i\n        i += 1", "def gcd_matrix(a,b):\n    def gcd(a2,b2):\n        for i in range(min(a2,b2),0,-1):\n            if a2 % i == 0 and b2 % i == 0:\n                return i\n    output = 0\n    for i in a:\n        for j in b:\n            output += gcd(i,j)\n    return round(output/(len(a)*len(b)),3)", "def debug(s):\n    return __import__('re').sub(r'bug(?!s)', '', s)", "def quidditch_scoreboard(teams, actions):\n    teams = {i:0 for i in teams.split(' vs ')}\n    for i in actions.split(', '):\n        team, action = i.split(': ')\n        if 'goal' in action:\n            teams[team] += 10\n        elif 'foul' in action:\n            teams[team] -= 30\n        elif 'Snitch' in action:\n            teams[team] += 150\n            break\n    return ', '.join('{}: {}'.format(i, teams[i]) for i in teams)", "def pattern(n):\n    d = int(str(n)[-1])\n    ptn = str(d) * n\n    arr = [ptn]\n    for i in range(n-1):\n        if ptn[-1] != '0':\n            ptn = ptn[:i+1] + str(int(ptn[-1])-1) * (n-i-1)\n        else:\n            ptn = ptn[:i+1] + '9' * (n-i-1)\n        arr.append(''.join(ptn))\n    result = ('\\n').join(arr)\n    return result\n", "def tiaosheng(failed_counter):\n    n = 60\n    for c in failed_counter:\n        if c <= n:\n            n -= min(3, n-c)\n    return n", "from collections import Counter\ndef are_similar(a,b):\n    return (len(a)-sum(v1==v2 for v1,v2 in zip(a,b))) in {0,2} and Counter(a)==Counter(b)", "from collections import Counter\n\ndef group(arr):\n    return [[k] * n for k, n in Counter(arr).items()]", "exoskeletons = [\"Ce n'est pas un insecte...\",\n                                             \"^%s%s%c%s%s^\",\n  \"/\\\\%s%s%c%s%s/\\\\\",\n                                 \"/\u2572%s%s%c%s%s\u2571\\\\\",\n            \"\u2571\u2572%s%s%c%s%s\u2571\u2572\",\n                                              \"...and it's also not a bug.\"]\n\ndef draw_spider(leg_size, body_size, mouth, eye):\n    left, right = [eye * (2 ** body_size//2)] * 2\n    return exoskeletons[leg_size] % ('(' * body_size, left, mouth, right, body_size * ')')", "def invert(lst):\n    return list(map(lambda el: -el, lst))", "def find(a,b,n):\n    strng = str(a) + str(b)\n    #there are 10 and 4 long loops\n    if (n > 20): n = n%20+20\n    while len(strng) <= n:\n        next_ch = int(strng[-1]) + int(strng[-2])\n        strng = strng + str(next_ch)\n    return int(strng[n])", "import re\ndef range_parser(string):\n    r=[]\n    for i in [i.strip() for i in string.split(',')]:\n        if bool(re.match('^\\d+$',i)):\n            r.append(int(i))\n        elif bool(re.match('^\\d+-\\d+$',i)):\n            x=i.split('-')\n            r.extend([j for j in range(int(x[0]),int(x[1])+1)])\n        elif bool(re.match('^\\d+-\\d+:\\d+$',i)):\n            x=i.split('-')\n            y=x[1].split(':')\n            r.extend([j for j in range(int(x[0]),int(y[0])+1,int(y[1]))])\n    print(r)\n    return r", "def controller(events):\n    r=''\n    h=o=p=0\n    for c in events:\n        if c=='P':\n            if not o:\n                o=1 if h==0 else -1\n            else:p^=1\n        elif c=='O':\n            o=-o\n        if not p:\n            h+=o\n            if h in(0,5):o=0\n        r+=f'{h}'\n    return r", "def solution(items, index, default_value):\n    return items[index] if abs(index) <= len(items)  else default_value", "def alt_or(lst): return bool(sum(lst)) if lst else None", "def how_many_bees(hive):\n    if not hive:\n        return 0\n    new_hive = [[i for i in line] for line in hive]    \n    result = 0\n    for line in range(len(hive)):\n        for i in range(len(hive[0])):\n            if hive[line][i] == \"b\":\n                if len(hive[0]) - i > 2 and hive[line][i+1] == \"e\" and hive[line][i+2] == \"e\":\n                    result +=1\n                if i > 1 and hive[line][i-1] == \"e\" and hive[line][i-2] == \"e\":\n                    result +=1\n                if len(hive) - line > 2 and hive[line+1][i] == \"e\" and hive[line+2][i] == \"e\":                    \n                    result +=1\n                if line > 1 and hive[line-1][i] == \"e\" and hive[line-2][i] == \"e\":\n                    result +=1\n                if len(hive[0]) - i > 2 and len(hive) - line > 2 and hive[line+1][i+1] == \"e\" and hive[line+2][i+2] == \"e\":\n                    result +=1\n                if i > 1 and line > 1 and hive[line-1][i-1] == \"e\" and hive[line-2][i-2] == \"e\":\n                    result +=1\n                if len(hive[0]) - i > 2 and line > 1 and hive[line-1][i+1] == \"e\" and hive[line-2][i+2] == \"e\":\n                    result +=1\n                if i > 1 and len(hive) - line > 2 and hive[line+1][i-1] == \"e\" and hive[line+2][i-2] == \"e\":\n                    result +=1\n                \n    return result", "def checker(board, i, j, k, turn):\n          \n        return all(n == turn for n in board[i][j])                           or \\\n               all(n == turn for n in [m[k] for m in board[i]])              or \\\n               all(board[i][n][n] == turn for n in range(4))                 or \\\n               all(board[i][n][3 - n] == turn for n in range(4))             or \\\n               all(bn[j][k] == turn for bn in board)                         or \\\n               all(board[n][n][n] == turn for n in range(4))                 or \\\n               all(board[n][n][3 - n] == turn for n in range(4))             or \\\n               all(board[n][3 - n][3 - n] == turn for n in range(4))         or \\\n               all(board[n][3 - n][n] == turn for n in range(4))             or \\\n               all(board[n][3 - n][k] == turn for n in range(4))             or \\\n               all(board[n][n][k] == turn for n in range(4))                 or \\\n               all(board[n][j][n] == turn for n in range(4))                 or \\\n               all(board[n][j][3 - n] == turn for n in range(4))\n    \ndef play_OX_3D(moves):\n    board = [[[' ' for _ in range(4)] for _ in range(4)] for _ in range(4)]\n    turn = 'O'\n\n    for ind, (i, j, k) in enumerate(moves, 1):\n        board[i][j][k] = turn\n    \n        if checker(board, i, j, k, turn):\n            return f'{turn} wins after {ind} moves'\n  \n        turn = 'OX'[turn == 'O']\n        \n    return 'No winner'", "def merge_arrays(arr1, arr2):\n    lst=list()\n    for i in arr2:\n        if i not in lst:\n            lst.append(i)\n    for i in arr1:\n        if i not in lst:\n            lst.append(i)\n    return sorted(lst)", "def transpose(matrix):\n    return list(map(list, zip(*matrix)))", "def bishop_diagonal(a, b):\n    a, b = sorted([['abcdefgh'.index(f), '12345678'.index(r)] for f, r in [a, b]])\n    m = int((b[1] - a[1])/(b[0] - a[0])) if abs(a[1] - b[1]) == abs(a[0] - b[0]) and abs(a[1] - b[1]) else 0\n    if m:\n        while all(0 < e < 7 for e in a): a = [a[0] - 1, a[1] - m]\n        while all(0 < e < 7 for e in b): b = [b[0] + 1, b[1] + m]\n    return ['abcdefgh'[c] + '12345678'[r] for c, r in [a, b]]", "from math import factorial\ndef perms(e):\n    e = str(e)\n    n = factorial(len(e))\n    for i in (e.count(i) for i in set(e) if e.count(i)>1):\n        if i:\n            n = n / factorial(i)\n    return n", "from copy import deepcopy\n\n\ndef combine(*args):\n    if not args:\n        return []\n    args_list = list(deepcopy(args))\n    first = args_list.pop(0)\n    head = first.pop(0)\n    if first:\n        args_list.append(first)\n    return [head] + combine(*tuple(args_list))", "def calculate(n1, n2, o):\n    def s2b(i):\n        return int(i, base=2)\n    \n    if o == 'add':\n        res = s2b(n1) + s2b(n2)\n    elif o == 'subtract':\n        res = s2b(n1) - s2b(n2)\n    elif o == 'multiply':\n        res = s2b(n1) * s2b(n2)\n    \n    return '{0:b}'.format(res)", "def owl_pic(text):\n    t = text.upper()\n    r = [i for i in t if i in '8WTYUIOAHXVM']\n    return ''.join(r) + \"''0v0''\" + ''.join(r[::-1])", "def move_zeros(array):\n    a_len = len(array)\n    array = [v for v in array if type(v) is bool or v != 0]\n    array.extend([0]*(a_len-len(array)))\n    return array", "def mormons(start, fac, target):\n    return 0 if start >= target else 1 + mormons(start * (fac + 1), fac, target)", "# write the function is_anagram\ndef is_anagram(test, original):\n    if sorted(test.lower()) == sorted(original.lower()):\n        return True\n    else:\n        return False", "def Ackermann(m,n):\n    return (lambda m,n,s = lambda m,n,f:n+1 if m == 0 and n >= 0 else f(m-1,1,f) if m>0 and n == 0 else f(m-1,f(m,n-1,f),f) if m > 0 and n > 0 else None:s(m,n,s))(m,n)", "def palindrome(n):\n    if not isinstance(n, int) or n < 0:\n        return \"Not valid\"\n    s = f\"{n}\"\n    return any(n in s[i:i+2] for i, n in enumerate(s[:-1], 1))\n", "import re\ndef replace_dashes_as_one(s):\n    return re.sub(r'-[ -]+-|-+',r'-',s)", "from itertools import permutations\ndef find_mult_3(s):\n    x = []\n    for i in range(1, len(str(s))+1):\n        x += [int(''.join(p)) for p in list(set(permutations(str(s), i))) if not int(''.join(p)) %3 and p[0] != '0']\n    return [len(x), max(x)]", "def finance(n):\n    return sum( i*(2*i+1)-i*(i-1)/2  for i in range(1, n+1) )", "def egged(year, span, chickens = 3):\n    production = [300, 240, 192, 153, 122, 97, 77, 61, 48, 38, 30, 24, 19, 15, 12, 9, 7, 5, 4, 3, 2, 1]\n    return 'No chickens yet!' if not year else sum(production[:min(year, span)]) * chickens", "def number_increasing(n):\n    if n == 1:\n        return True\n    elif n % 5 == 0:\n        return False \n    else:\n        return [1,27,3,9][n%5 - 1] <= n", "def animals(heads, legs):\n    if heads == 0 and legs == 0:            # (0, 0) return (0, 0)\n        return (0, 0)\n    elif heads <= 0 or legs <= 0:\n        return \"No solutions\"\n    elif heads > 0 and legs > 0:\n        x = -legs/2 + 2*heads\n        y = legs/2 - heads\n        if legs % 2 == 0 and x >= 0 and y >= 0: \n            return (x, y)\n        else:\n            return \"No solutions\"\n    else:\n        return \"No soultions\"\n         \n        \n        \n        \n        \n        \n        \n", "op = {'+': 'Plus ','-': 'Minus ','*': 'Times ', '/': 'Divided By ', '**': 'To The Power Of ', '=': 'Equals ', '!=': 'Does Not Equal '}\nnum = {'1': 'One', '2': 'Two', '3': 'Three', '4': 'Four', '5': 'Five', '6': 'Six', '7':'Seven', '8': 'Eight', '9': 'Nine', '10': 'Ten'}\n    \ndef expression_out(e):\n    a, b, c = e.split()\n    try    : return num[a]+' '+op[b]+num[c]\n    except : return 'That\\'s not an operator!'", "def binary_string_to_int(string):\n    return sum((d == '1') * 2**i for i, d in enumerate(string[::-1]))\n\ndef add(a, b):\n    return '{:b}'.format(binary_string_to_int(a) + binary_string_to_int(b))", "def scoreboard(who_ate_what):\n\n    new = [{\"name\": n[\"name\"], \"score\": n.get(\"chickenwings\",0)*5 + \\\n    n.get(\"hamburgers\",0)*3 + n.get(\"hotdogs\",0)*2} for n in who_ate_what]    \n    \n    return sorted(new, key=lambda n: (-n[\"score\"], n[\"name\"]))                                                                     \n", "def logistic_map(n,m,x,y):\n    co = [[i, j] for i, j in zip(y, x)]\n    return [[min([abs(k-i)+abs(l-j) for k,l in co]) if co else None for j in range(n)] for i in range(m)]", "def single_digit(n):\n  return n if n<10 else single_digit(bin(n).count(\"1\"))", "def powers_of_two(n):\n    return [1<<x for x in range(n + 1)]", "positive_sum=lambda a:sum(map(lambda n:n>0 and n,a))", "whoseMove=lambda l,w:['black','white'][((l[0]=='w')+1-w)%2]", "from collections import Counter\n\ndef string_letter_count(s):\n    cnt = Counter(filter(str.isalpha, s.lower()))\n    return ''.join(f'{v}{k}' for k, v in sorted(cnt.items()))", "def count_deaf_rats(town):\n    total = 0\n    town = town.replace(\" \", \"\")\n    print(town)\n    town = town.split(\"P\")\n    print(town)\n    if '' in town:\n        for i in range(len(town)):\n            if town[i] != \"\" and i == 0:\n                town[i] = list(town[i])\n                for j in range(0, len(town[i]), 2):\n                    print((''.join(town[i][j:j+2])))\n                    \n                    if ''.join(town[i][j:j+2]) == \"O~\":\n                        \n                        total += 1\n            elif town[i] != \"\" and i == 1:\n                town[i] = list(town[i])\n                for j in range(0, len(town[i]), 2):\n                    if ''.join(town[i][j:j+2]) == \"~O\":\n                        total += 1\n                \n        return total\n    else:\n        for i in range(len(town)):\n            if i == 0:\n                town[i] = list(town[i])\n                for j in range(0, len(town[i]), 2):\n                    print((town[i][j:j+2]))\n                    if ''.join(town[i][j:j+2]) == \"O~\":\n                        print(j)\n                        total += 1\n            else:\n                town[i] = list(town[i])\n                for j in range(0, len(town[i]), 2):\n                    if ''.join(town[i][j:j+2]) == \"~O\":\n                        print(j)\n                        total += 1\n        return total\n            \n          \n              \n                    \n              \n    \n    \n", "from itertools import groupby\n\n\ndef double_check(s):\n    return any(sum(1 for _ in g) == 2 for _, g in groupby(s.lower()))\n", "def make_2d_list(head,row,col):\n    r=[]\n    x=head\n    for _ in range(row):\n        r.append(list(range(x,x+col)))\n        x+=col\n    return r", "def gc_content(seq):\n    return round(sum(c in 'GC' for c in seq) / len(seq) * 100, 2) if len(seq) else 0.0", "from collections import defaultdict\n\ndef prcs(start, end, procs, path):\n    if start == end:\n        return path\n\n    paths = []\n    try:\n        for p in procs[start]:\n            if p in path:\n                continue\n            paths.append(prcs(p[1], end, procs, path + [p]))\n        return min([a for a in paths if a and a[-1][1] == end], key=len)\n    except (KeyError, ValueError):\n        return []\n    \n\n\ndef processes(start, end, procs):\n    dd = defaultdict(list)\n    for n, s, e in procs:\n        dd[s].append((n, e))\n\n    return [n for n, _ in prcs(start, end, dd, [])]", "lower = \"abcdefghijklmnopqrstuvwxyz\"\ntable = str.maketrans(lower + lower.upper(), lower[::-1] + lower.upper()[::-1])\n\ndef decode(stg):\n    if not isinstance(stg, str):\n        return \"Input is not a string\"\n    return stg.translate(table)\n", "def closest(lst):\n    result = min(lst, key=abs)\n    return result if not result or -result not in lst else None\n", "def sxore(n):\n    return (n * (n % 2 == 0)) + ((n + 1) % 4) // 2", "def penalty(a_list):\n    return ''.join(sorted(a_list,key=lambda x:x*10))", "def decrypt(s):\n    for a in range(1, 11):\n        if (a * 10**len(s) + int(s)) % 11 == 0:\n            return str((a * 10**len(s) + int(s)) // 11)\n    return \"impossible\"\n", "def createDict(keys, values):\n  return dict(list(zip(keys, values + [None]*len(keys))))\n", "def decode(string):\n    cipher = {'1':'9','2':'8','3':'7','4':'6','5':'0','6':'4','7':'3','8':'2','9':'1','0':'5'}\n    return ''.join([cipher[x] for x in string])\n", "convert=lambda s:bytes(int(s[i:i+2])for i in range(0,len(s),2)).decode()", "def pac_man(n, pm, enemies):\n    left, right, top, floor = -1, n, -1, n\n    for y, x in enemies:\n        if top < y < pm[0]: \n            top = y\n        if pm[0] < y < floor: \n            floor = y\n        if left < x < pm[1]: \n            left = x\n        if pm[1] < x < right: \n            right = x\n    return (right - left -1) * (floor - top - 1) - 1\n", "from math import ceil\nimport re\n\n\ndef convert_recipe(recipe):\n    spoons = set(re.findall(r\"[^ ]+ tb?sp\", recipe))\n    for spoon in spoons:\n        qty, typ = spoon.split(\" \")\n        wgt = ceil({\"tsp\": 5, \"tbsp\": 15}[typ] * eval(qty))\n        recipe = re.sub(f\"(^| ){spoon}\", f\"\\g<1>{spoon} ({wgt}g)\", recipe)\n    return recipe", "import math\ndef power_of_two(x):\n  return x == 2**(int(math.log2(x))) if x > 0 else False", "from itertools import combinations\n\ndef int_diff(arr, n):\n    return sum(abs(c1-c2)==n for c1,c2 in combinations(arr,2))", "def unique_in_order(iterable):\n    return [ ch for i, ch in enumerate(iterable) if i == 0 or ch != iterable[i - 1] ]", "from math import ceil\n\nEFF = {\n    ('fire','grass'):     2,\n    ('fire','water'):    .5,\n    ('grass','water'):    2,\n    ('electric','water'): 2,\n}\n\ndef calculate_damage(you, opp, attack, defense):\n    k   = (you,opp) if you<opp else (opp,you)\n    eff = .5 if you==opp else EFF.get(k,1) if k[0]==you else 1/EFF.get(k,1)\n    return ceil( 50 * eff * attack / defense )", "def zipvalidate(postcode):\n    try:\n        int(postcode)\n    except ValueError:\n        return False\n    \n    if len(postcode) != 6:\n        return False\n    return all([x!=postcode[0] for x in ['0', '5', '7', '8', '9']])\n\n", "def char_to_ascii(string):\n    return {c: ord(c) for c in set(string) if c.isalpha()} if len(string) else None", "import re\n\ndef encode(s):\n    return re.sub(r\"[a-zA-Z]\", lambda m: str((ord(m.group())+1)%2), s)", "from itertools import accumulate\n\n# Once again, thanks itertools\ndef get_section_id(scroll, sizes):\n    return next((i for i,x in enumerate(accumulate(sizes)) if x > scroll), -1)", "import re\ndef validPhoneNumber(num):\n    return bool(re.match(\"^[(][0-9]{3}[)] [0-9]{3}-[0-9]{4}$\", num))", "def christmas_tree(height):\n    if height < 3:\n        return ''\n    res = [1, 3, 5]\n    for _ in range((height-3)//3):\n        res.extend(res[-2:] + [res[-1]+2])\n    w = max(res)\n    ans = [('*' * r).center(w).rstrip() for r in res] + ['###'.center(w).rstrip()]\n    return '\\r\\n'.join(ans)", "from math import log2, ceil\n\ndef score(n):\n    return n if n in (0, 1) else 2 ** (ceil(log2(n))) - 1", "from string import ascii_lowercase as aLow\n\ntr = aLow[1:]+'a'\nTABLE = str.maketrans(aLow+aLow.upper(), tr+tr.upper())\n\ndef next_letter(s): return s.translate(TABLE)", "def travel(total_time, run_time, rest_time, speed):\n    cycle, left = divmod(total_time, run_time + rest_time)\n    return cycle * run_time * speed + min(left, run_time) * speed", "def sort_me(xs):\n    return sorted(xs, key=lambda x: str(x)[-1])", "from math import sqrt\nfrom itertools import permutations\n\ndef sort_by_perfsq(a):\n    return sorted(a, key = lambda n: (-sum(str(sqrt(int(''.join(p))))[-2:] =='.0' for p in set(permutations(str(n), len(str(n))))), n))", "from ipaddress import IPv4Address\n\ndef numberAndIPaddress(s):\n    return str(int(IPv4Address(s))) if '.' in s else str(IPv4Address(int(s)))", "def can_i_play(now_hour, start_hour, end_hour):\n    if start_hour < end_hour:\n        return start_hour <= now_hour < end_hour\n    return start_hour <= now_hour or now_hour < end_hour\n", "def pattern(n):\n    p = ' ' * (n - 1) + ''.join(str(x % 10) for x in range(1, n + 1)) + ' ' * (n - 1)\n    return \"\\n\".join(p[x:x + 2 * n - 1] for x in range(n))", "n,forbid = 100000, set(\"2357\")\nsieve, notPrimes = [0]*(n+1), [1]\nfor i in range(2, n+1):\n    if sieve[i]:\n        if not (forbid & set(str(i))): notPrimes.append(i)\n    else:\n        for j in range(i**2, n+1, i):  sieve[j] = 1\n\ndef solve(n): return notPrimes[n]", "def extract_number(word):\n    for l in word: \n        if l.isdigit(): return int(l)\n    return None\n\ndef order(sentence):\n    return ' '.join(sorted(sentence.split(), key=extract_number))\n", "def conference_picker(cities_visited, cities_offered):\n    return next((city for city in cities_offered if not city in cities_visited), \"No worthwhile conferences this year!\")", "def puzzle_tiles(width, height):    \n    temp1=(\" \"*3+\"_( )__ \"*width).rstrip()\n    temp2=\" _\"+\"     _\".join([\"|\"]*(width+1))\n    temp3=\"   _ \".join([\"(_\"]*(width+1))\n    temp4=\" \"+\"__( )_\".join([\"|\"]*(width+1))\n    temp5=\" \"+temp2[::-1].rstrip()\n    temp6=\"  _\"+\" _   _\".join([\")\"]*(width+1))\n    res=[temp1]\n    for i in range(height):\n        if i%2==0:\n            res.append(temp2)\n            res.append(temp3)\n            res.append(temp4)\n        else:\n            res.append(temp5)\n            res.append(temp6)\n            res.append(temp4)\n    return \"\\n\".join(res)", "def array_plus_array(arr1,arr2):\n    s = 0\n    for  i in arr1:\n        s = s+i\n    for j in arr2:\n        s = s+j\n    return s", "def is_divisible_by_6(s):\n    out=[]\n    for digit in \"0123456789\":\n        div=int(s.replace(\"*\",digit))\n        if div%6==0:out.append(str(div))\n    return out", "def beggars(values, n):\n    if n == 0:\n        return []\n    i=0\n    take=[]\n    for x in range(n):\n        take.append(0)\n    for val in values:\n        take[i%n]=take[i%n]+val\n        i= i + 1\n    return take    ", "def string_to_number(s):\n    # ... your code here\n    numb=int(s)\n    return numb", "def isTree(matrix):\n    '''depth first search; tree on n vertices has exactly n-1 edges'''\n    vertices = set(range(len(matrix)))\n    stack = [vertices.pop()]\n    while stack:\n        children = {y for y in matrix[stack.pop()] if y in vertices}\n        vertices.difference_update(children)\n        stack.extend(children)\n    return not vertices and sum(map(len,matrix)) == 2 * len(matrix) - 2", "import re\nfrom string import ascii_lowercase\n\ndef repl(m):\n    x = m.group()\n    if x.isdigit():\n        return ascii_lowercase[int(x)-1]\n    else:\n        return str(ascii_lowercase.find(x) + 1)\n\ndef AlphaNum_NumAlpha(string):\n    return re.sub(r'[a-z]|\\d+', repl, string)", "# From slowest to fastest.\n\ndef convert_hash_to_array(hash):\n    return sorted(map(list, hash.items()))\n    \ndef convert_hash_to_array(hash):\n    return sorted([k, v] for k, v in hash.items())\n\ndef convert_hash_to_array(hash):\n    return [[k, hash[k]] for k in sorted(hash)]", "DELTA = ord(\"a\")-1\n\ndef sumName(name):\n    return sum( ord(c)-DELTA for c in name) + len(name)\n\ndef rank(st, we, n):\n    return (\"No participants\" if st == \"\" else\n            \"Not enough participants\" if n > st.count(\",\")+1 else \n            sorted( (-sumName(name.lower())*w, name) for name,w in zip(st.split(','), we) )[n-1][1] )", "set_alarm = lambda e, v: 1 if [1, 0] == [e, v] else 0", "def diff(poly):\n  return [poly[i] * (len(poly)-1-i) for i in range(len(poly)-1)]", "import hashlib \n\ndef crack(hash):\n    for i in range (0,99999):\n        pin = digit_to_pin(i).encode()\n        rand_hash = hashlib.md5(pin).hexdigest()\n        if hash == rand_hash:\n            return pin.decode()\n        else:\n            pass\n    \ndef digit_to_pin(digit):\n    string = str(digit)\n    if len(string)<5:\n        nulls = (5 - len(string))*\"0\"\n        string  = nulls + string\n    return string", "from collections import Counter\n\ndef find_the_missing_tree(trees):\n    return min(Counter(trees).most_common(), key=lambda x: x[1])[0]", "def to_freud(sentence):\n    return ' '.join(['sex' for i in range(sentence.count(' ')+1)])", "def make_change(amount):\n    coins = {\n        'H' : 50,\n        'Q' : 25,\n        'D' : 10,\n        'N' : 5,\n        'P' : 1\n    }\n    \n    dict = {}\n    \n    for key in coins:\n        if amount >= coins[key]:\n            dict[key], amount = divmod(amount, coins[key])\n            \n    return dict", "def alphabetized(s):\n    return ''.join(sorted([c for c in s if c.isalnum()], key=str.lower))", "from re import match; from datetime import date as ymd, timedelta; date_correct=lambda date: \"\" if date==\"\" else None if date==None or not match(\"\\d\\d\\.\\d\\d\\.\\d{4}\",date or \"\") else (lambda d,m,y: (ymd(y+(m-1)//12,(m-1)%12+1,1)+timedelta(d-1)).strftime(\"%d.%m.%Y\"))(*map(int, date.split(\".\")))", "import math\ndef iter_pi(epsilon):\n  pi, iD, c, pos = 4.0, 1.0, 1, False\n  while abs(pi - math.pi) > epsilon:\n    iD += 2.0\n    pi, pos = 4 * (pi / 4 + (1 / iD if pos else -1 / iD)), not pos\n    c += 1\n  return [c, round(pi, 10)]", "from re import match\n\ndef is_hollow(x):\n    return bool(match(r'(x*)[0]{3,}\\1$', ''.join('x' if v else '0' for v in x)))", "def self_descriptive(num):\n    numList = list(str(num))\n    for i, s in enumerate(numList):\n        if int(s) != numList.count(str(i)):\n            return False\n    return True", "def double_every_other(l):\n    return [x * 2 if i % 2 else x for i, x in enumerate(l)]", "is_prime = lambda n: n == 2 or n % 2 and all(n % d for d in range(3, int(n ** .5) + 1, 2))\norder = lambda n, k: n and n // k + order(n // k, k)\ndecomp = lambda n: ' * '.join(str(p) if n < 2 * p else '%d^%d' % (p, order(n, p)) for p in range(2, n+1) if is_prime(p))", "def expanded_form(num):\n  split = str(num).split('.')\n  tens = [str(int(x) * 10**i) for i, x in enumerate(split[0][::-1]) if x != '0'][::-1]\n  decimals = [f'{x}/{10**i}' for i, x in enumerate(split[1], 1) if x != '0'] if '.' in str(num) else []\n  return ' + '.join(tens + decimals)", "import re\ndef solve(s):\n    return [len(re.findall(i,s)) for i in ('[A-Z]','[a-z]','\\d','[^a-zA-Z0-9]')]\n", "from itertools import islice\n\ndef max_profit(prices):\n    result = prices[1] - prices[0]\n    m = prices[0]\n    for x in islice(prices, 1, None):\n        result = max(x-m, result)\n        m = min(x, m)\n    return result", "def check_valid_tr_number(number):\n    n = str(number)\n    return isinstance(number, int) and len(n) == 11 and str(((sum(int(n[i]) for i in range(0, 10, 2)) * 7) - sum(int(n[i]) for i in range(1, 8, 2))) % 10) == n[9] and str(sum(int(n[i]) for i in range(10)) % 10) == n[10]", "def count_squares(n):\n    return (n + 1) * (2 * n + 1) * n // 6", "def same_encryption(s1, s2):\n  return (     s1[0] == s2[0]\n           and s1[-1] == s2[-1]\n           and len(s1) % 9 == len(s2) % 9 )", "from collections import Counter\nfrom functools import reduce\nfrom operator import and_\n\ndef common(*args):\n    return sum(key * value for key, value in reduce(and_, map(Counter, args)).items())", "def is_int_array(arr):\n    return isinstance(arr, list) and all(isinstance(x, int) or isinstance(x, float) and x.is_integer() for x in arr)", "def spinning_rings(inner_max, outer_max):\n  moves, inner, outer = 0, 0, 0\n\n  while True:\n      inner -= 1 # decrease inner ring by 1\n      inner %= inner_max + 1 # wrap if count goes beyond `inner_max`\n      \n      outer += 1 # increase outer ring by 1\n      outer %= outer_max + 1 # wrap if count goes beyond `outer_max`\n      \n      moves += 1 # count moves\n      \n      if(inner == outer):\n          break\n\n  return moves", "from itertools import product\nfrom functools import reduce\n\ndef solve(arr):\n    return max( reduce(int.__mul__, p,1) for p in product(*arr) )", "from math import ceil\ndef pay_cheese(arr):\n    return f'L{ceil(sum(arr) / 100) * 35}'", "def digits_product(product):\n\n    if product < 10: return 10 + product\n    \n    lst = []\n    for d in range(9, 1, -1):\n        while product % d == 0:\n            product /= d\n            lst.append(d)\n    return -1 if product != 1 else int( ''.join(map(str, lst[::-1])) )", "def bar_triang(pointA, pointB, pointC):\n    x_bary = round((pointA[0]+pointB[0]+pointC[0])/3, 4)\n    y_bary = round((pointA[1]+pointB[1]+pointC[1])/3, 4)\n    return [x_bary, y_bary]\n", "def esrever(string):\n    return string[:-1][::-1] + string[-1:]", "def split_exp(n):\n    dot = n.find('.')\n    if dot == -1: dot = len(n)\n    return [d+\"0\"*(dot-i-1) if i<dot else \".{}{}\".format(\"0\"*(i-dot-1), d)\n            for i,d in enumerate(n) if i != dot and d != '0']", "def to_bytes(n):\n    return [''.join(t) for t in zip(*[iter(format(n,'0{}b'.format((max(1,n.bit_length())+7)//8*8)))]*8)]", "def human_years_cat_years_dog_years(human_years):\n    if human_years ==1:\n        catYears,dogYears = 15,15\n    elif human_years == 2:  \n        catYears,dogYears  = 24,24\n    else:\n        catYears = 24 + (human_years-2)*4\n        dogYears = 24 + (human_years-2)*5\n    return  [human_years,catYears,dogYears] \n", "\ndef sequence(n):\n    # Thx OEIS\n    return int(format(n, 'b'), 3)  # Chai Wah Wu, Jan 04 2015", "def luck_check(s):\n    if not s or not all(c in '0123456789' for c in s):\n        raise ValueError('Invalid ticket number')\n    e0, b1 = len(s) // 2, (len(s) + 1) // 2\n    return sum(map(int, s[:e0])) == sum(map(int, s[b1:]))", "import math\n\ndef zeros(n):\n    Zeros = 0;\n    i = 5;\n    while i <= n:\n        Zeros += math.floor(n/i);\n        i *= 5\n    return Zeros", "def lucasnum(n):\n    a, b, i = 2, 1, 0\n    while True:\n        if i == n:    return a\n        if n > 0:\n            i += 1\n            a, b = b, a+b\n        else:\n            i -= 1\n            b,a = a, b-a   ", "from itertools import permutations\n\ndef late_clock(digits):\n    return max(\n        f'{a}{b}:{c}{d}'\n        for a,b,c,d in permutations(digits)\n        if 0 <= a*10+b < 24 and 0 <= c*10+d < 60\n    )", "from math import floor\ndef remainder(dividend, divisor): return \"NaN\" if divisor == 0 else dividend - floor(dividend / divisor) * divisor", "def build_palindrome(s):\n    a = s[1:][::-1] + s\n    temp = s\n    for i in range(len(s)+1):\n        temp = s[::-1][:i] + s\n        if temp == temp[::-1] and len(temp)<len(a):\n            a = temp\n\n    b = s + s[::-1]\n    temp = s\n    for i in range(len(s)+1):\n        temp = s + s[::-1][i:]\n        if temp == temp[::-1] and len(temp)<len(b):\n            b = temp\n    if len(a)>len(b):\n        return b\n    else:\n        return a\n", "def distribution_of(golds):\n    golds = golds[:]\n    take = lambda: golds.pop(0 if golds[0] >= golds[-1] else -1) if golds else 0\n    a = b = 0\n    while golds:\n        a += take()\n        b += take()\n    return [a, b]", "x = lambda n: [[1 if y == x or y == n - x - 1 else 0 for y in range(n)] for x in range(n)]", "def sort_array(lst):\n    even, odd = [], []\n    for n in sorted(lst):\n        (odd if n & 1 else even).append(n)\n    even, odd = iter(even[::-1]), iter(odd)\n    return [next(odd if n & 1 else even) for n in lst]", "def convert_temp(temp, from_scale, to_scale):\n    #Lookup table of x -> Kelvin conversions\n    input_lookup = {\n        'C' : lambda x: x+273.15, \n        'F' : lambda x: ((x + 359.67)*5)/9, \n        'K' : lambda x: x, \n        'R' : lambda x: (x*5)/9, \n        \"De\": lambda x: 373.15 - ((x*2)/3), \n        'N' : lambda x: ((x*100)/33) + 273.15, \n        \"Re\": lambda x: ((x*5)/4) + 273.15, \n        \"Ro\": lambda x: (((x -7.5)*40)/21) + 273.15\n    }\n    \n    #Lookup table of Kevin -> y conversions\n    output_lookup = {\n        'C' : lambda x: x-273.15, \n        'F' : lambda x: ((x*9)/5) - 459.67, \n        'K' : lambda x: x, \n        'R' : lambda x: (x*9)/5, \n        \"De\": lambda x: ((373.15 - x)*3)/2, \n        'N' : lambda x: ((x - 273.15)*33)/100, \n        \"Re\": lambda x: ((x-273.15)*4)/5, \n        \"Ro\": lambda x: (((x - 273.15) * 21)/40) + 7.5\n    }\n    \n    #Pass result from input_lookup into output_lookup and round result to match desired output\n    return round( output_lookup[to_scale](input_lookup[from_scale](temp)) )", "def e(s):return f([*s,'+'])\ndef f(s,r=0,o=0,x='',c=0):\n while s and')'!=c:\n  c=s.pop(0);i='+-*/)('.find(c)\n  if c=='-'>x or i<0:x+=c\n  elif c=='(':x=str(f(s))\n  elif i>-1:a=float(x);r=[r+a,r-a,r*a,r/a][o];o=i;x=''\n return r", "def greet(s):\n    return f'Hello {s.title()}!'", "def drop_cap(s):\n    return ' '.join(x.title() if len(x) > 2 else x for x in s.split(' '))", "def reverse(n):\n    return int(str(n)[::-1])", "def solve(s):\n    M = 10 ** 9 + 7;\n    z = ord('Z')\n    base = z - ord('A') + 1\n        \n    left, total = 0, 0 \n    # left-upside and total upside for the already traversed part of the list\n    for c_num in [(z - ord(c)) for c in s]:\n        l, t = left, total\n        left = (l * base + c_num) % M\n        total = ((l + 1) * c_num + t) % M\n    return total", "def remove_vowels(s):\n    return ''.join(i for i in s if i not in'aeiou')", "def populate_dict(keys, default):\n    return {k:default for k in keys}", "words = \"zero one two three four five six seven eight nine\".split()\nwordify = lambda n: \"\".join(words[int(d)] for d in str(n))\n\n\ndef numbers_of_letters(n):\n    result = [wordify(n)]\n    while result[-1] != \"four\":\n        result.append(wordify(len(result[-1])))\n    return result", "def prime(a):\n    if a < 2: return False\n    if a == 2 or a == 3: return True   \n    if a % 2 == 0 or a % 3 == 0: return False\n    maxDivisor = a**0.5\n    d, i = 5, 2\n    while d <= maxDivisor:\n        if a % d == 0: return False\n        d += i \n        i = 6 - i\n \n    return True\n\ndef prime_bef_aft(num):\n    res = []\n    for n in range(num-1, 1, -1):\n        if prime(n):\n            res.append(n)\n            break\n    for n in range(num+1, 3*num, 1):\n        if prime(n):\n            res.append(n)\n            break\n    return res", "def match(usefulness, months):\n    decay, needs = 0.15, 100\n    return \"Match!\" if needs * (1 - decay)**months <= sum(usefulness) else \"No match!\"", "def absent_vowel(x): \n    dictionary = {\n    \"a\": 0,\n    \"e\": 1,\n    \"i\": 2,\n    \"o\": 3,\n    \"u\": 4}\n    for vow in \"aeiou\":\n        if vow not in x:\n            return dictionary.get(vow)", "def rot_energies(B, Jmin, Jmax):\n    return [] if B <= 0 else [B * I * (I + 1) for I in range(Jmin, Jmax + 1)]", "def bonus_time(salary, bonus):\n    if bonus == True:\n        result = \"$\"+str(salary*10)\n    elif bonus == False:\n        result = \"$\"+str(salary)\n    return result\n    #your code here\n", "def keep_order(a,x):\n    for i,v in enumerate(a):\n        if v>=x:\n            return i\n    return len(a)", "def how_many_bees(hive):\n    if not hive:\n        return 0\n    count=0\n    for i in range(len(hive)):\n        for j in range(len(hive[i])-2):\n            compare=\"\".join(hive[i][j:j+3])\n            if compare==\"bee\" or compare==\"eeb\":\n                count+=1\n    for i in range(len(hive)-2):\n        for j in range(len(hive[i])):\n            compare=hive[i][j]+hive[i+1][j]+hive[i+2][j]\n            if compare==\"bee\" or compare==\"eeb\":\n                count+=1\n    return count", "def fuel_price(litres, price_per_litre):\n    return round(litres*(price_per_litre-min(0.05*(litres//2), 0.25)), 2)", "def find(rats):\n    \"\"\"\n    The rule the king should use is the following:\n        1) Label all bottle from 1 to 1000\n        2) Label all rats from 0 to 9\n        3) For each rat r, make it drink the bottle b if the binary representation of b has it's rth bit\n           is one.\n    Reconstruct the label of the poisonned bottle by computing the base-10 representation:\n    \"\"\"\n    return sum(map(lambda x: pow(2,x), rats))", "def same_col_seq(val, k, col):\n    # your code here\n    code ={'blue':0,'red':1,'yellow':2}\n    result =[]\n    limit = 2 * k * val   \n    term  =  1\n    temp  =  1\n    while(temp <= val):\n        temp =  temp + term + 1\n        term +=1\n        \n    while(True):\n        if(temp % 3  == code[col]):\n            result.append(temp)\n        temp = temp + term + 1\n        term +=1\n        \n        if(len(result)>= k  ):\n            break\n        if(len(result) == 0 and temp>=limit):\n            return []   \n\n    return result", "def row_sum_odd_numbers(n):\n    #your code here\n    \n    k = int((1+n)*n/2) #3\n    m = int((1+n-1)*(n-1)/2) #1\n    \n    if(k == 1):\n        return 1\n    \n    x = 0\n    y = 0\n    z = 0\n    w = 0\n    \n    for i in range(k):  \n        if i == 0:\n            x = 1\n        else:\n            x = x + 2\n        z = z + x\n    \n    for i in range(m):\n        if i == 0:\n            y = 1\n        else:\n            y = y + 2\n        w = w + y\n    \n    return z-w", "import re\n\ndef pseudo_sort(st):\n    lower_case_words = re.findall(r'\\b[a-z]\\w*', st)\n    upper_case_words = re.findall(r'\\b[A-Z]\\w*', st)\n\n    lower_case_words.sort()\n    upper_case_words.sort(reverse=True)\n\n    return ' '.join(lower_case_words + upper_case_words)", "from collections import Counter\n\ndef duplicates(arr):\n    return sum(v >> 1 for v in Counter(arr).values())", "def target_game(values):\n    max_can_shoot, max_can_not_shoot = 0, 0\n    for val in values:\n        new = max_can_shoot + val\n        max_can_shoot = max(max_can_not_shoot, new)\n        max_can_shoot, max_can_not_shoot = max_can_not_shoot, max_can_shoot\n    return max(max_can_shoot, max_can_not_shoot)", "def band_name_generator(s):\n    return (('The ' if s[0] != s[-1] else s[:-1]) + s).title()", "CATEGORIES = ['fruit', 'meat', 'other', 'vegetable']\nKNOWN = {c: c for c in CATEGORIES if c != 'other'}\n\ndef group_groceries(groceries):\n    d = {key: [] for key in CATEGORIES}\n    for item in groceries.split(','):\n        category, name = item.split('_')\n        d[KNOWN.get(category, 'other')].append(name)\n    return '\\n'.join(f'{c}:{\",\".join(sorted(d[c]))}' for c in CATEGORIES)", "from functools import reduce\nVALID = frozenset('abcdefABCDEF')\n\n\ndef fisHex(s):\n    return reduce(lambda b, c: b ^ c, (int(a, 16) for a in s if a in VALID), 0)\n", "def repeat_str(repeat, string):\n    if len(string)>=1:\n        pass\n    return repeat*string\n          \n", "def insert_dash2(num):\n    import re\n    return re.sub(r'([2468])(?=[2468])', r'\\1*', re.sub(r'([13579])(?=[13579])', r'\\1-', str(num)))", "def base_finder(seq):\n    digits = set(c for cs in seq for c in cs)\n    return int(max(digits)) + 1", "def flatten(lst):\n    r = []\n    for x in lst:\n       if type(x) is list:\n          r.extend(x)\n       else:\n          r.append(x)\n    return r ", "from collections import Counter\nfrom functools import reduce\nfrom fractions import gcd\n\ndef has_subpattern(s):\n    c = Counter(s)\n    m = reduce(gcd, c.values())\n    return ''.join(sorted(k*(v//m) for k,v in c.items()))", "geese = set([\"African\", \"Roman Tufted\", \"Toulouse\", \"Pilgrim\", \"Steinbacher\"])\n\ndef goose_filter(birds):\n    return [*filter(lambda s: s not in geese, birds)] ", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n    return [list(g) for _, g in groupby(lst, key.__gt__)]", "class Solution:\n    def bitwiseComplement(self, N: int) -> int:\n        return (1 << len(bin(N))-2) - N - 1", "#!/usr/bin/env python3\n\nimport re\n\ncons = 'QWRTYPSDFGHJKLZXCVBNMqwrtypsdfghjklzxcvbnm'\nvowels = 'AEIOUaeiou'\n\ndef __starting_point():\n    string = input().strip()\n    \n    m = re.findall(r\"(?<=[%s])([%s]{2,})[%s]\" % (cons, vowels, cons), string)\n    \n    print((\"\\n\".join(m or ['-1'])))\n    \n\n__starting_point()", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# import sys\n# input = sys.stdin.readline\n\nM = mod = 10**9 + 7 \ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n\n\ndef satisy(n, m, a, b, l):\n    for i in l:\n        if sum(i) != a:return 0\n    \n    for j in range(m):\n        curr = 0\n        for i in range(n):\n            curr += l[i][j]\n        if curr != b:return 0\n    return 1\n\nfor _ in range(val()):\n    n, m, a, b = li()\n    l = [[0]*m for i in range(n)]\n\n    col = 0\n    for i in range(n):\n        for j in range(col,col + a):l[i][j%m] = 1\n    \n    \n        col += m - a\n    \n    if satisy(n, m, a, b, l):\n        print('YES')\n        for i in l:print(*i,sep = '')\n    else:print('NO')", "from itertools import cycle, zip_longest\n\nEMPTY_CELL, HIGH, WIDTH = '-', 6, 7\n\ndef connect_four_place(columns):\n    player, cols = cycle(['Y', 'R']), [[] for _ in range(WIDTH)]\n    \n    for c in columns:           cols[c].append(next(player))\n    while len(cols[0]) < HIGH:  cols[0].append(EMPTY_CELL)\n    \n    return [ list(l) for l in zip_longest(*cols, fillvalue=EMPTY_CELL) ][::-1]", "def to_acronym(input):\n    words = input.split()\n    acronym = ''\n    for word in words:\n        acronym += word[0]\n    return acronym.upper()", "class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n        \ndef levelorder(self):\n    if not self:\n        return []\n    queue, R = [self], [self.value]\n    while queue:\n        Next = queue.pop(0)\n        for T in [Next.left, Next.right]:\n            if T:\n                queue.append(T)\n                R.append(T.value)\n    return R\n\ndef is_bst1(T):\n    if not (T and (T.left or T.right)):\n        return True\n    v, l, r = T.value, T.left, T.right\n    if l and max(levelorder(l)) > v or r and min(levelorder(r)) < v:\n        return False\n    return is_bst1(l) and is_bst1(r)\n\ndef is_bst2(T):\n    if not (T and (T.left or T.right)):\n        return True\n    v, l, r = T.value, T.left, T.right\n    if l and min(levelorder(l)) < v or r and max(levelorder(r)) > v:\n        return False\n    return is_bst2(l) and is_bst2(r)\n\ndef is_bst(T):\n    return is_bst1(T) or is_bst2(T)", "def search_k_from_end(ll, k):\n    \n    def _loop(n):\n        if not n: return 1, None\n        r = _loop(n.__next__)\n        return 1 + r[0], r[1] if r[0] != k else n.data\n\n    return _loop(ll.head)[1]\n", "find_variable=lambda:next(k for k in globals()if eval(k)==777)", "def rotate_clockwise(mx):\n    if not mx or not mx[0]:   return []\n    l0, lm, m,r = len(mx[0]),len(mx),[],''\n    while l0:\n        lm-= 1\n        r += mx[lm][l0-1]\n        if not lm:\n            m.insert(0, r)\n            lm = len(mx)\n            l0-= 1\n            r  = ''\n    return m", "class Hero(object):\n    def __init__(self, name='Hero'):\n        self.name = name\n        self.position = '00'\n        self.health = 100\n        self.damage = 5\n        self.experience = 0", "def n_closestPairs_tonum(num, k):\n    #m+n=p**2\n    #m-n=q**2 => n=m-q**2\n    result = []\n    for m in range(num-1,1,-1):\n        for q in range(1,int(m**.5)):\n            n=m-q**2\n            if int((m+n)**.5)**2 == m+n:\n                result.append([m, n])\n                if len(result)==k:\n                    return result\n    return result", "class User(object):\n    def __init__(self, name, balance, checking_account):\n        self.name = name\n        self.balance = balance\n        self.checking_account = checking_account\n    \n    def withdraw(self, v):\n        if v > self.balance: raise ValueError()\n        self.balance -= v\n        return \"{} has {}.\".format(self.name, int(self.balance))\n    \n    def add_cash(self, v):\n        self.balance += v\n        return \"{} has {}.\".format(self.name, int(self.balance))\n    \n    def check(self, other, v):\n        if not other.checking_account: raise ValueError()\n        s1,s2 = other.withdraw(v), self.add_cash(v)[:-1]\n        return \"{} and {}\".format(s2,s1)\n    \n    def __str__(self): return \"User({}, {}, {})\".format(self.name, self.balance, self.checking_account)", "def area(d, l):\n    return round(l * (d**2 - l**2)**0.5, 2) if d > l else \"Not a rectangle\"", "def peak_height(mountain):\n    points = { (row,col) for row,lst in enumerate(mountain) for col in range(len(lst)) if lst[col] == '^' }\n    height = 0\n    while points:\n        points -= { (row,col) for row,col in points if { (row-1,col), (row+1,col), (row,col-1), (row,col+1) } - points }\n        height += 1\n    return height", "def encryptor(key, message):\n  table = (''.join(map(chr, list(range(97, 123)))) * 2) + (''.join(map(chr, list(range(65, 91)))) * 2)\n  return ''.join([table[table.index(c) + (key % 26)] if c in table else c for c in message])\n", "def name_score(name):\n    return {name: sum(alpha[key] for c in name for key in alpha if c.upper() in key)}", "from bisect import insort\nfrom functools import reduce\n\ndef count_find_num(primesL, n):\n    product = reduce(lambda a, b: a * b, primesL)\n    if product > n:\n        return []\n    p = [product]\n    last = None\n    count = 0\n    while p:\n        first = p.pop(0)\n        if first == last:\n            continue\n        count += 1\n        for x in primesL:\n            m = x * first\n            if m <= n:\n                insort(p, m)\n        last = first\n    return [count, last] if count else []", "def find_in_array(seq, predicate): \n    for i, elem in enumerate(seq):\n        if predicate(elem, i):\n            return i\n    return -1", "def fusc(n):\n    if n <2:\n        return n\n    if n%2:\n        m = (n-1)//2\n        return fusc(m) + fusc(m+1)\n    return fusc(n/2)\n    \n", "from collections import Counter\n\ndef check(s,t):\n    return not s or any(check(s[d:], t-{d}) for d in range(max(map(len, t))+1) if s[:d] in t)\n\ndef mystery_range(s,n):\n    for i in range(1,100):\n        t = Counter(''.join(map(str,range(i,i+n))))\n        if Counter(s)==Counter(t): return [i,i+n-1] if check(s, set(map(str,range(i,i+n)))) else [i+1, i+n]", "def cashmuny(student):\n    return student.fives * 5 + student.tens * 10 + student.twenties * 20\ndef most_money(students):\n    timdeo = students[0]\n    all = False\n    if len(students) == 1:\n        return timdeo.name   \n    for s in students[1:]:\n        if cashmuny(s) > cashmuny(timdeo):\n            timdeo = s\n            all = False\n        elif cashmuny(s) == cashmuny(timdeo):\n            all = True\n    if all == False:\n        return timdeo.name\n    if all == True:\n        return \"all\"", "from math import ceil\n\npi = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\ndef square_pi(digits):  \n  return ceil(sum(int(d)**2 for d in pi[:digits])**0.5)", "from math import cos, pi\n\ndef spider_to_fly(a, b):\n    x, y = int(a[1]), int(b[1])\n    return (x**2 + y**2 - 2 * x * y * cos((ord(a[0]) - ord(b[0])) * pi / 4))**0.5", "def unwrap(obj, x):\n    return obj.do(x) if hasattr(obj, \"do\") else obj\n\n\nclass Placeholder:\n    def __init__(self, action=lambda x: x.pop(0)):\n        self.do = action\n\n    def __call__(self, *args):\n        return self.do([*args])\n\n    def __add__(self, other):\n        return Placeholder(lambda x: self.do(x) + unwrap(other, x))\n\n    def __sub__(self, other):\n        return Placeholder(lambda x: self.do(x) - unwrap(other, x))\n\n    def __mul__(self, other):\n        return Placeholder(lambda x: self.do(x) * unwrap(other, x))\n\n    def __floordiv__(self, other):\n        return Placeholder(lambda x: self.do(x) // unwrap(other, x))\n\n    def __radd__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) + self.do(x))\n\n    def __rsub__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) - self.do(x))\n\n    def __rmul__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) * self.do(x))\n\n    def __rfloordiv__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) // self.do(x))\n\nx = Placeholder()", "def weather_info (temp):\n    c = convert_to_celsius(temp)\n    if (c <= 0):\n        return str(c) + \" is freezing temperature\"\n    else:\n        return str(c) + \" is above freezing temperature\"\n    \ndef convert_to_celsius (temperature):\n    celsius = (temperature - 32) * (5/9)\n    return float(celsius)", "from urllib.request import urlopen\nfrom bs4 import BeautifulSoup as bs\ndef get_member_since(username):\n    html = urlopen(f'https://www.codewars.com/users/{username}')\n    soup = bs(html.read(), \"html.parser\")\n    tags = soup.find_all(\"div\", {\"class\": \"stat\"})\n    member_tag = [x.text for x in tags if 'Member Since' in x.text][0]\n    return member_tag.split(':')[1]", "# return the derivative of the polynomial.  \ndef poly_derivative(p):\n    return [(i+1)*m for i, m in enumerate(p[1:])]", "def remove(s: str) -> str:\n    r = s.replace('!', '')\n    return r + '!' * (len(s) - len(r))\n", "def sort_grades(lst):\n    grades = ['VB', 'V0', 'V0+', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6',\n    'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17']\n    return sorted(lst, key=lambda x: grades.index(x))", "from statistics import mean, pstdev\n\ndef clean_mean(sample, cutoff):\n    u, v = mean(sample), pstdev(sample)\n    cleaned = list(filter(lambda x: abs(x - u) <= cutoff*v, sample))\n    if len(sample) == len(cleaned): return round(u, 2)\n    return clean_mean(cleaned, cutoff)", "def word_to_bin(s):\n    return [\"{0:08b}\".format(ord(c)) for c in s]", "def parse_float(string):\n    \n    try:\n        return float(string)\n    except:\n        return None\n\n\n\n\n    #try:\n        #return float(string)\n    #except ValueError:\n        #return None\n", "def to_currency(price):\n    p = str(price)\n    return p if len(p)<=3 else to_currency(p[:-3])+','+p[-3:]", "def comfortable_numbers(l, r):\n  sd = lambda x:sum(int(d) for d in str(x))\n  return sum(sd(b+1)>=b-a+1 for a in range(l,r) for b in range(a,min(a+sd(a),r)))", "import re\ndef flesch_kincaid(text):\n    nLines = len(re.findall(r'([.?!;:]+)',text))\n    nWords = text.count(' ')+1\n    nSyll = len(re.findall(r'([aeiou]+)',text, flags=re.IGNORECASE))\n    return round( 0.39 * nWords/nLines + 11.8 * nSyll/nWords - 15.59, 2)", "class Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n    \ndef get_nth(node, index):\n    # Your code goes here.\n    if node is None or index < 0 :\n        raise LookupError('invalid index')\n    for i in range(index):\n        if node.__next__ is None:\n            raise IndexError('index out of range')\n        node = node.__next__\n    return node\n        \n", "def shorter_reverse_longer(a,b):\n  return a+b[::-1]+a if len(b)>len(a) else b+a[::-1]+b", "def hotpo(n):\n    count = 0\n    num = n\n    if(n < 1):\n        return 1\n    while(num > 1):\n        if(num % 2 == 0):\n            num = num / 2\n        else:\n            num = 3 * num + 1\n        count += 1\n    return count\n", "import re\nclass Checkout(object):\n    def __init__(self,sales={}):\n        self.total=0.0\n        self.items={}\n        self.sales={}\n        self.buyget={}\n        self.off={}\n        for k,v in sales.items():\n            if 'for' in v:\n                x,y=v.split('for')\n                self.sales[k]=(int(x),float(y))\n            elif 'buy' in v:\n                x,y=v.split('get')\n                self.buyget[k]=(int(x.replace('buy','')),int(y))\n            elif 'off' in v:\n                x,y=v.split('off')\n                self.off[k]=(float(x),int(y.replace('ormore','')))\n    \n    def scan(self,item,q=1):\n        self.items[item]=self.items.get(item,0)+q\n        self.total+=get_price(item)*q\n        if item in self.sales:\n            if self.sales[item][0]<=self.items[item]:\n                x=self.items[item]//self.sales[item][0]\n                self.total+=x*self.sales[item][1]-x*self.sales[item][0]*get_price(item)\n                self.items[item]%=self.sales[item][0]\n        elif item in self.buyget:\n            x,y=self.buyget[item]\n            if self.items[item]>=x+y:\n                z=self.items[item]//(x+y)\n                self.total-=z*y*get_price(item)\n            self.items[item]%=(x+y)\n        elif item in self.off:\n            if self.items[item]==self.off[item][1]:\n                self.total-=self.off[item][0]\n        self.total=round(self.total,2)", "def two_sum(n, target):\n    for i in range(len(n)-1):\n        if (target-n[i]) in n[i+1:]:\n            return [i, n[i+1:].index(target-n[i])+(i+1)]\n    return None\n", "def relations(family_list, target_pair):\n    parents = {}\n    for parent, child in family_list:\n        parents[child] = parent\n\n    a, b = target_pair\n    ap = parents.get(a)\n    app = parents.get(ap)\n    bp = parents.get(b)\n    bpp = parents.get(bp)\n\n    if b == ap:\n        return 'Mother'\n    if b == app:\n        return 'Grandmother'\n    if a == bp:\n        return 'Daughter'\n    if a == bpp:\n        return 'Granddaughter'\n    if ap == bp:\n        return 'Sister'\n    if app == bpp:\n        return 'Cousin'\n    if app == bp:\n        return 'Aunt'\n    if ap == bpp:\n        return 'Niece'", "def check(seq, elem):\n    marker = False\n    for _ in seq:\n        if elem == _:\n            return True\n    return marker", "class LCG(object):\n  def __init__(self, seed):\n      self.seed = seed\n  \n  def random(self):\n      a, c, m = 2, 3, 10\n      self.seed = (a * self.seed + c) % m\n      return self.seed / 10.0", "def search_names(x):\n    return([['bar_', 'bar@bar.com']])", "def equalize(arr):\n    return [f\"{e - arr[0]:+d}\" for e in arr]", "dict = {i[0]:i[1] for i in ['GA', 'DE', 'RY', 'PO', 'LU', 'KI', 'AG', 'ED', 'YR', 'OP', 'UL', 'IK','ga', 'de', 'ry', 'po', 'lu', 'ki', 'ag', 'ed', 'yr', 'op', 'ul', 'ik'] }\ndef encode(s):\n    return ''.join([dict[i] if i in dict else i for i in s])\n    \ndef decode(s):\n    return ''.join([dict[i] if i in dict else i for i in s])\n", "from operator import itemgetter\nfrom numpy import delete\n\ndef make_spanning_tree(edges, t):\n    memo, result = [], []\n    for v in sorted(edges, key=itemgetter(1), reverse=(t==\"max\")):\n        (x,y), w = v\n        \n        if x == y: continue\n        \n        i = next((i for i,s in enumerate(memo) if x in s), None)\n        j = next((j for j,s in enumerate(memo) if y in s), None)\n        \n        if i == j != None: continue\n            \n        result.append(v)\n        \n        if i == j: memo.append({x, y})\n        elif i is None: memo[j].add(x)\n        elif j is None: memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n\n    return result", "class Vector(object):\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n        \n    def __add__(self, other):\n        return Vector(self.x+other.x, self.y+other.y)\n        \n    def add(self, other):\n        return self + other", "from math import ceil\ndef nth_floyd(t):\n    return ceil((-1+(1+8*t)**0.5)/2)", "holes = {\"0\": 1, \"6\":1, \"8\":2, \"9\":1}\n\ndef get_num(n):\n    return sum(holes.get(i, 0) for i in str(n))", "def is_palindrome(s):\n    iterations = len(s) // 2\n    palindrome = True\n    for i in range(iterations-1):\n        a = s[i].lower()\n        b = s[-(i + 1)].lower()\n        if a != b:\n            palindrome = False\n            break    \n    return palindrome\n", "def is_very_even_number(n):\n    while len(str(n)) > 1:\n        n = sum(int(x) for x in str(n))\n    return True if n % 2 == 0 else False", "def child(bird1, bird2):\n    return 1 <= sum(i != j for i, j in zip(bird1, bird2)) <= 2 \n\ndef grandchild(bird1, bird2):\n    return bird1 == bird2 or sum(i != j for i, j in zip(bird1, bird2)) <= 4 and len(bird1) > 1\n", "# takes a function or lambda and a list of arguments to be passed to that function or lambda\n# returns the result of calling the function or lambda on those arguments\ndef spread(func, args):\n    return func(*args)", "def solution(a, b):\n    A_length= len(a)\n    B_length= len(b)\n    if A_length<=B_length:\n        return a + b+ a\n    else :\n        return b + a + b", "# Your code here. \nclass SelfClosing(object):\n    def __init__(self, CookieJar):\n        self.CookieJar = CookieJar\n        \n    def __enter__(self):\n        self.CookieJar.open_jar()\n        return self.CookieJar\n        \n    def __exit__(self, *args):\n        self.CookieJar.close_jar()\n", "class Cat(Animal):\n\n    def __init__(self,name):\n        self.name = name\n    \n    def speak(self):\n        return str.format(\"{} meows.\",self.name)", "class FileMaster():\n    def __init__(self, filepath):\n        self.fp = filepath\n\n    def extension(self):\n        return self.fp.split('.')[-1]\n\n    def filename(self):\n        return self.fp.rsplit('/', 1)[-1].split('.')[0]\n\n    def dirpath(self):\n        return self.fp.rsplit('/', 1)[0] + '/'", "def wallpaper(l, w, h):\n    from math import ceil\n    \n    num_words_dic = {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', \\\n            6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', \\\n            11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', \\\n            15: 'fifteen', 16: 'sixteen', 17: 'seventeen', \\\n            18: 'eighteen', 19: 'nineteen', 20: 'twenty'}\n    S_wall = (l + w) * 2 * h\n    S_paper = 5.2 \n    \n    return \"zero\" if l*w*h == 0 else num_words_dic[ceil(S_wall / S_paper * 1.15)]", "def get_min_max(seq): \n    return (min(seq),max(seq))# your code here\n# print(min(seq),max(seq))pass\n", "def decrypt(test_key):\n    return ''.join(str(test_key.count(c)) for c in 'abcdefghijklmnopqrstuvwxyz')", "archive = []\narchive_values = {0: 0}\ndef count_squareable(n):\n    def solve(nn):\n        return next((1 for x in range(1, int(nn**.5)+1) if not nn%x and x%2==(nn//x)%2), 0)\n    first_ind = next((i for i in reversed(archive) if i<=n), 0)\n    result = sum(solve(i) for i in range(first_ind+1, n+1))+archive_values[first_ind]\n    archive.append(n)\n    archive_values[n] = result\n    return result", "def compose(*func):\n    return C(func)\n    \nclass C:\n    def __init__(self,func):\n        self.func = list(func)[::-1]\n        \n    def __call__(self,*value):\n        value = sum(value)  \n        for f in self.func:\n            value = f(value)\n        return value", "def riemann_trapezoidal(f, n, a, b):\n    s = 0\n    d = (b-a) / n\n    for i in range(n):\n        x = a + i*d\n        y = x + d\n        s += (f(x) + f(y)) * d / 2\n    return round(s,2)\n", "def solved(string):\n    n = len(string)\n    return ''.join(sorted(string[:n//2] + string[n//2 + n % 2:]))", "def all_non_consecutive(arr):\n    answer = []\n    for i in range(len(arr)-1):\n        if arr[i + 1] - arr[i] != 1:\n            answer.append({'i': i + 1, 'n': arr[i + 1]})\n    return answer", "def replace_exclamation(s):\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    result = \"\"\n    for letter in s:\n        if letter.lower() in vowels:\n            result += \"!\"\n        else:\n            result += letter\n    return result", "def backwardsPrime(start, stop):\n    primes = []\n    for n in range(start, stop+1):\n        if n not in primes and is_prime(n) and is_prime(reverse(n)) and n != reverse(n):\n            primes.append(n)\n            if start <= reverse(n) <= stop:\n                primes.append(reverse(n))\n    return sorted(primes)\n\ndef is_prime(n):\n    for i in range(2, int(n**(0.5))+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef reverse(n):\n    return int(''.join(str(n)[::-1]))", "SCORE = {'O': '0', 'o': '0', 'k': '1'}\n\n\ndef okkOokOo(s):\n    \"\"\" okkookoo == PEP8, forced mixedCase by CodeWars \"\"\"\n    return ''.join(chr(int(''.join(SCORE.get(a, '') for a in word), 2))\n                   for word in s.split('?'))", "def elapsed_seconds(start, end):\n    return (end - start).total_seconds()", "import re\n\ndef find_nth_occurrence(substring, string, occurrence=1):\n    try: return [m.start() for m in re.finditer(f'(?={substring})', string)][occurrence-1] \n    except: return -1\n", "def new_avg(arr, newavg):\n    extra = newavg*float(len(arr) + 1) - sum(arr)\n    if extra < 0:\n        raise ValueError\n    return int(extra + 0.999)", "import math\n\ndef simpson(n):\n    a, b = 0, math.pi\n    f = lambda x: (3/2) * (math.sin(x) ** 3)\n    h = (b - a) / n\n    res = f(a)\n    res += 4 * sum(f(a + i*h) for i in range(1, n, 2))\n    res += 2 * sum(f(a + i*h) for i in range(2, n, 2))\n    res += f(b)\n    return (h / 3) * res", "from random import random\n\n\ndef mutate(chromosome, p):\n    return ''.join((a, '01'[a == '0'])[random() <= p] for a in chromosome)\n", "def get_password(grid,directions):\n    axis={'left':-1,'leftT':-1,'right':+1, 'rightT':+1}\n    ordinate={'up':-1,'upT':-1,'down':+1, 'downT':+1}\n    pwd=''\n    for ele in grid:\n        if 'x' in ele:\n            row_index, column_index = grid.index(ele), ele.index('x')\n            break\n\n    for direction in directions:\n        if 't' in direction:\n            column_index += axis[direction]\n            if 'T' in direction:    pwd += grid[row_index][column_index]\n        else:\n            row_index += ordinate[direction]\n            if 'T' in direction:    pwd += grid[row_index][column_index]\n    return pwd", "def fl(l):\n    for x in l:\n        if isinstance(x,list):\n            for j in fl(x):\n                yield j\n        else:\n            yield x\n\n\ndef sort_nested_list(a):\n    numbers = iter(sorted(fl(a)))\n\n    def b(n,a):\n        return [next(n)if isinstance(c,int)else b(n,c)for c in a]\n    return b(numbers,a)", "def calculate_total(subtotal, tax, tip):\n    return float(\"{0:.2f}\".format(subtotal + subtotal*(tax+tip)/100))", "from math import floor, ceil\n\ndef count_black_cells(h, w):\n    if w < h: h, w = w, h\n    diag, step = -2, w / h\n    for i in range(h):\n        left = floor(i * step - 1e-9)\n        right = ceil((i+1) * step + 1e-9)\n        diag += right - left\n    return diag", "def char_freq(message):\n    d=dict.fromkeys(message, 0)\n    for string in message:\n        d[string]+=1\n    return d", "from re import escape, split as my_split\ndef my_very_own_split(string, delimiter = None):\n    if delimiter == '':\n        raise None\n    for s in my_split(r'{0}'.format(escape(delimiter) if delimiter else '[\\s\\t$]+'), string):\n        yield s\n", "def solution(molar_mass1, molar_mass2, given_mass1, given_mass2, volume, temp) :  \n    m1 = given_mass1 * 0.001 / molar_mass1\n    m2 = given_mass2 * 0.001 / molar_mass2\n    \n    temp += 273.15\n    \n    return (m1 + m2) * 0.082 * temp / volume * 1000", "def sort_ranks(ranks):\n    return sorted(ranks, key=lambda s: list(map(int, s.split('.'))))", "def interpreter(tape):\n    j, k = {}, []\n    for i in range(len(tape)):\n        if tape[i] == \"[\": k.append(i)\n        elif tape[i] == \"]\":\n            j[i] = k[-1]\n            j[k.pop()] = i\n            \n    m, r, i, l = [0], \"\", 0, len(tape)\n    while i < l:\n        if tape[i] == \"^\": m.pop(0)\n        elif tape[i] == \"!\": m.append(0)\n        elif tape[i] == \"+\": m[-1] += 1\n        elif tape[i] == \"-\": m[-1] -= 1\n        elif tape[i] == \"*\": r += chr(m.pop(0) % 256)\n        elif (tape[i] == \"[\" and not m[-1] % 256) or (tape[i] == \"]\" and m[-1] % 256): i = j[i]\n        i += 1\n    return r", "def double_char(s):\n    return ''.join(map(lambda x:''.join(x), zip(s,s)))", "def vert_mirror(strng):\n    # your code\n    x = [i[::-1] for i in strng.split('\\n')]\n    return '\\n'.join(x)\n\ndef hor_mirror(strng):\n    # your code\n    a = strng[::-1]\n    x = [i[::-1] for i in a.split('\\n')]\n    return '\\n'.join(x)\n    \ndef oper(fct, s):\n    # your code\n    if fct == hor_mirror:\n        return hor_mirror(s)\n    else:\n        return vert_mirror(s)", "def adjust(coin, price):\n    return price + (coin - price) % coin", "def square_up(n):\n    return [n - j if n - j - 1 <= i else 0 for i in range(n) for j in range(n)]", "def f(ar, col):\n    for row in ar:\n        if col < len(row) and row[col] == '1':\n            col += 1\n        elif col > 0 and row[col-1] == '1':\n            col -= 1\n    return col\n\ndef amidakuji(ar):\n    return [f(ar[::-1], col) for col in range(len(ar[0]) + 1)]", "def get_number_of_squares(n):\n    return int((n * 3) ** (1. / 3.) - 0.5)", "def put_the_cat_on_the_table(cat, room):\n    try:\n        ci, cj = cat\n        if not (0 <= ci < len(room) and 0 <= cj < len(room[0])):\n            return \"NoCat\"\n        ti, tj = next((i, j) for i,row in enumerate(room) for j,x in enumerate(row) if x)\n        return \"{}{}\".format(\"UD\"[ti>ci]*abs(ti-ci), \"LR\"[tj>cj]*abs(tj-cj))\n    except StopIteration:\n        return \"NoTable\"", "def circularly_sorted(arr):\n    return sum(x > y for x,y in zip(arr, arr[1:]+[arr[0]])) < 2", "import re\n\ndef remove(stg):\n    words = stg.split(\" \")\n    for i, group in enumerate(words):\n        b, w, a = re.search(r\"(!*)([^!]+)(!*)\", group).groups()\n        s = min(a, b, key=len)\n        words[i] = f\"{s}{w}{s}\"\n    return \" \".join(words)\n", "multiply = lambda x, y: int.__mul__(x,y)\n", "def chess_board_cell_color(c1, c2):\n  return len(set(x[1] in '1357' if x[0] in 'ACEG' else x[1] in '2468' for x in [c1, c2])) == 1", "from os import popen\n\ndef get_output(s):\n    return popen(s).read()", "import json\n\ndef f(data, level):\n    if level == 0:\n        yield data['name']\n        return\n    children = data['children']\n    if len(children) >= 7 and all(child['gender'] == 'male' for child in children[:7]):\n        yield from f(children[6], level-1)\n    for child in children:\n        yield from f(child, 2)\n        \ndef find_seventh_sons_of_seventh_sons(jstring):\n    data = json.loads(jstring)\n    return set(f(data, 2))", "def redistribute_wealth(w):\n    w[:] = [sum(w) / len(w)] * len(w)", "def letter_frequency(text):\n  text = text.lower()\n  freq_count = [(c, text.count(c)) for c in text if c.isalpha()]\n  return sorted(list(set(freq_count)), key=lambda x: (-x[1], x[0]))\n\n", "class value:\n def __init__(self,v):self.v=v\nclass o:\n def __init__(self,a,b):A,B=a.v,b.v;self.r={add:A+B,sub:A-B,mul:A*B,truediv:A/B,mod:A%B,pow:A**B}[type(self)]\n def compute(self):return self.r\nclass add(o):1\nclass sub(o):1\nclass mul(o):1\nclass truediv(o):1\nclass mod(o):1\nclass pow(o):1", "def distance_between_points(a, b):\n    return ((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2)**0.5\n", "def travel(r, zipcode):\n    streets = []\n    nums = []\n    addresses = r.split(',')\n    for address in addresses:\n        if ' '.join(address.split()[-2:]) == zipcode:\n            streets.append(' '.join(address.split()[1:-2]))\n            nums += address.split()[:1]\n    return '{}:{}/{}'.format(zipcode, ','.join(streets), ','.join(nums))", "def is_valid_coordinates(coordinates):\n    print(coordinates)\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(\", \")\n    if len(l) != 2:\n        return False\n    print(l)\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])\n    except:\n        return False\n    print(latitude, longitude)\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180", "def hello(name = None):\n    ans = \"\"\n    if name is \"\" or name is None:\n        return \"Hello, World!\"\n    nm = list(name)\n    for i in range(0, len(nm)):\n        if i == 0:\n            ans += nm[i].upper()\n        else:\n            ans += nm[i].lower()\n    return \"Hello, \"+ans+\"!\"\n        \n", "from inspect import getgeneratorstate\ndef check_generator(gen):\n    _ = getgeneratorstate(gen)\n    if _ == \"GEN_CREATED\":\n        return \"Created\"\n    if _ == \"GEN_RUNNING\" or _ == \"GEN_SUSPENDED\":\n        return \"Started\"\n    else:\n        return \"Finished\"", "from math import factorial as f\nfrom operator import mul\n\ndef count_perms(m):\n    rep = [[i for s in m for i in s].count(j) for j in set([i for s in m for i in s])]\n    rep = [f(i) for i in rep]\n    tot = (len(m)*len(m[0]))\n    return f(tot)/reduce(mul, rep, 1)", "class anything:\n    def __init__(self, value): pass\n    __eq__=__ne__=__lt__=__le__=__gt__=__ge__ = lambda self,second: True", "import re\ndef camelize(str_):\n    return ''.join(x.capitalize() for x in re.split(r'[\\W_]', str_))", "def round_to_next5(n):\n    # Your code here\n    i = 5\n    while True:\n        x = i - n\n        if x in range(0, 5):\n            return i\n        elif x < 0:\n            i = i + 5\n        elif x >= 5:\n            i = i - 5\n        \n        \n    return n", "def is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return n > 1\n\n\ndef next_prime(n):\n    i = n + 1\n    while not is_prime(i):\n        i += 1\n    return i\n", "def connect_the_dots(paper):\n    dots = {c: (i, j) for i, row in enumerate(paper.split(\"\\n\")) for j, c in enumerate(row) if c != \" \"}\n    points = sorted(dots.keys())\n    coords = sum((link(dots[a], dots[b]) for a, b in zip(points, points[1:])), list(dots.values()))\n    return \"\\n\".join(\"\".join(\"*\" if (i, j) in coords else \" \" for j, _ in enumerate(row)) for i, row in enumerate(paper.split(\"\\n\")))\n    \ndef link(a, b):\n    dx, dy = (-1 if a[i] > b[i] else 1 if a[i] < b[i] else 0 for i in (0, 1))\n    return [(a[0] + dx*i, a[1] + dy*i) for i in range(1, abs(a[0] - b[0]) or abs(a[1] - b[1]))]\n    \n# Not very proud of that, so ugly and antipythonic.\n", "def find_gatecrashers(people, invitations):\n    guests = []\n    for guest, otherGuests in invitations:\n        guests.append(guest)\n        guests.extend(otherGuests)\n    return sorted(set(people).difference(set(guests)))", "from collections import Counter\n\ndef find_dups_miss(arr):\n    cnt = Counter(arr)\n    dup = sorted(x for x in cnt if cnt[x] >= 2)\n    miss = (set(xrange(min(cnt), max(cnt) + 1)) - set(cnt)).pop()\n    return [miss, dup]", "def recaman(n):\n    a, i = 0, 0\n    k = {0}\n    while i<=n:\n        x = [a+i,a-i][(a-i) > 0 and a-i not in k]\n        k.add(x)\n        a = x\n        i += 1\n    return x      ", "def find_difference(a, b):\n    cube_a = cube_b = 1\n    for x in a: cube_a *= x\n    for x in b: cube_b *= x\n    return abs(cube_a - cube_b)", "class Datamining:\n    def __init__(self, train_set):\n        x_mean=sum([i[0] for i in train_set])/len([i[0] for i in train_set])\n        y_mean=sum([i[1] for i in train_set])/len([i[1] for i in train_set])\n        self.a = (sum((x - x_mean) * (y - y_mean) for x, y in train_set)) / \\\n                 (sum((x - x_mean) ** 2 for x in [i[0] for i in train_set]))\n        self.b = y_mean - self.a * x_mean\n    def predict(self, x): return x * self.a + self.b", "def wave_sort(a):\n    a1, a2 = sorted(a), sorted(a)[::-1]\n    \n    for i in range(len(a)):\n        if i % 2 == 1:\n            a[i] = a1.pop(0)\n        else:\n            a[i] = a2.pop(0)\n    print(a)\n    return a", "def makeParts(arr, size):\n    return [arr[i:i+size] for i in range(0, len(arr), size)]", "def build_trie(*words):\n    trie = {}\n    for word in words:\n        node = trie\n        for i in range(1, len(word)+1):\n            prefix = word[:i]\n            if prefix not in node:\n                node[prefix] = None\n            if i < len(word) and node[prefix] is None:\n                node[prefix] = {}\n            node = node[prefix]\n    return trie", "def binary_gcd(x, y):\n    if x == 0 and y == 0:\n        return 0\n    elif x == 0 or y == 0:\n        return bin(max(abs(x),abs(y))).count('1')\n    for i in range(min(abs(x),abs(y)),0,-1):\n        if (x % i == 0 and y % i == 0):\n            return bin(i).count('1')\n", "import re\n\ndef digit_all (x):\n    return re.sub(\"\\D\", \"\", x) if type(x) is str else 'Invalid input !'", "import math\n\ndef f(z, eps):\n    return max(-1, math.log(eps)/math.log(math.hypot(z.real, z.imag)))", "from fractions import gcd\ndef calculate_ratio(w,h):\n    c = gcd(w, h)\n    return \"{}:{}\".format(w/c, h/c) if w > 0 and h > 0 else 'You threw an error' ", "def show_me(instname):\n    hi = f\"Hi, I'm one of those {instname.__class__.__name__}s!\"\n    fields = sorted(vars(instname))\n    if len(fields) == 1:\n        return f\"{hi} Have a look at my {fields[0]}.\"\n    else:\n        return f\"{hi} Have a look at my {', '.join(fields[:-1])} and {fields[-1]}.\"", "def nthterm(a, n, r):\n    return a + n * r", "def iter_unpack(x):\n    if isinstance(x, (tuple, list, set)):\n        for item in x:\n            yield from iter_unpack(item)\n    elif isinstance(x, dict):\n        for key, value in x.items():\n            yield from iter_unpack(key)\n            yield from iter_unpack(value)\n    else:\n        yield x\n\ndef unpack(x):\n    return list(iter_unpack(x))", "def answer(puzzlebox):\n    #print(dir(puzzlebox))\n    #puzzlebox.hint\n    #print(puzzlebox.hint_two)\n    #print(puzzlebox.lock(puzzlebox.key))\n    return 42\n    pass", "def candles(m, n):\n    c = m\n    while m >= n:\n        a, b = divmod(m, n)\n        c += a\n        m = a + b\n    return c", "from datetime import datetime\nclass Random():\n    def __init__(self, seed):\n        self.seed=seed\n        self.x=self.next_x(self.seed)\n    \n    @property\n    def seed(self):\n        return self.__seed\n\n    @seed.setter\n    def seed(self,seed):\n        self.x=self.next_x(seed)\n        self.__seed=seed\n    \n    def next_x(self,x):\n        x=x^(x<<13&0xFFFFFFFF)\n        x=x^(x>>17&0xFFFFFFFF)\n        x=x^(x<<15&0xFFFFFFFF)\n        return x&0xFFFFFFFF\n    \n    def random(self):\n        x=self.x\n        self.x=self.next_x(x)\n        return x/(2**32)\n        \n    def randint(self, start, end):\n        x=self.x\n        self.x=self.next_x(x)\n        return (end-start)*x//(2**32)+start", "from fractions import Fraction\n\ndef to_string(self):\n    n, d = self.numerator, self.denominator\n    s, w, n = \"-\" if n < 0 else \"\", *divmod(abs(n), d)\n    r = \" \".join((str(w) if w else \"\", f\"{n}/{d}\" if n else \"\")).strip()\n    return f\"{s}{r}\"\n\nFraction.__str__ = to_string\nFraction.to_decimal = lambda self: self.numerator / self.denominator", "from itertools import zip_longest\n\n\ndef sum_arrays(arrays, shift):\n    new_arr = []\n    for i, arr in enumerate(arrays):\n        new_arr.append([0] * shift * i  + arr)\n    return list(map(sum, zip_longest(*new_arr, fillvalue=0)))\n", "def html_end_tag_by_start_tag(start_tag):\n    return \"</{}>\".format(start_tag.strip(\"<>\").split(\" \")[0])\n", "position = lambda letter: f\"Position of alphabet: {'abcdefghijklmnopqrstuvwxyz'.index(letter) + 1}\"", "def get_primes(how_many, group_size):\n    primes = [False] * 2 + list(range(2, 13*how_many))\n    for x in primes:\n        if x:\n            for i in range(x*x, 13*how_many, x):\n                primes[i] = False\n    seq = sorted(set(primes))[1:how_many+1]\n    while len(seq) % group_size != 0:\n        seq += [None]\n    return (tuple(seq[x:x+group_size]) for x in range(0, len(seq), group_size))", "def validBraces(string):\n    stack = []\n    delim = {'(':')', '[':']', '{':'}'}\n    for c in string:\n        if c in list(delim.keys()): stack.append(c)\n        elif c in list(delim.values()):\n            if not stack or delim[stack.pop()] != c: return False\n    return not stack\n", "def convert(n):\n    s = str(n)[::-1]\n    p = [s[i::4].count('1') for i in range(4)]\n    return [p[0] - p[2], p[1] - p[3]]", "def grid_index(grid, idxs):\n    return ''.join(grid[x][y] for x,y in map(lambda n: divmod(n-1,len(grid)),idxs))", "def gcd(a,b):\n    while b:\n        a,b = b,a%b\n    return a\n\ndef lcd(a,b):\n    return a*b/gcd(a,b)\n\ndef checkstring(arr):\n    strlist = []\n    for elem in arr:\n        if type(elem) == str:\n            strlist.append(elem)\n    return strlist\n\ndef converttoint(arr):\n    intarray = []\n    for elem in arr:\n        if elem is None: pass\n        else:\n            try:\n                intarray.append(int(elem))\n            except:\n                intarray.append(elem)\n    return intarray\n    \ndef min_special_mult(arr):\n    arr = converttoint(arr)\n    if len(checkstring(arr)) == 1: \n        return 'There is 1 invalid entry: ' + str(checkstring(arr)[0])\n    elif len(checkstring(arr)) > 1: \n        return 'There are ' + str(len(checkstring(arr))) + ' invalid entries: ' + str(checkstring(arr))\n    current = 1\n    for elem in arr:\n        current = lcd(current,elem)\n    return current", "letters =  {\n    \"A\": \"Alpha\",  \"B\": \"Bravo\",   \"C\": \"Charlie\",\n    \"D\": \"Delta\",  \"E\": \"Echo\",    \"F\": \"Foxtrot\",\n    \"G\": \"Golf\",   \"H\": \"Hotel\",   \"I\": \"India\",\n    \"J\": \"Juliett\",\"K\": \"Kilo\",    \"L\": \"Lima\",\n    \"M\": \"Mike\",   \"N\": \"November\",\"O\": \"Oscar\",\n    \"P\": \"Papa\",   \"Q\": \"Quebec\",  \"R\": \"Romeo\",\n    \"S\": \"Sierra\", \"T\": \"Tango\",   \"U\": \"Uniform\",\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\n  }\n  \ndef nato(word):\n    stringlist = []\n    for ch in word.upper():\n        stringlist.append(letters[ch])\n    string = \" \".join(stringlist)\n        \n    return string", "def list_to_array(lst):\n    list=[]\n    while lst:\n        list.append(lst.value)\n        lst=lst.next\n    return list", "from collections import Counter\n\ndef count_feelings(s, arr):\n    count = sum(1 for f in arr if not Counter(f) - Counter(s))\n    return '{} feeling{}.'.format(count, '' if count == 1 else 's')", "class PokeScan:\n    def __init__(self, name, level, pkmntype):\n        self.name = name\n        self.level = level\n        self.pkmntype = pkmntype\n\n    def info(self):\n        type_words = {'water': 'wet', 'fire':'fiery', 'grass':'grassy'}\n        outstring = self.name + ', a '\n        outstring += type_words.get(self.pkmntype) + ' and '\n        if self.level<=20: outstring += 'weak'\n        elif self.level<=50: outstring += 'fair'\n        else: outstring += 'strong'\n        outstring += ' Pokemon.'\n\n        return outstring", "def collatz_step(n):\n    if n % 2 == 0:\n        return n//2\n    else:\n        return n*3 + 1\n\ndef collatz_seq(n):\n    while n != 1:\n        yield n\n        n = collatz_step(n)\n    yield 1\n\ndef collatz(n):\n    return '->'.join(str(x) for x in collatz_seq(n))\n", "def only_one(*flags):\n    return len([a for a in flags if a])==1\n", "from gmpy2 import comb\nfrom operator import xor\nfrom functools import reduce\n\ntransform = lambda A,x: reduce(xor, (comb(n+1, x+1) for n in A))", "def binRota(arr):\n    arr[1::2] = map(lambda x: x[::-1], arr[1::2])\n    return sum(arr,[])", "def get_diagonale_code(grid: str) -> str:\n    grid = grid.replace(' ','').split('\\n')\n    x,y = 0,0\n    s=1\n    res=''\n    try:\n        while True:\n            print((x,y,s,grid[x][y]))\n            res+=grid[x][y]\n            y+=1\n            x+= 1 if s==1 else -1\n            if not 0<=x<len(grid):\n                s*=-1\n                x+=s*2\n    except:\n        return res\n", "from itertools import combinations\n\ndef find_zero_sum_groups(lst, n):\n    if not lst:\n        return \"No elements to combine\"\n    result = [list(c) for c in combinations(sorted(set(lst)), n) if sum(c) == 0]\n    return (result[0] if len(result) == 1 else result) or \"No combinations\"\n", "def different_squares(matrix):\n    s = set()\n    rows, cols = len(matrix), len(matrix[0])\n    for row in range(rows - 1):\n        for col in range(cols - 1):\n            s.add((matrix[row][col], matrix[row][col + 1], matrix[row + 1][col], matrix[row + 1][col + 1]))\n    return len(s)", "from random import choice\n\ndef random_case(text):\n    return ''.join(choice([c.upper(), c.lower()]) for c in text)", "def sort(words):\n    if not words: return\n    it = iter(words)\n    pivot = next(it)\n    lt, ge = [], []\n    for i in it:\n        if i < pivot: lt.append(i)\n        else: ge.append(i)\n    yield from sort(lt)\n    yield pivot\n    yield from sort(ge)", "import re\n\ndef infected(s):\n    n = sum(map(len, re.findall(r'0*1[01]*', s)))\n    s = len(s.replace('X',''))\n    return s and 100*n/s", "def reverse(lst):\n    result = list()\n    for item in lst:\n        result.insert(0, item)\n    return result\n", "def martingale(bank, outcomes):\n    nxt = 100\n    for result in outcomes:\n        if result:\n            bank += nxt\n            nxt = 100\n        else:\n            bank -= nxt\n            nxt *= 2\n    return bank", "def count_char(s,c):\n    return s.lower().count(c.lower())", "def shut_the_gate(farm):\n    if not farm:\n        return \"\"\n    RA=[]\n    if farm[0]!=\"|\" and farm[-1]!=\"|\"and \"|\" in farm:\n        R = farm.rfind(\"|\")\n        L = farm.find(\"|\")\n        tmp = farm[R:]+farm[:L]\n        if \"H\" in tmp:\n            farm = farm[:R]+farm[R:].replace(\"A\",\".\").replace(\"V\",\".\")\n            farm = farm[:L].replace(\"A\",\".\").replace(\"V\",\".\")+farm[L:]\n        if \"R\" in tmp:\n            farm = farm[:R]+farm[R:].replace(\"V\",\".\")\n            farm = farm[:L].replace(\"V\",\".\")+farm[L:]\n    res=''\n    L = len(farm)\n    T = [e for e in range(L) if farm[e]==\"|\"]\n    if farm[0]!=\"|\":        T = [0]+T\n    if farm[-1]!=\"|\":        T.append(L)\n    idx=0\n    while True:\n        if T[idx]==T[-1]:            break\n        S = T[idx]\n        E = T[idx+1]\n        tmp = farm[S:E+1]\n        if \"H\" in tmp:\n            tmp = tmp.replace(\"A\",\".\").replace(\"V\",\".\")\n        if \"R\" in tmp:\n            tmp = tmp.replace(\"V\",\".\")\n        if tmp.count(\"|\")<=1:\n            if \"H\" in RA:\n                tmp = tmp.replace(\"A\",\".\").replace(\"V\",\".\")\n            if \"R\" in RA:\n                tmp = tmp.replace(\"V\",\".\")\n            if \"H\" in tmp:\n                tmp = tmp.replace(\"H\",\".\")\n                RA.append(\"H\")\n            if \"R\" in tmp:\n                tmp = tmp.replace(\"R\",\".\")\n                RA.append(\"R\")\n            tmp = tmp.replace(\"C\",\".\")\n        res+=tmp[:-1] if E!=T[-1] else tmp\n        idx+=1\n    return res", "from collections import Counter\n\ndef directions(goal):\n    c = Counter(goal)\n    for a, b in ['NS', 'EW']:\n        m = min(c[a], c[b])\n        c[a] -= m\n        c[b] -= m\n    return sorted(c.elements(), key='NSEW'.find)", "def string_counter(string, char):\n    return sum(1 for i in string if char == i)", "from math import sqrt\n\nclass Vector:\n    def __init__(self, *vector):\n        self.vector = vector\n        if len(vector) == 1:\n           self.vector = tuple(vector[0])\n        self.x, self.y, self.z = self.vector\n        self.magnitude = sqrt(sum(v*v for v in self.vector))\n\n    def to_tuple(self):\n        return tuple(self.vector)\n\n    def __str__(self):\n        return f'<{self.x}, {self.y}, {self.z}>'\n\n    def __add__(self, other):\n        x, y, z = (a + other.vector[i] for i,a in enumerate(self.vector))\n        return Vector(x, y, z)\n\n    def __sub__(self, other):\n        x, y, z = (a - other.vector[i] for i,a in enumerate(self.vector))\n        return Vector(x, y, z)\n    \n    def __eq__(self, other):\n        return all(v == other.vector[i] for i, v in enumerate(self.vector))\n\n    def dot(self, other):\n        return sum(v * other.vector[i] for i, v in enumerate(self.vector))\n\n    def cross(self, other):\n        x = self.y * other.z - self.z * other.y\n        y = -(self.x * other.z - self.z * other.x)\n        z = self.x * other.y - self.y * other.x\n        return Vector(x, y, z)", "def two_by_two(animals):\n    return {animal: 2 for animal in set(animals) if animals.count(animal) > 1} if animals else False", "def house_numbers_sum(inp):\n    index = inp.index(0)\n    return sum([a for a in inp[:index]])", "def resistor_parallel(*resistors):\n    return 1.0 / sum(map(lambda x:1.0/x, resistors))", "def find_initial_numbers (divisor, iterations):\n    if iterations == 0:\n        return (divisor,0)\n    \n    a = divisor\n    b = 0\n    \n    for _ in range(iterations+1):\n        a, b = a+b, a\n    \n    return (a,b)", "def ip_to_int32(ip):\n  retInt = 0\n  octets = ip.split('.')\n  for ndx, offset in enumerate((24, 16, 8, 0)):\n      retInt = retInt | int(octets[ndx]) << offset\n  return retInt", "\ndef partial_keys(d):\n    class Dct(dict):\n        def __getitem__(self,pk):\n            k = min((k for k in self if k.startswith(pk)), default=None)\n            return k if k is None else super().__getitem__(k)\n    return Dct(d)", "class Pong:\n    def __init__(self, win):\n        self.win = win\n        self.turn = -1\n        self.scores = [0, 0]\n\n    def play(self, ball, player):\n        \n        if max(self.scores) == self.win: return 'Game Over!'\n            \n        self.turn = (self.turn + 1) % 2\n        \n        if abs(ball - player) < 4: return 'Player ' + str(self.turn + 1) + ' has hit the ball!'\n\n        self.scores[(self.turn + 1) % 2] += 1\n            \n        return 'Player ' + (str(1 if self.turn else 2) + ' has won the game!' if max(self.scores) == self.win else str(self.turn + 1) + ' has missed the ball!')", "from itertools import zip_longest\n\nclass WordDictionary:\n\n  def __init__(self):\n    self.words = []\n\n  def add_word(self, word):\n    self.words.append(word)\n\n  def search(self, pattern):\n    return any(all((a and b == '.') or a == b for a, b in zip_longest(word, pattern)) for word in self.words)", "class Dog ():\n  def __init__(self, breed):\n    self.breed = breed\n    \n\nsnoopy = Dog(\"Beagle\")\n\nsnoopy.bark = lambda: \"Woof\"\n\nDog.bark = staticmethod(snoopy.bark)\n\nscoobydoo = Dog(\"Great Dane\")", "solution = lambda q: 'Value is %05d' % q\n    \n", "def find_ball(scales, ball_count):\n  balls = range(ball_count)\n  \n  while (len(balls) > 1):\n    x = len(balls) / 3 + (len(balls) % 3 > 0)\n    j, k, l = balls[:x], balls[x:x*2], balls[x*2:]\n    balls = [l, k, j][scales.get_weight(j, k)]\n    \n  return balls[0]", "from itertools import count, islice\n\n\nclass Harshad:\n    @staticmethod\n    def is_valid(number):\n        return number % sum(map(int, str(number))) == 0\n    \n    @classmethod\n    def get_next(cls, number):\n        return next(i for i in count(number+1) if cls.is_valid(i))\n    \n    @classmethod\n    def get_series(cls, c, start=0):\n        return list(islice(filter(cls.is_valid, (i for i in count(start+1))), c))", "def box(coords):\n    a = [n for n,m in coords]\n    b = [m for n,m in coords]\n    \n    return {'nw': [max(a), min(b)], 'se': [min(a), max(b)]}", "import datetime\n\ndef days_until_christmas(today):\n    noel = datetime.date(today.year, 12, 25)\n    result = (noel-today).days\n    return result if result >= 0 else (datetime.date(noel.year+1,noel.month,noel.day)-today).days", "closest_multiple_10=lambda x:round(x/10)*10", "import re\ndef sum_of_integers_in_string(s):\n    return sum([int(i) for i in re.findall(r'\\d+',s)])", "def relatively_prime (n, l):\n    from fractions import gcd\n    return [i for i in l if gcd(n,i)==1]", "def tower_builder(n_floors, block_size):\n    w, h = block_size\n    filled_block = '*' * w\n    empty_block = ' ' * w\n    tower = []\n    for n in range(1,n_floors+1):\n        for _ in range(h):\n            tower.append( empty_block * (n_floors - n) + filled_block * (2*n -1) + empty_block * (n_floors - n))\n    return tower", "def vampire_test(x, y):\n    return (str(x*y).count('1') == ((str(x).count('1')) + (str(y).count('1')))) & ((x > 0) | (y>0))", "class Node(object):\n  def __init__(self, data):\n    self.data = data\n    self.next = None\n    \ndef sorted_insert(head, data):\n  current = head;\n  if head is None or head.data > data:\n    return push(head, data)\n  while current.next is not None and data > current.next.data:\n    current = current.next\n  current.next = push(current.next, data)\n  return head", "class Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n    \ndef length(node):\n    leng = 0\n    while node:\n        leng += 1\n        node = node.next\n    return leng\n  \ndef count(node, data):\n    c = 0\n    while node:\n        if node.data==data:\n            c += 1\n        node = node.next\n    return c", "def trouble(x, t):\n    n = x[:1]\n    for i in x[1:]:\n        if i + n[-1] != t:\n            n.append(i)\n    return n\n", "def user_contacts(data):\n  return {p[0]: p[1] if len(p) > 1 else None for p in data}", "units = \" I II III IV V VI VII VIII IX\".split(\" \")\ntens = \" X XX XXX XL L LX LXX LXXX XC\".split(\" \")\nhundreds = \" C CC CCC CD D DC DCC DCCC CM\".split(\" \")\nthousands = \" M MM MMM\".split(\" \")\n\ndef solution(n):\n    return thousands[n//1000] + hundreds[n%1000//100] + tens[n%100//10] + units[n%10]", "def search(titles, term): \n    term = term.lower()\n    return [s for s in titles if term in s.lower()]", "def goals(laLiga, copaDelRey, championsLeague):\n    somme = sum([laLiga,copaDelRey,championsLeague])\n    print(somme)\n    return somme", "rat_dirs = {\n  '\u2190': (-1, 0),\n  '\u2191': (0, -1),\n  '\u2192': (1, 0),\n  '\u2193': (0, 1),\n  '\u2196': (-1, -1),\n  '\u2197': (1, -1),\n  '\u2198': (1, 1),\n  '\u2199': (-1, 1)\n }\n  \ndef find_piper(town_square, width, height):\n  for y in range(height):\n    for x in range(width):\n      if town_square[y][x] == 'P':\n        return x, y\n  return -1, -1 \n  \ndef is_rat_deaf(rx, ry, px, py, c):\n  dx, dy = px - rx, py - ry\n  cx, cy = rat_dirs[c]\n  return cx * dx + cy * dy <= 0\n  \ndef count_deaf_rats(town_square):\n  width, height = len(town_square[0]), len(town_square)\n  px, py = find_piper(town_square, width, height)\n  num_deaf = 0\n  \n  for y in range(height):\n    for x in range(width):\n      c = town_square[y][x]\n      if c in rat_dirs and is_rat_deaf(x, y, px, py, c):\n        num_deaf += 1\n  \n  return num_deaf\n", "def sort_csv_columns(csv_file_content, sep=';', end='\\n'):\n    '''Sort a CSV file by column name.'''\n    csv_columns = zip(*(row.split(sep) for row in csv_file_content.split(end)))\n    sorted_columns = sorted(csv_columns, key=lambda col: col[0].lower())\n    return end.join(sep.join(row) for row in zip(*sorted_columns))", "def merge(*dicts):\n    r = {}\n    for d in dicts:\n        for k, v in d.items():\n            if k in r: r[k].append(v)\n            else: r[k] = [v]\n    return r", "def meeting(s):\n    names = s.upper().split(';')\n    return ''.join(sorted('({1}, {0})'.format(*(n.split(':'))) for n in names))", "SHARP = \"A, A#, B, C, C#, D, D#, E, F, F#, G, G#\".split(\", \")\nFLAT = \"A, Bb, B, C, Db, D, Eb, E, F, Gb, G, Ab\".split(\", \")\nREVERSED_INDEX = {**{note: i for i, note in enumerate(SHARP)},\n                  **{note: i for i, note in enumerate(FLAT)}}\n\ndef transpose(song, interval):\n    return [SHARP[(REVERSED_INDEX[note] + interval) % 12] for note in song]", "def f(n, m):\n    # Either n or m seems to have a floating-point representation in one of the official tests.\n    # Since it's a .0, converting to int is fine.\n    n, m = int(n), int(m)\n    \n    # n=14, m=5  ->  2 whole runs, plus the 4 first modulos\n    whole_runs = n / m\n    leftovers = n % m\n    \n    # n=5, m=5  ->  1+2+3+4+0 == (m-1)/(m-1+1)/2\n    per_run = (m - 1) * (m - 1 + 1) / 2\n    leftovers_sum = leftovers * (leftovers + 1) / 2\n  \n    return whole_runs * per_run + leftovers_sum", "def how_many_years (date1, date2):\n    get_year = lambda date: int(date.split('/')[0])\n    return abs(get_year(date1) - get_year(date2))", "def square(n):\n    x = int(n)*int(n)\n    return x\n", "def hollow_triangle(n):\n    width = n * 2 - 1\n    row = '{{:_^{}}}'.format(width).format\n    return [row(mid(a)) for a in xrange(1, width, 2)] + [width * '#']\n\n\ndef mid(n):\n    return '#' if n == 1 else '#{}#'.format('_' * (n - 2))", "def solution(string, ending):\n    e_len = len(ending)\n    s_len = len(string)\n    if e_len == 0:\n        return True\n    elif (s_len >= e_len) and (string[-e_len:] == ending):\n        return True\n    else:\n        return False", "from collections import OrderedDict\n\ndef mutate_my_strings(s1,s2):\n    return '\\n'.join(OrderedDict.fromkeys((s2[:i] + s1[i:] for i in range(len(s1) + 1)))) + '\\n'", "class HTMLGen:\n    def __init__(self):\n        tags = ['a', 'b', 'p', 'body', 'div', 'span', 'title', 'comment']\n        for tag in tags:\n            setattr(self, tag, lambda content, tag=tag: '<'+tag+'>'+content+'</'+tag+'>' if not tag == 'comment' else '<!--'+content+'-->')", "def fib(n):\n    f = [1,1]\n    while len(f) < n:\n        f.append(f[-2]+f[-1])\n    return f[:n]\n\n\ndef fizz_buzzify(l):\n    return [\"Fizz\"*(n%3==0)+\"Buzz\"*(n%5==0) or n for n in l]\n\n\ndef fibs_fizz_buzz(n):\n    return fizz_buzzify(fib(n))\n", "from collections import defaultdict\nWORD_INDEX = defaultdict(list)\nfor w in WORD_LIST:\n    WORD_INDEX[len(w), sum(map(w.count, 'aeiou'))].append(w)\n\ndef wanted_words(vowels, consonants, forbidden):\n  return [w for w in WORD_INDEX[vowels + consonants, vowels] if not any(c in w for c in forbidden)]\n", "def capital(capitals): \n    result= []\n    \n    for i in capitals:\n        if \"country\" in list(i.keys()):\n            country_State = \"country\"\n        else: \n            country_State = \"state\"\n        result.append(\"The capital of \" + i[country_State] + \" is \" + i[\"capital\"])\n    return result\n    \n"]}